### YamlMime:ManagedReference
items:
- uid: System.Windows.Media.Animation.Animatable
  id: Animatable
  children:
  - System.Windows.Media.Animation.Animatable.#ctor
  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.Media.Animation.Animatable.Clone
  - System.Windows.Media.Animation.Animatable.FreezeCore(System.Boolean)
  - System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.Media.Animation.Animatable.HasAnimatedProperties
  - System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)
  langs:
  - csharp
  name: Animatable
  nameWithType: Animatable
  fullName: System.Windows.Media.Animation.Animatable
  type: Class
  summary: "애니메이션 지원을 제공 하는 추상 클래스입니다."
  syntax:
    content: 'public abstract class Animatable : System.Windows.Freezable, System.Windows.Media.Animation.IAnimatable'
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.Freezable
  implements:
  - System.Windows.Media.Animation.IAnimatable
  inheritedMembers:
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Freezable.CanFreeze
  - System.Windows.Freezable.Changed
  - System.Windows.Freezable.CloneCore(System.Windows.Freezable)
  - System.Windows.Freezable.CloneCurrentValue
  - System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)
  - System.Windows.Freezable.CreateInstance
  - System.Windows.Freezable.CreateInstanceCore
  - System.Windows.Freezable.Freeze
  - System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)
  - System.Windows.Freezable.GetAsFrozen
  - System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)
  - System.Windows.Freezable.GetCurrentValueAsFrozen
  - System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  - System.Windows.Freezable.IsFrozen
  - System.Windows.Freezable.OnChanged
  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)
  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)
  - System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.Freezable.ReadPreamble
  - System.Windows.Freezable.WritePostscript
  - System.Windows.Freezable.WritePreamble
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.#ctor
  id: '#ctor'
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: Animatable()
  nameWithType: Animatable.Animatable()
  fullName: System.Windows.Media.Animation.Animatable.Animatable()
  type: Constructor
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Windows.Media.Animation.Animatable&quot;> </xref> 클래스입니다."
  syntax:
    content: protected Animatable ();
    parameters: []
  overload: System.Windows.Media.Animation.Animatable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  id: ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: ApplyAnimationClock(DependencyProperty,AnimationClock)
  nameWithType: Animatable.ApplyAnimationClock(DependencyProperty,AnimationClock)
  fullName: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(DependencyProperty,AnimationClock)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "적용 되는 <xref href=&quot;System.Windows.Media.Animation.AnimationClock&quot;> </xref> 지정 된 <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>합니다. 속성이 이미 애니메이션 효과가 적용 하는 경우는 <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref> 전달 동작이 사용 됩니다."
  remarks: "속성에서 시간이 제거 하려면이 메서드를 사용 하는 해당 clock 중지 되지 않습니다."
  syntax:
    content: public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "애니메이션 효과를 주는 속성입니다."
    - id: clock
      type: System.Windows.Media.Animation.AnimationClock
      description: "지정된 된 속성에 애니메이션 효과를 주는로 나타냅니다. 경우 `clock` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, 모든 애니메이션이 됩니다 제거 지정된 된 속성에서 (되지만 중지 되지 않습니다)."
  overload: System.Windows.Media.Animation.Animatable.ApplyAnimationClock*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  id: ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  nameWithType: Animatable.ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  fullName: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "적용 되는 <xref href=&quot;System.Windows.Media.Animation.AnimationClock&quot;> </xref> 지정 된 <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>합니다. 속성이 이미 애니메이션 효과가 적용 하는 경우 지정 된 <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref> 사용 됩니다."
  remarks: "제거 하려면이 메서드를 사용 하 여 속성에서 시간이 해당 clock 중지 되지 않습니다.      ## 작성 HandoffBehavior 적용할 때 사용 하는 <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, 또는 <xref:System.Windows.Media.Animation.AnimationClock>사용 하 여 속성에는 <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>있으면 모든 <xref:System.Windows.Media.Animation.Clock>해당 속성을 이전에 연관 된 개체가 시스템 리소스를 소비한 계속 있으며 타이밍 시스템이 클록이를 자동으로 제거 되지 것입니다.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       많은 수의 시계를 사용 하 여 적용 하는 경우 성능 문제를 방지 하려면 <xref:System.Windows.Media.Animation.HandoffBehavior>를 완성 한 후 속성에서 구성 중인 clock를 제거 해야 합니다.</xref:System.Windows.Media.Animation.HandoffBehavior> 클록을 제거 하는 방법은 여러 가지가 있습니다.      -에서 제거 하려면 모든 clock 속성을 사용 하 여는 <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>또는 <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>애니메이션된 된 개체의 메서드.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> 첫 번째 매개 변수로 애니메이션 효과가 적용 되는 속성을 지정 하 고 `null` 를 두 번째입니다. 모든 애니메이션 클록 속성에서 제거 합니다.      -특정 <xref:System.Windows.Media.Animation.AnimationClock>시계를 목록에서 <xref:System.Windows.Media.Animation.Clock.Controller%2A> <xref:System.Windows.Media.Animation.AnimationClock>a <xref:System.Windows.Media.Animation.ClockController> <xref:System.Windows.Media.Animation.ClockController.Remove%2A> <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> 메서드</xref:System.Windows.Media.Animation.ClockController.Remove%2A> 호출을</xref:System.Windows.Media.Animation.ClockController> 검색 하</xref:System.Windows.Media.Animation.AnimationClock> 방법의 속성</xref:System.Windows.Media.Animation.Clock.Controller%2A> 을 사용 하 여</xref:System.Windows.Media.Animation.AnimationClock> 제거 하려면 이 일반적으로 수행 된 <xref:System.Windows.Media.Animation.Clock.Completed>클록에 대 한 이벤트 처리기.</xref:System.Windows.Media.Animation.Clock.Completed> 유일한 루트 클록을 제어할 수 있는 참고는 <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A>자식 클록의 속성은 반환 `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> 또한는 <xref:System.Windows.Media.Animation.Clock.Completed>이벤트 시계의 유효 기간을 무제한 인 경우 호출 되지 것입니다.</xref:System.Windows.Media.Animation.Clock.Completed>  이 경우 사용자 결정 해야 합니다 <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A> 를 호출 하는 경우       이 주로 수명이 긴 개체에 애니메이션에 대 한 문제입니다.  개체가 가비지 수집 된 경우 해당 clock도 끊어집니다 및 가비지 수집 합니다.       클록 개체에 대 한 자세한 내용은 참조는 [애니메이션 및 타이밍 시스템 개요](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - The following example shows how to apply animation clocks using different <xref:System.Windows.Media.Animation.HandoffBehavior> settings.
  syntax:
    content: public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "애니메이션 효과를 주는 속성입니다."
    - id: clock
      type: System.Windows.Media.Animation.AnimationClock
      description: "지정된 된 속성에 애니메이션 효과를 주는로 나타냅니다. 경우 `handoffBehavior` 은 <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref> 및 `clock` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, 모든 애니메이션이 됩니다 제거 지정된 된 속성에서 (되지만 중지 되지 않습니다). 경우 `handoffBehavior` 은 <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref> 클록은 및 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>,이 메서드는 영향을 주지 않습니다."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "새 애니메이션이 이미 속성 값에 영향을 주는 현재 애니메이션과 상호 작용 하는 방법을 지정 하는 값입니다."
  overload: System.Windows.Media.Animation.Animatable.ApplyAnimationClock*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  id: BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: BeginAnimation(DependencyProperty,AnimationTimeline)
  nameWithType: Animatable.BeginAnimation(DependencyProperty,AnimationTimeline)
  fullName: System.Windows.Media.Animation.Animatable.BeginAnimation(DependencyProperty,AnimationTimeline)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "애니메이션을 지정 된 적용 <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>합니다. 애니메이션은 프레임이 렌더링 될 때 시작 됩니다. 지정된 된 속성이 이미 애니메이션 효과가 적용 하는 경우는 <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref> 전달 동작이 사용 됩니다."
  remarks: "애니메이션에는 <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>0 보다 큼 즉, 해당 시간이 경과한 후 다음 프레임이 렌더링 되는 시간에서 애니메이션을 시작 합니다.</xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>"
  syntax:
    content: public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "애니메이션 효과를 주는 속성입니다."
    - id: animation
      type: System.Windows.Media.Animation.AnimationTimeline
      description: "지정된 된 속성에 애니메이션을 적용 하는 데 사용 하는 애니메이션입니다.       경우 애니메이션의 <xref:System.Windows.Media.Animation.Timeline.BeginTime*>은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, 현재 애니메이션이 모두 제거 됩니다 및 속성의 현재 값이 유지 됩니다.</xref:System.Windows.Media.Animation.Timeline.BeginTime*>       경우 `animation` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, 모든 애니메이션이 속성에서 제거 되 고 속성 값이 기준 값으로 되돌아갑니다."
  overload: System.Windows.Media.Animation.Animatable.BeginAnimation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  id: BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  nameWithType: Animatable.BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  fullName: System.Windows.Media.Animation.Animatable.BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "애니메이션을 지정 된 적용 <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>합니다. 애니메이션은 프레임이 렌더링 될 때 시작 됩니다. 지정된 된 속성이 이미 애니메이션 효과가 적용 하는 경우 지정 된 <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref> 사용 됩니다."
  remarks: "애니메이션에는 <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>0 보다 큼 즉, 해당 시간이 경과한 후 다음 프레임이 렌더링 되는 시간에서 애니메이션을 시작 합니다.</xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>      ## 작성 HandoffBehavior 적용할 때 사용 하는 <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, 또는 <xref:System.Windows.Media.Animation.AnimationClock>사용 하 여 속성에는 <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>있으면 모든 <xref:System.Windows.Media.Animation.Clock>해당 속성을 이전에 연관 된 개체가 시스템 리소스를 소비한 계속 있으며 타이밍 시스템이 클록이를 자동으로 제거 되지 것입니다.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       많은 수의 시계를 사용 하 여 적용 하는 경우 성능 문제를 방지 하려면 <xref:System.Windows.Media.Animation.HandoffBehavior>를 완성 한 후 속성에서 구성 중인 clock를 제거 해야 합니다.</xref:System.Windows.Media.Animation.HandoffBehavior> 클록을 제거 하는 방법은 여러 가지가 있습니다.      -에서 제거 하려면 모든 clock 속성을 사용 하 여는 <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>또는 <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>애니메이션된 된 개체의 메서드.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> 첫 번째 매개 변수로 애니메이션 효과가 적용 되는 속성을 지정 하 고 `null` 를 두 번째입니다. 모든 애니메이션 클록 속성에서 제거 합니다.      -특정 <xref:System.Windows.Media.Animation.AnimationClock>시계를 목록에서 <xref:System.Windows.Media.Animation.Clock.Controller%2A> <xref:System.Windows.Media.Animation.AnimationClock>a <xref:System.Windows.Media.Animation.ClockController> <xref:System.Windows.Media.Animation.ClockController.Remove%2A> <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> 메서드</xref:System.Windows.Media.Animation.ClockController.Remove%2A> 호출을</xref:System.Windows.Media.Animation.ClockController> 검색 하</xref:System.Windows.Media.Animation.AnimationClock> 방법의 속성</xref:System.Windows.Media.Animation.Clock.Controller%2A> 을 사용 하 여</xref:System.Windows.Media.Animation.AnimationClock> 제거 하려면 이 일반적으로 수행 된 <xref:System.Windows.Media.Animation.Clock.Completed>클록에 대 한 이벤트 처리기.</xref:System.Windows.Media.Animation.Clock.Completed> 유일한 루트 클록을 제어할 수 있는 참고는 <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A>자식 클록의 속성은 반환 `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> 또한는 <xref:System.Windows.Media.Animation.Clock.Completed>이벤트 시계의 유효 기간을 무제한 인 경우 호출 되지 것입니다.</xref:System.Windows.Media.Animation.Clock.Completed>  이 경우 사용자 결정 해야 합니다 <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A> 를 호출 하는 경우       이 주로 수명이 긴 개체에 애니메이션에 대 한 문제입니다.  개체가 가비지 수집 된 경우 해당 clock도 끊어집니다 및 가비지 수집 합니다.       클록 개체에 대 한 자세한 내용은 참조는 [애니메이션 및 타이밍 시스템 개요](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following example shows how to apply animations using different <xref:System.Windows.Media.Animation.HandoffBehavior> settings.  \n  \n [!code-cpp[animateproperty#InteractiveAnimationExampleWholePage](~/add/codesnippet/cpp/animagionproperty_cpp/InteractiveExample.cpp#interactiveanimationexamplewholepage)]\n [!code-cs[animateproperty#InteractiveAnimationExampleWholePage](~/add/codesnippet/csharp/animateproperty_csharp/InteractiveExample.cs#interactiveanimationexamplewholepage)]\n [!code-vb[animateproperty#InteractiveAnimationExampleWholePage](~/add/codesnippet/visualbasic/animateproperty_vb/InteractiveExample.vb#interactiveanimationexamplewholepage)]"
  syntax:
    content: public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "애니메이션 효과를 주는 속성입니다."
    - id: animation
      type: System.Windows.Media.Animation.AnimationTimeline
      description: "지정된 된 속성에 애니메이션을 적용 하는 데 사용 하는 애니메이션입니다.       경우 `handoffBehavior` 은 <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref> 및 애니메이션의 <> </> *>은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, 현재 애니메이션이 모두 제거 됩니다 및 속성의 현재 값이 유지 됩니다.       경우 `handoffBehavior` 은 <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref> 및 `animation` 는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 참조, 모든 애니메이션이 속성에서 제거 되 고 속성 값이 기준 값으로 되돌아갑니다.       경우 `handoffBehavior` 은 <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref>,이 메서드는 경우 영향을 미치지 것입니다 애니메이션 또는 해당 <> </> *>은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "새 애니메이션이 이미 속성 값에 영향을 주는 현재 애니메이션과 상호 작용 하는 방법을 지정 하는 값입니다."
  overload: System.Windows.Media.Animation.Animatable.BeginAnimation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.Clone
  id: Clone
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: Clone()
  nameWithType: Animatable.Clone()
  fullName: System.Windows.Media.Animation.Animatable.Clone()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "수정 가능한 복제본을 만듭니다 <xref href=&quot;System.Windows.Media.Animation.Animatable&quot;> </xref>,이 개체 값의 전체 복사본입니다. 이 개체의 종속성 속성을 복사 하는 경우이 메서드는 리소스 참조와 데이터 바인딩을 복사 (하지만 이러한 요소는 더 이상 확인) 나 하지 않습니다 애니메이션의 현재 값입니다."
  remarks: "Clone 메서드를 사용 하 여의 수정 가능한 복사본을 만드는 수 고정 <xref:System.Windows.Freezable>개체입니다.</xref:System.Windows.Freezable> 편의 위해이 메서드는 상속 된 숨깁니다 <xref:System.Windows.Freezable.Clone%2A>메서드는 강력한 형식의 구현을 제공 합니다.</xref:System.Windows.Freezable.Clone%2A>"
  syntax:
    content: public System.Windows.Media.Animation.Animatable Clone ();
    parameters: []
    return:
      type: System.Windows.Media.Animation.Animatable
      description: "이 인스턴스의 수정 가능한 복제본입니다. 반환 되는 복제본은 사실상 현재 개체의 전체 복사본입니다. 복제본의 <> </> *> 속성은 * *false** 합니다."
  overload: System.Windows.Media.Animation.Animatable.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.FreezeCore(System.Boolean)
  id: FreezeCore(System.Boolean)
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: FreezeCore(Boolean)
  nameWithType: Animatable.FreezeCore(Boolean)
  fullName: System.Windows.Media.Animation.Animatable.FreezeCore(Boolean)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "이 <xref href=&quot;System.Windows.Media.Animation.Animatable&quot;> </xref> 수정할 수 없는 개체 또는 만들 수 있는지 여부를 결정 합니다."
  remarks: "이 메서드는 반환 **false** 때 <xref:System.Windows.Media.Animation.Animatable.HasAnimatedProperties%2A>은 **true**.</xref:System.Windows.Media.Animation.Animatable.HasAnimatedProperties%2A>       직접 (제외 경우 기본 구현에서 호출)이이 메서드를 호출 하지 마십시오. 이 메서드는 내부적으로 <xref:System.Windows.Freezable.CanFreeze%2A>(와 `isChecking` 같지 `true`) 및 <xref:System.Windows.Freezable.Freeze%2A>(으로 `isChecking` 같음 `false`).</xref:System.Windows.Freezable.Freeze%2A> </xref:System.Windows.Freezable.CanFreeze%2A>"
  syntax:
    content: protected override bool FreezeCore (bool isChecking);
    parameters:
    - id: isChecking
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>이 메서드가이 인스턴스를 고정할 수 있는지 여부를 확인 해야 하는 경우 합니다. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>이 인스턴스의 고정 해야 하면 실제로이 메서드를 호출할 때입니다."
    return:
      type: System.Boolean
      description: "경우 <code> isChecking </code> 은 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>,이 메서드가 반환 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> 이 <xref href=&quot;System.Windows.Media.Animation.Animatable&quot;> </xref> , 수정할 수 또는 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 수정할 수 없게 만들 수 없는 경우.       경우 <code> isChecking </code> 은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>,이 메서드가 반환 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> 경우 if이 <xref href=&quot;System.Windows.Media.Animation.Animatable&quot;> </xref> 이제 수정할 수 없는, 또는 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 이 개체의 고정된 상태가 변경 되므로의 부작용으로 수정할 수 없게 만들 수 없는 경우."
  overload: System.Windows.Media.Animation.Animatable.FreezeCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)
  id: GetAnimationBaseValue(System.Windows.DependencyProperty)
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: GetAnimationBaseValue(DependencyProperty)
  nameWithType: Animatable.GetAnimationBaseValue(DependencyProperty)
  fullName: System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(DependencyProperty)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "지정 된 애니메이션이 적용 되지 않은 값을 반환 <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>합니다."
  remarks: "지정된 된 속성 움직이지 않으면이 메서드 <xref:System.Windows.DependencyObject.GetValue%2A>.</xref:System.Windows.DependencyObject.GetValue%2A> 와 동일한 결과 반환"
  example:
  - "In the following example, the non-animated values of animated properties are retrieved and displayed.  \n  \n [!code-cs[timingbehaviors_procedural_snip#GetAnimationBaseValueExampleWholePage](~/add/codesnippet/csharp/TimingBehavior_csharp/GetAnimationBaseValueExample.cs#getanimationbasevalueexamplewholepage)]\n [!code-vb[timingbehaviors_procedural_snip#GetAnimationBaseValueExampleWholePage](~/add/codesnippet/visualbasic/timingbehavior_vb/getanimationbasevalueexample.vb#getanimationbasevalueexamplewholepage)]"
  syntax:
    content: public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "기본 (애니메이션이 적용 되지 않은) 값을 검색할 속성을 식별 합니다."
    return:
      type: System.Object
      description: "지정된 된 속성 애니메이션이 적용 되지 않은 경우 반환 되는 값입니다."
  overload: System.Windows.Media.Animation.Animatable.GetAnimationBaseValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.HasAnimatedProperties
  id: HasAnimatedProperties
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: HasAnimatedProperties
  nameWithType: Animatable.HasAnimatedProperties
  fullName: System.Windows.Media.Animation.Animatable.HasAnimatedProperties
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "나타내는 값을 가져옵니다 있는지 여부를 하나 이상의 <xref href=&quot;System.Windows.Media.Animation.AnimationClock&quot;> </xref> 이 개체의 종속성 속성의 모든 연결 된 개체입니다."
  remarks: "이 속성은이 개체에 애니메이션 효과 준된 하위 개체가 포함 되는지 여부를 나타내지 않습니다."
  syntax:
    content: public bool HasAnimatedProperties { get; }
    return:
      type: System.Boolean
      description: '**true** if one or more <xref href="System.Windows.Media.Animation.AnimationClock"></xref> objects is associated with any of this object''s dependency properties; otherwise, **false**.'
  overload: System.Windows.Media.Animation.Animatable.HasAnimatedProperties*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)
  id: ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: ShouldSerializeStoredWeakReference(DependencyObject)
  nameWithType: Animatable.ShouldSerializeStoredWeakReference(DependencyObject)
  fullName: System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(DependencyObject)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "종속성 개체를 serialize 해야 하는지 여부를 지정 합니다."
  remarks: "<xref:System.ComponentModel.TypeDescriptor>클래스 ShouldSerializeStoredWeakReference 메서드를 사용 하 여 속성을 serialize 해야 하는지 결정 합니다.</xref:System.ComponentModel.TypeDescriptor>"
  syntax:
    content: public static bool ShouldSerializeStoredWeakReference (System.Windows.DependencyObject target);
    parameters:
    - id: target
      type: System.Windows.DependencyObject
      description: "종속성 속성 시스템에 참가 하는 개체를 나타냅니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>to serialize <code>target</code>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>. 기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Freezable
  isExternal: false
  name: System.Windows.Freezable
- uid: System.Windows.Media.Animation.Animatable.#ctor
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: Animatable()
  nameWithType: Animatable.Animatable()
  fullName: System.Windows.Media.Animation.Animatable.Animatable()
- uid: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: ApplyAnimationClock(DependencyProperty,AnimationClock)
  nameWithType: Animatable.ApplyAnimationClock(DependencyProperty,AnimationClock)
  fullName: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(DependencyProperty,AnimationClock)
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.Media.Animation.AnimationClock
  parent: System.Windows.Media.Animation
  isExternal: false
  name: AnimationClock
  nameWithType: AnimationClock
  fullName: System.Windows.Media.Animation.AnimationClock
- uid: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  nameWithType: Animatable.ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  fullName: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
- uid: System.Windows.Media.Animation.HandoffBehavior
  parent: System.Windows.Media.Animation
  isExternal: false
  name: HandoffBehavior
  nameWithType: HandoffBehavior
  fullName: System.Windows.Media.Animation.HandoffBehavior
- uid: System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: BeginAnimation(DependencyProperty,AnimationTimeline)
  nameWithType: Animatable.BeginAnimation(DependencyProperty,AnimationTimeline)
  fullName: System.Windows.Media.Animation.Animatable.BeginAnimation(DependencyProperty,AnimationTimeline)
- uid: System.Windows.Media.Animation.AnimationTimeline
  parent: System.Windows.Media.Animation
  isExternal: false
  name: AnimationTimeline
  nameWithType: AnimationTimeline
  fullName: System.Windows.Media.Animation.AnimationTimeline
- uid: System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  nameWithType: Animatable.BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  fullName: System.Windows.Media.Animation.Animatable.BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
- uid: System.Windows.Media.Animation.Animatable.Clone
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: Clone()
  nameWithType: Animatable.Clone()
  fullName: System.Windows.Media.Animation.Animatable.Clone()
- uid: System.Windows.Media.Animation.Animatable
  parent: System.Windows.Media.Animation
  isExternal: false
  name: Animatable
  nameWithType: Animatable
  fullName: System.Windows.Media.Animation.Animatable
- uid: System.Windows.Media.Animation.Animatable.FreezeCore(System.Boolean)
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: FreezeCore(Boolean)
  nameWithType: Animatable.FreezeCore(Boolean)
  fullName: System.Windows.Media.Animation.Animatable.FreezeCore(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: GetAnimationBaseValue(DependencyProperty)
  nameWithType: Animatable.GetAnimationBaseValue(DependencyProperty)
  fullName: System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(DependencyProperty)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.Media.Animation.Animatable.HasAnimatedProperties
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: HasAnimatedProperties
  nameWithType: Animatable.HasAnimatedProperties
  fullName: System.Windows.Media.Animation.Animatable.HasAnimatedProperties
- uid: System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: ShouldSerializeStoredWeakReference(DependencyObject)
  nameWithType: Animatable.ShouldSerializeStoredWeakReference(DependencyObject)
  fullName: System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(DependencyObject)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.Media.Animation.Animatable.#ctor*
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: Animatable
  nameWithType: Animatable.Animatable
- uid: System.Windows.Media.Animation.Animatable.ApplyAnimationClock*
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: ApplyAnimationClock
  nameWithType: Animatable.ApplyAnimationClock
- uid: System.Windows.Media.Animation.Animatable.BeginAnimation*
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: BeginAnimation
  nameWithType: Animatable.BeginAnimation
- uid: System.Windows.Media.Animation.Animatable.Clone*
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: Clone
  nameWithType: Animatable.Clone
- uid: System.Windows.Media.Animation.Animatable.FreezeCore*
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: FreezeCore
  nameWithType: Animatable.FreezeCore
- uid: System.Windows.Media.Animation.Animatable.GetAnimationBaseValue*
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: GetAnimationBaseValue
  nameWithType: Animatable.GetAnimationBaseValue
- uid: System.Windows.Media.Animation.Animatable.HasAnimatedProperties*
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: HasAnimatedProperties
  nameWithType: Animatable.HasAnimatedProperties
- uid: System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference*
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: ShouldSerializeStoredWeakReference
  nameWithType: Animatable.ShouldSerializeStoredWeakReference
