### YamlMime:ManagedReference
items:
- uid: System.Windows.FrameworkElement
  id: FrameworkElement
  children:
  - System.Windows.FrameworkElement.#ctor
  - System.Windows.FrameworkElement.ActualHeight
  - System.Windows.FrameworkElement.ActualHeightProperty
  - System.Windows.FrameworkElement.ActualWidth
  - System.Windows.FrameworkElement.ActualWidthProperty
  - System.Windows.FrameworkElement.AddLogicalChild(System.Object)
  - System.Windows.FrameworkElement.ApplyTemplate
  - System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)
  - System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)
  - System.Windows.FrameworkElement.BeginInit
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  - System.Windows.FrameworkElement.BindingGroup
  - System.Windows.FrameworkElement.BindingGroupProperty
  - System.Windows.FrameworkElement.BringIntoView
  - System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)
  - System.Windows.FrameworkElement.ContextMenu
  - System.Windows.FrameworkElement.ContextMenuClosing
  - System.Windows.FrameworkElement.ContextMenuClosingEvent
  - System.Windows.FrameworkElement.ContextMenuOpening
  - System.Windows.FrameworkElement.ContextMenuOpeningEvent
  - System.Windows.FrameworkElement.ContextMenuProperty
  - System.Windows.FrameworkElement.Cursor
  - System.Windows.FrameworkElement.CursorProperty
  - System.Windows.FrameworkElement.DataContext
  - System.Windows.FrameworkElement.DataContextChanged
  - System.Windows.FrameworkElement.DataContextProperty
  - System.Windows.FrameworkElement.DefaultStyleKey
  - System.Windows.FrameworkElement.DefaultStyleKeyProperty
  - System.Windows.FrameworkElement.EndInit
  - System.Windows.FrameworkElement.FindName(System.String)
  - System.Windows.FrameworkElement.FindResource(System.Object)
  - System.Windows.FrameworkElement.FlowDirection
  - System.Windows.FrameworkElement.FlowDirectionProperty
  - System.Windows.FrameworkElement.FocusVisualStyle
  - System.Windows.FrameworkElement.FocusVisualStyleProperty
  - System.Windows.FrameworkElement.ForceCursor
  - System.Windows.FrameworkElement.ForceCursorProperty
  - System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)
  - System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)
  - System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)
  - System.Windows.FrameworkElement.GetTemplateChild(System.String)
  - System.Windows.FrameworkElement.GetUIParentCore
  - System.Windows.FrameworkElement.GetVisualChild(System.Int32)
  - System.Windows.FrameworkElement.Height
  - System.Windows.FrameworkElement.HeightProperty
  - System.Windows.FrameworkElement.HorizontalAlignment
  - System.Windows.FrameworkElement.HorizontalAlignmentProperty
  - System.Windows.FrameworkElement.InheritanceBehavior
  - System.Windows.FrameworkElement.Initialized
  - System.Windows.FrameworkElement.InputScope
  - System.Windows.FrameworkElement.InputScopeProperty
  - System.Windows.FrameworkElement.IsInitialized
  - System.Windows.FrameworkElement.IsLoaded
  - System.Windows.FrameworkElement.Language
  - System.Windows.FrameworkElement.LanguageProperty
  - System.Windows.FrameworkElement.LayoutTransform
  - System.Windows.FrameworkElement.LayoutTransformProperty
  - System.Windows.FrameworkElement.Loaded
  - System.Windows.FrameworkElement.LoadedEvent
  - System.Windows.FrameworkElement.LogicalChildren
  - System.Windows.FrameworkElement.Margin
  - System.Windows.FrameworkElement.MarginProperty
  - System.Windows.FrameworkElement.MaxHeight
  - System.Windows.FrameworkElement.MaxHeightProperty
  - System.Windows.FrameworkElement.MaxWidth
  - System.Windows.FrameworkElement.MaxWidthProperty
  - System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)
  - System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)
  - System.Windows.FrameworkElement.MinHeight
  - System.Windows.FrameworkElement.MinHeightProperty
  - System.Windows.FrameworkElement.MinWidth
  - System.Windows.FrameworkElement.MinWidthProperty
  - System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)
  - System.Windows.FrameworkElement.Name
  - System.Windows.FrameworkElement.NameProperty
  - System.Windows.FrameworkElement.OnApplyTemplate
  - System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)
  - System.Windows.FrameworkElement.OnInitialized(System.EventArgs)
  - System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  - System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  - System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)
  - System.Windows.FrameworkElement.OverridesDefaultStyle
  - System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  - System.Windows.FrameworkElement.Parent
  - System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)
  - System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  - System.Windows.FrameworkElement.RegisterName(System.String,System.Object)
  - System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)
  - System.Windows.FrameworkElement.RequestBringIntoView
  - System.Windows.FrameworkElement.RequestBringIntoViewEvent
  - System.Windows.FrameworkElement.Resources
  - System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)
  - System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  - System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  - System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  - System.Windows.FrameworkElement.ShouldSerializeResources
  - System.Windows.FrameworkElement.ShouldSerializeStyle
  - System.Windows.FrameworkElement.ShouldSerializeTriggers
  - System.Windows.FrameworkElement.SizeChanged
  - System.Windows.FrameworkElement.SizeChangedEvent
  - System.Windows.FrameworkElement.SourceUpdated
  - System.Windows.FrameworkElement.Style
  - System.Windows.FrameworkElement.StyleProperty
  - System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.FrameworkElement.Tag
  - System.Windows.FrameworkElement.TagProperty
  - System.Windows.FrameworkElement.TargetUpdated
  - System.Windows.FrameworkElement.TemplatedParent
  - System.Windows.FrameworkElement.ToolTip
  - System.Windows.FrameworkElement.ToolTipClosing
  - System.Windows.FrameworkElement.ToolTipClosingEvent
  - System.Windows.FrameworkElement.ToolTipOpening
  - System.Windows.FrameworkElement.ToolTipOpeningEvent
  - System.Windows.FrameworkElement.ToolTipProperty
  - System.Windows.FrameworkElement.Triggers
  - System.Windows.FrameworkElement.TryFindResource(System.Object)
  - System.Windows.FrameworkElement.Unloaded
  - System.Windows.FrameworkElement.UnloadedEvent
  - System.Windows.FrameworkElement.UnregisterName(System.String)
  - System.Windows.FrameworkElement.UpdateDefaultStyle
  - System.Windows.FrameworkElement.UseLayoutRounding
  - System.Windows.FrameworkElement.UseLayoutRoundingProperty
  - System.Windows.FrameworkElement.VerticalAlignment
  - System.Windows.FrameworkElement.VerticalAlignmentProperty
  - System.Windows.FrameworkElement.VisualChildrenCount
  - System.Windows.FrameworkElement.Width
  - System.Windows.FrameworkElement.WidthProperty
  langs:
  - csharp
  name: FrameworkElement
  nameWithType: FrameworkElement
  fullName: System.Windows.FrameworkElement
  type: Class
  summary: "속성, 이벤트 및 방법에 대 한 WPF 프레임 워크 수준 집합을 제공 [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] 요소입니다. 이 클래스는 WPF 핵심 수준에 제공 된 WPF 프레임 워크 수준 구현 나타냅니다 [!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)] 에 정의 된 <xref href=&quot;System.Windows.UIElement&quot;> </xref>합니다."
  remarks: "FrameworkElement가 WPF 프레임 워크 수준 요소 클래스와의 WPF 핵심 수준 집합 사이의 연결 점을 한 <xref:System.Windows.UIElement>프레젠테이션 서비스.</xref:System.Windows.UIElement> 이러한 개념에 대 한 자세한 내용은 참조 [WPF 아키텍처](~/add/includes/ajax-current-ext-md.md)합니다.       FrameworkElement 확장 <xref:System.Windows.UIElement>다음과 같은 기능을 추가 하 고:- **레이아웃 시스템 정의**: FrameworkElement 특정 WPF 프레임 워크 수준 구현 특정 <xref:System.Windows.UIElement>.</xref:System.Windows.UIElement> 가상 멤버로 정의 된 메서드를 제공</xref:System.Windows.UIElement> 가장 주목할 만한 FrameworkElement 특정 WPF 핵심 수준 레이아웃 재정의가 봉인 하 고 대신 파생 된 클래스 WPF 프레임 워크 수준 동작을 재정의 해야를 제공 합니다. FrameworkElement <xref:System.Windows.UIElement.ArrangeCore%2A>이지만 <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.</xref:System.Windows.FrameworkElement.ArrangeOverride%2A> 제공</xref:System.Windows.UIElement.ArrangeCore%2A> 을 봉인 하는 예를 들어 이러한 변경 내용은 된다는 사실에 입각 WPF 프레임 워크 수준에 있는 전체 레이아웃 시스템 모든 FrameworkElement를 렌더링할 수 있는 원위치 파생 클래스를 반영 합니다. WPF 핵심 수준, 특정 구성원을 일반 구성 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] 기반된 레이아웃 솔루션 장소에 있더라도 레이아웃 시스템의 실제 엔진 정의 되어 있지 않습니다. 자세한 내용은 참조 [레이아웃](~/add/includes/ajax-current-ext-md.md)합니다.      - **논리적 트리에서:** 일반 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] 프로그래밍 모델은 종종 요소 트리 되 고 측면에서 표현 됩니다. FrameworkElement 수준에서 구현 되며 함께 나타날 태그에서 해당 트리를 정의 하는 것에 대 한 지원 및 논리적 트리 요소 트리를 표현 하 지원 합니다. 하지만 FrameworkElement 의도 한 대로 콘텐츠 모델을 정의 하지 않는 및 해당 작업 파생된 클래스가 수행 note 합니다. 자세한 내용은 참조 [In WPF](~/add/includes/ajax-current-ext-md.md)합니다.      - **개체 수명을 이벤트:** 요소의 초기화 시기를 알고 유용 (생성자를 호출) 요소는 처음으로 로드 논리적 트리로 또는 합니다. FrameworkElement 개체 수명 관련 된 다른 자식 요소를 추가 하는 등의 요소를 포함 하는 코드 숨김 작업에 대 한 유용한 후크를 제공 하는 여러 이벤트를 정의 합니다. 자세한 내용은 참조 [개체 수명 이벤트](~/add/includes/ajax-current-ext-md.md)합니다.      - **데이터 바인딩 및 동적 리소스 참조에 대 한 지원:** 데이터 바인딩 및 리소스에 대 한 속성 수준 지원을 구현한는 <xref:System.Windows.DependencyProperty>클래스 및 속성 시스템 하지만로 저장 하는 멤버 값을 해결 하는 기능에 포함 된 프로그램 <xref:System.Windows.Expression>(데이터 바인딩 및 동적 리소스 둘 다의 기반이 되는 프로그래밍 구문) FrameworkElement에 의해 구현 됩니다.</xref:System.Windows.Expression> </xref:System.Windows.DependencyProperty> 자세한 내용은 참조 [데이터 바인딩 개요](~/add/includes/ajax-current-ext-md.md) 및 [XAML 리소스](~/add/includes/ajax-current-ext-md.md)합니다.      - **스타일:** FrameworkElement 정의 <xref:System.Windows.FrameworkElement.Style%2A>속성.</xref:System.Windows.FrameworkElement.Style%2A> 그러나 FrameworkElement가 아직 템플릿에 대 한 지원을 정의 또는 데코레이터를 지원 합니다. 이러한 기능 <xref:System.Windows.Controls.Control>및 <xref:System.Windows.Controls.ContentControl>.</xref:System.Windows.Controls.ContentControl> </xref:System.Windows.Controls.Control> 등의 컨트롤 클래스에 의해 도입 된      - **지원:** WPF 핵심 수준 일부 애니메이션 지원을 이미 정의 하지만 FrameworkElement를 구현 하 여이 확장 <xref:System.Windows.FrameworkElement.BeginStoryboard%2A>및 멤버를 관련.</xref:System.Windows.FrameworkElement.BeginStoryboard%2A>       클래스 계층 구조에서 볼 수 있듯이 많은 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] 직접 또는 <xref:System.Windows.Controls.Panel>또는 <xref:System.Windows.Controls.Control>.</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Panel> 같은 중간 기본 클래스를 통해 FrameworkElement에서 파생 되는 클래스       FrameworkElement를 기본 클래스로 사용 하려는 경우 먼저 기존의 파생 된 클래스를 검사 하는 것이 좋습니다. FrameworkElement 다양 한 기본 시나리오에 대 한 지원을 제공 하지만 또한 다양 한 기능을 만드는 데 사용 하는 빌딩 블록의 의미의 &quot;요소&quot;에 대해 적합 하지 않습니다 [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] 에서 [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]합니다. 예를 들어, FrameworkElement는 true 콘텐츠 모델; 정의 하지 않습니다. FrameworkElement를 기본 클래스로 만들 수 있는 속성을 정의 하지 않는 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 자식 요소입니다. 특히, 할 수 있습니다 <xref:System.Windows.Controls.Control>및 <xref:System.Windows.Controls.ContentControl>.</xref:System.Windows.Controls.ContentControl> </xref:System.Windows.Controls.Control> 살펴보고"
  syntax:
    content: >-
      [System.Windows.Markup.RuntimeNameProperty("Name")]

      [System.Windows.Markup.UsableDuringInitialization(true)]

      [System.Windows.Markup.XmlLangProperty("Language")]

      [System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))]

      public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.Media.Visual
  - System.Windows.UIElement
  implements:
  - System.ComponentModel.ISupportInitialize
  - System.Windows.IFrameworkInputElement
  - System.Windows.Markup.IQueryAmbient
  inheritedMembers:
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Media.Visual.AddVisualChild(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.FindCommonVisualAncestor(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.IsAncestorOf(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.IsDescendantOf(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)
  - System.Windows.Media.Visual.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)
  - System.Windows.Media.Visual.PointFromScreen(System.Windows.Point)
  - System.Windows.Media.Visual.PointToScreen(System.Windows.Point)
  - System.Windows.Media.Visual.RemoveVisualChild(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Media3D.Visual3D)
  - System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToDescendant(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToVisual(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.VisualBitmapEffect
  - System.Windows.Media.Visual.VisualBitmapEffectInput
  - System.Windows.Media.Visual.VisualBitmapScalingMode
  - System.Windows.Media.Visual.VisualCacheMode
  - System.Windows.Media.Visual.VisualClearTypeHint
  - System.Windows.Media.Visual.VisualClip
  - System.Windows.Media.Visual.VisualEdgeMode
  - System.Windows.Media.Visual.VisualEffect
  - System.Windows.Media.Visual.VisualOffset
  - System.Windows.Media.Visual.VisualOpacity
  - System.Windows.Media.Visual.VisualOpacityMask
  - System.Windows.Media.Visual.VisualParent
  - System.Windows.Media.Visual.VisualScrollableAreaClip
  - System.Windows.Media.Visual.VisualTextHintingMode
  - System.Windows.Media.Visual.VisualTextRenderingMode
  - System.Windows.Media.Visual.VisualTransform
  - System.Windows.Media.Visual.VisualXSnappingGuidelines
  - System.Windows.Media.Visual.VisualYSnappingGuidelines
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  - System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  - System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.AllowDrop
  - System.Windows.UIElement.AllowDropProperty
  - System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.UIElement.AreAnyTouchesCaptured
  - System.Windows.UIElement.AreAnyTouchesCapturedProperty
  - System.Windows.UIElement.AreAnyTouchesCapturedWithin
  - System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty
  - System.Windows.UIElement.AreAnyTouchesDirectlyOver
  - System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty
  - System.Windows.UIElement.AreAnyTouchesOver
  - System.Windows.UIElement.AreAnyTouchesOverProperty
  - System.Windows.UIElement.Arrange(System.Windows.Rect)
  - System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.UIElement.BitmapEffect
  - System.Windows.UIElement.BitmapEffectInput
  - System.Windows.UIElement.BitmapEffectInputProperty
  - System.Windows.UIElement.BitmapEffectProperty
  - System.Windows.UIElement.CacheMode
  - System.Windows.UIElement.CacheModeProperty
  - System.Windows.UIElement.CaptureMouse
  - System.Windows.UIElement.CaptureStylus
  - System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)
  - System.Windows.UIElement.Clip
  - System.Windows.UIElement.ClipProperty
  - System.Windows.UIElement.ClipToBounds
  - System.Windows.UIElement.ClipToBoundsProperty
  - System.Windows.UIElement.CommandBindings
  - System.Windows.UIElement.DesiredSize
  - System.Windows.UIElement.DragEnter
  - System.Windows.UIElement.DragEnterEvent
  - System.Windows.UIElement.DragLeave
  - System.Windows.UIElement.DragLeaveEvent
  - System.Windows.UIElement.DragOver
  - System.Windows.UIElement.DragOverEvent
  - System.Windows.UIElement.Drop
  - System.Windows.UIElement.DropEvent
  - System.Windows.UIElement.Effect
  - System.Windows.UIElement.EffectProperty
  - System.Windows.UIElement.Focus
  - System.Windows.UIElement.Focusable
  - System.Windows.UIElement.FocusableChanged
  - System.Windows.UIElement.FocusableProperty
  - System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.UIElement.GiveFeedback
  - System.Windows.UIElement.GiveFeedbackEvent
  - System.Windows.UIElement.GotFocus
  - System.Windows.UIElement.GotFocusEvent
  - System.Windows.UIElement.GotKeyboardFocus
  - System.Windows.UIElement.GotKeyboardFocusEvent
  - System.Windows.UIElement.GotMouseCapture
  - System.Windows.UIElement.GotMouseCaptureEvent
  - System.Windows.UIElement.GotStylusCapture
  - System.Windows.UIElement.GotStylusCaptureEvent
  - System.Windows.UIElement.GotTouchCapture
  - System.Windows.UIElement.GotTouchCaptureEvent
  - System.Windows.UIElement.HasAnimatedProperties
  - System.Windows.UIElement.HasEffectiveKeyboardFocus
  - System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)
  - System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)
  - System.Windows.UIElement.InputBindings
  - System.Windows.UIElement.InputHitTest(System.Windows.Point)
  - System.Windows.UIElement.InvalidateArrange
  - System.Windows.UIElement.InvalidateMeasure
  - System.Windows.UIElement.InvalidateVisual
  - System.Windows.UIElement.IsArrangeValid
  - System.Windows.UIElement.IsEnabled
  - System.Windows.UIElement.IsEnabledChanged
  - System.Windows.UIElement.IsEnabledCore
  - System.Windows.UIElement.IsEnabledProperty
  - System.Windows.UIElement.IsFocused
  - System.Windows.UIElement.IsFocusedProperty
  - System.Windows.UIElement.IsHitTestVisible
  - System.Windows.UIElement.IsHitTestVisibleChanged
  - System.Windows.UIElement.IsHitTestVisibleProperty
  - System.Windows.UIElement.IsInputMethodEnabled
  - System.Windows.UIElement.IsKeyboardFocused
  - System.Windows.UIElement.IsKeyboardFocusedChanged
  - System.Windows.UIElement.IsKeyboardFocusedProperty
  - System.Windows.UIElement.IsKeyboardFocusWithin
  - System.Windows.UIElement.IsKeyboardFocusWithinChanged
  - System.Windows.UIElement.IsKeyboardFocusWithinProperty
  - System.Windows.UIElement.IsManipulationEnabled
  - System.Windows.UIElement.IsManipulationEnabledProperty
  - System.Windows.UIElement.IsMeasureValid
  - System.Windows.UIElement.IsMouseCaptured
  - System.Windows.UIElement.IsMouseCapturedChanged
  - System.Windows.UIElement.IsMouseCapturedProperty
  - System.Windows.UIElement.IsMouseCaptureWithin
  - System.Windows.UIElement.IsMouseCaptureWithinChanged
  - System.Windows.UIElement.IsMouseCaptureWithinProperty
  - System.Windows.UIElement.IsMouseDirectlyOver
  - System.Windows.UIElement.IsMouseDirectlyOverChanged
  - System.Windows.UIElement.IsMouseDirectlyOverProperty
  - System.Windows.UIElement.IsMouseOver
  - System.Windows.UIElement.IsMouseOverProperty
  - System.Windows.UIElement.IsStylusCaptured
  - System.Windows.UIElement.IsStylusCapturedChanged
  - System.Windows.UIElement.IsStylusCapturedProperty
  - System.Windows.UIElement.IsStylusCaptureWithin
  - System.Windows.UIElement.IsStylusCaptureWithinChanged
  - System.Windows.UIElement.IsStylusCaptureWithinProperty
  - System.Windows.UIElement.IsStylusDirectlyOver
  - System.Windows.UIElement.IsStylusDirectlyOverChanged
  - System.Windows.UIElement.IsStylusDirectlyOverProperty
  - System.Windows.UIElement.IsStylusOver
  - System.Windows.UIElement.IsStylusOverProperty
  - System.Windows.UIElement.IsVisible
  - System.Windows.UIElement.IsVisibleChanged
  - System.Windows.UIElement.IsVisibleProperty
  - System.Windows.UIElement.KeyDown
  - System.Windows.UIElement.KeyDownEvent
  - System.Windows.UIElement.KeyUp
  - System.Windows.UIElement.KeyUpEvent
  - System.Windows.UIElement.LayoutUpdated
  - System.Windows.UIElement.LostFocus
  - System.Windows.UIElement.LostFocusEvent
  - System.Windows.UIElement.LostKeyboardFocus
  - System.Windows.UIElement.LostKeyboardFocusEvent
  - System.Windows.UIElement.LostMouseCapture
  - System.Windows.UIElement.LostMouseCaptureEvent
  - System.Windows.UIElement.LostStylusCapture
  - System.Windows.UIElement.LostStylusCaptureEvent
  - System.Windows.UIElement.LostTouchCapture
  - System.Windows.UIElement.LostTouchCaptureEvent
  - System.Windows.UIElement.ManipulationBoundaryFeedback
  - System.Windows.UIElement.ManipulationBoundaryFeedbackEvent
  - System.Windows.UIElement.ManipulationCompleted
  - System.Windows.UIElement.ManipulationCompletedEvent
  - System.Windows.UIElement.ManipulationDelta
  - System.Windows.UIElement.ManipulationDeltaEvent
  - System.Windows.UIElement.ManipulationInertiaStarting
  - System.Windows.UIElement.ManipulationInertiaStartingEvent
  - System.Windows.UIElement.ManipulationStarted
  - System.Windows.UIElement.ManipulationStartedEvent
  - System.Windows.UIElement.ManipulationStarting
  - System.Windows.UIElement.ManipulationStartingEvent
  - System.Windows.UIElement.Measure(System.Windows.Size)
  - System.Windows.UIElement.MouseDown
  - System.Windows.UIElement.MouseDownEvent
  - System.Windows.UIElement.MouseEnter
  - System.Windows.UIElement.MouseEnterEvent
  - System.Windows.UIElement.MouseLeave
  - System.Windows.UIElement.MouseLeaveEvent
  - System.Windows.UIElement.MouseLeftButtonDown
  - System.Windows.UIElement.MouseLeftButtonDownEvent
  - System.Windows.UIElement.MouseLeftButtonUp
  - System.Windows.UIElement.MouseLeftButtonUpEvent
  - System.Windows.UIElement.MouseMove
  - System.Windows.UIElement.MouseMoveEvent
  - System.Windows.UIElement.MouseRightButtonDown
  - System.Windows.UIElement.MouseRightButtonDownEvent
  - System.Windows.UIElement.MouseRightButtonUp
  - System.Windows.UIElement.MouseRightButtonUpEvent
  - System.Windows.UIElement.MouseUp
  - System.Windows.UIElement.MouseUpEvent
  - System.Windows.UIElement.MouseWheel
  - System.Windows.UIElement.MouseWheelEvent
  - System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)
  - System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)
  - System.Windows.UIElement.OnCreateAutomationPeer
  - System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)
  - System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)
  - System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)
  - System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)
  - System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)
  - System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)
  - System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  - System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)
  - System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.Opacity
  - System.Windows.UIElement.OpacityMask
  - System.Windows.UIElement.OpacityMaskProperty
  - System.Windows.UIElement.OpacityProperty
  - System.Windows.UIElement.PersistId
  - System.Windows.UIElement.PreviewDragEnter
  - System.Windows.UIElement.PreviewDragEnterEvent
  - System.Windows.UIElement.PreviewDragLeave
  - System.Windows.UIElement.PreviewDragLeaveEvent
  - System.Windows.UIElement.PreviewDragOver
  - System.Windows.UIElement.PreviewDragOverEvent
  - System.Windows.UIElement.PreviewDrop
  - System.Windows.UIElement.PreviewDropEvent
  - System.Windows.UIElement.PreviewGiveFeedback
  - System.Windows.UIElement.PreviewGiveFeedbackEvent
  - System.Windows.UIElement.PreviewGotKeyboardFocus
  - System.Windows.UIElement.PreviewGotKeyboardFocusEvent
  - System.Windows.UIElement.PreviewKeyDown
  - System.Windows.UIElement.PreviewKeyDownEvent
  - System.Windows.UIElement.PreviewKeyUp
  - System.Windows.UIElement.PreviewKeyUpEvent
  - System.Windows.UIElement.PreviewLostKeyboardFocus
  - System.Windows.UIElement.PreviewLostKeyboardFocusEvent
  - System.Windows.UIElement.PreviewMouseDown
  - System.Windows.UIElement.PreviewMouseDownEvent
  - System.Windows.UIElement.PreviewMouseLeftButtonDown
  - System.Windows.UIElement.PreviewMouseLeftButtonDownEvent
  - System.Windows.UIElement.PreviewMouseLeftButtonUp
  - System.Windows.UIElement.PreviewMouseLeftButtonUpEvent
  - System.Windows.UIElement.PreviewMouseMove
  - System.Windows.UIElement.PreviewMouseMoveEvent
  - System.Windows.UIElement.PreviewMouseRightButtonDown
  - System.Windows.UIElement.PreviewMouseRightButtonDownEvent
  - System.Windows.UIElement.PreviewMouseRightButtonUp
  - System.Windows.UIElement.PreviewMouseRightButtonUpEvent
  - System.Windows.UIElement.PreviewMouseUp
  - System.Windows.UIElement.PreviewMouseUpEvent
  - System.Windows.UIElement.PreviewMouseWheel
  - System.Windows.UIElement.PreviewMouseWheelEvent
  - System.Windows.UIElement.PreviewQueryContinueDrag
  - System.Windows.UIElement.PreviewQueryContinueDragEvent
  - System.Windows.UIElement.PreviewStylusButtonDown
  - System.Windows.UIElement.PreviewStylusButtonDownEvent
  - System.Windows.UIElement.PreviewStylusButtonUp
  - System.Windows.UIElement.PreviewStylusButtonUpEvent
  - System.Windows.UIElement.PreviewStylusDown
  - System.Windows.UIElement.PreviewStylusDownEvent
  - System.Windows.UIElement.PreviewStylusInAirMove
  - System.Windows.UIElement.PreviewStylusInAirMoveEvent
  - System.Windows.UIElement.PreviewStylusInRange
  - System.Windows.UIElement.PreviewStylusInRangeEvent
  - System.Windows.UIElement.PreviewStylusMove
  - System.Windows.UIElement.PreviewStylusMoveEvent
  - System.Windows.UIElement.PreviewStylusOutOfRange
  - System.Windows.UIElement.PreviewStylusOutOfRangeEvent
  - System.Windows.UIElement.PreviewStylusSystemGesture
  - System.Windows.UIElement.PreviewStylusSystemGestureEvent
  - System.Windows.UIElement.PreviewStylusUp
  - System.Windows.UIElement.PreviewStylusUpEvent
  - System.Windows.UIElement.PreviewTextInput
  - System.Windows.UIElement.PreviewTextInputEvent
  - System.Windows.UIElement.PreviewTouchDown
  - System.Windows.UIElement.PreviewTouchDownEvent
  - System.Windows.UIElement.PreviewTouchMove
  - System.Windows.UIElement.PreviewTouchMoveEvent
  - System.Windows.UIElement.PreviewTouchUp
  - System.Windows.UIElement.PreviewTouchUpEvent
  - System.Windows.UIElement.QueryContinueDrag
  - System.Windows.UIElement.QueryContinueDragEvent
  - System.Windows.UIElement.QueryCursor
  - System.Windows.UIElement.QueryCursorEvent
  - System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.ReleaseAllTouchCaptures
  - System.Windows.UIElement.ReleaseMouseCapture
  - System.Windows.UIElement.ReleaseStylusCapture
  - System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  - System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.UIElement.RenderSize
  - System.Windows.UIElement.RenderTransform
  - System.Windows.UIElement.RenderTransformOrigin
  - System.Windows.UIElement.RenderTransformOriginProperty
  - System.Windows.UIElement.RenderTransformProperty
  - System.Windows.UIElement.ShouldSerializeCommandBindings
  - System.Windows.UIElement.ShouldSerializeInputBindings
  - System.Windows.UIElement.SnapsToDevicePixels
  - System.Windows.UIElement.SnapsToDevicePixelsProperty
  - System.Windows.UIElement.StylusButtonDown
  - System.Windows.UIElement.StylusButtonDownEvent
  - System.Windows.UIElement.StylusButtonUp
  - System.Windows.UIElement.StylusButtonUpEvent
  - System.Windows.UIElement.StylusDown
  - System.Windows.UIElement.StylusDownEvent
  - System.Windows.UIElement.StylusEnter
  - System.Windows.UIElement.StylusEnterEvent
  - System.Windows.UIElement.StylusInAirMove
  - System.Windows.UIElement.StylusInAirMoveEvent
  - System.Windows.UIElement.StylusInRange
  - System.Windows.UIElement.StylusInRangeEvent
  - System.Windows.UIElement.StylusLeave
  - System.Windows.UIElement.StylusLeaveEvent
  - System.Windows.UIElement.StylusMove
  - System.Windows.UIElement.StylusMoveEvent
  - System.Windows.UIElement.StylusOutOfRange
  - System.Windows.UIElement.StylusOutOfRangeEvent
  - System.Windows.UIElement.StylusPlugIns
  - System.Windows.UIElement.StylusSystemGesture
  - System.Windows.UIElement.StylusSystemGestureEvent
  - System.Windows.UIElement.StylusUp
  - System.Windows.UIElement.StylusUpEvent
  - System.Windows.UIElement.TextInput
  - System.Windows.UIElement.TextInputEvent
  - System.Windows.UIElement.TouchDown
  - System.Windows.UIElement.TouchDownEvent
  - System.Windows.UIElement.TouchEnter
  - System.Windows.UIElement.TouchEnterEvent
  - System.Windows.UIElement.TouchesCaptured
  - System.Windows.UIElement.TouchesCapturedWithin
  - System.Windows.UIElement.TouchesDirectlyOver
  - System.Windows.UIElement.TouchesOver
  - System.Windows.UIElement.TouchLeave
  - System.Windows.UIElement.TouchLeaveEvent
  - System.Windows.UIElement.TouchMove
  - System.Windows.UIElement.TouchMoveEvent
  - System.Windows.UIElement.TouchUp
  - System.Windows.UIElement.TouchUpEvent
  - System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)
  - System.Windows.UIElement.Uid
  - System.Windows.UIElement.UidProperty
  - System.Windows.UIElement.UpdateLayout
  - System.Windows.UIElement.Visibility
  - System.Windows.UIElement.VisibilityProperty
  platform:
  - net462
- uid: System.Windows.FrameworkElement.#ctor
  id: '#ctor'
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FrameworkElement()
  nameWithType: FrameworkElement.FrameworkElement()
  fullName: System.Windows.FrameworkElement.FrameworkElement()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> 클래스입니다."
  syntax:
    content: public FrameworkElement ();
    parameters: []
  overload: System.Windows.FrameworkElement.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualHeight
  id: ActualHeight
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualHeight
  nameWithType: FrameworkElement.ActualHeight
  fullName: System.Windows.FrameworkElement.ActualHeight
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소의 렌더링 된 높이 가져옵니다."
  remarks: "이 속성은 다른 높이 입력 레이아웃 시스템에 따라 계산된 된 값입니다. 값은 실제 렌더링 단계에 따라 레이아웃 시스템 자체에서 설정 되며 같은 속성의 설정 값 뒤에 약간 지연 될 수 있습니다 <xref:System.Windows.FrameworkElement.Height%2A>입력된 변경 기준인.</xref:System.Windows.FrameworkElement.Height%2A>       ActualHeight 계산된 된 값 이기 때문에 있을 수 여러 또는 증분 변경 내용에 다양 한 작업의 결과로 시스템에서 보고 레이아웃 인식 해야 합니다. 이 레이아웃 시스템 등 및 부모 요소에 의해 제약 조건, 자식 요소에 필요한 측정 공간을 계산할 수도 있습니다.       이 속성을 설정할 수 없어도 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], 기준을 지정할 수는 <xref:System.Windows.Trigger>스타일의 해당 값에.</xref:System.Windows.Trigger>      <a name=&quot;dependencyPropertyInfo_ActualHeight&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.ActualHeightProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.FrameworkElement.ActualHeightProperty>"
  example:
  - "The following example displays various height properties.  \n  \n [!code-cs[HeightMinHeightMaxHeight#3](~/add/codesnippet/csharp/Height_MinHeight_MaxHeight_CSharp/Window1.xaml.cs#3)]\n [!code-vb[HeightMinHeightMaxHeight#3](~/add/codesnippet/visualbasic/Height_MinHeight_MaxHeight/Window1.xaml.vb#3)]"
  syntax:
    content: public double ActualHeight { get; }
    return:
      type: System.Double
      description: "요소의 높이에 값으로 [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]합니다. 기본값은 0 (영)입니다."
  overload: System.Windows.FrameworkElement.ActualHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualHeightProperty
  id: ActualHeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualHeightProperty
  nameWithType: FrameworkElement.ActualHeightProperty
  fullName: System.Windows.FrameworkElement.ActualHeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.ActualHeight*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.ActualHeight*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ActualHeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualWidth
  id: ActualWidth
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualWidth
  nameWithType: FrameworkElement.ActualWidth
  fullName: System.Windows.FrameworkElement.ActualWidth
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소의 렌더링 된 너비를 가져옵니다."
  remarks: "이 속성은 다른 너비 입력 레이아웃 시스템에 따라 계산된 된 값입니다. 값은 실제 렌더링 단계에 따라 레이아웃 시스템 자체에서 설정 되며 같은 속성의 설정 값 뒤에 약간 지연 될 수 있습니다 <xref:System.Windows.FrameworkElement.Width%2A>입력된 변경 기준인.</xref:System.Windows.FrameworkElement.Width%2A>       ActualWidth 계산된 된 값 이기 때문에 있을 수 여러 또는 증분 변경 내용에 다양 한 작업의 결과로 시스템에서 보고 레이아웃 인식 해야 합니다. 이 레이아웃 시스템 등 및 부모 요소에 의해 제약 조건, 자식 요소에 필요한 측정 공간을 계산할 수도 있습니다.       이 속성을 설정할 수 없어도 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], 기준을 지정할 수는 <xref:System.Windows.Trigger>스타일의 해당 값에.</xref:System.Windows.Trigger>      <a name=&quot;dependencyPropertyInfo_ActualWidth&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.ActualWidthProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.FrameworkElement.ActualWidthProperty>"
  example:
  - "The following example displays various width properties.  \n  \n [!code-vb[WidthMinWidthMaxWidth#3](~/add/codesnippet/visualbasic/Width_MinWidth_MaxWidth/Window1.xaml.vb#3)]\n [!code-cs[WidthMinWidthMaxWidth#3](~/add/codesnippet/csharp/Width_MinWidth_MaxWidth_CSharp/Window1.xaml.cs#3)]"
  syntax:
    content: public double ActualWidth { get; }
    return:
      type: System.Double
      description: "요소의 너비에 값으로 [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]합니다. 기본값은 0 (영)입니다."
  overload: System.Windows.FrameworkElement.ActualWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualWidthProperty
  id: ActualWidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualWidthProperty
  nameWithType: FrameworkElement.ActualWidthProperty
  fullName: System.Windows.FrameworkElement.ActualWidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.ActualWidth*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.ActualWidth*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ActualWidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.AddLogicalChild(System.Object)
  id: AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: AddLogicalChild(Object)
  nameWithType: FrameworkElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.AddLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소의 논리적 트리에서에 제공된 된 개체를 추가합니다."
  remarks: "이 메서드는 요소의 논리 자식 요소를 나타내는 개체에는 컬렉션의 구현에 사용 합니다. 속성 getter 또는 setter, Changed 이벤트, 생성자의 또는 컬렉션 형식 자체 내에서 처리 하는 클래스에서 자식 요소 컬렉션에 대 한 컬렉션 유지 관리를 수행할 수 있습니다.       컨트롤 작성자에 대 한이 수준에서 논리 트리를 조작 하지 않는 것이 좋을 사용 가능한 기본 컨트롤 클래스에 대 한 콘텐츠 모델의 제어 시나리오에 적합 합니다. 수준에서 서브클래싱 고려 <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, 및 <xref:System.Windows.Controls.HeaderedItemsControl>.</xref:System.Windows.Controls.HeaderedItemsControl> </xref:System.Windows.Controls.ItemsControl> </xref:System.Windows.Controls.ContentControl> 이러한 클래스는 특정 적용 전용 통해 논리적 트리에서 자식 요소의 콘텐츠 모델을 제공 [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]에서 일반적으로 사용 가능한 다른 기능에 대 한 지원 및는 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] 스타일 템플릿을 통해 같은 제어 합니다. 사용 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.FrameworkElement.LogicalChildren%2A>및 참조 AddLogicalChild [In WPF](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkElement.LogicalChildren%2A>       AddLogicalChild 논리적 트리를 다른 프로세스에 의해 반복 중일 때 한 번에 메서드를 호출 하면 예외가 throw 될 수 있습니다."
  example:
  - "The following example implements a `Child` property on a custom <xref:System.Windows.FrameworkElement> that does its own visual layer implementation. The property setter is designed so that if the value changes, the old value is removed from the logical tree, as well as a class-specific visual collection. The property value is cached, and then the new value is added to both the logical tree and the custom visual collection.  \n  \n [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/visualbasic/compositiontargetrenderinganimations/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]\n [!code-cs[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/csharp/CompositionTargetRenderingAnimations/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]"
  syntax:
    content: protected void AddLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "추가 될 자식 요소입니다."
  overload: System.Windows.FrameworkElement.AddLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ApplyTemplate
  id: ApplyTemplate
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ApplyTemplate()
  nameWithType: FrameworkElement.ApplyTemplate()
  fullName: System.Windows.FrameworkElement.ApplyTemplate()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "필요한 경우 현재 템플릿의 시각적 트리를 생성 하 고 시각적 트리가이 호출으로 다시 작성 되었는지 여부를 나타내는 값을 반환 합니다."
  remarks: "응용 프로그램 프로그램 요소의 시각적 트리에 완료 되었음을 보장 하기 위해이 메서드를 호출할 수 있습니다. 이 보장 단계 코드는 트리의 자식 요소를 확인 하는 경우에 할 수 있습니다. 응용 프로그램 내에서 일반 요소 논리, ApplyTemplate를 호출할 필요가 없습니다, 서식 파일은 될 요소에 적용 되므로 적절 한 시점에 수명이에 자동으로 합니다.       모든 측정값에 ApplyTemplate 라고 WPF 프레임 워크 수준 레이아웃 시스템으로 전달 합니다.       <xref:System.Windows.FrameworkElement>파생된 클래스가 사용할 수는 <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>클래스 처리기의 경우가이 메서드가 명시적으로 호출 된 또는 레이아웃 시스템에서 알림을 받도록 합니다.</xref:System.Windows.FrameworkElement.OnApplyTemplate%2A></xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>서식 파일 완전히 생성 되 고 논리적 트리에서에 연결 된 후 호출 됩니다.</xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>"
  syntax:
    content: public bool ApplyTemplate ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>시각적 개체가 트리에; 추가 하는 경우 반환 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 그렇지 않은 경우."
  overload: System.Windows.FrameworkElement.ApplyTemplate*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)
  id: ArrangeCore(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ArrangeCore(Rect)
  nameWithType: FrameworkElement.ArrangeCore(Rect)
  fullName: System.Windows.FrameworkElement.ArrangeCore(Rect)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "구현 <xref:System.Windows.UIElement.ArrangeCore*>(에서 virtual로 정의 된 <xref href=&quot;System.Windows.UIElement&quot;> </xref>) 구현 봉인.</xref:System.Windows.UIElement.ArrangeCore*>"
  remarks: "이 메서드는 봉인 클래스입니다. <xref:System.Windows.FrameworkElement>파생된 클래스에서 <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.</xref:System.Windows.FrameworkElement.ArrangeOverride%2A> 를 재정의 해야</xref:System.Windows.FrameworkElement> 하는 요소 레이아웃의 정렬 단계에 맞게 사용자 지정 요소에 논리를 재정의."
  syntax:
    content: protected override sealed void ArrangeCore (System.Windows.Rect finalRect);
    parameters:
    - id: finalRect
      type: System.Windows.Rect
      description: "이 요소는 자신과 자식을 정렬 하는 데 사용 해야 하는 부모 내의 마지막 영역입니다."
  overload: System.Windows.FrameworkElement.ArrangeCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)
  id: ArrangeOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ArrangeOverride(Size)
  nameWithType: FrameworkElement.ArrangeOverride(Size)
  fullName: System.Windows.FrameworkElement.ArrangeOverride(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "파생된 클래스에서 재정의할 경우, 자식 요소를 배치 하 고 크기를 결정 한 <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> 클래스를 파생 합니다."
  syntax:
    content: protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);
    parameters:
    - id: finalSize
      type: System.Windows.Size
      description: "이 요소는 자신과 자식을 정렬 하는 데 사용 해야 하는 부모 내의 마지막 영역입니다."
    return:
      type: System.Windows.Size
      description: "사용 되는 실제 크기입니다."
  overload: System.Windows.FrameworkElement.ArrangeOverride*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginInit
  id: BeginInit
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginInit()
  nameWithType: FrameworkElement.BeginInit()
  fullName: System.Windows.FrameworkElement.BeginInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소를 위한 초기화 프로세스를 시작합니다."
  remarks: "아직 노출 하거나 요소 요소 트리에 있는 방식으로 조정 하는 경우 개별 요소에서이 메서드를 호출할 수 있습니다. 예를 들어, 만든 새 <xref:System.Windows.FrameworkElement>, 논리적 트리에 아직 연결 되지 했으며 하지만.</xref:System.Windows.FrameworkElement> 또는 논리적 트리 요소가 자식 요소 내 창 또는 응용 프로그램의 페이지에 연결 하지 않을 수 있습니다."
  syntax:
    content: public virtual void BeginInit ();
    parameters: []
  overload: System.Windows.FrameworkElement.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "제공 된 스토리 보드에 포함 된 작업의 순서를 시작 합니다."
  remarks: "애니메이션의 가장 일반적인 시나리오는이 메서드를 사용 하지 마십시오. 만들 때는 일반적으로 <xref:System.Windows.Media.Animation.Storyboard>또는 <xref:System.Windows.Media.Animation.BeginStoryboard>태그 및 다음에 요소 배치는 <xref:System.Windows.EventTrigger>요소에 콘텐츠.</xref:System.Windows.EventTrigger> </xref:System.Windows.Media.Animation.BeginStoryboard> </xref:System.Windows.Media.Animation.Storyboard> 이벤트에 의해 트리거될 때 애니메이션 다음 실행 합니다. 대부분의 컨트롤 측면의는 <xref:System.Windows.Media.Animation.Storyboard>태그에서 노출 된 속성을 통해 해결할 수 있습니다.</xref:System.Windows.Media.Animation.Storyboard>       사용 하지 않는 서명을 위한는 `isControllable`, 매개 변수를 해당 매개 변수에 지정 된 경우 또는 `false`, 연결 된 애니메이션 시간 표시 막대 clock은 애니메이션이 &quot;전체&quot; 기간의 끝에 도달 하는 즉시 제거 됩니다. 따라서 애니메이션을 한 번 실행 한 후에 다시 시작할 수 없습니다. 애니메이션을 제어 또한 있어야 스토리 보드는 [X:name 지시문](~/add/includes/ajax-current-ext-md.md) 코드에서 참조로 액세스할 수 있습니다."
  example:
  - "The following example retrieves a <xref:System.Windows.Media.Animation.Storyboard> from resources, and then runs that <xref:System.Windows.Media.Animation.Storyboard> when an internal event is class handled.  \n  \n [!code-vb[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/visualbasic/cubeanimation_xbap/page1.xaml.vb#febeginstoryboard)]\n [!code-cs[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/csharp/CubeAnimation_XBAP/Page1.xaml.cs#febeginstoryboard)]"
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "시작 하려면 스토리 보드 합니다."
  overload: System.Windows.FrameworkElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "속성이 이미 애니메이션 효과가 적용 하는 경우 수행할 작업에 대해 지정 된 옵션으로 제공 된 스토리 보드에 포함 된 작업 순서를 시작 합니다."
  remarks: "애니메이션의 가장 일반적인 시나리오는이 메서드를 사용 하지 마십시오. 만들 때는 일반적으로 <xref:System.Windows.Media.Animation.Storyboard>또는 <xref:System.Windows.Media.Animation.BeginStoryboard>태그 및 다음에 요소 배치는 <xref:System.Windows.EventTrigger>요소에 콘텐츠.</xref:System.Windows.EventTrigger> </xref:System.Windows.Media.Animation.BeginStoryboard> </xref:System.Windows.Media.Animation.Storyboard> 이벤트에 의해 트리거될 때 애니메이션 다음 실행 합니다. 대부분의 컨트롤 측면의는 <xref:System.Windows.Media.Animation.Storyboard>태그에서 노출 된 속성을 통해 해결할 수 있습니다.</xref:System.Windows.Media.Animation.Storyboard>       사용 하지 않는 서명을 위한는 `isControllable`, 매개 변수를 해당 매개 변수에 지정 된 경우 또는 `false`, 연결 된 애니메이션 시간 표시 막대 clock은 애니메이션이 &quot;전체&quot; 기간의 끝에 도달 하는 즉시 제거 됩니다. 따라서 애니메이션을 한 번 실행 한 후에 다시 시작할 수 없습니다. 애니메이션을 제어 또한 있어야 스토리 보드는 [X:name 지시문](~/add/includes/ajax-current-ext-md.md) 코드에서 참조로 액세스할 수 있습니다.       전달 동작이 <xref:System.Windows.Media.Animation.BeginStoryboard>안내 하십시오.</xref:System.Windows.Media.Animation.BeginStoryboard> 특성으로 지정할 수 있습니다.      ## 작성 HandoffBehavior 적용할 때 사용 하는 <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, 또는 <xref:System.Windows.Media.Animation.AnimationClock>를 사용 하 여 속성에는 <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>있으면 모든 <xref:System.Windows.Media.Animation.Clock>해당 속성을 이전에 연관 된 개체가 시스템 리소스를 소비한 계속 있으며 타이밍 시스템 시계를 자동으로 제거 되지 않습니다.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       사용 하 여 많은 수의 clock 적용할 때 성능 문제를 방지 하려면 <xref:System.Windows.Media.Animation.HandoffBehavior>를 완성 한 후 속성에서 구성 중인 clock를 제거 해야 합니다.</xref:System.Windows.Media.Animation.HandoffBehavior> 클록을 제거 하는 방법은 여러 가지가:-모든 clock 속성에서 제거을 사용 하려면는 <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>또는 <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>애니메이션된 된 개체의 메서드.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> 첫 번째 매개 변수로 애니메이션 효과가 적용 되는 속성을 지정 하 고 `null` 를 두 번째입니다. 그러면 모든 애니메이션 클록 속성에서 제거 됩니다.      -특정 <xref:System.Windows.Media.Animation.AnimationClock>시계를 목록에서 <xref:System.Windows.Media.Animation.Clock.Controller%2A> <xref:System.Windows.Media.Animation.AnimationClock>a <xref:System.Windows.Media.Animation.ClockController> <xref:System.Windows.Media.Animation.ClockController.Remove%2A> <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> 메서드</xref:System.Windows.Media.Animation.ClockController.Remove%2A> 호출을</xref:System.Windows.Media.Animation.ClockController> 검색 하</xref:System.Windows.Media.Animation.AnimationClock> 방법의 속성</xref:System.Windows.Media.Animation.Clock.Controller%2A> 을 사용 하 여</xref:System.Windows.Media.Animation.AnimationClock> 제거 하려면 이 일반적으로 수행 된 <xref:System.Windows.Media.Animation.Clock.Completed>클록에 대 한 이벤트 처리기.</xref:System.Windows.Media.Animation.Clock.Completed> 유일한 루트 클록을 제어할 수 있는 참고는 <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A>자식 클록의 속성을 반환 `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> 또한는 <xref:System.Windows.Media.Animation.Clock.Completed>클록의 유효 기간이 무제한 인 경우 이벤트가 발생 하지 않습니다.</xref:System.Windows.Media.Animation.Clock.Completed>  이 경우 사용자 <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A> 를 호출 하는 경우 결정 해야       이 주로 수명이 긴 개체에 애니메이션에 대 한 문제입니다.  개체가 가비지 수집 된 경우 해당 clock도 연결이 끊어지고 가비지 수집.       클록 개체에 대 한 자세한 내용은 참조 [애니메이션 및 타이밍 시스템 개요](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following example retrieves a <xref:System.Windows.Media.Animation.Storyboard> from resources, and then runs that <xref:System.Windows.Media.Animation.Storyboard> when an internal event is class handled.  \n  \n [!code-vb[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/visualbasic/cubeanimation_xbap/page1.xaml.vb#febeginstoryboard)]\n [!code-cs[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/csharp/CubeAnimation_XBAP/Page1.xaml.cs#febeginstoryboard)]"
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "시작 하려면 스토리 보드 합니다."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "경우 스토리 보드에 설명 된 속성에 애니메이션을 이미 사용 하는 동작을 설명 하는 열거형 값입니다."
  overload: System.Windows.FrameworkElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "애니메이션 시작 된 후의 컨트롤에 대 한 지정 된 상태와 함께 제공 된 스토리 보드에 포함 된 작업 순서를 시작 합니다."
  remarks: "애니메이션의 가장 일반적인 시나리오는이 메서드를 사용 하지 마십시오. 만들 때는 일반적으로 <xref:System.Windows.Media.Animation.Storyboard>또는 <xref:System.Windows.Media.Animation.BeginStoryboard>태그 및 다음에 요소 배치는 <xref:System.Windows.EventTrigger>요소에 콘텐츠.</xref:System.Windows.EventTrigger> </xref:System.Windows.Media.Animation.BeginStoryboard> </xref:System.Windows.Media.Animation.Storyboard> 이벤트에 의해 트리거될 때 애니메이션 다음 실행 합니다. 대부분의 컨트롤 측면의는 <xref:System.Windows.Media.Animation.Storyboard>태그에서 노출 된 속성을 통해 해결할 수 있습니다.</xref:System.Windows.Media.Animation.Storyboard>       사용 하지 않는 서명을 위한는 `isControllable`, 매개 변수를 해당 매개 변수에 지정 된 경우 또는 `false`, 연결 된 애니메이션 시간 표시 막대 clock은 애니메이션이 &quot;전체&quot; 기간의 끝에 도달 하는 즉시 제거 됩니다. 따라서 애니메이션을 한 번 실행 한 후에 다시 시작할 수 없습니다. 애니메이션을 제어 또한 있어야 스토리 보드는 [X:name 지시문](~/add/includes/ajax-current-ext-md.md) 코드에서 참조로 액세스할 수 있습니다.       전달 동작이 <xref:System.Windows.Media.Animation.BeginStoryboard>안내 하십시오.</xref:System.Windows.Media.Animation.BeginStoryboard> 특성으로 지정할 수 있습니다.      ## 작성 HandoffBehavior 적용할 때 사용 하는 <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, 또는 <xref:System.Windows.Media.Animation.AnimationClock>를 사용 하 여 속성에는 <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>있으면 모든 <xref:System.Windows.Media.Animation.Clock>해당 속성을 이전에 연관 된 개체가 시스템 리소스를 소비한 계속 있으며 타이밍 시스템 시계를 자동으로 제거 되지 않습니다.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       사용 하 여 많은 수의 clock 적용할 때 성능 문제를 방지 하려면 <xref:System.Windows.Media.Animation.HandoffBehavior>를 완성 한 후 속성에서 구성 중인 clock를 제거 해야 합니다.</xref:System.Windows.Media.Animation.HandoffBehavior> 클록을 제거 하는 방법은 여러 가지가:-모든 clock 속성에서 제거을 사용 하려면는 <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>또는 <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>애니메이션된 된 개체의 메서드.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> 첫 번째 매개 변수로 애니메이션 효과가 적용 되는 속성을 지정 하 고 `null` 를 두 번째입니다. 그러면 모든 애니메이션 클록 속성에서 제거 됩니다.      -특정 <xref:System.Windows.Media.Animation.AnimationClock>시계를 목록에서 <xref:System.Windows.Media.Animation.Clock.Controller%2A> <xref:System.Windows.Media.Animation.AnimationClock>a <xref:System.Windows.Media.Animation.ClockController> <xref:System.Windows.Media.Animation.ClockController.Remove%2A> <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> 메서드</xref:System.Windows.Media.Animation.ClockController.Remove%2A> 호출을</xref:System.Windows.Media.Animation.ClockController> 검색 하</xref:System.Windows.Media.Animation.AnimationClock> 방법의 속성</xref:System.Windows.Media.Animation.Clock.Controller%2A> 을 사용 하 여</xref:System.Windows.Media.Animation.AnimationClock> 제거 하려면 이 일반적으로 수행 된 <xref:System.Windows.Media.Animation.Clock.Completed>클록에 대 한 이벤트 처리기.</xref:System.Windows.Media.Animation.Clock.Completed> 유일한 루트 클록을 제어할 수 있는 참고는 <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A>자식 클록의 속성을 반환 `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> 또한는 <xref:System.Windows.Media.Animation.Clock.Completed>클록의 유효 기간이 무제한 인 경우 이벤트가 발생 하지 않습니다.</xref:System.Windows.Media.Animation.Clock.Completed>  이 경우 사용자 <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A> 를 호출 하는 경우 결정 해야       이 주로 수명이 긴 개체에 애니메이션에 대 한 문제입니다.  개체가 가비지 수집 된 경우 해당 clock도 연결이 끊어지고 가비지 수집.       클록 개체에 대 한 자세한 내용은 참조 [애니메이션 및 타이밍 시스템 개요](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "시작 하려면 스토리 보드 합니다."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "경우 스토리 보드에 설명 된 속성에 애니메이션을 이미 사용 하는 동작을 설명 하는 열거형 값입니다."
    - id: isControllable
      type: System.Boolean
      description: "애니메이션은 제어할 수 있는지 여부를 선언 (일시 중지할 수) 시작 된 후입니다."
  overload: System.Windows.FrameworkElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BindingGroup
  id: BindingGroup
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BindingGroup
  nameWithType: FrameworkElement.BindingGroup
  fullName: System.Windows.FrameworkElement.BindingGroup
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "가져오거나는 <xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref> 요소에 사용 되는 합니다."
  remarks: "A <xref:System.Windows.Data.BindingGroup>개체의 여러 속성 값의 유효성 검사를 사용할 수 있습니다.</xref:System.Windows.Data.BindingGroup> 예를 들어 응용 프로그램 주소를 입력 하 라는 메시지를 표시 하 고 다음 유형의 개체를 채웁니다 `Address`, 속성이 있는 `Street`, `City`, `ZipCode`, 및 `Country`, 사용자가 제공한 값을 사용 합니다. 응용 프로그램에&4; 개를 포함 하는 패널 <xref:System.Windows.Controls.TextBox>개체의 속성 중 하나에 바인딩되어 있으며 각 컨트롤.</xref:System.Windows.Controls.TextBox> 사용할 수 있습니다는 <xref:System.Windows.Controls.ValidationRule>에 <xref:System.Windows.Data.BindingGroup>유효성을 검사 하 여 `Address` 개체입니다.</xref:System.Windows.Data.BindingGroup> </xref:System.Windows.Controls.ValidationRule> 예를 들어는 <xref:System.Windows.Controls.ValidationRule>우편 번호 주소 국가 대 한 유효한 되는지 확인할 수 있습니다.</xref:System.Windows.Controls.ValidationRule>       자식 요소를 상속 된 <xref:System.Windows.Data.BindingGroup>다른 상속 가능한 속성 경우와 마찬가지로, 부모 요소 로부터.</xref:System.Windows.Data.BindingGroup>      <a name=&quot;dependencyPropertyInfo_BindingGroup&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.BindingGroupProperty>|   | 메타 데이터 속성이 **true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.BindingGroupProperty>"
  example:
  - "The following examples are part of an application that checks whether the user has set the properties of two objects to equal values. The first example creates two <xref:System.Windows.Controls.TextBox> controls, each of which is bound to a different data source. The <xref:System.Windows.Controls.StackPanel> has a <xref:System.Windows.Data.BindingGroup> that contains a <xref:System.Windows.Controls.ValidationRule> that checks that the two strings are equal.  \n  \n [!code-xml[BindingGroupSnippets#BindingGroupComplete](~/add/codesnippet/xaml/BindingGroupSnippets/Window3.xaml#bindinggroupcomplete)]  \n  \n The following example shows the <xref:System.Windows.Controls.ValidationRule> that the previous example uses.  In the <xref:System.Windows.Controls.ValidationRule.Validate%2A> method override, the example gets each source object from the <xref:System.Windows.Data.BindingGroup> and checks whether the properties of the objects are equal.  \n  \n [!code-cs[BindingGroupSnippets#BindingGroupNameValidationRule](~/add/codesnippet/csharp/BindingGroupSnippets/Window3.xaml.cs#bindinggroupnamevalidationrule)]\n [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/add/codesnippet/visualbasic/bindinggroupsnippets/window3.xaml.vb#bindinggroupnamevalidationrule)]  \n  \n To invoke the <xref:System.Windows.Controls.ValidationRule>, call the <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> method.  The following example calls <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> when the click event of the button occurs.  \n  \n [!code-cs[BindingGroupSnippets#UpdateSourcesClick](~/add/codesnippet/csharp/BindingGroupSnippets/Window3.xaml.cs#updatesourcesclick)]\n [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/add/codesnippet/visualbasic/bindinggroupsnippets/window3.xaml.vb#updatesourcesclick)]"
  syntax:
    content: public System.Windows.Data.BindingGroup BindingGroup { get; set; }
    return:
      type: System.Windows.Data.BindingGroup
      description: "<xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref> 요소에 사용 되는 합니다."
  overload: System.Windows.FrameworkElement.BindingGroup*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BindingGroupProperty
  id: BindingGroupProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BindingGroupProperty
  nameWithType: FrameworkElement.BindingGroupProperty
  fullName: System.Windows.FrameworkElement.BindingGroupProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.BindingGroup*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.BindingGroup*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty BindingGroupProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BringIntoView
  id: BringIntoView
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BringIntoView()
  nameWithType: FrameworkElement.BringIntoView()
  fullName: System.Windows.FrameworkElement.BringIntoView()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소 내에 포함 된 스크롤 가능한 영역 내에서 보기에 표시 하려고 합니다."
  remarks: "이 메서드를 호출 하 여 발생 한 <xref:System.Windows.FrameworkElement.RequestBringIntoView>현재 요소에서 시작 된 이벤트입니다.</xref:System.Windows.FrameworkElement.RequestBringIntoView> 처리 될 수 있도록이 이벤트는 발생 한 <xref:System.Windows.Controls.ScrollViewer>, 또는 파생 또는 유사한 클래스</xref:System.Windows.Controls.ScrollViewer> 예상 되는 동작은 표시 된 이벤트 데이터에서 처리 하는 부모 요소에는 이벤트를 처리 하 고 이벤트 소스에 포함 된 논리를 통해 보기에 표시 되는 <xref:System.Windows.Controls.ScrollViewer>컨트롤.</xref:System.Windows.Controls.ScrollViewer> 모두는 <xref:System.Windows.FrameworkElement.RequestBringIntoView>이벤트 나 BringIntoView 메서드에 대 한 성공 또는 실패를 이외의 이벤트는 일반적으로 표시 된 처리에 성공 하는 모든 정보를 전송 합니다.</xref:System.Windows.FrameworkElement.RequestBringIntoView> 실패 한 이유 요소 설정 예 <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Visibility>.</xref:System.Windows.Visibility> 이외의 일부 값을</xref:System.Windows.UIElement.Visibility%2A> 포함할 수 있습니다.       지정 하지 않는 서명을 사용 하는 경우는 `targetRectangle`, 전체 요소 크기 합니다 (해당 <xref:System.Windows.UIElement.RenderSize%2A>) 볼 수 있게 됩니다.</xref:System.Windows.UIElement.RenderSize%2A>       이 메서드를 호출 하면 호출 됩니다 <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>요소가 포함 된 부모 스크롤 가능한 영역에서.</xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> 이 요소는 스크롤 가능한 영역에 포함 되지 않은 경우는 <xref:System.Windows.FrameworkElement.RequestBringIntoView>이벤트는 발생 하지만 이벤트 수신기가 때문에 영향을 주지 않습니다 됩니다.</xref:System.Windows.FrameworkElement.RequestBringIntoView>"
  example:
  - "The following example implements a handler for an application navigation event that responds whenever the [!INCLUDE[TLA#tla_uri](~/add/includes/tlasharptla-uri-md.md)] being navigated to includes a fragment. The fragment is named in the [!INCLUDE[TLA2#tla_uri](~/add/includes/tla2sharptla-uri-md.md)] following the hash sign (#), and the implemented behavior causes the element to scroll into view within the frame. BringIntoView and <xref:System.Windows.FrameworkElement.RequestBringIntoView> request that scrolling behavior in the example.  \n  \n [!code-vb[FragmentNavigationSample#FEBringIntoView](~/add/codesnippet/visualbasic/FragmentNavigationSampleVisualBasic/MainWindow.xaml.vb#febringintoview)]\n [!code-cs[FragmentNavigationSample#FEBringIntoView](~/add/codesnippet/csharp/FragmentNavigationSample/MainWindow.xaml.cs#febringintoview)]"
  syntax:
    content: public void BringIntoView ();
    parameters: []
  overload: System.Windows.FrameworkElement.BringIntoView*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)
  id: BringIntoView(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BringIntoView(Rect)
  nameWithType: FrameworkElement.BringIntoView(Rect)
  fullName: System.Windows.FrameworkElement.BringIntoView(Rect)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소의 제공 된 영역 크기 내에 포함 된 스크롤 가능한 영역 내에서 보기에 표시 하려고 합니다."
  remarks: "이 메서드를 호출 하 여 발생 한 <xref:System.Windows.FrameworkElement.RequestBringIntoView>현재 요소에서 시작 된 이벤트입니다.</xref:System.Windows.FrameworkElement.RequestBringIntoView> 처리 될 수 있도록이 이벤트는 발생 한 <xref:System.Windows.Controls.ScrollViewer>, 또는 파생 또는 유사한 클래스</xref:System.Windows.Controls.ScrollViewer> 예상 되는 동작은 표시 된 이벤트 데이터에서 처리 하는 부모 요소에는 이벤트를 처리 하 고 이벤트 소스에 포함 된 논리를 통해 보기에 표시 되는 <xref:System.Windows.Controls.ScrollViewer>컨트롤.</xref:System.Windows.Controls.ScrollViewer> 모두는 <xref:System.Windows.FrameworkElement.RequestBringIntoView>이벤트와 <xref:System.Windows.FrameworkElement.BringIntoView%2A>메서드에 대 한 성공 또는 실패를 이외의 이벤트는 일반적으로 표시 된 처리에 성공 하는 모든 정보를 전송 합니다.</xref:System.Windows.FrameworkElement.BringIntoView%2A> </xref:System.Windows.FrameworkElement.RequestBringIntoView> 실패 한 이유 요소 설정 예 <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Visibility>.</xref:System.Windows.Visibility> 이외의 일부 값을</xref:System.Windows.UIElement.Visibility%2A> 포함할 수 있습니다.       지정 하지 않는 서명을 사용 하는 경우는 `targetRectangle`, 전체 요소 크기 합니다 (해당 <xref:System.Windows.UIElement.RenderSize%2A>) 볼 수 있게 됩니다.</xref:System.Windows.UIElement.RenderSize%2A>       이 메서드를 호출 하면 호출 됩니다 <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>요소가 포함 된 부모 스크롤 가능한 영역에서.</xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> 이 요소는 스크롤 가능한 영역에 포함 되지 않은 경우는 <xref:System.Windows.FrameworkElement.RequestBringIntoView>이벤트는 발생 하지만 이벤트 수신기가 때문에 영향을 주지 않습니다 됩니다.</xref:System.Windows.FrameworkElement.RequestBringIntoView>"
  example:
  - "The following example has a large graphic in a constrained scrolling region. A button on the page has a handler that scrolls the view to a particular region of the large graphic.  \n  \n [!code-xml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/add/codesnippet/xaml/BaseElementsSmorgasbord/Page1.xaml#bringintoviewrectmarkup)]  \n  \n [!code-cs[BaseElementsSmorgasbord#BringIntoViewRectCode](~/add/codesnippet/csharp/BaseElementsSmorgasbord/Page1.xaml.cs#bringintoviewrectcode)]\n [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/add/codesnippet/visualbasic/baseelementssmorgasbord/page1.xaml.vb#bringintoviewrectcode)]"
  syntax:
    content: public void BringIntoView (System.Windows.Rect targetRectangle);
    parameters:
    - id: targetRectangle
      type: System.Windows.Rect
      description: "지정 된 크기 보기에 가져올 수 있어야 하는 요소입니다."
  overload: System.Windows.FrameworkElement.BringIntoView*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenu
  id: ContextMenu
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenu
  nameWithType: FrameworkElement.ContextMenu
  fullName: System.Windows.FrameworkElement.ContextMenu
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "상황에 맞는 메뉴를 통해 요청 될 때마다 표시 되는 상황에 맞는 메뉴 요소를 가져오거나 설정 합니다. [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] 에서이 요소 내에서."
  remarks: "<xref:System.Windows.Controls.ContextMenu>자체는 <xref:System.Windows.FrameworkElement>파생 클래스가 있으며이 기술적으로 가능 <xref:System.Windows.Controls.ContextMenu>ContextMenu 속성 자체.</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.FrameworkElement></xref:System.Windows.Controls.ContextMenu> 그러나 이렇게 사용자에 대 한 혼란 스러운 상황에 맞는 메뉴 환경 만들어지고이 방법은 권장 되지 않습니다.      <a name=&quot;dependencyPropertyInfo_ContextMenu&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.ContextMenuProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.FrameworkElement.ContextMenuProperty>"
  syntax:
    content: public System.Windows.Controls.ContextMenu ContextMenu { get; set; }
    return:
      type: System.Windows.Controls.ContextMenu
      description: "이 요소에 할당 된 상황에 맞는 메뉴입니다."
  overload: System.Windows.FrameworkElement.ContextMenu*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuClosing
  id: ContextMenuClosing
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuClosing
  nameWithType: FrameworkElement.ContextMenuClosing
  fullName: System.Windows.FrameworkElement.ContextMenuClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "요소에 맞는 메뉴가 닫히기 바로 전에 발생 합니다."
  remarks: "닫히지 않도록 하려면 상황에 맞는 메뉴는 이벤트 처리기로 표시 해야 처리.       이 이벤트로 사용 하는 <xref:System.Windows.EventTrigger>스타일에서 이벤트의 원본으로 사용 하는 서비스의 정의 참조 해야 합니다: [!code-xml [CorePseudocode #FEContextMenuClosing](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuclosing) ] (때문에이 사용은 필수에서 이벤트를 구현 <xref:System.Windows.FrameworkElement>내부를 노출 하는 트리거도 사용할 수 있도록 서비스 이벤트 ContextMenuClosing 식별자 매핑되지 않습니다).</xref:System.Windows.FrameworkElement> </xref:System.Windows.EventTrigger>       <xref:System.Windows.Controls.ContextMenu>자체는 <xref:System.Windows.FrameworkElement>파생 클래스 이지만 ContextMenuClosing 이벤트 발생 하지 것입니다 상황에 맞는 메뉴에서 직접.</xref:System.Windows.FrameworkElement></xref:System.Windows.Controls.ContextMenu> 대신,이 이벤트는 속성으로 상황에 맞는 메뉴를 &quot;소유&quot; 하 고는 사용자가 UI의 상황에 맞는 메뉴를 시도할 때만 발생 하는 요소에서 발생 합니다. 그러나 것이 가능 <xref:System.Windows.Controls.ContextMenu>자체에 <xref:System.Windows.FrameworkElement.ContextMenu%2A>속성 (중첩 된 상황에 맞는 메뉴).</xref:System.Windows.FrameworkElement.ContextMenu%2A> </xref:System.Windows.Controls.ContextMenu> 이 경우에 <xref:System.Windows.Controls.ContextMenu>실제로 소유 하 고 중첩 된 <xref:System.Windows.Controls.ContextMenu>및 중첩 된 상황에 맞는 메뉴 되는 이벤트의 원본과 이벤트를 발생 시킬 수 있습니다.</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.Controls.ContextMenu>       <xref:System.Windows.Controls.ContextMenu>자체 클래스에 비슷한 이벤트 (<xref:System.Windows.Controls.ContextMenu.Closed>) 이지만 <xref:System.Windows.Controls.ContextMenu.Closed>이벤트는 사용자 작업을 취소할 기회 제공 하지 않습니다.</xref:System.Windows.Controls.ContextMenu.Closed> </xref:System.Windows.Controls.ContextMenu.Closed> </xref:System.Windows.Controls.ContextMenu>      <a name=&quot;routedEventInfo_ContextMenuClosing&quot;></a># # 이벤트 정보 라우트된 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|   | 라우팅 전략 | 버블링 |   | 대리자 | <xref:System.Windows.Controls.ContextMenuEventHandler>|      -재정의 <xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A>파생된 클래스에서이 이벤트를 처리 하는 클래스를 구현 합니다.</xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A> </xref:System.Windows.Controls.ContextMenuEventHandler> </xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuClosingEvent
  id: ContextMenuClosingEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuClosingEvent
  nameWithType: FrameworkElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkElement.ContextMenuClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref href=&quot;System.Windows.FrameworkElement.ContextMenuClosing&quot;> </xref> 라우트된 이벤트입니다."
  remarks: "라우트된 이벤트 식별자는 라우트된 이벤트가 등록 될 때 생성 됩니다. 이러한 식별자는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드가 포함 됩니다. 클래스 처리기를 추가 하려면 이러한 식별자를 사용할 수 있습니다.       라우트된 이벤트를 등록 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 을 참조 하십시오. 라우트된 이벤트 식별자를 사용 하 여 클래스 처리기를 추가 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A> 을 참조 하십시오."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuOpening
  id: ContextMenuOpening
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuOpening
  nameWithType: FrameworkElement.ContextMenuOpening
  fullName: System.Windows.FrameworkElement.ContextMenuOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "요소에 맞는 메뉴가 열리면 발생 합니다."
  remarks: "상황에 맞는 메뉴를 열어야 하는 처리 된 것으로 이벤트의 처리기 관련 이벤트를 표시 해야 합니다. 그렇지 않은 경우의 기존 값에서 <xref:System.Windows.FrameworkElement.ContextMenu%2A>를 자동으로 상황에 맞는 메뉴를 열려면 속성을 사용 합니다.</xref:System.Windows.FrameworkElement.ContextMenu%2A> 이벤트를 처리 된을 효과적으로 기본 작업을 취소 및 다시 설정의 <xref:System.Windows.FrameworkElement.ContextMenu%2A>속성 연 후 새 <xref:System.Windows.Controls.ContextMenu>.</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.FrameworkElement.ContextMenu%2A> 값 영업 기회 수 그러나은 알고 있어야 하는 타이밍 문제입니다. ContextMenuOpening 처리기를 통해 상황에 맞는 메뉴를 완전히 바꾸기 위해 초기 상황에 맞는 메뉴 해야 null 이거나 비워 둘 수 없습니다. 또는 이벤트를 처리 한 다음 수동으로 새 상황에 맞는 메뉴를 엽니다. 해야 합니다. 자세한 내용은 참조 [하는 방법: ContextMenuOpening 이벤트를 처리할](~/add/includes/ajax-current-ext-md.md)합니다.       이 이벤트로 사용 하는 <xref:System.Windows.EventTrigger>스타일에서 연결 된 이벤트를 참조 해야 합니다: [!code-xml [CorePseudocode #FEContextMenuOpening](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuopening) ] (때문에이 사용은 필수에서 이벤트를 구현 <xref:System.Windows.FrameworkElement>내부를 노출 하 트리거에서 사용할 수 있도록 서비스 이벤트에서는 ContextMenuOpening 식별자를 매핑하지 않습니다).</xref:System.Windows.FrameworkElement> </xref:System.Windows.EventTrigger>       <xref:System.Windows.Controls.ContextMenu>자체는 <xref:System.Windows.FrameworkElement>클래스를 파생 되지만이 이벤트를 원본으로 열려는 상황에 맞는 메뉴에서 발생 하지 것입니다.</xref:System.Windows.FrameworkElement></xref:System.Windows.Controls.ContextMenu> 속성으로 상황에 맞는 메뉴를 &quot;소유&quot; 하 고는 사용자가 UI의 상황에 맞는 메뉴를 열 때만 발생 하는 요소에서 발생 합니다. <xref:System.Windows.Controls.ContextMenu>자체에 <xref:System.Windows.FrameworkElement.ContextMenu%2A>속성을 하지만이 시나리오를 방지 해야 (세부 정보를 참조 하십시오. <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=fullName>).</xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=fullName> </xref:System.Windows.FrameworkElement.ContextMenu%2A> </xref:System.Windows.Controls.ContextMenu>       <xref:System.Windows.Controls.ContextMenu>자체 클래스에 비슷한 이벤트 (<xref:System.Windows.Controls.ContextMenu.Opened>) 하지만 <xref:System.Windows.Controls.ContextMenu.Opened>사용자 작업을 취소할 기회 제공 되지 않습니다.</xref:System.Windows.Controls.ContextMenu.Opened> </xref:System.Windows.Controls.ContextMenu.Opened> </xref:System.Windows.Controls.ContextMenu>      <a name=&quot;routedEventInfo_ContextMenuOpening&quot;></a># # 이벤트 정보 라우트된 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|   | 라우팅 전략 | 버블링 |   | 대리자 | <xref:System.Windows.Controls.ContextMenuEventHandler>|      -재정의 <xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A>파생된 클래스에서이 이벤트를 처리 하는 클래스를 구현 합니다.</xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A> </xref:System.Windows.Controls.ContextMenuEventHandler> </xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuOpeningEvent
  id: ContextMenuOpeningEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkElement.ContextMenuOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref href=&quot;System.Windows.FrameworkElement.ContextMenuOpening&quot;> </xref> 라우트된 이벤트입니다."
  remarks: "라우트된 이벤트 식별자는 라우트된 이벤트가 등록 될 때 생성 됩니다. 이러한 식별자는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드가 포함 됩니다. 클래스 처리기를 추가 하려면 이러한 식별자를 사용할 수 있습니다.       라우트된 이벤트를 등록 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 을 참조 하십시오. 라우트된 이벤트 식별자를 사용 하 여 클래스 처리기를 추가 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A> 을 참조 하십시오."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuProperty
  id: ContextMenuProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuProperty
  nameWithType: FrameworkElement.ContextMenuProperty
  fullName: System.Windows.FrameworkElement.ContextMenuProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.ContextMenu*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.ContextMenu*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ContextMenuProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Cursor
  id: Cursor
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Cursor
  nameWithType: FrameworkElement.Cursor
  fullName: System.Windows.FrameworkElement.Cursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "마우스 포인터가이 요소 위에 있을 때 표시 되는 커서를 가져오거나 설정 합니다."
  remarks: "이 속성을 설정 하면 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 프로세서에 대 한 형식 변환에 의존는 <xref:System.Windows.Input.Cursor>문자열을 평가 하는 클래스입니다.</xref:System.Windows.Input.Cursor> 제공된 된 문자열을 평가 해야는 <xref:System.Windows.Input.CursorType>값.</xref:System.Windows.Input.CursorType> 참조 <xref:System.Windows.Input.Cursor>대 한 자세한 내용은.</xref:System.Windows.Input.Cursor>       이 속성에서 설정한 커서가 여부 마우스 포인터가이 요소 위에 있을 때 표시 되지 것입니다의 값에 따라 결정 됩니다.는 <xref:System.Windows.FrameworkElement.ForceCursor%2A>속성.</xref:System.Windows.FrameworkElement.ForceCursor%2A> 또한는 활성 끌기, 마우스 캡처, 컨트롤 및 등 내의 텍스트 편집 모드와 같은 이벤트 관련 고려 사항 보다 우선 순위가 높은 사용자가이 속성에 지정한 값 보다 커서를 적용도 됩니다.       최종 기본적으로이 속성을 설정 하는 동작을 되돌리려면로 설정 `null` 다시 합니다.       `null` 실제 커서 값의 결정 지연 시키고 다른 곳에서 가져올 기본값인 의미 합니다. 제공 되지 않는 경우 소스에서 프로그래밍 방식으로 값을 기본 커서를 초과 하는 시각적으로 [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] 응용 프로그램에 화살표가 됩니다. 그러나 임시 커서 변경 내용이 통해 전달 될 때 요소의 커서 값으로 설정 되지 않습니다. 속성에 null이 아닌 값에 대해서만 보고 합니다 커서 있던 실제로 설정, 예를 들어 코드 또는 스타일을 통해 경우입니다. 각 위로 마우스를 움직일은 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] 발생 한 <xref:System.Windows.UIElement.QueryCursor>이벤트.</xref:System.Windows.UIElement.QueryCursor> 이벤트 버블 및 경로 따라 모든 요소에는 이벤트를 처리 하 고이 이벤트의 인수를 통해 커서의 값을 설정할 수 있습니다. 대부분의 경우에서 명백 커서를 생성 하는 메커니즘입니다. 경우는 <xref:System.Windows.UIElement.QueryCursor>커서 결과 반환 하는 처리기 다음 이벤트를 처리 하 고 인수에서 변경 된 값은 보다 우선 모든 수준에서 커서 속성의 값 <xref:System.Windows.FrameworkElement.ForceCursor%2A>설정 됩니다.</xref:System.Windows.FrameworkElement.ForceCursor%2A> </xref:System.Windows.UIElement.QueryCursor>       사용자 지정 커서를 만드는 경우가, 하는 경우 일반적으로이 속성을 설정 하면 <xref:System.Windows.Input.Cursors>클래스</xref:System.Windows.Input.Cursors> 의 정적 속성 값 다음 중 하나 필요로 코드에서 커서를 설정:-호출 된 <xref:System.Windows.Input.Cursor>를 가져오기 위해 생성자는 <xref:System.Windows.Input.Cursor>인스턴스.</xref:System.Windows.Input.Cursor> </xref:System.Windows.Input.Cursor> 서명을 모두는 <xref:System.Windows.Input.Cursor>생성자에서 만들고 있는 대비 하 여 파일을 사용 하 여는 <xref:System.Windows.Input.Cursor>사용자 지정 커서에 대 한 개체입니다.</xref:System.Windows.Input.Cursor> </xref:System.Windows.Input.Cursor>      -사용는 <xref:System.Windows.Input.CursorConverter>클래스 및 해당 <xref:System.Windows.Input.CursorConverter.ConvertFrom%2A>하 여 커서를 지정 하는 메서드 <xref:System.Windows.Input.CursorType>, 또는으로 계산 되는 문자열을 <xref:System.Windows.Input.CursorType>, <xref:System.Windows.Input.Cursor>.</xref:System.Windows.Input.Cursor> 돌아가기 캐스팅 하 고</xref:System.Windows.Input.CursorType> </xref:System.Windows.Input.CursorType> </xref:System.Windows.Input.CursorConverter.ConvertFrom%2A> </xref:System.Windows.Input.CursorConverter>       설정의 <xref:System.Windows.Input.Cursor>사용자 지정 값으로 설정 되지 않은 부분 신뢰.</xref:System.Windows.Input.Cursor> 사용자 지정 커서에 대 한 자세한 내용은 참조 하십시오. [입력 개요](~/add/includes/ajax-current-ext-md.md)합니다.      <a name=&quot;dependencyPropertyInfo_Cursor&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.CursorProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.FrameworkElement.CursorProperty>"
  example:
  - "The following example shows how to deliberately set the cursor graphic.  \n  \n [!code-cs[cursors#ChangeCursorsSample](~/add/codesnippet/csharp/cursors/Window1.xaml.cs#changecursorssample)]\n [!code-vb[cursors#ChangeCursorsSample](~/add/codesnippet/visualbasic/cursors/Window1.xaml.vb#changecursorssample)]"
  syntax:
    content: public System.Windows.Input.Cursor Cursor { get; set; }
    return:
      type: System.Windows.Input.Cursor
      description: "표시할 커서입니다. 기본 값으로 정의 됩니다 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 이 종속성 속성입니다. 그러나 런타임 시 실제 기본값은 다양 한 요소에서에서 제공 됩니다."
  overload: System.Windows.FrameworkElement.Cursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.CursorProperty
  id: CursorProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: CursorProperty
  nameWithType: FrameworkElement.CursorProperty
  fullName: System.Windows.FrameworkElement.CursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.Cursor*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.Cursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty CursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DataContext
  id: DataContext
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DataContext
  nameWithType: FrameworkElement.DataContext
  fullName: System.Windows.FrameworkElement.DataContext
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "데이터 바인딩에 참여할 때 요소에 대 한 데이터 컨텍스트를 가져오거나 설정 합니다."
  remarks: "*데이터 컨텍스트* 정보 바인딩 뿐만 아니라 경로 같은 바인딩의 다른 특성에 사용 되는 데이터 원본에 대 한 부모 요소 로부터 상속할 수 있도록 하는 개념은 합니다.       데이터 컨텍스트를 직접 설정할 수는 [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] 바인딩 해당 개체의 속성을 사용 하 여 개체입니다. 또는 데이터 컨텍스트 설정할 수는 <xref:System.Windows.Data.DataSourceProvider>개체입니다.</xref:System.Windows.Data.DataSourceProvider>       속성 값이 종속성 속성을 상속 합니다. 로컬 값 또는 스타일을 통해 설정 된 DataContext에 대 한 다른 값이 없는 자식 요소가 없으면 속성 시스템은 값이이 값이 할당 된 가장 가까운 부모 요소의 DataContext 값을 설정 합니다.       다음 속성 중 하나를 사용할 수 있습니다 또는 <xref:System.Windows.Data.Binding>바인딩 소스를 명시적으로 지정 하려면 클래스: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, 또는 <xref:System.Windows.Data.Binding.RelativeSource%2A>.</xref:System.Windows.Data.Binding.RelativeSource%2A> </xref:System.Windows.Data.Binding.Source%2A> </xref:System.Windows.Data.Binding.ElementName%2A> </xref:System.Windows.Data.Binding> 자세한 내용은 참조 [하는 방법: 바인딩 소스를 지정](~/add/includes/ajax-current-ext-md.md)합니다.       [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], DataContext가로 설정 가장 일반적으로 <xref:System.Windows.Data.Binding>선언.</xref:System.Windows.Data.Binding> 속성 요소 구문 또는 특성 구문 중 하나를 사용할 수 있습니다. 특성 구문은이 페이지에 표시 됩니다. DataContext를 설정 하려면 코드를 사용할 수 있습니다.       DataContext은 한 컨텍스트가 다른에 바인딩하여 있는 시나리오를 용이 하 게 바인딩할 수 있는 속성입니다. 그러나 DataContext에 바인딩하는 경우 (연결 하지 않음 DataContext를 DataContext 속성의 속성 값 상속 특성 때문에 수행할 수 있는 자체) 순환 바인딩 참조를 만들지 않도록 주의 해야 합니다.      <a name=&quot;xamlPropertyElementUsage_DataContext&quot;></a># # XAML 속성 요소 사용 ```   <object>     <object.DataContext>       <dataContextObject />     </object.DataContext>   </object>   ``` <a name=&quot;xamlAttributeUsage_DataContext&quot;> </a> # # XAML 특성 사용 ```   <object DataContext=&quot;bindingUsage&quot;/>   - or -   <object DataContext=&quot;{resourceExtension contextResourceKey}&quot;/>   ``` <a name=&quot;xamlValues_DataContext&quot;> </a> # # XAML 값 *dataContextObject* 부모 요소 내에서 모든 바인딩에 대 한 데이터 컨텍스트 역할을 하는 직접 포함 된 개체입니다.             이 개체는 <xref:System.Windows.Data.Binding>다른 <xref:System.Windows.Data.BindingBase>파생 클래스</xref:System.Windows.Data.BindingBase> 또는</xref:System.Windows.Data.Binding> 일반적으로 또는 원시 데이터 [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] 개체 바인딩 나중에 정의 된 실제 바인딩은 여기서 배치 될 수 있습니다에 사용 되는 형식입니다.       *bindingUsage* 는 적절 한 데이터 컨텍스트를 평가 하는 바인딩 사용 합니다. 자세한 내용은 참조 [바인딩 태그 확장](~/add/includes/ajax-current-ext-md.md)합니다.       *resourceExtension* 다음 중 하나: 또는 합니다. 리소스에는 개체로 정의 하는 원시 데이터를 참조할 때 사용 됩니다. 참조 [XAML 리소스](~/add/includes/ajax-current-ext-md.md)합니다.       *contextResourceKey* 에 <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> 내에서 요청 된 개체에 대 한 키 식별자      <a name=&quot;dependencyPropertyInfo_DataContext&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.DataContextProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.DataContextProperty>"
  example:
  - "The following example illustrates how a data context acts on a binding and provides the information that defines the specific values of bound properties.  \n  \n [!code-xml[MasterDetail#DataContextProperty](~/add/codesnippet/xaml/MasterDetail/Page1.xaml#datacontextproperty)]  \n[!code-xml[MasterDetail#DataContextProperty2](~/add/codesnippet/xaml/MasterDetail/Page1.xaml#datacontextproperty2)]  \n[!code-xml[MasterDetail#DataContextProperty3](~/add/codesnippet/xaml/MasterDetail/Page1.xaml#datacontextproperty3)]"
  syntax:
    content: public object DataContext { get; set; }
    return:
      type: System.Object
      description: "데이터 컨텍스트로 사용할 개체입니다."
  overload: System.Windows.FrameworkElement.DataContext*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DataContextChanged
  id: DataContextChanged
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DataContextChanged
  nameWithType: FrameworkElement.DataContextChanged
  fullName: System.Windows.FrameworkElement.DataContextChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소에 대 한 데이터 컨텍스트가 변경 될 때 발생 합니다."
  remarks: "참조에 대 한 데이터 컨텍스트 및 데이터 바인딩에 설명은 [데이터 바인딩 개요](~/add/includes/ajax-current-ext-md.md)합니다.      > [!IMPORTANT] > 때는 <xref:System.Windows.FrameworkElement.DataContext%2A>요소 변경을 위해이 요소의 모든 데이터 바인딩 속성은 영향을 받을 수 있습니다.</xref:System.Windows.FrameworkElement.DataContext%2A> 이 모든 요소는 데이터 컨텍스트를 상속 하는 현재 요소의 논리적 트리에서 자식 요소를 서로 그리고 현재 요소 자체에 적용 됩니다. 이러한 모든 기존 바인딩은 다시 새 해석 해야 <xref:System.Windows.FrameworkElement.DataContext%2A>고 바인딩 결과 다시 평가 됩니다.</xref:System.Windows.FrameworkElement.DataContext%2A> 데이터 바인딩 엔진의 이러한 재계산이 DataContextChanged 이벤트의 발생을 기준으로 순서에 대 한 결정적있지 않습니다. 혼합 또는 이벤트 이후에 전이나 이벤트 전에 발생할 수 있습니다."
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DataContextProperty
  id: DataContextProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DataContextProperty
  nameWithType: FrameworkElement.DataContextProperty
  fullName: System.Windows.FrameworkElement.DataContextProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.DataContext*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.DataContext*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty DataContextProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DefaultStyleKey
  id: DefaultStyleKey
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DefaultStyleKey
  nameWithType: FrameworkElement.DefaultStyleKey
  fullName: System.Windows.FrameworkElement.DefaultStyleKey
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "테마 스타일을 사용 하거나 정의 하는 경우이 컨트롤에 스타일을 참조 하는 데 키를 가져오거나 설정 합니다."
  remarks: "이 속성은 일반적으로 직접 속성 접근자를 통해 설정 되지 않습니다. 새 <xref:System.Windows.FrameworkElement>파생 클래스를</xref:System.Windows.FrameworkElement> 만들 때마다이 종속성 속성의 유형별 메타 데이터 재정의 대신, 컨트롤을 파생 시킬 때 호출의 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>에 대 한 메서드는 <xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>컨트롤의 정적 생성자 내에서 식별자 파생 클래스 (또는 해당 하는 클래스 초기화).</xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty> </xref:System.Windows.DependencyProperty.OverrideMetadata%2A>       컨트롤은 일반적으로 자체 형식으로이 속성의 기본값을 재정의 하지만 일부 경우에 사용할 수도 스타일 테마 사전에 존재 하는 기본 형식. 이 기본 컨트롤의 컨트롤 템플릿을 전체 해당 파생된 컨트롤의 시각적 표시를 정의 하 고 파생된 된 형식을 노출 하는 모든 추가 멤버 컨트롤 서식 파일의 일부로 추가 요소를 필요 하지 않은 경우에 유용한.       테마 스타일을 사용 하지 않도록 신중 하 게 컨트롤을 하려는 경우 설정 된 <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>속성을 `true`.</xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>      <a name=&quot;dependencyPropertyInfo_DefaultStyleKey&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>"
  example:
  - "The following example illustrates the dependency property metadata override usage discussed in Remarks. This code defines a custom control class `NumericUpDown` intended to be used from a dedicated control library assembly. The illustrated static constructor references some private initialization function, registers a class handler (another common control subclassing scenario; see [Marking Routed Events as Handled, and Class Handling](~/add/includes/ajax-current-ext-md.md)) and finally overrides the DefaultStyleKey dependency property metadata on the `NumericUpDown` class. DefaultStyleKey always returns its own type as the intended key, which is the convention that the theme style system uses to look up the style for some arbitrary otherwise non-styled control. The complete sample also defines the actual control's theme style that is referenced by that key; see [NumericUpDown Custom Control with Theme and UI Automation Support Sample](http://go.microsoft.com/fwlink/?LinkID=160025).  \n  \n [!code-cs[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/add/codesnippet/csharp/CustomControlLibrary/NumericUpDown.cs#staticctorofcustomclasscommontasks)]\n [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/add/codesnippet/visualbasic/customcontrollibrary/numericupdown.vb#staticctorofcustomclasscommontasks)]  \n[!code-cs[CustomControlNumericUpDown#Close](~/add/codesnippet/csharp/CustomControlLibrary/NumericUpDown.cs#close)]\n[!code-vb[CustomControlNumericUpDown#Close](~/add/codesnippet/visualbasic/customcontrollibrary/numericupdown.vb#close)]"
  syntax:
    content: protected object DefaultStyleKey { get; set; }
    return:
      type: System.Object
      description: "스타일 키입니다. 테마 스타일 조회의 일부로 올바르게 작동 하려면이 값은 해야는 <xref:System.Type>스타일을 지정 하는 컨트롤의.</xref:System.Type>"
  overload: System.Windows.FrameworkElement.DefaultStyleKey*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DefaultStyleKeyProperty
  id: DefaultStyleKeyProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkElement.DefaultStyleKeyProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.DefaultStyleKey*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.DefaultStyleKey*>"
  syntax:
    content: protected static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.EndInit
  id: EndInit
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: EndInit()
  nameWithType: FrameworkElement.EndInit()
  fullName: System.Windows.FrameworkElement.EndInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "요소에 대 한 초기화 프로세스가 완료 되었음을 나타냅니다."
  remarks: "경우 <xref:System.Windows.FrameworkElement.BeginInit%2A>가 이전에 호출, 기본 구현에서 발생 된 <xref:System.Windows.FrameworkElement.Initialized>이벤트.</xref:System.Windows.FrameworkElement.Initialized> </xref:System.Windows.FrameworkElement.BeginInit%2A> 그렇지 않은 경우, <xref:System.Windows.FrameworkElement.BeginInit%2A>호출 되지 않은 것일 수도 되었는지를 확인할 <xref:System.Windows.FrameworkElement.BeginInit%2A>를 호출 했지만 <xref:System.Windows.FrameworkElement.Initialized>발생 하지 않습니다 예외가 대신 및.</xref:System.Windows.FrameworkElement.Initialized> </xref:System.Windows.FrameworkElement.BeginInit%2A> </xref:System.Windows.FrameworkElement.BeginInit%2A>"
  syntax:
    content: public virtual void EndInit ();
    parameters: []
  overload: System.Windows.FrameworkElement.EndInit*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndInit 없이 호출한 <xref:System.Windows.FrameworkElement.BeginInit*>요소에 대해 이전에 호출 된.</xref:System.Windows.FrameworkElement.BeginInit*>"
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FindName(System.String)
  id: FindName(System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FindName(String)
  nameWithType: FrameworkElement.FindName(String)
  fullName: System.Windows.FrameworkElement.FindName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "제공 된 식별자 이름을 가진 요소를 찾습니다."
  remarks: "요소에 자식 요소가 있으면 이러한 자식 요소는 요청 된 명명 된 요소에 대 한 모든 검색 결과 재귀적으로.       FindName 현재 요소의 이름 범위 내에서 작동합니다. 자세한 내용은 참조 [WPF XAML 이름 범위](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public object FindName (string name);
    parameters:
    - id: name
      type: System.String
      description: "요청한 요소의 이름입니다."
    return:
      type: System.Object
      description: "요청 된 요소입니다. 이 수 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 가 일치 하는 요소가 없는 경우."
  overload: System.Windows.FrameworkElement.FindName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FindResource(System.Object)
  id: FindResource(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FindResource(Object)
  nameWithType: FrameworkElement.FindResource(Object)
  fullName: System.Windows.FrameworkElement.FindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "지정된 된 키와 리소스를 검색 하 고 요청 된 리소스가 없는 경우 예외를 throw 합니다."
  remarks: "> [!IMPORTANT]>를 찾을 수 없는 키에 대 한이 메서드를 호출 하는 경우 예외가 throw 됩니다. FindResource, 호출을 호출 하 여 발생 하는 예외를 처리 하지 않을 경우 <xref:System.Windows.FrameworkElement.TryFindResource%2A>대신.</xref:System.Windows.FrameworkElement.TryFindResource%2A> <xref:System.Windows.FrameworkElement.TryFindResource%2A>반환 `null` 요청 된 리소스를 찾을 수 없으면 시점과 예외를 throw 하지 않습니다.</xref:System.Windows.FrameworkElement.TryFindResource%2A>       호출 하는 요소에는 리소스를 찾을 수 없습니다, 논리적 트리에서 부모 요소 이면 검색 결과 다음 다음는 응용 프로그램을 다음 테마, 고 마지막으로 시스템 리소스입니다. 이 조회 방법은 태그에서 동적 리소스 참조 하 여 리소스를 요청 하는 경우 트리를 검색 하는 방법을 동일 합니다. 리소스 조회에 대 한 자세한 내용은 참조 [XAML 리소스](~/add/includes/ajax-current-ext-md.md)합니다.       일반적으로 반환 되는 리소스 값을 사용 하 여 설정 하는 속성의 형식으로 반환 값 FindResource 즉시 캐스팅 합니다.       리소스 키는 반드시 문자열입니다. 예를 들어, 컨트롤 테마 수준으로 지정에 대 한 스타일은 <xref:System.Type>컨트롤 및 스타일을 응용 프로그램 또는 페이지에 대 한 컨트롤 일반적으로 사용 하 여이 동일한 키 규칙.</xref:System.Type> 자세한 내용은 참조 [스타일 및 템플릿](~/add/includes/ajax-current-ext-md.md) 또는 [XAML 리소스](../Topic/XAML%20Resources.md)합니다."
  example:
  - "The following example obtains a named resource and casts it to an appropriate type to fill a property.  \n  \n [!code-cs[PropertiesOvwSupport#ResourceProceduralGet](~/add/codesnippet/csharp/PropertiesOvwSupport/page3.xaml.cs#resourceproceduralget)]\n [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/add/codesnippet/visualbasic/propertiesovwsupport/page3.xaml.vb#resourceproceduralget)]"
  syntax:
    content: public object FindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "요청된 된 리소스에 대 한 키 식별자입니다."
    return:
      type: System.Object
      description: "요청 된 리소스입니다. 제공 된 키에 리소스가 없으면 예외가 throw 됩니다. <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref> 값 예외인 경우에 반환 될 수도 있습니다."
  overload: System.Windows.FrameworkElement.FindResource*
  exceptions:
  - type: System.Windows.ResourceReferenceKeyNotFoundException
    commentId: T:System.Windows.ResourceReferenceKeyNotFoundException
    description: "<code>resourceKey</code>찾을 수 없으며 한 이벤트 처리기에 대 한 존재 하지 않습니다는 <xref href=&quot;System.Windows.Threading.Dispatcher.UnhandledException&quot;> </xref> 이벤트입니다.       -또는- <code>resourceKey</code> 찾을 수 없습니다 및 <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled*> 속성은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 에 <xref href=&quot;System.Windows.Threading.Dispatcher.UnhandledException&quot;> </xref> 이벤트입니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceKey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FlowDirection
  id: FlowDirection
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FlowDirection
  nameWithType: FrameworkElement.FlowDirection
  fullName: System.Windows.FrameworkElement.FlowDirection
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "텍스트 및 기타 방향을 가져오거나 [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] 해당 레이아웃을 제어 하는 부모 요소 안에서 요소를 배치 합니다."
  remarks: "The dependency property usage sets the FlowDirection on this element. Because of property value inheritance, setting FlowDirection on an element can potentially set FlowDirection on all child elements that did not set FlowDirection locally or though other means such as styles.  \n  \n This property is not automatically set as part of any application culture information, because an element might contain content that is not necessarily intended to obey the general flow direction implied by the culture information. For more information on globalization considerations, see [Globalization for WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n This property has a defined [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] property accessor, so it functions as a dependency property. However, it is also registered as attached, so it can also function as an attached property. The attached registration is mainly so that property value inheritance is supported, but the property can also be used as a true attached property. The attached property usage is only relevant if the object you intend to set the flow direction on has a <xref:System.Windows.FrameworkElement> parent element that performs layout upon it, is itself not a <xref:System.Windows.FrameworkElement>, and does not already have a more directly defined `FlowDirection` property. (Some of the flow document classes such as <xref:System.Windows.Documents.Block> and <xref:System.Windows.Documents.Inline> define their own `FlowDirection`, and this property can also set the flow direction. The property value is then read by the eventual content host without requiring attached property usage.)  \n  \n<a name=\"xamlAttributeUsage_FlowDirection\"></a>   \n## XAML Attribute Usage  \n \\<*object* **FlowDirection**=\"<xref:System.Windows.FlowDirection>\"/>  \n  \n<a name=\"xamlTextUsage_FlowDirection\"></a>   \n## XAML Text Usage  \n This property can also be set on classes that are not <xref:System.Windows.FrameworkElement> derived classes, by the following [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] attached property usage:  \n  \n `<` *object* `FrameworkElement.`**FlowDirection**=\"<xref:System.Windows.FlowDirection>`\"/>`  \n  \n<a name=\"dependencyPropertyInfo_FlowDirection\"></a>   \n## Dependency Property Information  \n  \n|||  \n|-|-|  \n|Identifier field|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  \n|Metadata properties set to `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  \n  \n This property is both a dependency property and an attached property; see Remarks."
  syntax:
    content: public System.Windows.FlowDirection FlowDirection { get; set; }
    return:
      type: System.Windows.FlowDirection
      description: "방향 텍스트 및 기타 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] 열거형의 값으로 해당 부모 요소 안에서 요소를 배치 합니다. 기본값은 <xref href=&quot;System.Windows.FlowDirection&quot;> </xref>합니다."
  overload: System.Windows.FrameworkElement.FlowDirection*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FlowDirectionProperty
  id: FlowDirectionProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FlowDirectionProperty
  nameWithType: FrameworkElement.FlowDirectionProperty
  fullName: System.Windows.FrameworkElement.FlowDirectionProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.FlowDirection*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.FlowDirection*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty FlowDirectionProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FocusVisualStyle
  id: FocusVisualStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FocusVisualStyle
  nameWithType: FrameworkElement.FocusVisualStyle
  fullName: System.Windows.FrameworkElement.FocusVisualStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "모양, 효과 또는 기타 스타일 특성을 키보드 포커스를 캡처할 때이 요소에 적용 되는 사용자 지정할 수 있는 속성을 가져오거나 설정 합니다."
  remarks: "이 속성 시각적 모양에 영향을 미칩니다. 하지만 보고 하지 않습니다 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>메타 데이터에.</xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 시각적으로 유사한 변경 이벤트 구동 하 고 모든 시간에 적용 되지 않을 수 및 따라서 보고 하지 않아야 일반적으로 메타 데이터에는 visual 또는 레이아웃 정보가 때문입니다.       개념적으로 컨트롤에 적용 되는 포커스의 시각적 동작 컨트롤에 일관 된 있어야 합니다. 일관성을 적용 하는 가장 적절 한 방법은 전체 테마를 작성 하는 경우에 포커스 시각적 스타일을 변경 하는 것입니다. 개별 컨트롤 스타일 및 테마의 일부가 아니라이 속성을 설정할 수는 없습니다. 테마 전체에서 일관 된 의도 한 대로 되지 않는 컨트롤 관련 동작을 하려는 경우 더 좋은 방법은를 사용 하 트리거 스타일의 개별 입력된 상태 속성 같은 <xref:System.Windows.UIElement.IsFocused%2A>또는 <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, 하므로 기존 포커스 시각적 스타일 시각적 방해 하지 않는 방식으로 수행할 수 있습니다.</xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> </xref:System.Windows.UIElement.IsFocused%2A> FocusVisualStyle 및 대체 포커스 속성의 디자인 의도에 자세한 내용은 참조 하십시오. [컨트롤과 FocusVisualStyle에 포커스에 대 한 스타일 지정](~/add/includes/ajax-current-ext-md.md)합니다.      <a name=&quot;xamlAttributeUsage_FocusVisualStyle&quot;></a># # XAML 특성 사용 ```   <object FocusVisualStyle=&quot;{resourceExtension styleResourceKey}&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_FocusVisualStyle&quot;> </a> # # XAML 속성 요소 사용 <a name=&quot;xamlValues_FocusVisualStyle&quot;> </a> # # XAML 값 *resourceExtension* 다음 중 하나:, 또는.       참조 [XAML 리소스](~/add/includes/ajax-current-ext-md.md)합니다.       *styleResourceKey* 요청 되는 스타일을 식별 하는 키입니다. 에 <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> 의 기존 리소스를이 키는      > [!NOTE] > 속성 요소 구문을 기술적으로 가능 하지만 권장 하지는 않습니다. 참조 [인라인 스타일 및 템플릿](~/add/includes/ajax-current-ext-md.md)합니다. 사용 하 여 바인딩 참조 또는 <xref:System.Windows.Data.Binding>가능 하지만 일반적이 지 않은 이기도 합니다.</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_FocusVisualStyle&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>"
  syntax:
    content: public System.Windows.Style FocusVisualStyle { get; set; }
    return:
      type: System.Windows.Style
      description: "포커스에 적용 하려면 원하는 스타일입니다. 종속성 속성에 선언 된 기본값은 빈 정적 <xref href=&quot;System.Windows.Style&quot;> </xref>합니다. 그러나 런타임 시 유효 값은 대체로 (항상 그렇지는 않음) 컨트롤에 대 한 테마 지원에서 제공 되는 스타일입니다."
  overload: System.Windows.FrameworkElement.FocusVisualStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FocusVisualStyleProperty
  id: FocusVisualStyleProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FocusVisualStyleProperty
  nameWithType: FrameworkElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkElement.FocusVisualStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.FocusVisualStyle*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.FocusVisualStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ForceCursor
  id: ForceCursor
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ForceCursor
  nameWithType: FrameworkElement.ForceCursor
  fullName: System.Windows.FrameworkElement.ForceCursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "표시 하는 값을 가져오거나 설정 합니다. 여부이 <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> 강제로 다시 시작은 [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] 으로 선언 된 커서를 렌더링 하는 <xref:System.Windows.FrameworkElement.Cursor*>속성.</xref:System.Windows.FrameworkElement.Cursor*>"
  remarks: "이 속성을 설정 하는 경우 `true` 자식 요소에서 설정한 커서 기본 설정을 재정의 합니다. 이렇게 하면 일반적 응용 프로그램 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] 자식 요소는 커서를 지정 하려고 하는 경우에 특히 해당 사용자를 혼동 될 수 있습니다. ForceCursor 설정은 컨트롤 서브클래싱 또는 작성 시나리오에 보다 적합 합니다.      <a name=&quot;dependencyPropertyInfo_ForceCursor&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.ForceCursorProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.FrameworkElement.ForceCursorProperty>"
  example:
  - "The following example forces the cursor value.  \n  \n [!code-xml[ForceCursor#ForceCursor](~/add/codesnippet/xaml/forcecursor/default.xaml#forcecursor)]"
  syntax:
    content: public bool ForceCursor { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>이 요소 위에 있는 동안 커서가 표시 현재 사용 하도록 강제 됩니다 <xref:System.Windows.FrameworkElement.Cursor*>(모든 자식 요소 포함); 커서에 대 한 설정을 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkElement.Cursor*> 기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.FrameworkElement.ForceCursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ForceCursorProperty
  id: ForceCursorProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ForceCursorProperty
  nameWithType: FrameworkElement.ForceCursorProperty
  fullName: System.Windows.FrameworkElement.ForceCursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.ForceCursor*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.ForceCursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ForceCursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)
  id: GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkElement.GetBindingExpression(DependencyProperty)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "반환 된 <xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref> 지정 된 속성의 바인딩을 나타내는입니다."
  remarks: "에 대 한 반환 값을 확인 `null` 기술을 사용 하면 속성에 활성 바인딩이 있는지 여부를 확인 하는 데 사용할 수 있습니다.       이 메서드는 실제로 편리한 래퍼는 <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName>메서드.</xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName> 현재 인스턴스를 전달 하는 GetBindingExpression 및 `dp` <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName>.</xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName> 매개 변수"
  syntax:
    content: public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "대상 <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> 에서 바인딩을 가져오려는 합니다."
    return:
      type: System.Windows.Data.BindingExpression
      description: "A <xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref> 대상 속성에 활성 바인딩이; 그렇지 않으면 반환 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.FrameworkElement.GetBindingExpression*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)
  id: GetFlowDirection(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetFlowDirection(DependencyObject)
  nameWithType: FrameworkElement.GetFlowDirection(DependencyObject)
  fullName: System.Windows.FrameworkElement.GetFlowDirection(DependencyObject)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "값을 가져옵니다는 <xref:System.Windows.FrameworkElement.FlowDirection*>연결 된 속성에서 지정 된 <xref href=&quot;System.Windows.DependencyObject&quot;> </xref>.</xref:System.Windows.FrameworkElement.FlowDirection*>"
  remarks: "에 대 한 연결 된 속성 구문을 지원 하도록이 메서드의 주요 목적은는 <xref:System.Windows.FrameworkElement.FlowDirection%2A>속성, 자식 요소는 제공 된 <xref:System.Windows.FrameworkElement>해당 부모 요소 내에서 정렬에 대 한 흐름 방향을 지정 하도록 합니다.</xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement.FlowDirection%2A> 현재 값을 <xref:System.Windows.FrameworkElement>를 직접 사용 하 여 [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] 접근자 <xref:System.Windows.FrameworkElement.FlowDirection%2A>.</xref:System.Windows.FrameworkElement.FlowDirection%2A> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);
    parameters:
    - id: element
      type: System.Windows.DependencyObject
      description: "<xref:System.Windows.FrameworkElement.FlowDirection*>&Gt;for</xref:System.Windows.FrameworkElement.FlowDirection*> 반환할 요소"
    return:
      type: System.Windows.FlowDirection
      description: "열거형의 값으로 요청 된 흐름 방향입니다."
  overload: System.Windows.FrameworkElement.GetFlowDirection*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)
  id: GetLayoutClip(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetLayoutClip(Size)
  nameWithType: FrameworkElement.GetLayoutClip(Size)
  fullName: System.Windows.FrameworkElement.GetLayoutClip(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "클리핑 기 하 도형을 반환 합니다. / / 마스크에는 레이아웃 시스템에서 사용 가능한 표시 공간 보다 큰 요소를 정렬 하려고 하는 경우 적용 됩니다."
  remarks: "여백에서 차감는 `layoutSlotSize` 레이아웃 시스템 동작의 일부로 합니다.       Null 참조가 반환 되는 오려낸 없습니다 발생 하는지 나타냅니다. 기본 구현에서는 항상 반환 `null` 때 <xref:System.Windows.UIElement.ClipToBounds%2A>은 `false`.</xref:System.Windows.UIElement.ClipToBounds%2A> 이 메서드를 재정의 <xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=fullName>.</xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=fullName> <xref:System.Windows.FrameworkElement>구현 사용 <xref:System.Windows.FrameworkElement.MaxHeight%2A>및 <xref:System.Windows.FrameworkElement.MaxWidth%2A>계산에.</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement> 여러 하위 클래스 <xref:System.Windows.FrameworkElement>다시이 메서드를 재정의 합니다.</xref:System.Windows.FrameworkElement> <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=fullName>를 반환을 항상 재정의 `null` 표시기 경우가 많기 때문에 의도적으로 일반 범위를 벗어났습니다.</xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=fullName> <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=fullName>and <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=fullName> return `null` if <xref:System.Windows.UIElement.ClipToBounds%2A> is `false`.</xref:System.Windows.UIElement.ClipToBounds%2A></xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=fullName></xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=fullName>"
  syntax:
    content: protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);
    parameters:
    - id: layoutSlotSize
      type: System.Windows.Size
      description: "시각적 표시를 수행 하는 요소 부분의 크기입니다."
    return:
      type: System.Windows.Media.Geometry
      description: "클리핑 기 하 도형입니다."
  overload: System.Windows.FrameworkElement.GetLayoutClip*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetTemplateChild(System.String)
  id: GetTemplateChild(System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetTemplateChild(String)
  nameWithType: FrameworkElement.GetTemplateChild(String)
  fullName: System.Windows.FrameworkElement.GetTemplateChild(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "명명된 된 요소는 인스턴스화된의 시각적 트리에 반환 <xref href=&quot;System.Windows.Controls.ControlTemplate&quot;> </xref>합니다."
  remarks: "서식 파일에서 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] 는 자체 포함 된 네임 스페이스에 있어야 합니다. 서식 파일에 정의 된 이름이 없는 고유 하지 않게 될 각 컨트롤의 여러 인스턴스 템플릿을 인스턴스화하면 및 템플릿이 다시 사용 되므로 때문입니다. 인스턴스화된 후 서식 파일에서 가져온 개체에 대 한 참조를 반환 하려면 GetTemplateChild 메서드를 호출 합니다. 사용할 수 없습니다는 <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName>때문에 서식 파일에서 항목을 찾을 메서드의 <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName>범위 보다 일반적인 내에서 작동 하 고 간의 연결이 <xref:System.Windows.Controls.ControlTemplate>클래스 자체와 인스턴스화된 템플릿이 적용 되 고 나면.</xref:System.Windows.Controls.ControlTemplate> </xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName> </xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName>       <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>이 방법으로 동일한 기능을 제공합니다.</xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName> <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>요소 이름이 items이 고 그 안에 찾기 내의 서식 파일에 액세스할 수 있도록 허용 하는 올바른 이름-범위 고려 사항 사용 하는 public이 아닌 보호.</xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName> 사용 하 여 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>부모 컨트롤 외부에서 요소를 가져오는 중지 해야 합니다.</xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>"
  syntax:
    content: protected System.Windows.DependencyObject GetTemplateChild (string childName);
    parameters:
    - id: childName
      type: System.String
      description: "찾을 자식의의 이름입니다."
    return:
      type: System.Windows.DependencyObject
      description: "요청 된 요소입니다. 되었을 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 요청한 이름이의 요소가 없을 경우."
  overload: System.Windows.FrameworkElement.GetTemplateChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetUIParentCore
  id: GetUIParentCore
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetUIParentCore()
  nameWithType: FrameworkElement.GetUIParentCore()
  fullName: System.Windows.FrameworkElement.GetUIParentCore()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "시각적 부모가 없는 경우이 요소에 대 한 대체 논리 부모를 반환 합니다."
  remarks: "이 메서드를 재정의 <xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=fullName>.</xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=fullName> 기본 <xref:System.Windows.FrameworkElement>구현은 가져오는와 동일한 결과 즉 예상된 단일 시각적 부모는 <xref:System.Windows.FrameworkElement.Parent%2A>값.</xref:System.Windows.FrameworkElement.Parent%2A> </xref:System.Windows.FrameworkElement> 파생된 클래스 구현은 대체 부모 관계를 반환할 수 있습니다."
  syntax:
    content: protected override System.Windows.DependencyObject GetUIParentCore ();
    parameters: []
    return:
      type: System.Windows.DependencyObject
      description: "이외의 다른 값을 반환 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 때마다이 메서드의 WPF 프레임 워크 수준 구현에 시각적 부모가 아닌 연결이 있습니다."
  overload: System.Windows.FrameworkElement.GetUIParentCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetVisualChild(System.Int32)
  id: GetVisualChild(System.Int32)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetVisualChild(Int32)
  nameWithType: FrameworkElement.GetVisualChild(Int32)
  fullName: System.Windows.FrameworkElement.GetVisualChild(Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "재정의 &lt;xref:System.Windows.Media.Visual.GetVisualChild%2A?displayProperty=fullName&gt;, 자식 요소 컬렉션에서 지정된 된 인덱스의 자식을 반환 합니다."
  remarks: "에 <xref:System.Windows.FrameworkElement>구현만 유효한 인덱스는&0;입니다.</xref:System.Windows.FrameworkElement> 콘텐츠 모델 GetVisualChild에&0; 개 또는&1; 자식 요소, 컬렉션이 아닌를 지원합니다."
  example:
  - "The following example shows how a custom adorner uses the values declared by a <xref:System.Windows.Media.VisualCollection> that it maintains for its multiple visual children. These values are reported through overrides of <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> and GetVisualChild.  \n  \n [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverridespre)]\n [!code-cs[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverridespre)]  \n[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverrides)]\n[!code-cs[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverrides)]"
  syntax:
    content: protected override System.Windows.Media.Visual GetVisualChild (int index);
    parameters:
    - id: index
      type: System.Int32
      description: "컬렉션에서 요청 된 자식 요소의&0;부터 시작 하는 인덱스입니다."
    return:
      type: System.Windows.Media.Visual
      description: "요청 된 자식 요소입니다. 이렇게 하면 반환 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>부재 중 지정 된 인덱스는 범위, 예외가 throw 됩니다."
  overload: System.Windows.FrameworkElement.GetVisualChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Height
  id: Height
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Height
  nameWithType: FrameworkElement.Height
  fullName: System.Windows.FrameworkElement.Height
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "요소의 제안 된 높이 가져오거나 설정 합니다."
  remarks: "높이 세 개의 쓰기 가능한 속성 중 하나에서 <xref:System.Windows.FrameworkElement>높이 정보를 지정 하는.</xref:System.Windows.FrameworkElement> 다른 두 <xref:System.Windows.FrameworkElement.MinHeight%2A>및 <xref:System.Windows.FrameworkElement.MaxHeight%2A>.</xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement.MinHeight%2A> 은 간에 충돌 하는 경우 이들 값이 실제 높이 결정 하기 위한 응용 프로그램의 순서는 첫 번째 <xref:System.Windows.FrameworkElement.MinHeight%2A>다음, 해야 <xref:System.Windows.FrameworkElement.MaxHeight%2A>, 마지막으로, 높이 범위 내에 있는 경우.</xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement.MinHeight%2A>       이 요소는 자식 요소가 다른 요소 내에서 이면 다음이 속성 값을 설정 실제로 제안 된 값입니다. 이 레이아웃 시스템 뿐만 아니라 부모 요소의 특정 레이아웃 논리 값이 사용 됩니다 바인딩되지 입력으로 레이아웃 과정입니다. 실제로 <xref:System.Windows.FrameworkElement>거의 항상 <xref:System.Windows.Window>.</xref:System.Windows.Window> 높이 설정 하는 경우에 다른; 값인지의 자식 요소는</xref:System.Windows.FrameworkElement> (에 대 한 <xref:System.Windows.Window>, 응용 프로그램을 호스팅하는 기본 응용 프로그램 모델의 기본 렌더링 가정은 Hwnd를 만드는 하는 경우 값이 사용 됩니다.)</xref:System.Windows.Window>       <xref:System.Double>이 속성 값 또한 <xref:System.Double.NaN?displayProperty=fullName>.</xref:System.Double.NaN?displayProperty=fullName> 수</xref:System.Double> 허용 하는 것 외에도 코드에서 자동 크기 조정 동작을 지정 하는 방법입니다. [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 는 값을 설정 하면 문자열 &quot;Auto&quot; (대/소문자 구분)로 자동 크기 조정 동작을 사용 하도록 설정 합니다. 자동 크기 조정 동작 요소를 사용할 수 있는 높이 가득 찰 의미 합니다. 그러나 note 특정 컨트롤을 기본 테마 스타일 자동 크기 조정 동작 구체적으로 다시 설정 된 경우가 아니라면 사용할 수 없게 됩니다을 통해 기본 값 제공 하는 경우가 많습니다.       이 속성의 반환 값은 항상에 대해 설정 된 값과 동일 합니다. 반대로,의 값은 <xref:System.Windows.FrameworkElement.ActualHeight%2A>다를 수 있습니다.</xref:System.Windows.FrameworkElement.ActualHeight%2A> 어떤 이유로 제안 된 크기를 거부 하는 레이아웃 정적으로 발생할 수 있습니다이 일시적으로 또는 합니다. 레이아웃 시스템 자체의 높이 속성 시스템의 집합을 기준으로 비동기적으로 작동 하 고 해당 특정 크기 조정 속성 변경 내용을 아직 처리 되지 않을 수 있습니다.       에 대 한 값 제한은 <xref:System.Double>값에 의해 적용 되는 <xref:System.Windows.ValidateValueCallback>메커니즘.</xref:System.Windows.ValidateValueCallback> </xref:System.Double> 잘못 된 값을 설정 하려고 하면 런타임 예외가 throw 됩니다.       유효성 검사 이외에 비결 정적 상한 값이 레이아웃 시스템에 의해 적용 되는 높이 대 한 경계 (이 보다 큰 매우 큰 숫자 <xref:System.Single.MaxValue?displayProperty=fullName>보다 높지만 <xref:System.Double.MaxValue?displayProperty=fullName>).</xref:System.Double.MaxValue?displayProperty=fullName> </xref:System.Single.MaxValue?displayProperty=fullName> 이 경계를 초과 하면 요소가 렌더링 되지 하 고 예외가 throw 되지 않습니다. 높이 가능한 시각적 표시의 최대 크기 보다 훨씬 큰 값으로 설정 하지 않으면 또는 비결 정적이 상한 값을 초과할 수 있습니다.      <a name=&quot;xamlAttributeUsage_Height&quot;></a># # XAML 특성 사용 ```   <object Height=&quot;double&quot;/>   - or -   <object Height=&quot;qualifiedDouble&quot;/>   - or -   <object Height=&quot;Auto&quot;/>   ``` <a name=&quot;xamlValues_Height&quot;> </a> # # XAML 값 *double* <xref:System.Double> 의 문자열 표현은 <xref:System.Double>0.0 보다 크거나 같은 값.</xref:System.Double> </xref:System.Double>           상한 정보에 대 한 설명을 참조 하세요. 이 값으로 해석 되는 [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] 측정 합니다. 문자열은 소수점이 하를 명시적으로 포함 하지 않아야 합니다. 예를 들어 값의 `1` 허용 됩니다.       *도* A *double* 단위 선언 문자열 중 하나에 의해 다음 위에서 설명한 대로 값: `px`, `in`, `cm`, `pt`합니다.       `px`(기본값)은 [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` 인치; 1in 96px = = `cm` 센티미터; 1cm==(96/2.54) px `pt` 은 포인트; 1pt==(96/72) px **자동** 크기 자동 조정 동작을 사용 합니다.        설명 부분을 참조 하십시오.      <a name=&quot;dependencyPropertyInfo_Height&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.HeightProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.HeightProperty>"
  syntax:
    content: public double Height { get; set; }
    return:
      type: System.Double
      description: "요소의 높이 [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]합니다. 기본값은 &lt;xref:System.Double?displayProperty=fullName&gt;합니다. 이 값은 0.0 보다 크거나 같은 이어야 합니다. 상한 정보에 대 한 설명을 참조 하세요."
  overload: System.Windows.FrameworkElement.Height*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.HeightProperty
  id: HeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: HeightProperty
  nameWithType: FrameworkElement.HeightProperty
  fullName: System.Windows.FrameworkElement.HeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.Height*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.Height*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty HeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.HorizontalAlignment
  id: HorizontalAlignment
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: HorizontalAlignment
  nameWithType: FrameworkElement.HorizontalAlignment
  fullName: System.Windows.FrameworkElement.HorizontalAlignment
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "패널 또는 항목 컨트롤 같은 부모 요소에서 작성 하는 경우이 요소에 적용 되는 가로 맞춤 특징을 가져오거나 설정 합니다."
  remarks: "경우 <xref:System.Windows.FrameworkElement.Height%2A>및 <xref:System.Windows.FrameworkElement.Width%2A>속성 요소에 명시적으로 설정 되어, 이러한 측정값을 레이아웃 하는 동안 높은 우선 되며 <xref:System.Windows.HorizontalAlignment>.</xref:System.Windows.HorizontalAlignment> HorizontalAlignment을 설정할 때의 일반적인 효과 취소 합니다.</xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.Height%2A>       HorizontalAlignment는는 [!INCLUDE[TLA#tla_net](~/add/includes/tlasharptla-net-md.md)] 이란 현실에서 종속성 속성에 대 한 속성 접근자입니다. 이 특정 종속성 속성에는 상당히 자주 해당 &quot;기본값&quot;이 서브클래싱된 요소, 특히 컨트롤에서에서 서로 다르게 설정 되어 있습니다. 일반적으로이 두 가지 방법 중 하나에서 발생 합니다: 종속성 속성은 해당 기본값을 설정 하기 위한 여러 가지 메타 데이터 사용 하면서도 특정 서브 클래스에 다시 등록 있거나 해당 종속성 속성 값을 다르게 설정 하는 기본 스타일 적용 되 고 있습니다. 예를 들어 명백한 &quot;기본값인&quot;에 대 한 HorizontalAlignment는 <xref:System.Windows.Controls.Label>컨트롤 됩니다 <xref:System.Windows.HorizontalAlignment>경우라도, <xref:System.Windows.Controls.Label> <xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement> HorizontalAlignment 직접 상속</xref:System.Windows.Controls.Label> </xref:System.Windows.HorizontalAlignment> </xref:System.Windows.Controls.Label> 즉, 해당 값의 기본 스타일 내에서 다시 설정 된 <xref:System.Windows.Controls.Label>, 스타일의 컨트롤 템플릿 내에서.</xref:System.Windows.Controls.Label>       <xref:System.Windows.Controls.Canvas>되므로 사용 하지 않습니다 HorizontalAlignment 레이아웃을 구성할 때 <xref:System.Windows.Controls.Canvas>절대 위치에 따라.</xref:System.Windows.Controls.Canvas></xref:System.Windows.Controls.Canvas>       <xref:System.Windows.Controls.Label>또는 <xref:System.Windows.Controls.Label> <xref:System.Windows.HorizontalAlignment>.</xref:System.Windows.HorizontalAlignment> 되도록이 종속성 속성의 기본값 다시 정의 하는</xref:System.Windows.Controls.Label> 파생된 클래스에서</xref:System.Windows.Controls.Label> 상속 되는 경우      <a name=&quot;dependencyPropertyInfo_HorizontalAlignment&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> </xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>"
  syntax:
    content: public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }
    return:
      type: System.Windows.HorizontalAlignment
      description: "열거형의 값으로는 가로 맞춤 설정입니다. 기본값은 <xref href=&quot;System.Windows.HorizontalAlignment&quot;> </xref>합니다."
  overload: System.Windows.FrameworkElement.HorizontalAlignment*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.HorizontalAlignmentProperty
  id: HorizontalAlignmentProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: HorizontalAlignmentProperty
  nameWithType: FrameworkElement.HorizontalAlignmentProperty
  fullName: System.Windows.FrameworkElement.HorizontalAlignmentProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.HorizontalAlignment*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.HorizontalAlignment*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.InheritanceBehavior
  id: InheritanceBehavior
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: InheritanceBehavior
  nameWithType: FrameworkElement.InheritanceBehavior
  fullName: System.Windows.FrameworkElement.InheritanceBehavior
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "속성 값 상속, 리소스 키 조회 및 RelativeSource FindAncestor 조회에 대 한 범위 제한을 가져오거나 설정 합니다."
  remarks: "요소 트리의 특정 경계를에서 의도 한 대로 응용 프로그램 리소스를 확인 하거나 RelativeSource FindAncestor 조회를 더 이상 현재 요소 또는 쿼리 않으려면 force 리소스 조회에 상속 동작의 범위를 제한 하는 InheritanceBehavior를 설정 합니다. RelativeSource FindAncestor 조회 바인딩을 사용 하는 경우에 발생 한 <xref:System.Windows.Data.RelativeSource>있는 해당 <xref:System.Windows.Data.RelativeSource.Mode%2A>속성이로 설정는 <xref:System.Windows.Data.RelativeSourceMode?displayProperty=fullName>값.</xref:System.Windows.Data.RelativeSourceMode?displayProperty=fullName> </xref:System.Windows.Data.RelativeSource.Mode%2A> </xref:System.Windows.Data.RelativeSource>       이 속성을 설정 하려면 파생된 클래스를 사용 하도록 하려는 경우 정적 생성자 또는 다른 초기화 루틴에서 그렇게 수행 해야 합니다."
  syntax:
    content: protected System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }
    return:
      type: System.Windows.InheritanceBehavior
      description: "열거형의 값입니다. 기본값은 <xref href=&quot;System.Windows.InheritanceBehavior&quot;> </xref>합니다."
  overload: System.Windows.FrameworkElement.InheritanceBehavior*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Initialized
  id: Initialized
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Initialized
  nameWithType: FrameworkElement.Initialized
  fullName: System.Windows.FrameworkElement.Initialized
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 경우이 <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> 초기화 됩니다. 이 이벤트는 경우와 일치 여기서의 값은 <xref:System.Windows.FrameworkElement.IsInitialized*>속성이에서 변경 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (또는 undefined)를 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkElement.IsInitialized*>"
  remarks: "이 이벤트가 될 때마다 발생는 <xref:System.Windows.FrameworkElement.EndInit%2A>또는 <xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A>메서드가 호출 됩니다.</xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A> </xref:System.Windows.FrameworkElement.EndInit%2A> 두 방법 중 하나에 대 한 호출에서 응용 프로그램 코드 또는 나올 수는 [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] 프로세서 동작 때는 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 페이지를 처리 합니다.       처리 하도록 선택 하 든 <xref:System.Windows.FrameworkElement.Loaded>없거나 Initialized 요구 사항에 따라 다릅니다.</xref:System.Windows.FrameworkElement.Loaded> 요소 속성, 속성을 다시 사용할 필요가 없습니다 레이아웃 정보가 필요 하지 않은 경우 Initialized 더 나은 이벤트 작업을 수행할 수 있습니다. 를 사용할 수 있도록이 요소의 모든 속성이 필요 하 고 레이아웃을 다시 설정할 수 있는 속성을 설정 하는 경우 <xref:System.Windows.FrameworkElement.Loaded>더 나은 이벤트 작업을 수행할 수 있습니다.</xref:System.Windows.FrameworkElement.Loaded> 처리기에 필요한 새로운 레이아웃 단계는이 레이아웃 시스템에서 해석 하는 모든 속성이 다시 설정 하는 경우 재진입 주의 해야 합니다. (확인 해야 할 수 있습니다는 <xref:System.Windows.FrameworkPropertyMetadata>속성 새 레이아웃을 요구할 수의 확실 하지 않은 경우에 속성의 값 변경 된 경우에 전달 합니다.)</xref:System.Windows.FrameworkPropertyMetadata>       개체에 대 한 이벤트 시퀀스에 대 한 자세한 내용은 <xref:System.Windows.FrameworkElement>, 또한 여러 관련 응용 프로그램 및 요소 클래스를 참조 하 고 [개체 수명 이벤트](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkElement>"
  syntax:
    content: public event EventHandler Initialized;
    return:
      type: System.EventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.InputScope
  id: InputScope
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: InputScope
  nameWithType: FrameworkElement.InputScope
  fullName: System.Windows.FrameworkElement.InputScope
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 사용 되는 입력에 대 한 컨텍스트를 가져오거나 설정 합니다. <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>합니다."
  remarks: "속성 값이 종속성 속성을 상속 합니다. InputScope 로컬 값 또는 스타일을 통해 설정에 대 한 다른 값이 없는 자식 요소가 없으면 속성 시스템은 값이이 값이 할당 된 가장 가까운 상위 항목 요소 InputScope 값을 설정 합니다.       하지만 한 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 구문 사용 나열 되 고 구문이 허용 되는 경우이 속성을 설정할 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 이 일반적입니다.      <a name=&quot;dependencyPropertyInfo_InputScope&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.InputScopeProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.InputScopeProperty>"
  syntax:
    content: public System.Windows.Input.InputScope InputScope { get; set; }
    return:
      type: System.Windows.Input.InputScope
      description: "대체 입력 메서드에서 입력이 해석 되는 방법을 수정 하는 입력된 범위입니다. 기본값은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> (명령의 기본 처리 결과)."
  overload: System.Windows.FrameworkElement.InputScope*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.InputScopeProperty
  id: InputScopeProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: InputScopeProperty
  nameWithType: FrameworkElement.InputScopeProperty
  fullName: System.Windows.FrameworkElement.InputScopeProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.InputScope*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.InputScope*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty InputScopeProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.IsInitialized
  id: IsInitialized
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: IsInitialized
  nameWithType: FrameworkElement.IsInitialized
  fullName: System.Windows.FrameworkElement.IsInitialized
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소가 초기화 되었는지 여부를 나타내는 값을 가져옵니다에서 처리 하는 동안는 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 프로세서를 명시적으로 해당 <xref:System.Windows.FrameworkElement.EndInit*>메서드를 호출 합니다.</xref:System.Windows.FrameworkElement.EndInit*>"
  remarks: "두이 일 수도 `true` 새 부모 요소가 있으며 따라서 요소가 다시 로드 되도록이 요소의 논리적 트리 내에서 옮겨졌습니다 경우.       이 속성은 또한 사용 중인 경우 <xref:System.Windows.FrameworkElement.BeginInit%2A>및 <xref:System.Windows.FrameworkElement.EndInit%2A>.</xref:System.Windows.FrameworkElement.EndInit%2A> </xref:System.Windows.FrameworkElement.BeginInit%2A> 유용 로드 하는 논리적 트리에서 요소는 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 프로세서 초기화를 보장 합니다. 논리 트리에 없는 요소를 초기화할 때 <xref:System.Windows.FrameworkElement.EndInit%2A>호출 됩니다.</xref:System.Windows.FrameworkElement.EndInit%2A> 없는 경우 모든 특정 처리 <xref:System.Windows.FrameworkElement.BeginInit%2A>및 <xref:System.Windows.FrameworkElement.EndInit%2A>, 생성자 초기화 된 결과 반환 하는 즉시 발생 합니다.</xref:System.Windows.FrameworkElement.EndInit%2A> </xref:System.Windows.FrameworkElement.BeginInit%2A>"
  syntax:
    content: public bool IsInitialized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>요소가 앞서 언급 한 마다 초기화 되 면 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 처리 또는 메서드 호출, 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.FrameworkElement.IsInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.IsLoaded
  id: IsLoaded
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: IsLoaded
  nameWithType: FrameworkElement.IsLoaded
  fullName: System.Windows.FrameworkElement.IsLoaded
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소를 표시 하기 위해 로드 했는지 여부를 나타내는 값을 가져옵니다."
  remarks: "새로 생성 된 <xref:System.Windows.FrameworkElement>,이 속성 설정을 시작할 `false`, 상태를 유지 하 고 `true` 로 설정 된 후 `true`는 요소가 코드를 통해 연결 된 논리적 트리에서 제거 되는 경우에.</xref:System.Windows.FrameworkElement> `true`요소 프레젠테이션 엔진에 로드 될 때 상태가 일반 프레젠테이션 논리에 의해 설정 됩니다.       일반적으로 로드 된 요소는 렌더링 아니지만 일부 <xref:System.Windows.FrameworkElement>파생된 클래스에는 프레젠테이션 및과 같은 기타 속성 <xref:System.Windows.UIElement.Visibility%2A>프레젠테이션에 영향을 줄 수 있습니다.</xref:System.Windows.UIElement.Visibility%2A> </xref:System.Windows.FrameworkElement>"
  example:
  - "The following example implements two handlers: one is handling the <xref:System.Windows.FrameworkElement.Loaded> event of the root element, so it is certain that the page root element is loaded because that is the significance of the event. The other handler is hooked to a user control, and calls IsLoaded to assure that the root element is loaded completely. Both handlers call the same function (not shown) that will populate child elements with fresh data.  \n  \n [!code-cs[GroupBoxExample#FEIsLoaded](~/add/codesnippet/csharp/GroupBoxExample/Page1.xaml.cs#feisloaded)]"
  syntax:
    content: public bool IsLoaded { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>현재 요소의 요소 트리에서;에 연결 된 경우 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 요소는 로드 된 요소 트리에 연결 되지 않은 경우."
  overload: System.Windows.FrameworkElement.IsLoaded*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Language
  id: Language
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Language
  nameWithType: FrameworkElement.Language
  fullName: System.Windows.FrameworkElement.Language
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "요소에 적용 되는 지역화/세계화 언어 정보를 가져오거나 설정 합니다."
  remarks: "문자열 형식의 RFC 3066 표준에 따라 합니다. 예를 들어 미국 영어는 &quot;EN-US&quot;입니다. 값 및 형식에 대 한 자세한 내용은 <xref:System.Windows.Markup.XmlLanguage>.</xref:System.Windows.Markup.XmlLanguage> 을 참조 하십시오.       속성 값이 종속성 속성을 상속 합니다. 로컬 값 또는 스타일을 통해 설정 하는 언어에 대 한 다른 값이 없는 자식 요소가 없으면 속성 시스템에 값이이 값이 할당 된 가장 가까운 상위 요소의 언어 값을 설정 합니다.       [!INCLUDE[TLA2#tla_xml](~/add/includes/tla2sharptla-xml-md.md)]일반적인 의미를 정의 고 `xml:lang` 특성입니다. 언어는 기본적으로이 특성의 의미는 종속성 속성으로 노출합니다. 언어 프로그래밍 방식으로 조정할 수 있습니다 및 기능과 유사한 방식으로 속성 시스템 값을 상속에 참여할 수는 어떻게 `xml:lang` 특성의 자식 요소 범위를 상속할 수 [!INCLUDE[TLA2#tla_xml](~/add/includes/tla2sharptla-xml-md.md)]합니다. 언어를 설정 하는 경우 해당 값이 고 `xml:lang` 하 고 이전 값을 덮어씁니다. 자세한 내용은 참조 [xml: lang XAML의 처리](~/add/includes/ajax-current-ext-md.md)합니다.      <a name=&quot;dependencyPropertyInfo_CultureInfo&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.LanguageProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.LanguageProperty>"
  syntax:
    content: public System.Windows.Markup.XmlLanguage Language { get; set; }
    return:
      type: System.Windows.Markup.XmlLanguage
      description: "이 요소에 대 한 언어 정보입니다. 기본값은는 <xref href=&quot;System.Windows.Markup.XmlLanguage&quot;> </xref> 와 해당 <xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>값 문자열 &quot;EN-US&quot;로 설정 합니다.</xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>"
  overload: System.Windows.FrameworkElement.Language*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LanguageProperty
  id: LanguageProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LanguageProperty
  nameWithType: FrameworkElement.LanguageProperty
  fullName: System.Windows.FrameworkElement.LanguageProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.Language*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.Language*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty LanguageProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LayoutTransform
  id: LayoutTransform
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LayoutTransform
  nameWithType: FrameworkElement.LayoutTransform
  fullName: System.Windows.FrameworkElement.LayoutTransform
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "레이아웃이 수행 될 때이 요소에 적용 해야 하는 그래픽 변형을 가져오거나 설정 합니다."
  remarks: "달리 <xref:System.Windows.UIElement.RenderTransform%2A>, LayoutTransform 레이아웃의 결과 영향을 줍니다.</xref:System.Windows.UIElement.RenderTransform%2A>       변환을 설정 하면 크기 조정 및 회전의 강력한 기능을 제공 합니다. 그러나 LayoutTransform 무시 <xref:System.Windows.Media.TranslateTransform>작업.</xref:System.Windows.Media.TranslateTransform> 때문에 이것이의 자식 요소에 대 한 레이아웃 시스템 동작은 <xref:System.Windows.FrameworkElement>자동 수정 레이아웃에 크기가 조정 되거나 회전 된 요소의 위치 및 좌표계 부모 요소에 대 한 오프셋입니다.</xref:System.Windows.FrameworkElement>       LayoutTransform은 레이아웃 시스템에서 전체 과정을 필요로 하지 않는 시나리오에서 호출 하는 경우 응용 프로그램 성능이 저하 될 수 있습니다. LayoutTransform을 적용 하는 경우는 <xref:System.Windows.Controls.Panel.Children%2A>의 컬렉션은 <xref:System.Windows.Controls.Panel>, 레이아웃 시스템에서 새로운 패스를 트리거합니다 및 모든 화면 트리거되고 하 고 다시 정렬 하려면 개체가.</xref:System.Windows.Controls.Panel> </xref:System.Windows.Controls.Panel.Children%2A> 전체 응용 프로그램을 업데이트 하는 경우 [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)],이 기능은 정확히 일 수 있습니다 어떻게 해야 합니다. 그러나 전체 레이아웃 단계를 필요 하지 않은 경우 사용 하 여는 <xref:System.Windows.UIElement.RenderTransform%2A>속성 레이아웃 시스템을 호출 하지 않는 이며 따라서 일반적으로이 시나리오에 대 한 더 좋습니다.</xref:System.Windows.UIElement.RenderTransform%2A>       예를 들면 여기서 LayoutTransform 것이 유용한 다음과: 편집 동작 등을 제공 하는 포커스 (확대) 요소 크기를 조정 하는 가로 또는 그 반대로 세로로 메뉴 구성 요소 같은 요소를 회전 합니다.      <a name=&quot;dependencyPropertyInfo_LayoutTransform&quot;> </a> # # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.LayoutTransformProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.LayoutTransformProperty>"
  example:
  - "The following example shows how to apply a LayoutTransform to an element. The example creates an instance of <xref:System.Windows.Controls.Button> and hosts it within a parent <xref:System.Windows.Controls.Grid>. It also uses the LayoutTransform property to apply a <xref:System.Windows.Media.RotateTransform> to the <xref:System.Windows.Controls.Button>.  \n  \n [!code-vb[LayoutTransform#1](~/add/codesnippet/visualbasic/LayoutTransformVB/LayoutTransform.vb#1)]\n [!code-cpp[LayoutTransform#1](~/add/codesnippet/cpp/layouttransform/LayoutTransform.cpp#1)]\n [!code-xml[LayoutTransform#1](~/add/codesnippet/xaml/LayoutTransform/default.xaml#1)]\n [!code-cs[LayoutTransform#1](~/add/codesnippet/csharp/LayoutTransformCsharp/LayoutTransform.cs#1)]"
  syntax:
    content: public System.Windows.Media.Transform LayoutTransform { get; set; }
    return:
      type: System.Windows.Media.Transform
      description: "이 요소를 사용 해야 하는 변환입니다. 기본값은 <xref:System.Windows.Media.Transform.Identity*>.</xref:System.Windows.Media.Transform.Identity*>"
  overload: System.Windows.FrameworkElement.LayoutTransform*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LayoutTransformProperty
  id: LayoutTransformProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LayoutTransformProperty
  nameWithType: FrameworkElement.LayoutTransformProperty
  fullName: System.Windows.FrameworkElement.LayoutTransformProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.LayoutTransform*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.LayoutTransform*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty LayoutTransformProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Loaded
  id: Loaded
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Loaded
  nameWithType: FrameworkElement.Loaded
  fullName: System.Windows.FrameworkElement.Loaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "요소를 배치 하 고 상호 작용할 준비가 렌더링 하는 경우 발생 합니다."
  remarks: "로드는 일반적으로 마지막 이벤트 발생 요소 초기화 시퀀스 합니다. 항상 <xref:System.Windows.FrameworkElement.Initialized>.</xref:System.Windows.FrameworkElement.Initialized> 후 발생 합니다. 로드를 처리 하도록 선택 하 든 또는 <xref:System.Windows.FrameworkElement.Initialized>요구 사항에 따라 달라 집니다.</xref:System.Windows.FrameworkElement.Initialized> 요소 속성을 읽는 필요 하지 않는 경우 속성을 다시 설정 하려고 하 고 모든 레이아웃 정보가 필요 하지 않은 <xref:System.Windows.FrameworkElement.Initialized>더 나은 이벤트 작업을 수행할 수 있습니다.</xref:System.Windows.FrameworkElement.Initialized> 모든 속성을 사용 해야 할 경우에 요소를 사용할 수 있도록 하 고 속성을 설정 레이아웃을 다시 설정할 수 있는 로드 더 나은 이벤트 작업을 수행할 수 있습니다. 처리기에 필요한 새로운 레이아웃 단계는이 레이아웃 시스템에서 해석 하는 모든 속성이 다시 설정 하는 경우 재진입 주의 해야 합니다. (확인 해야 할 수 있습니다는 <xref:System.Windows.FrameworkPropertyMetadata>속성 새 레이아웃을 요구할 수의 확실 하지 않은 경우에 속성의 값 변경 된 경우에 전달 합니다.)</xref:System.Windows.FrameworkPropertyMetadata>       개체에 대 한 이벤트 시퀀스에 대 한 자세한 내용은 <xref:System.Windows.FrameworkElement>, 또한 여러 관련 응용 프로그램 및 요소 클래스를 참조 하 고 [개체 수명 이벤트](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkElement>       라우트된 이벤트를 직접 경로 따르지 않는, 에서만 발생 하는 동일한 요소 내에서 처리 됩니다. 라우트된 이벤트에 다른 라우트된 이벤트 동작 지원 않는 직접: 액세스할 수 있는 처리기 컬렉션을 지원 하며으로 사용할 수는 <xref:System.Windows.EventTrigger>스타일에서.</xref:System.Windows.EventTrigger>       로드 및 <xref:System.Windows.FrameworkElement.Unloaded>시스템 사용자가 시작한 테마 변경의 결과로 컨트롤에서 발생할 수 있습니다.</xref:System.Windows.FrameworkElement.Unloaded> 테마를 변경 하면 컨트롤 템플릿 및 포함 된 시각적 트리가 그러면 언로드하고 다시 로드 하기 위해 전체 컨트롤의 무효화 합니다. 따라서 Loaded만 페이지를 처음 로드할 때 페이지 탐색을 통해 적용 되려면 가정할 수 없습니다.      <a name=&quot;routedEventInfo_Loaded&quot;></a># # 이벤트 정보 라우트된 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.LoadedEvent>|   | 라우팅 전략 | 직접 |   | 대리자 | <xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkElement.LoadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Loaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LoadedEvent
  id: LoadedEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LoadedEvent
  nameWithType: FrameworkElement.LoadedEvent
  fullName: System.Windows.FrameworkElement.LoadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref href=&quot;System.Windows.FrameworkElement.Loaded&quot;> </xref> 라우트된 이벤트입니다."
  remarks: "라우트된 이벤트 식별자는 라우트된 이벤트가 등록 될 때 생성 됩니다. 이러한 식별자는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드가 포함 됩니다. 클래스 처리기를 추가 하려면 이러한 식별자를 사용할 수 있습니다.       라우트된 이벤트를 등록 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 을 참조 하십시오. 라우트된 이벤트 식별자를 사용 하 여 클래스 처리기를 추가 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A> 을 참조 하십시오."
  syntax:
    content: public static readonly System.Windows.RoutedEvent LoadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LogicalChildren
  id: LogicalChildren
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LogicalChildren
  nameWithType: FrameworkElement.LogicalChildren
  fullName: System.Windows.FrameworkElement.LogicalChildren
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소의 논리 자식 요소에 대 한 열거자를 가져옵니다."
  remarks: "LogicalChildren를 사용 하면 자식 요소를 반복할 수 있습니다. 이 정의 되 고 전용 컬렉션이 수 있지만 여전히 특히 둘 이상의 자식 요소를 포함 하는 요소에 대 한 유용한 <xref:System.Windows.FrameworkContentElement>자식 요소.</xref:System.Windows.FrameworkContentElement>       LogicalChildren를 사용 하는 방법에 대 한 자세한 내용은 및 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>, 참조 [In WPF](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkElement.AddLogicalChild%2A>"
  syntax:
    content: protected virtual System.Collections.IEnumerator LogicalChildren { get; }
    return:
      type: System.Collections.IEnumerator
      description: "이 요소의 논리 자식 요소에 대 한 열거자입니다."
  overload: System.Windows.FrameworkElement.LogicalChildren*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Margin
  id: Margin
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Margin
  nameWithType: FrameworkElement.Margin
  fullName: System.Windows.FrameworkElement.Margin
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "요소의 바깥쪽 여백을 가져오거나 설정 합니다."
  remarks: "이 요소와 레이아웃을 만들 때 인접 하는 다른 요소 사이의 간격을 여백은 [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]합니다. 공유 요소 피어 요소 (예: 다른 요소는 공통 부모 컨트롤의 컬렉션), 없거나이 요소의 부모 수도 있습니다.       여백이 설정으로 <xref:System.Windows.Thickness>구조 아닌 숫자로 여백을 비대칭적으로 설정할 수 있도록 합니다.</xref:System.Windows.Thickness> <xref:System.Windows.Thickness>구조 자체 비대칭 여백에 지정할 수 있도록 문자열 형식 변환을 지원 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 특성 구문 에서도.</xref:System.Windows.Thickness>       0이 아닌 여백 <xref:System.Windows.FrameworkElement.ActualWidth%2A>및 <xref:System.Windows.FrameworkElement.ActualHeight%2A>.</xref:System.Windows.FrameworkElement.ActualHeight%2A> </xref:System.Windows.FrameworkElement.ActualWidth%2A> 요소 레이아웃의 바깥쪽에 공간을 적용       여백은 레이아웃; 형제 요소에 대 한 추가 예를 들어 인접 가장자리 30의 여백 모두 설정 하는 인접 요소 두 개 사이 공백 60 개의 것입니다.       할당 된 사각형 공간이 여백 및 요소 콘텐츠 영역에 충분 하지 않을 경우 여백이 설정 되어 있는 요소 지정 된 여백 크기를 일반적으로 제한 하지 않습니다. 대신 레이아웃을 계산할 때 요소 콘텐츠 영역에 제한이 적용 됩니다. 여백을 제한할 수는 유일한 경우는 또한 하는 경우이 콘텐츠가 이미&0;까지 제약 조건이 적용 됩니다.      <a name=&quot;xamlAttributeUsage_Margin&quot;></a># # XAML 특성 사용 ```   <object Margin=&quot;left,top,right,bottom&quot;/>   - or -   <object Margin=&quot;left,top&quot;/>   - or -   <object Margin=&quot;thicknessReference&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_Margin&quot;> </a> # # XAML 속성 요소 사용 ```   <object>     <object.Margin>       <Thickness Left=&quot;left&quot; Top=&quot;top&quot; Right=&quot;right&quot; Bottom=&quot;bottom&quot;/>     </object.Margin>   </object>   ``` <a name=&quot;xamlValues_Margin&quot;> </a> # # XAML 값 *상위, 오른쪽, 아래쪽,* 0 사이의 숫자 값 및 <xref:System.Double.PositiveInfinity>의 4 가지 가능한 차원 속성을 지정 하는 한 <xref:System.Windows.Thickness>구조.</xref:System.Windows.Thickness> </xref:System.Double.PositiveInfinity>                   특성 사용에 수락할 대칭적 및 논리적으로 제공 된 순서에 적용 되는 약어 값도 합니다. 예를 들어, `Margin=&quot;20&quot;` 의미를 해석할 수는 <xref:System.Windows.Thickness>20으로 설정 하는 모든 속성을 가진.</xref:System.Windows.Thickness> `Margin=&quot;20,50&quot;`으로 해석 됩니다는 <xref:System.Windows.Thickness>와 <xref:System.Windows.Thickness.Left%2A>및 <xref:System.Windows.Thickness.Right%2A>20으로 설정 하 고 <xref:System.Windows.Thickness.Top%2A>및 <xref:System.Windows.Thickness.Bottom%2A>50으로 설정 합니다.</xref:System.Windows.Thickness.Bottom%2A> </xref:System.Windows.Thickness.Top%2A> </xref:System.Windows.Thickness.Right%2A> </xref:System.Windows.Thickness.Left%2A> </xref:System.Windows.Thickness>       기본 단위는 <xref:System.Windows.Thickness>측정값은 [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)].</xref:System.Windows.Thickness> 단위 형식 문자열을 추가 하 여 다른 단위를 지정할 수도 `cm`, `in`, 또는 `pt` 모든 측정값을 합니다.       숫자 값으로 제공 된 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 특성 소수점이 하를 지정 하지 않아도 (0이 허용 되는, 0.0으로 제공 될 필요는 없습니다.). 대 한 자세한 내용은 [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] 사용량, <xref:System.Windows.Thickness>.</xref:System.Windows.Thickness> 를 참조 하세요.       *thicknessReference* 기존 <xref:System.Windows.Thickness>.</xref:System.Windows.Thickness> 에 대 한 개체 참조 이렇게 할 수는 `}`a, 또는 `}` 참조 합니다. 대 한 자세한 내용은 [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] 사용량, <xref:System.Windows.Thickness>.</xref:System.Windows.Thickness> 를 참조 하세요.      <a name=&quot;dependencyPropertyInfo_Margin&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.MarginProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MarginProperty>"
  syntax:
    content: public System.Windows.Thickness Margin { get; set; }
    return:
      type: System.Windows.Thickness
      description: "요소에 대 한 여백 값을 제공합니다. 기본값은 한 <xref href=&quot;System.Windows.Thickness&quot;> </xref> 속성은 모두 0 (영)입니다."
  overload: System.Windows.FrameworkElement.Margin*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MarginProperty
  id: MarginProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MarginProperty
  nameWithType: FrameworkElement.MarginProperty
  fullName: System.Windows.FrameworkElement.MarginProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.Margin*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.Margin*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MarginProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxHeight
  id: MaxHeight
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxHeight
  nameWithType: FrameworkElement.MaxHeight
  fullName: System.Windows.FrameworkElement.MaxHeight
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "요소의 최대 높이 제약 조건을 가져오거나 설정 합니다."
  remarks: "이 세 가지 속성 중 하나에 <xref:System.Windows.FrameworkElement>높이 정보를 지정 하는.</xref:System.Windows.FrameworkElement> 다른 두 <xref:System.Windows.FrameworkElement.MinHeight%2A>및 <xref:System.Windows.FrameworkElement.Height%2A>.</xref:System.Windows.FrameworkElement.Height%2A> </xref:System.Windows.FrameworkElement.MinHeight%2A> 은  이러한 값 간에 충돌이 발생 하는 경우 실제 높이 결정 하기 위한 응용 프로그램의 순서는 첫 번째 <xref:System.Windows.FrameworkElement.MinHeight%2A>, 다음 최대 높이 마지막으로 <xref:System.Windows.FrameworkElement.Height%2A>.</xref:System.Windows.FrameworkElement.Height%2A> 범위 내에 있는 이러한 각 경우</xref:System.Windows.FrameworkElement.MinHeight%2A>       에 대 한 값 제한은 <xref:System.Double>값에 의해 적용 되는 <xref:System.Windows.ValidateValueCallback>메커니즘.</xref:System.Windows.ValidateValueCallback> </xref:System.Double> 잘못 된 값을 설정 하려고 하면 런타임 예외가 throw 됩니다.      <a name=&quot;xamlAttributeUsage_MaxHeight&quot;></a># # XAML 특성 사용 ```   <object MaxHeight=&quot;double&quot;/>   - or –   <object MaxHeight =&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MaxHeight&quot;> </a> # # XAML 값 *double* <xref:System.Double> 의 문자열 표현은 <xref:System.Double>0.0 보다 크거나 같은 값.</xref:System.Double> </xref:System.Double>           이 값으로 해석 되는 [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] 측정 합니다. 문자열은 소수점이 하를 명시적으로 포함 하지 않아야 합니다. 예를 들어 값의 `1` 허용 됩니다.       동일한 <xref:System.Double>속성 값 섹션에 설명 된 대로 제한 된 범위 적용 [X:static 태그 확장](~/add/includes/ajax-current-ext-md.md) <xref:System.Double.PositiveInfinity>.</xref:System.Double.PositiveInfinity> 되도록 값을 명시적으로 설정 해야 하는 경우</xref:System.Double>       *도* A *double* 단위 선언 문자열 중 하나에 의해 다음 위에서 설명한 대로 값: `px`, `in`, `cm`, `pt`합니다.       `px`(기본값)은 [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` 인치; 1in 96px = = `cm` 센티미터; 1cm==(96/2.54) px `pt` 은 포인트; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MaxHeight&quot;> </a> # # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.MaxHeightProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MaxHeightProperty>       "
  syntax:
    content: public double MaxHeight { get; set; }
    return:
      type: System.Double
      description: "요소의 최대 높이 [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]합니다. 기본값은 <xref:System.Double>.</xref:System.Double> 이 값에는 0.0 보다 크거나 같은 임의의 값일 수 있습니다. <xref:System.Double>도 유효합니다.</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MaxHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxHeightProperty
  id: MaxHeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxHeightProperty
  nameWithType: FrameworkElement.MaxHeightProperty
  fullName: System.Windows.FrameworkElement.MaxHeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.MaxHeight*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.MaxHeight*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MaxHeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxWidth
  id: MaxWidth
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxWidth
  nameWithType: FrameworkElement.MaxWidth
  fullName: System.Windows.FrameworkElement.MaxWidth
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "요소의 최대 너비 제약 조건을 가져오거나 설정 합니다."
  remarks: "이 세 가지 속성 중 하나에 <xref:System.Windows.FrameworkElement>너비 정보를 지정 하는.</xref:System.Windows.FrameworkElement> 다른 두 <xref:System.Windows.FrameworkElement.MinWidth%2A>및 <xref:System.Windows.FrameworkElement.Width%2A>.</xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.MinWidth%2A> 은 이러한 값 간에 충돌이 발생 하는 경우 실제 너비 결정 하기 위한 응용 프로그램의 순서는 첫 번째 <xref:System.Windows.FrameworkElement.MinWidth%2A>, 다음 최대 너비를 마지막으로 <xref:System.Windows.FrameworkElement.Width%2A>.</xref:System.Windows.FrameworkElement.Width%2A> 범위 내에 있는 이러한 각 경우</xref:System.Windows.FrameworkElement.MinWidth%2A>       에 대 한 값 제한은 <xref:System.Double>값에 의해 적용 되는 <xref:System.Windows.ValidateValueCallback>메커니즘.</xref:System.Windows.ValidateValueCallback> </xref:System.Double> 잘못 된 값을 설정 하려고 하면 런타임 예외가 throw 됩니다.      <a name=&quot;xamlAttributeUsage_MaxWidth&quot;></a># # XAML 특성 사용 ```   <object MaxWidth=&quot;double&quot;/>   - or -   <object MaxWidth=&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MaxWidth&quot;> </a> # # XAML 값 *double* <xref:System.Double> 의 문자열 표현은 <xref:System.Double>0.0 보다 크거나 같은 값.</xref:System.Double> </xref:System.Double>           이 값으로 해석 되는 [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] 측정 합니다. 문자열은 소수점이 하를 명시적으로 포함 하지 않아야 합니다. 예를 들어 값의 `1` 허용 됩니다.       동일한 <xref:System.Double>속성 값 섹션에 설명 된 대로 제한 된 범위 적용 [X:static 태그 확장](~/add/includes/ajax-current-ext-md.md) <xref:System.Double.PositiveInfinity>.</xref:System.Double.PositiveInfinity> 되도록 값을 설정 하려면</xref:System.Double>       *도* A *double* 단위 선언 문자열 중 하나에 의해 다음 위에서 설명한 대로 값: `px`, `in`, `cm`, `pt`합니다.       `px`(기본값)은 [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` 인치; 1in 96px = = `cm` 센티미터; 1cm==(96/2.54) px `pt` 은 포인트; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MaxWidth&quot;> </a> # # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.MaxWidthProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MaxWidthProperty>       "
  syntax:
    content: public double MaxWidth { get; set; }
    return:
      type: System.Double
      description: "요소의 최대 너비의 [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]합니다. 기본값은 <xref:System.Double>.</xref:System.Double> 이 값에는 0.0 보다 크거나 같은 임의의 값일 수 있습니다. <xref:System.Double>도 유효합니다.</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MaxWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxWidthProperty
  id: MaxWidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxWidthProperty
  nameWithType: FrameworkElement.MaxWidthProperty
  fullName: System.Windows.FrameworkElement.MaxWidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.MaxWidth*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.MaxWidth*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MaxWidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)
  id: MeasureCore(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MeasureCore(Size)
  nameWithType: FrameworkElement.MeasureCore(Size)
  fullName: System.Windows.FrameworkElement.MeasureCore(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "구현 기본 측정 단계 레이아웃 시스템 동작에 대 한 <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>합니다."
  remarks: "이 메서드를 재정의 <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName>WPF 핵심 수준 및 WPF 프레임 워크 수준 레이아웃 측정 구현을 연결할.</xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName> <xref:System.Windows.FrameworkElement>구현에서는 메서드가 봉인.</xref:System.Windows.FrameworkElement> WPF 프레임 워크 수준에 작성 되는 요소의 측정 단계 레이아웃 동작을 조정 하려면 재정의 <xref:System.Windows.FrameworkElement.MeasureOverride%2A>대신.</xref:System.Windows.FrameworkElement.MeasureOverride%2A> 의도적으로 또는 하지 않는 WPF 프레임 워크 수준에서 빌드 <xref:System.Windows.FrameworkElement>, <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName>.</xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName> 재정의</xref:System.Windows.FrameworkElement> 사용 하 여 요소의 측정 단계 레이아웃 동작을 조정 하려면"
  syntax:
    content: protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);
    parameters:
    - id: availableSize
      type: System.Windows.Size
      description: "부모 요소가 자식 요소에 제공할 수 있는 사용 가능한 크기입니다."
    return:
      type: System.Windows.Size
      description: "원하는 크기 레이아웃에서이 요소입니다."
  overload: System.Windows.FrameworkElement.MeasureCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)
  id: MeasureOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MeasureOverride(Size)
  nameWithType: FrameworkElement.MeasureOverride(Size)
  fullName: System.Windows.FrameworkElement.MeasureOverride(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "파생된 클래스에서 재정의할 경우, 자식 요소에 필요한 레이아웃의 크기를 측정 하 여 크기를 결정은 <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>-클래스를 파생 합니다."
  remarks: "재정의에 참여 하는 대로 프로그램 요소에 대 한 사용자 지정 레이아웃 크기 조정 동작을 구현 하는 일반적은 [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] 레이아웃 시스템입니다. 구현에서 다음을 수행 해야 합니다. 1.  요소의 특정 레이아웃, 호출의 일부인 자식 컬렉션을 반복 <xref:System.Windows.UIElement.Measure%2A>각 자식 요소에 대해.</xref:System.Windows.UIElement.Measure%2A>      2.  즉시 <xref:System.Windows.UIElement.DesiredSize%2A>자식 (후 속성으로 설정 되어이 <xref:System.Windows.UIElement.Measure%2A>라고).</xref:System.Windows.UIElement.Measure%2A> </xref:System.Windows.UIElement.DesiredSize%2A>      3.  자식 요소의 측정에 따라 부모 net 원하는 크기를 계산 합니다.       일반적 반환 값에는 현재 요소의 부모 요소에 대 한 측정값 입력 되는 요소 자체의 필요한 크기 여야 합니다. 페이지의 루트 요소에 도달할 때까지 동일한 프로세스에이 레이아웃 시스템을 통해 계속 합니다.       이 과정에서 자식 요소를 반환할 수 있습니다 더 큰 <xref:System.Windows.UIElement.DesiredSize%2A>초기 보다 크기가 `availableSize` 를 나타내는 자식 요소에 공간이 더 필요 합니다.</xref:System.Windows.UIElement.DesiredSize%2A> 이 측정 또는 콘텐츠를 정렬에 대 한 솔루션을 개수에 관계 없이 또는 누적 주문의 특정 방식으로 설정 하 여 부모 컨트롤 크기 조정 하 여 스크롤 가능한 영역을 도입 하 여 사용자 고유의 구현에서 처리 될 수 있습니다.      > [!IMPORTANT] > 요소를 호출 해야 <xref:System.Windows.UIElement.Measure%2A>이 프로세스 동안 각 자식에 그렇지 않은 경우 자식 요소 되거나 되지 것입니다 수 올바르게 크기의 배열입니다.</xref:System.Windows.UIElement.Measure%2A>"
  syntax:
    content: protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);
    parameters:
    - id: availableSize
      type: System.Windows.Size
      description: "이 요소가 자식 요소에 제공할 수 있는 사용 가능한 크기입니다. 요소가 크기는 모든 콘텐츠를 사용할 수 있는지를 나타내는 값으로 무한대를 지정할 수 있습니다."
    return:
      type: System.Windows.Size
      description: "이 요소 것을 결정 하는 크기 자식 요소 크기 계산에 따라 레이아웃 중에 필요 합니다."
  overload: System.Windows.FrameworkElement.MeasureOverride*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinHeight
  id: MinHeight
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinHeight
  nameWithType: FrameworkElement.MinHeight
  fullName: System.Windows.FrameworkElement.MinHeight
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "요소의 최소 높이 제약 조건을 가져오거나 설정 합니다."
  remarks: "이 세 가지 속성 중 하나에 <xref:System.Windows.FrameworkElement>높이 정보를 지정 하는.</xref:System.Windows.FrameworkElement>  다른 두 <xref:System.Windows.FrameworkElement.Height%2A>및 <xref:System.Windows.FrameworkElement.MaxHeight%2A>.</xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement.Height%2A> 은 실제 높이 결정은 응용 프로그램의 순서에서는 이러한 값 간에 충돌이 발생 하는 경우 첫 번째 MinHeight 해야이 적용 될 다음 <xref:System.Windows.FrameworkElement.MaxHeight%2A>, 마지막으로 <xref:System.Windows.FrameworkElement.Height%2A>.</xref:System.Windows.FrameworkElement.Height%2A> 범위 내에 있는 이러한 각 경우</xref:System.Windows.FrameworkElement.MaxHeight%2A>       에 대 한 값 제한은 <xref:System.Double>값에 의해 적용 되는 <xref:System.Windows.ValidateValueCallback>메커니즘.</xref:System.Windows.ValidateValueCallback> </xref:System.Double> 잘못 된 값을 설정 하려고 하면 런타임 예외가 throw 됩니다.      <a name=&quot;xamlAttributeUsage_MinHeight&quot;></a># # XAML 특성 사용 ```   <object MinHeight=&quot;double&quot;/>   - or -   <object MinHeight=&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MinHeight&quot;> </a> # # XAML 값 *double* <xref:System.Double> 의 문자열 표현은 <xref:System.Double>0.0 보다 크거나 같은 값.</xref:System.Double> </xref:System.Double>           이 값으로 해석 되는 [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] 측정 합니다. 문자열은 소수점이 하를 명시적으로 포함 하지 않아야 합니다. 예를 들어 값의 `1` 허용 됩니다.       동일한 <xref:System.Double>속성 값 섹션에서 설명한 것 처럼 범위 제한 사항이 적용 됩니다.</xref:System.Double>       *도* A *double* 단위 선언 문자열 중 하나에 의해 다음 위에서 설명한 대로 값: `px`, `in`, `cm`, `pt`합니다.       `px`(기본값)은 [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` 인치; 1in 96px = = `cm` 센티미터; 1cm==(96/2.54) px `pt` 은 포인트; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MinHeight&quot;> </a> # # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.MinHeightProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MinHeightProperty>       "
  syntax:
    content: public double MinHeight { get; set; }
    return:
      type: System.Double
      description: "요소의 최소 높이 [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]합니다. 기본값은 0.0입니다. 이 값에는 0.0 보다 크거나 같은 임의의 값일 수 있습니다. 그러나 <xref:System.Double>않습니다 유효 없거나 이러한 속성이 &lt;xref:System.Double?displayProperty=fullName&gt;.</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MinHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinHeightProperty
  id: MinHeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinHeightProperty
  nameWithType: FrameworkElement.MinHeightProperty
  fullName: System.Windows.FrameworkElement.MinHeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.MinHeight*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.MinHeight*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MinHeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinWidth
  id: MinWidth
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinWidth
  nameWithType: FrameworkElement.MinWidth
  fullName: System.Windows.FrameworkElement.MinWidth
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "요소의 최소 너비 제약 조건을 가져오거나 설정 합니다."
  remarks: "이 세 가지 속성 중 하나에 <xref:System.Windows.FrameworkElement>너비 정보를 지정 하는.</xref:System.Windows.FrameworkElement>  다른 두 <xref:System.Windows.FrameworkElement.Width%2A>및 <xref:System.Windows.FrameworkElement.MaxWidth%2A>.</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.Width%2A> 은  실제 너비 결정은 응용 프로그램의 순서에서는 이러한 값 간에 충돌이 발생 하는 경우 첫 번째 MinWidth 해야이 적용 될 다음 <xref:System.Windows.FrameworkElement.MaxWidth%2A>, 마지막으로 <xref:System.Windows.FrameworkElement.Width%2A>.</xref:System.Windows.FrameworkElement.Width%2A> 범위 내에 있는 이러한 각 경우</xref:System.Windows.FrameworkElement.MaxWidth%2A>       에 대 한 값 제한은 <xref:System.Double>값에 의해 적용 되는 <xref:System.Windows.ValidateValueCallback>메커니즘.</xref:System.Windows.ValidateValueCallback> </xref:System.Double> 잘못 된 값을 설정 하려고 하면 런타임 예외가 throw 됩니다.      <a name=&quot;xamlAttributeUsage_MinWidth&quot;></a># # XAML 특성 사용 ```   <object MinWidth=&quot;double&quot;/>   - or -   <object MinWidth=&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MinWidth&quot;> </a> # # XAML 값 *double* <xref:System.Double> 의 문자열 표현은 <xref:System.Double>0.0 보다 크거나 같은 값.</xref:System.Double> </xref:System.Double>           이 값으로 해석 되는 [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] 측정 합니다. 문자열은 소수점이 하를 명시적으로 포함 하지 않아야 합니다. 예를 들어 값의 `1` 허용 됩니다.       동일한 <xref:System.Double>속성 값 섹션에서 설명한 것 처럼 범위 제한 사항이 적용 됩니다.</xref:System.Double>       *도* A *double* 단위 선언 문자열 중 하나에 의해 다음 위에서 설명한 대로 값: `px`, `in`, `cm`, `pt`합니다.       `px`(기본값)은 [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` 인치; 1in 96px = = `cm` 센티미터; 1cm==(96/2.54) px `pt` 은 포인트; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MinWidth&quot;> </a> # # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.MinWidthProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MinWidthProperty>       "
  syntax:
    content: public double MinWidth { get; set; }
    return:
      type: System.Double
      description: "요소의 최소 너비에 [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]합니다. 기본값은 0.0입니다. 이 값에는 0.0 보다 크거나 같은 임의의 값일 수 있습니다. 그러나 <xref:System.Double>없거나 유효 하지 않을 경우 &lt;xref:System.Double?displayProperty=fullName&gt;.</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MinWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinWidthProperty
  id: MinWidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinWidthProperty
  nameWithType: FrameworkElement.MinWidthProperty
  fullName: System.Windows.FrameworkElement.MinWidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.MinWidth*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.MinWidth*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MinWidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)
  id: MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkElement.MoveFocus(TraversalRequest)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "제공 된 이동 방향을에서이 요소에서와 다른 요소에 키보드 포커스를 이동합니다."
  remarks: "이 구현을 재정의 <xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=fullName>메서드를 봉인.</xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=fullName>"
  example:
  - "The following example implements a handler that handles several possible button inputs. Each button represents a possible <xref:System.Windows.Input.FocusNavigationDirection>. The handler tracks the element with current keyboard focus, and calls MoveFocus on that element, by specifying the appropriate <xref:System.Windows.Input.FocusNavigationDirection> as initialization for the <xref:System.Windows.Input.TraversalRequest> type parameter provided.  \n  \n [!code-cs[FocusSample#FocusSampleMoveFocus](~/add/codesnippet/csharp/FocusSample/Window1.xaml.cs#focussamplemovefocus)]\n [!code-vb[FocusSample#FocusSampleMoveFocus](~/add/codesnippet/visualbasic/focussample/window1.xaml.vb#focussamplemovefocus)]"
  syntax:
    content: public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);
    parameters:
    - id: request
      type: System.Windows.Input.TraversalRequest
      description: "방향 포커스 열거형의 값으로 이동 하는 것입니다."
    return:
      type: System.Boolean
      description: "반환 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> 포커스가 성공적으로 이동 하는 경우 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 대상 요소 방향으로 지정 하는 존재 하지 않는 경우 또는 키보드 포커스가 수 하지 못했습니다."
  overload: System.Windows.FrameworkElement.MoveFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Name
  id: Name
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Name
  nameWithType: FrameworkElement.Name
  fullName: System.Windows.FrameworkElement.Name
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 하는 요소 이름을 가져오거나 설정 합니다. 이름으로 처리 하는 동안 생성 된 후 이벤트 처리기 코드 등의 코드 숨김에서 태그 요소를 참조할 수 있도록 참조를 제공는 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 프로세서."
  remarks: "지정 하는 것이 속성의 가장 일반적인 용도 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 태그에서 특성으로 요소 이름입니다.       이 속성에는 기본적으로 설정 하는 WPF 프레임 워크 수준 편의 속성은 제공 된 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] [X:name 지시문](~/add/includes/ajax-current-ext-md.md)합니다.       이름은 이름 범위 내에서 고유 해야 합니다. 자세한 내용은 참조 [WPF XAML 이름 범위](~/add/includes/ajax-current-ext-md.md)합니다.       코드에서 요소를 만드는 경우 이름을 받은 흔하지 않습니다. 코드에 적절 한 참조가 이미 있는 경우 방금 메서드를 호출할 수 있습니다 및 요소에서 속성 참조 하 고 일반적으로 이름을 하지 않아도 됩니다. 이 예외는 이름 문자열에 오버 로드 된 의미가 경우, 예를 들어이에 해당 이름을 표시 하는 유용한 경우 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]합니다. 코드 숨김 원래 이름 태그에서 설정 된 경우에서 이름을 권장 되지 설정 및 속성을 로드 한 후 변경의 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 원래 개체 참조를 변경 되지 것입니다. 개체 참조는 구문 분석 중에 기본 이름 범위를 명시적으로 만든 경우에 생성 됩니다. 명시적으로 호출 해야 <xref:System.Windows.FrameworkElement.RegisterName%2A>이미 로드 된 요소의 Name 속성에 대 한 효과적인 변경 되도록 합니다.</xref:System.Windows.FrameworkElement.RegisterName%2A>       코드에서 이름을 설정 하는 것이 중요 한 경우에는 런타임 시 참조할 수 있도록 스토리 보드에 대해를 실행 하는 요소에 대 한 이름을 등록 하는 경우는 합니다. 이름을 등록할 수 있습니다, 전에 인스턴스화하고 할당 해야 할 수도 <xref:System.Windows.NameScope>인스턴스.</xref:System.Windows.NameScope> 예 섹션을 참조 하거나 [적기](~/add/includes/ajax-current-ext-md.md)합니다.       설정 이름 코드에서 응용 프로그램을 제한적으로 하지만 요소 이름으로 시작 하는 것이 더 일반적입니다. 하나의 특정 한 시나리오는 응용 프로그램은 여기서에 응용 프로그램 페이지가 다시 로드 하 고 런타임 코드는 반드시 해당 페이지에 대해 정의 된 코드 숨김 하지 탐색 모델을 지원 하는 경우입니다. 유틸리티 메서드 <xref:System.Windows.FrameworkElement.FindName%2A>에서 사용 하지 않는 <xref:System.Windows.FrameworkElement>, 필요에 따라 재귀적으로 트리를 검색 하는 해당 요소에 대 한 논리적 트리에서 이름으로 모든 요소를 찾을 수 있습니다.</xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement.FindName%2A> 또는 사용할 수 있습니다는 <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>의 정적 메서드 <xref:System.Windows.LogicalTreeHelper>, 이름 문자열을 인수로 걸립니다.</xref:System.Windows.LogicalTreeHelper> </xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>       일반적으로 사용 되는 루트 요소 (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page>예를 들어) <xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> 인터페이스를 구현</xref:System.Windows.Controls.Page> </xref:System.Windows.Window> 이 인터페이스의 구현 적용 이름이 해당 범위 내에서 모호한 것으로 예상 됩니다. 또한이 인터페이스를 정의 하는 루트 요소에는 모든의 이름 범위 동작 경계를 정의 하면 관련 [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]합니다.       Name 속성은 다른 프로세스에 대 한 식별자로도 사용 됩니다. 예를 들어,는 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] 자동화 모델 클라이언트 및 공급자에 AutomationId로 이름이 사용 됩니다.       내부에서 부여 된 이름에 사용 되는 문자열 값에 몇 가지 제한 사항이 있는 [X:name 지시문](../Topic/x:Name%20Directive.md) 정의한는 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 사양입니다. 가장 주목할 만한 이름을 문자 또는 밑줄 문자 (_)을 시작 해야 하며 문자, 숫자 또는 밑줄만 포함 해야 합니다. 자세한 내용은 참조 [WPF XAML 이름 범위](../Topic/WPF%20XAML%20Namescopes.md)합니다.       이름은 애니메이션을 적용할 수 있는 종속성 속성이 거의 중 하나입니다 (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> 은 `true` 메타 데이터에) 이름 자체는 애니메이션을 대상으로 하는 것에 대 한 중요 한 이기 때문에.</xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> 데이터 바인딩 이름을 기술적으로 가능 하지만 데이터 바인딩 이름 수 없는 속성의 주 용도 대로 사용 하기 때문에 매우 드문 경우: 코드 숨김에 대 한 식별자 연결 지점을 제공 하기.      <a name=&quot;dependencyPropertyInfo_Name&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.NameProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|</xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> </xref:System.Windows.FrameworkElement.NameProperty>"
  example:
  - "The following example sets the Name property in code, and then registers the name into the newly created <xref:System.Windows.NameScope> by calling <xref:System.Windows.FrameworkElement.RegisterName%2A>. The technique illustrated here is a requirement for animating with storyboards, because storyboards require targeting by the Name, and cannot be targeted by object reference.  \n  \n [!code-vb[animateHeight_procedural#FEName](~/add/codesnippet/visualbasic/animateheight/animatedheightexample.vb#fename)]\n [!code-cs[animateHeight_procedural#FEName](~/add/codesnippet/csharp/animateheight_csharp/AnimatedHeightExample.cs#fename)]"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "요소 이름입니다. 기본값은 빈 문자열입니다."
  overload: System.Windows.FrameworkElement.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.NameProperty
  id: NameProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: NameProperty
  nameWithType: FrameworkElement.NameProperty
  fullName: System.Windows.FrameworkElement.NameProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.Name*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.Name*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty NameProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnApplyTemplate
  id: OnApplyTemplate
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnApplyTemplate()
  nameWithType: FrameworkElement.OnApplyTemplate()
  fullName: System.Windows.FrameworkElement.OnApplyTemplate()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "파생된 클래스에서 재정의 하는 경우 응용 프로그램 코드 또는 내부 프로세스 <xref:System.Windows.FrameworkElement.ApplyTemplate*>.</xref:System.Windows.FrameworkElement.ApplyTemplate*> 호출할 때마다 호출 됩니다."
  remarks: "이 메서드는 기본 구현이 없습니다.       서식 파일은 섹션 요소 완료 된 시각적 트리의 템플릿 속성에서 제공 되는 <xref:System.Windows.Style>요소에 대해 적용 되는.</xref:System.Windows.Style> 자세한 내용은 참조 [스타일 및 템플릿](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public virtual void OnApplyTemplate ();
    parameters: []
  overload: System.Windows.FrameworkElement.OnApplyTemplate*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "처리 되지 않은 때마다 호출 됩니다. <xref href=&quot;System.Windows.FrameworkElement.ContextMenuClosing&quot;> </xref> 라우트된 이벤트가 해당 경로에서이 클래스에 도달 합니다. 이 이벤트를 처리 하는 클래스를 추가 하려면이 메서드를 구현 합니다."
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled."
  syntax:
    content: protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "이벤트에 대 한 데이터를 제공합니다."
  overload: System.Windows.FrameworkElement.OnContextMenuClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "처리 되지 않은 때마다 호출 됩니다. <xref href=&quot;System.Windows.FrameworkElement.ContextMenuOpening&quot;> </xref> 라우트된 이벤트가 해당 경로에서이 클래스에 도달 합니다. 이 이벤트를 처리 하는 클래스를 추가 하려면이 메서드를 구현 합니다."
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled."
  syntax:
    content: protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "<xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Windows.FrameworkElement.OnContextMenuOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)
  id: OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkElement.OnGotFocus(RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "처리 되지 않은 때마다 호출 됩니다. <xref href=&quot;System.Windows.UIElement.GotFocus&quot;> </xref> 이벤트가 해당 경로에서이 요소에 도달할 합니다."
  remarks: "에 다른 달리 * OnGotFocus 기본 요소에서 노출 하는 방법에는 기본 구현입니다. 특히,이 <xref:System.Windows.UIElement.OnGotFocus%2A>.</xref:System.Windows.UIElement.OnGotFocus%2A> 다운 기본 요소의 다음 수준에서 null 구현을 재정의 하는 구현이 호출 되 면 OnGotFocus 이벤트가 키보드 포커스로 인해 현재 요소에서 시작 하는 경우에이 요소에 적절 한 포커스 동작을 설정 합니다. 현재 요소에 포커스가 설정 되어 있더라도 처리 된 것으로 OnGotFocus 처리기 이벤트 인수를 표시 하지 않습니다. 이벤트의 소스는 현재 요소가 아닌 트리의 다른 요소를 한 경우 처리기는 아무 작업도 수행 하지 않습니다.       이러한 방식으로 포커스 동작을 변경 수 쉽게 수행할 수는 요소 전혀 허용 하지 않도록 수 있지만 요소에 대 한 기본 포커스 동작을 변경 하기 위해이 메서드를 재정의할 수 있습니다 (참조 <xref:System.Windows.UIElement.Focusable%2A>).</xref:System.Windows.UIElement.Focusable%2A>"
  syntax:
    content: protected override void OnGotFocus (System.Windows.RoutedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "<xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Windows.FrameworkElement.OnGotFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnInitialized(System.EventArgs)
  id: OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkElement.OnInitialized(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.FrameworkElement.Initialized&quot;> </xref> 이벤트입니다. 이 메서드가 호출 될 때마다 <xref:System.Windows.FrameworkElement.IsInitialized*>로 설정 된 <xref uid=&quot;langword_csharp_true &quot; name=&quot;true &quot; href=&quot;&quot;> </xref>내부적으로.</xref:System.Windows.FrameworkElement.IsInitialized*>"
  remarks: "This particular On* method is not a class handler hook. Nor does it exactly follow the established [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] On\\* method convention that the matching event could be suppressed by overriding this method and not calling the base implementation.  \n  \n Note that the <xref:System.Windows.FrameworkElement.IsInitialized%2A> property is read-only, so you cannot set <xref:System.Windows.FrameworkElement.IsInitialized%2A> to force initialization behavior. Setting the initialization state is intended to be done only by the [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] framework."
  syntax:
    content: protected virtual void OnInitialized (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Windows.FrameworkElement.OnInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "때마다 호출에서이 종속성 속성의 유효 값 <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> 업데이트 되었습니다. 변경 된 특정 종속성 속성이 인수 매개 변수에서 보고 됩니다. <xref:System.Windows.DependencyObject.OnPropertyChanged*>.</xref:System.Windows.DependencyObject.OnPropertyChanged*> 재정의"
  remarks: "일반적으로 속성 변경 내용 또는 무효화를 검색 하려면이 메서드를 사용 하는 것이 없습니다. 대신 것은 일반적인 무효화 패턴의 수정에 대 한 속성의 광범위 한 분류에 대 한 특정 정보가 알려져 있는 경우.       이 메서드는 개체의 수명 동안 여러 번 호출 될 수도 있습니다. 따라서 특정 속성의 메타 데이터를 무시 하 고 다음 연결 성능을 향상 시킬 수 있습니다 <xref:System.Windows.CoerceValueCallback>또는 <xref:System.Windows.PropertyChangedCallback>개별 속성에 대 한 함수.</xref:System.Windows.PropertyChangedCallback> </xref:System.Windows.CoerceValueCallback> 그러나, 사용이 메서드는 경우는 <xref:System.Windows.FrameworkElement>많은 수의 값을 상호 연관 된 종속성 속성을 포함 하는 렌더링 동작 다시 실행 해야 다양 한 관련 속성 무효화의 경우와 같은 논리를 포함 하는 경우 또는.</xref:System.Windows.FrameworkElement>       같은 이름의 `OnPropertyChanged` 를 다른 서명으로 메서드 (매개 변수 형식이 <xref:System.ComponentModel.PropertyChangedEventArgs>)는 다양 한 클래스에 나타날 수 있는.</xref:System.ComponentModel.PropertyChangedEventArgs> `OnPropertyChanged` 데이터 개체 알림에 사용 되 고 <xref:System.ComponentModel.INotifyPropertyChanged>.</xref:System.ComponentModel.INotifyPropertyChanged> 에 대 한 계약의 일부인"
  syntax:
    content: protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "변경 된 속성을 설명 하는 이벤트 데이터 뿐만 아니라 이전 및 새 값입니다."
  overload: System.Windows.FrameworkElement.OnPropertyChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  id: OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnRenderSizeChanged(SizeChangedInfo)
  nameWithType: FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
  fullName: System.Windows.FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생는 <xref href=&quot;System.Windows.FrameworkElement.SizeChanged&quot;> </xref> 이벤트 형식, 최종적인 이벤트 데이터의 일부로 지정 된 정보를 사용 합니다."
  remarks: "이 메서드를 재정의 <xref:System.Windows.UIElement.OnRenderSizeChanged%2A>.</xref:System.Windows.UIElement.OnRenderSizeChanged%2A> 다시 설정 되며이 메서드를 호출 하는 경우는 <xref:System.Windows.FrameworkElement.ActualWidth%2A>속성은 <xref:System.Windows.FrameworkElement.ActualHeight%2A>제공된 된 인수에서 속성 또는 두로 지정 된 내용에 따라 변경 되 고 됩니다 하면 항상 이벤트를 발생 시킵니다.</xref:System.Windows.FrameworkElement.ActualHeight%2A> </xref:System.Windows.FrameworkElement.ActualWidth%2A>"
  syntax:
    content: protected override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);
    parameters:
    - id: sizeInfo
      type: System.Windows.SizeChangedInfo
      description: "변경과 관련 된 이전 및 새 크기의 세부 정보입니다."
  overload: System.Windows.FrameworkElement.OnRenderSizeChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  id: OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkElement.OnStyleChanged(Style,Style)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소에서 사용 중인 스타일이 변경 될 때 호출 되는 레이아웃을 무효화 됩니다."
  remarks: "이 메서드는 스타일 변경 상태를 기록 하는 내부 플래그를 설정 하는 기본 구현입니다."
  syntax:
    content: protected virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);
    parameters:
    - id: oldStyle
      type: System.Windows.Style
      description: "이전 스타일입니다."
    - id: newStyle
      type: System.Windows.Style
      description: "새 스타일입니다."
  overload: System.Windows.FrameworkElement.OnStyleChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "처리 되지 않은 때마다 호출 됩니다. <xref href=&quot;System.Windows.FrameworkElement.ToolTipClosing&quot;> </xref> 라우트된 이벤트가 해당 경로에서이 클래스에 도달 합니다. 이 이벤트를 처리 하는 클래스를 추가 하려면이 메서드를 구현 합니다."
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled."
  syntax:
    content: protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "이벤트에 대 한 데이터를 제공합니다."
  overload: System.Windows.FrameworkElement.OnToolTipClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "때마다 호출 된 <xref href=&quot;System.Windows.FrameworkElement.ToolTipOpening&quot;> </xref> 라우트된 이벤트가 해당 경로에서이 클래스에 도달 합니다. 이 이벤트를 처리 하는 클래스를 추가 하려면이 메서드를 구현 합니다."
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "이벤트에 대 한 데이터를 제공합니다."
  overload: System.Windows.FrameworkElement.OnToolTipOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)
  id: OnVisualParentChanged(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnVisualParentChanged(DependencyObject)
  nameWithType: FrameworkElement.OnVisualParentChanged(DependencyObject)
  fullName: System.Windows.FrameworkElement.OnVisualParentChanged(DependencyObject)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "시각적 트리에서이 요소의 부모가 변경 될 때 호출 됩니다. <xref:System.Windows.UIElement.OnVisualParentChanged*>.</xref:System.Windows.UIElement.OnVisualParentChanged*> 재정의"
  remarks: "시각적 트리 컬렉션 같은 시각적으로 렌더링 되지 않는 요소를 생략 하기 때문에 잠재적으로 다른 논리적 트리에서 고 해당 테마 및 스타일 합치기를 기반으로 일부 요소를 확장 합니다. 자세한 내용은 참조 [In WPF](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: protected override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);
    parameters:
    - id: oldParent
      type: System.Windows.DependencyObject
      description: "이전 부모 요소입니다. 수 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 하는 요소는 시각적 부모가 없는 이전에 나타냅니다."
  overload: System.Windows.FrameworkElement.OnVisualParentChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OverridesDefaultStyle
  id: OverridesDefaultStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OverridesDefaultStyle
  nameWithType: FrameworkElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소가 테마 스타일의 스타일 속성을 통합 여부를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "이 속성의 가장 일반적인 사용법은 테마 스타일을 제공 하는 스타일의 setter 내에서 간접적으로 사용 합니다.      > [!IMPORTANT] > OverridesDefaultStyle을 설정 하면 `true` 컨트롤에 표시 되지 것입니다 테마 스타일에서 제공 하는 기본 컨트롤 템플릿을 합니다. 컨트롤 템플릿에 일반적으로 콘텐츠 발표자 및 기본 제공 하는 다른 복합 요소 포함 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] 기능 및 컨트롤에 대 한 시각화입니다. 계속 기본 테마 스타일과 같은 기능을 지원 하려면 제어 하려는 경우 동일한 구조를 복제 하는 컨트롤 템플릿 사용 하 여 대체 스타일을 제공 해야 합니다. 자세한 내용은 참조 [컨트롤 제작 개요](~/add/includes/ajax-current-ext-md.md)합니다.      <a name=&quot;dependencyPropertyInfo_OverridesDefaultStyle&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>"
  syntax:
    content: public bool OverridesDefaultStyle { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>이 요소가 테마 스타일 속성을 사용 하지 않는 경우 스타일에서 생성 하는 모든 속성의 로컬 응용 프로그램 스타일 및 테마 스타일 속성이 적용 되지 않습니다. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>응용 프로그램 스타일이 먼저 적용 하 고 테마 스타일 응용 프로그램 스타일에 구체적으로 설정 되지 않은 속성에 대 한 다음 적용 합니다. 기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.FrameworkElement.OverridesDefaultStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  id: OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.OverridesDefaultStyle*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.OverridesDefaultStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Parent
  id: Parent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Parent
  nameWithType: FrameworkElement.Parent
  fullName: System.Windows.FrameworkElement.Parent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소의 논리적 부모 요소를 가져옵니다."
  remarks: "부모 `null` 요소 인스턴스화 하지만 결국 페이지 수준 루트 요소 또는 응용 프로그램 개체에 연결 하는 모든 논리적 트리에 연결 되지 않은 경우에 합니다.       Note 요소의 논리적 부모 응용 프로그램의 기능에 따라 변경 될 수 있습니다 및이 속성의 값을 유지 해도 해당 변경 내용을 반영 되지 것입니다. 일반적으로 필요한 직전 값을 가져올 해야 합니다.       참조 [In WPF](~/add/includes/ajax-current-ext-md.md) 논리적 트리 이동 및 부모 요소 검색 기법으로 부모를 사용 하는 적절 한 시나리오에 대 한 자세한 내용은 합니다.       속성 엔진에서는 다시 계산할 수 요소의 모든 속성 값, 부모가 때 일부 속성 논리 트리를 통해 값을 상속 하기 때문에 합니다. <xref:System.Windows.FrameworkElement.DataContext%2A>적용 되는 요소는 부모가 바인딩 크기도 변경 수에 대 한.</xref:System.Windows.FrameworkElement.DataContext%2A>       요소의 부모는 일반적으로을 통해 변경할 컬렉션 조작, 전용을 사용 하 여 추가 또는 제거 메서드, 또는 요소의 콘텐츠 속성을 설정 하는 과정입니다.       부모 속성을 사용 하는 가장 일반적인 시나리오는 다양 한를 가져온 후 한 참조를 가져올를 <xref:System.Windows.FrameworkElement>부모 개체에서 속성 값.</xref:System.Windows.FrameworkElement> 템플릿, 결국 서식 파일의 부모 됩니다 `null`합니다. 이 지점을 벗어나 하는 템플릿이 실제로 적용 되는 논리 트리로 확장를 <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.</xref:System.Windows.FrameworkElement.TemplatedParent%2A> 사용       이 속성은 논리적 트리 부모에서 다른 경우에는 시각적 트리 부모 항목을 보고 하지 note 합니다. 시각적 트리 부모 일반 응용 프로그램의 경우에 일반적으로 중요 하지 않지만 특정 시각적 수준의 경우에 대 한 원하는 상위 요소가 있을 수 있습니다. <xref:System.Windows.Media.VisualTreeHelper>.</xref:System.Windows.Media.VisualTreeHelper> 를 참조 하십시오."
  example:
  - "The following example shows code that checks for an element's parent, and then uses property values from the parent to set properties on the child element to match. In this case these are properties that affect the rendering size.  \n  \n [!code-vb[GeometryDesigner#FEParentProperty](~/add/codesnippet/visualbasic/geometrydesigner/window1.xaml.vb#feparentproperty)]\n [!code-cs[GeometryDesigner#FEParentProperty](~/add/codesnippet/csharp/GeometryDesigner/Window1.xaml.cs#feparentproperty)]"
  syntax:
    content: public System.Windows.DependencyObject Parent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "이 요소의 논리적 부모입니다."
  overload: System.Windows.FrameworkElement.Parent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)
  id: ParentLayoutInvalidated(System.Windows.UIElement)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ParentLayoutInvalidated(UIElement)
  nameWithType: FrameworkElement.ParentLayoutInvalidated(UIElement)
  fullName: System.Windows.FrameworkElement.ParentLayoutInvalidated(UIElement)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "특수화 된 서브 클래스에서 증분 레이아웃 구현을 지원 <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>합니다. ParentLayoutInvalidated에서 부모의 측정에 영향을 주도록 메타 데이터에 표시 된 속성을 자식 요소가 무효화 될 때 호출 되 또는 레이아웃 하는 동안 정렬 전달 합니다."
  remarks: "이 요소에는 자식 요소에 무효화 된 일부 속성 및 속성으로 표시 된 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>또는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>등록 하는 동안 속성 메타 데이터에이 메서드가 호출 됩니다.</xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> </xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 메서드 호출에이 요소 레이아웃의 부분 (증분) 업데이트를 지 원하는 경우 특정 자식 요소에 다시 측정 해야 하는 부모 요소를 알립니다.       기본적으로 <xref:System.Windows.FrameworkElement>증분 레이아웃을 지원 하지 않습니다 및는 <xref:System.Windows.FrameworkElement>클래스이 메서드에 기본 구현이 없습니다.</xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement> 기본 레이아웃 시스템 동작을 수정 해야 하기 때문에이 메서드를 재정의할 수 없는 필요한 시나리오 일반적이 지 않습니다.       WPF 프레임 워크 수준 레이아웃 시스템 보다 더 제한적인 가능한 자식 요소에 대 한 형식 제한을 클래스의 경우에 이러한 구현 방식을 사용할 수 있습니다. 이러한 사용자 지정 요소 이기 때문에 속성 변경 내용은 연기 될 수 의도적으로 일부 사용자 지정 레이아웃 동작을 구현 하는 경우. 예를 들어, 특정 유형의 다른 레이아웃 과정에서 일반적으로 발생 하는 변경 내용에 대 한 자식 요소를 최적화 하려고 하는 렌더링 패스, 측정값/정렬 메서드 재정의 지연 시킬 수 있습니다."
  syntax:
    content: protected virtual void ParentLayoutInvalidated (System.Windows.UIElement child);
    parameters:
    - id: child
      type: System.Windows.UIElement
      description: "변경을 보고 하는 자식 요소입니다."
  overload: System.Windows.FrameworkElement.ParentLayoutInvalidated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  id: PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkElement.PredictFocus(FocusNavigationDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "제공 된 포커스 이동 방향에 대 한이 요소를 기준으로 포커스를 받을 하지만 실제로 포커스를 이동 하지 않는 다음 요소를 결정 합니다."
  remarks: "<xref:System.Windows.FrameworkElement.MoveFocus%2A>실제로 포커스를 이동 하는 관련된 방법.</xref:System.Windows.FrameworkElement.MoveFocus%2A>"
  example:
  - "The following example implements a handler that handles several possible button inputs, each button representing a possible <xref:System.Windows.Input.FocusNavigationDirection>. The handler tracks the element with current keyboard focus, and calls PredictFocus on that element, and specifies the appropriate <xref:System.Windows.Input.FocusNavigationDirection> as initialization for the <xref:System.Windows.Input.TraversalRequest> type parameter provided. Instead of moving to that element as <xref:System.Windows.FrameworkElement.MoveFocus%2A> would do, the handler changes the physical dimensions of the predicted focus destination for visualization purposes.  \n  \n [!code-cs[FocusSample#FEPredictFocus](~/add/codesnippet/csharp/FocusSample/Window1.xaml.cs#fepredictfocus)]\n [!code-vb[FocusSample#FEPredictFocus](~/add/codesnippet/visualbasic/focussample/window1.xaml.vb#fepredictfocus)]"
  syntax:
    content: public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Input.FocusNavigationDirection
      description: "예상 포커스 변경을 결정 해야 하는 방향입니다."
    return:
      type: System.Windows.DependencyObject
      description: "포커스를 실제로 이동 하는 경우에 집중 하는 다음 요소로 이동 합니다. 반환할 수 있습니다 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 제공된 방향에 대해이 요소를 기준으로 포커스를 이동할 수 없는 경우."
  overload: System.Windows.FrameworkElement.PredictFocus*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: 'Specified one of the following directions in the <xref href=&quot;System.Windows.Input.TraversalRequest&quot;></xref>: <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>. 이 지침 PredictFocus에 적합 하지 않습니다 (에 사용할 하지만 <xref:System.Windows.FrameworkElement.MoveFocus*>).</xref:System.Windows.FrameworkElement.MoveFocus*>'
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RegisterName(System.String,System.Object)
  id: RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RegisterName(String,Object)
  nameWithType: FrameworkElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkElement.RegisterName(String,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "에 대 한 액세스를 간소화 하는 접근자를 제공는 <xref:System.Windows.NameScope>등록 방법을.</xref:System.Windows.NameScope>"
  remarks: "이 메서드는 <xref:System.Windows.NameScope.RegisterName%2A>.</xref:System.Windows.NameScope.RegisterName%2A> 호출에 대 한 편의 메서드 적용 가능한 <xref:System.Windows.NameScope> <xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> 를 구현 하는 요소를 검색 하 여 위에 표시 되는 구현</xref:System.Windows.NameScope> 을 찾을 때까지 구현 연속 된 부모 요소를 확인 합니다. 네임 스페이스에 대 한 자세한 내용은 참조 [WPF XAML 이름 범위](~/add/includes/ajax-current-ext-md.md)합니다.       레지스터 이름 호출 하는 것은 올바르게 코드에서 만들어진 경우 응용 프로그램에 대 한 애니메이션 스토리 보드를 연결 하는 데 필요 합니다. 속성을 스토리 보드 키 중 하나 때문에 이것이 <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, 대상 요소에 대 한 참조 하는 대신 런타임 이름 조회를 사용 합니다.</xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> 해당 요소는 코드에서 참조 하 여 액세스할 수 있는 경우에 마찬가지입니다. 스토리 보드 대상에 대 한 이름을 등록 해야 이유에 대 한 자세한 내용은 참조 하십시오. [적기](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - >-
    [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/add/codesnippet/visualbasic/animateproperty_storyboards_vb/scopeexample.vb#namescopeexample)]
     [!code-cs[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/add/codesnippet/csharp/AnimateProperty_Storyboards_csharp/ScopeExample.cs#namescopeexample)]
  syntax:
    content: public void RegisterName (string name, object scopedElement);
    parameters:
    - id: name
      type: System.String
      description: "지정 된 이름-개체 매핑을 위해 사용할 이름입니다."
    - id: scopedElement
      type: System.Object
      description: "매핑에 대 한 개체입니다."
  overload: System.Windows.FrameworkElement.RegisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)
  id: RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.RemoveLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소의 논리적 트리에서 제공된 된 개체를 제거 합니다. <xref href=&quot;System.Windows.FrameworkElement&quot;></xref>이 삭제 작업과 동기화 상태로 유지 하려면 영향을 받는 논리적 트리 부모 포인터를 업데이트 합니다."
  remarks: "논리 자식 요소를 나타내는 개체에는 컬렉션의 구현에이 메서드를 사용 합니다. 속성 getter 또는 setter의 클래스 처리기에서 수행할 수 있습니다이 `Changed` 이벤트, 생성자 또는 형식 자체는 컬렉션 내에서.       컨트롤 작성자에 대 한이 수준에서 논리 트리를 조작 하지 않는 것이 좋을 제공 된 기본 컨트롤 클래스의 정적 콘텐츠 모델 중 적절 한 합니다. 수준에서 서브클래싱 고려 <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, 및 <xref:System.Windows.Controls.HeaderedItemsControl>.</xref:System.Windows.Controls.HeaderedItemsControl> </xref:System.Windows.Controls.ItemsControl> </xref:System.Windows.Controls.ContentControl> 이러한 클래스는 특정 방식으로 전용 통해 논리 자식 적용을 사용 하 여 콘텐츠 모델 제공 [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]에서 일반적으로 사용 가능한 다른 기능에 대 한 지원 및는 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] 스타일 템플릿을 통해 같은 제어 합니다."
  example:
  - "The following example implements a `Child` property on a custom <xref:System.Windows.FrameworkElement> that does its own visual layer implementation. The property's setter is designed so that if the value changes, the old value is removed from the logical tree, as well as a class-specific visual collection. The values are cached, and then the new value is added to both the standard WPF framework level logical tree and the custom visual collection.  \n  \n [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/visualbasic/compositiontargetrenderinganimations/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]\n [!code-cs[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/csharp/CompositionTargetRenderingAnimations/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]"
  syntax:
    content: protected void RemoveLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "제거할 요소입니다."
  overload: System.Windows.FrameworkElement.RemoveLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RequestBringIntoView
  id: RequestBringIntoView
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RequestBringIntoView
  nameWithType: FrameworkElement.RequestBringIntoView
  fullName: System.Windows.FrameworkElement.RequestBringIntoView
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 경우 <xref:System.Windows.FrameworkElement.BringIntoView*>이 요소에 호출 됩니다.</xref:System.Windows.FrameworkElement.BringIntoView*>"
  remarks: "이 이벤트는 부모에 알립니다 <xref:System.Windows.Controls.ScrollViewer>(또는 파생 클래스) RequestBringIntoView 이벤트를 발생 하는 요소 수 있도록 표시 되는 스크롤 가능한 영역 내에서.</xref:System.Windows.Controls.ScrollViewer> <xref:System.Windows.Controls.ScrollViewer>이벤트의 클래스 처리를 사용 하 여 처리 된 것으로 RequestBringIntoView 이벤트 후 표시 됩니다.</xref:System.Windows.Controls.ScrollViewer> 일반적 RequestBringIntoView 이벤트 데이터 표시 하지 말아야 처리는 스크롤 영역을 제어 하는 클래스에 의해 모든 인스턴스 처리기를 <xref:System.Windows.FrameworkElement.BringIntoView%2A>.</xref:System.Windows.FrameworkElement.BringIntoView%2A> 요소의 원하는 목표 방해 하 게 이렇게      <a name=&quot;routedEventInfo_RequestBringIntoView&quot;></a># # 이벤트 정보 라우트된 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|   | 라우팅 전략 | 버블링 |   | 대리자 | <xref:System.Windows.RequestBringIntoViewEventHandler>|</xref:System.Windows.RequestBringIntoViewEventHandler></xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>"
  syntax:
    content: public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;
    return:
      type: System.Windows.RequestBringIntoViewEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RequestBringIntoViewEvent
  id: RequestBringIntoViewEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RequestBringIntoViewEvent
  nameWithType: FrameworkElement.RequestBringIntoViewEvent
  fullName: System.Windows.FrameworkElement.RequestBringIntoViewEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref href=&quot;System.Windows.FrameworkElement.RequestBringIntoView&quot;> </xref> 라우트된 이벤트입니다."
  syntax:
    content: public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Resources
  id: Resources
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Resources
  nameWithType: FrameworkElement.Resources
  fullName: System.Windows.FrameworkElement.Resources
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "로컬로 정의 된 리소스 사전을 가져오거나 설정 합니다."
  remarks: "완전히 또는 부분적으로 정의할 수 있는 리소스 사전 [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] 개별 페이지 또는 응용 프로그램에 대 한 루트 요소에는 일반적으로 및 속성 요소로 일반적으로 만들어집니다. 이 수준에서 리소스 사전을 배치 쉽게 페이지의 개별 자식 요소 (또는 응용 프로그램의 경우에는 페이지)를 찾을 수 있습니다. 대부분의 응용 프로그램 시나리오의 리소스 사전에서 개체 요소로 스타일을 정의 하는 것 권장 전체 스타일 리소스 자체 포함 될 수 있도록 외부 리소스로 정의 된 또는 (이 방법은 하 개발자 책임에서 편집 해야 하는 물리적 파일을 구분 하 여).       이 속성에서 반환 하는 리소스 사전에만 해당 요소 내부에서 직접 선언 참고 합니다. 이 자식 요소를 위쪽으로 재귀적으로 검색 되는 각 부모 요소에 정의 된 리소스에 액세스할 수 있는 실제 리소스 조회 프로세스와 다릅니다.       리소스에서 리소스를 만들 수 있지만 컬렉션 내에서 코드에 의해 참조 될 수도 있습니다 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 를 확실 하 게 액세스할 수 없는까지 후 <xref:System.Windows.FrameworkElement.Loaded>는 사전을 선언 하는 요소에 의해 발생 합니다.</xref:System.Windows.FrameworkElement.Loaded> 비동기적으로 및 not 리소스 구문 분석 하는 사실, 심지어는 <xref:System.Windows.FrameworkElement.Loaded>이벤트는 참조할 수 있는 보증은 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 리소스를 정의 합니다.</xref:System.Windows.FrameworkElement.Loaded> 따라서 일반적으로 액세스 해야 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 또는 다른를 통해 런타임 코드의 일부로 정의 된 리소스 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 스타일이 나 특성 값에 대 한 리소스 확장 참조 하는 기법입니다. 기본적으로 해당에서 만든 참조 하는 코드를 통해 리소스에 액세스할 때 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]합니다.       내부 <xref:System.Windows.ResourceDictionary>추가, 제거 또는 코드를 사용 하 여 컬렉션 내에서 리소스를 쿼리 하는 데 필요한 메서드를 지원 합니다.</xref:System.Windows.ResourceDictionary> 리소스 속성은 완전히 새로운 되도록 요소의 리소스 컬렉션을 교체 하는 시나리오를 지원 하기 위해 설정할 수 나 다른 <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>       에 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 표시 된 구문 <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> 에 대 한 요소를 포함 하지 않습니다 이것이; 암시적 컬렉션 구문의 예 컬렉션 요소를 나타내는 태그를 생략할 수 있습니다. 컬렉션에 항목으로 추가 하는 요소 대신 지정 됩니다. 암시적 컬렉션에 대 한 자세한 내용은 및 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], 참조 [XAML 구문에서 세부](~/add/includes/ajax-current-ext-md.md)합니다. 하나의 <xref:System.Windows.ResourceDictionary>요소가 병합된 된 사전을 도입 하는 경우이 경우 일반적으로 없는 자식 요소가 <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> 으로 명시적으로 지정 되어</xref:System.Windows.ResourceDictionary> 있는 경우 자세한 내용은 참조 [자세한](~/add/includes/ajax-current-ext-md.md)합니다.      <a name=&quot;xamlPropertyElementUsage_Resources&quot;></a># # XAML 속성 요소 사용 ```   <object>     <object.Resources>       oneOrMoreResourceElements     </object.Resources>   </object>   ``` <a name=&quot;xamlValues_Resources&quot;> </a> # # XAML 값 *oneOrMoreResourceElements* 리소스 정의 하는 하나 이상의 개체 요소입니다.       각 내에서 각 리소스 속성 요소 <xref:System.Windows.ResourceDictionary>에 대 한 고유 값이 있어야는 [X:key 지시문](~/add/includes/ajax-current-ext-md.md), <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> 에서 값을 검색할 때 고유 키로 제공 되</xref:System.Windows.ResourceDictionary>"
  syntax:
    content: public System.Windows.ResourceDictionary Resources { get; set; }
    return:
      type: System.Windows.ResourceDictionary
      description: "현재 로컬로 정의 된 사전 키로 각 리소스에 액세스할 수 있는 리소스입니다."
  overload: System.Windows.FrameworkElement.Resources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)
  id: SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "데이터 원본에 대 한 경로 정규화도 제공 된 원본 속성 이름에 따라이 요소에 바인딩을 연결 합니다."
  remarks: "이 메서드는 호출에 대 한 편리한 메서드입니다 <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>는 현재 인스턴스를 전달 하는 <xref:System.Windows.DependencyObject>, 새 및 <xref:System.Windows.Data.Binding>제공 된 기준 `path` 매개 변수.</xref:System.Windows.Data.Binding> </xref:System.Windows.DependencyObject> </xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName> 이 서명은 단순한 기본 바인딩을 설정 하는 경우 더 편리 합니다. 기본이 아닌 조건에 대 한 바인딩 속성을 지정 하거나 사용 하려는 해야 할 경우는 <xref:System.Windows.Data.MultiBinding>또는 <xref:System.Windows.Data.PriorityBinding>, 사용할지는 <xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>서명.</xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> </xref:System.Windows.Data.PriorityBinding> </xref:System.Windows.Data.MultiBinding>"
  example:
  - "The following example sets a binding using a specific path.  \n  \n [!code-cs[BaseElementsSmorgasbord#SetBindingPath](~/add/codesnippet/csharp/BaseElementsSmorgasbord/Page1.xaml.cs#setbindingpath)]\n [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/add/codesnippet/visualbasic/baseelementssmorgasbord/page1.xaml.vb#setbindingpath)]"
  syntax:
    content: public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "바인딩을 해야 설정할 대상 속성을 식별 합니다."
    - id: path
      type: System.String
      description: "원본 속성 이름 또는 경로 바인딩에 사용 되는 속성입니다."
    return:
      type: System.Windows.Data.BindingExpression
      description: "바인딩 상태를 기록 합니다. 이 반환 값은 오류 검사에 유용할 수 있습니다."
  overload: System.Windows.FrameworkElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  id: SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,BindingBase)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "제공된 된 바인딩 개체를 기반으로이 요소에 바인딩을 연결 합니다."
  remarks: "이 메서드는 <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>, <xref:System.Windows.DependencyObject>.</xref:System.Windows.DependencyObject> 는 현재 인스턴스를 전달 하는</xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName> 호출에 대 한 편의 메서드"
  syntax:
    content: public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "바인딩을 해야 설정할 속성을 식별 합니다."
    - id: binding
      type: System.Windows.Data.BindingBase
      description: "데이터 바인딩의 고유 정보를 나타냅니다."
    return:
      type: System.Windows.Data.BindingExpressionBase
      description: "바인딩 상태를 기록 합니다. 이 반환 값은 오류 검사에 유용할 수 있습니다."
  overload: System.Windows.FrameworkElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  id: SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetFlowDirection(DependencyObject,FlowDirection)
  nameWithType: FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
  fullName: System.Windows.FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "값을 설정 하는 <xref:System.Windows.FrameworkElement.FlowDirection*>연결 된 지정된 된 요소에 대 한 속성.</xref:System.Windows.FrameworkElement.FlowDirection*>"
  remarks: "이 메서드는 지원에 대 한 연결 된 속성 구문이 <xref:System.Windows.FrameworkElement.FlowDirection%2A>속성, 자식 요소는 제공 된 <xref:System.Windows.FrameworkElement>해당 부모 요소 내에서 정렬에 대 한 흐름 방향을 지정 하도록 합니다.</xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement.FlowDirection%2A> 현재 값을 설정 하려면 <xref:System.Windows.FrameworkElement>를 직접 사용 하 여 [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] 접근자 <xref:System.Windows.FrameworkElement.FlowDirection%2A>.</xref:System.Windows.FrameworkElement.FlowDirection%2A> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);
    parameters:
    - id: element
      type: System.Windows.DependencyObject
      description: "흐름 방향을 지정 하는 요소입니다."
    - id: value
      type: System.Windows.FlowDirection
      description: "방향을 지정 하는 열거형의 값입니다."
  overload: System.Windows.FrameworkElement.SetFlowDirection*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  id: SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkElement.SetResourceReference(DependencyProperty,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "지정 된 이름의 리소스를 검색 하 고 지정 된 속성에 리소스 참조를 설정 합니다."
  remarks: "리소스 참조는를 사용 하는 [DynamicResource 태그 확장](~/add/includes/ajax-current-ext-md.md) 태그에 있습니다. 리소스 참조는 런타임에 지연 기준 지정된 된 속성의 값을 제공 하는 내부 식을 작성 합니다. 내부 이벤트를 통해 변경 된 값을 표시 하는 리소스 사전 때마다 또는 현재 요소에 부모가 될 때마다 식이 다시 계산 됩니다 (부모 변경 변경 사전 조회 경로)."
  syntax:
    content: public void SetResourceReference (System.Windows.DependencyProperty dp, object name);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "리소스 연결 된 속성입니다."
    - id: name
      type: System.Object
      description: "리소스의 이름입니다."
  overload: System.Windows.FrameworkElement.SetResourceReference*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ShouldSerializeResources
  id: ShouldSerializeResources
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ShouldSerializeResources()
  nameWithType: FrameworkElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkElement.ShouldSerializeResources()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Serialization 프로세스의 콘텐츠를 serialize 해야 하는지 여부를 반환 합니다.는 <xref:System.Windows.FrameworkElement.Resources*>속성.</xref:System.Windows.FrameworkElement.Resources*>"
  remarks: "이 반환 됩니다 `true` 으로 로컬 <xref:System.Windows.FrameworkElement.Resources%2A>.</xref:System.Windows.FrameworkElement.Resources%2A> 중인 키가 지정 된 리소스를 하나 이상 있습니다."
  syntax:
    content: public bool ShouldSerializeResources ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우는 <xref:System.Windows.FrameworkElement.Resources*>고, 그렇지 않으면 직렬화 된 속성 값은 여야 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkElement.Resources*>"
  overload: System.Windows.FrameworkElement.ShouldSerializeResources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ShouldSerializeStyle
  id: ShouldSerializeStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ShouldSerializeStyle()
  nameWithType: FrameworkElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkElement.ShouldSerializeStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Serialization 프로세스의 콘텐츠를 serialize 해야 하는지 여부를 반환 합니다.는 <xref:System.Windows.FrameworkElement.Style*>속성.</xref:System.Windows.FrameworkElement.Style*>"
  remarks: "이 반환 됩니다 `true` 경우는 <xref:System.Windows.Style>로컬로 설정.</xref:System.Windows.Style>"
  syntax:
    content: public bool ShouldSerializeStyle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우는 <xref:System.Windows.FrameworkElement.Style*>고, 그렇지 않으면 직렬화 된 속성 값은 여야 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkElement.Style*>"
  overload: System.Windows.FrameworkElement.ShouldSerializeStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ShouldSerializeTriggers
  id: ShouldSerializeTriggers
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ShouldSerializeTriggers()
  nameWithType: FrameworkElement.ShouldSerializeTriggers()
  fullName: System.Windows.FrameworkElement.ShouldSerializeTriggers()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Serialization 프로세스의 콘텐츠를 serialize 해야 하는지 여부를 반환 합니다.는 <xref:System.Windows.FrameworkElement.Triggers*>속성.</xref:System.Windows.FrameworkElement.Triggers*>"
  remarks: "이 메서드가 반환 `true` 경우는 <xref:System.Windows.FrameworkElement.Triggers%2A>속성이 로컬로.</xref:System.Windows.FrameworkElement.Triggers%2A>"
  syntax:
    content: public bool ShouldSerializeTriggers ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우는 <xref:System.Windows.FrameworkElement.Triggers*>고, 그렇지 않으면 직렬화 된 속성 값은 여야 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkElement.Triggers*>"
  overload: System.Windows.FrameworkElement.ShouldSerializeTriggers*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SizeChanged
  id: SizeChanged
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SizeChanged
  nameWithType: FrameworkElement.SizeChanged
  fullName: System.Windows.FrameworkElement.SizeChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 경우 중 하나는 <> </> *> 또는 <> </> *> 속성이이 요소의 값을 변경 합니다."
  remarks: "라우트된 이벤트를 직접 경로 따르지 않는, 에서만 발생 하는 동일한 요소 내에서 처리 됩니다. 라우트된 이벤트에 다른 라우트된 이벤트 동작 지원 않는 직접: 액세스할 수 있는 처리기 컬렉션을 지원 하며으로 사용할 수는 <xref:System.Windows.EventTrigger>스타일에서.</xref:System.Windows.EventTrigger>       이 레이아웃 시스템 내에서 속성을 읽고는 <xref:System.Windows.SizeChangedEventArgs>고려할지 여부를 보고 된 크기를 변경 하는 중요 한을 확인 하려면이 이벤트의 인수 클래스입니다.</xref:System.Windows.SizeChangedEventArgs> 이 레이아웃 시스템 또는 이전 구문과 새 높이 또는 너비 값 사이의 않는 시각적으로 차이로 인해 레이아웃 변경을 적용 하지 않도록 사용자 컨트롤별 레이아웃 구현을 허용 합니다. 차이로 부동 소수점 데이터 형식 반올림 하거나 동일한 결과 계산 때문일 수 있습니다.      <a name=&quot;routedEventInfo_SizeChanged&quot;></a># # 이벤트 정보 라우트된 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.SizeChangedEvent>|   | 라우팅 전략 | 직접 |   | 대리자 | <xref:System.Windows.SizeChangedEventHandler>|</xref:System.Windows.SizeChangedEventHandler></xref:System.Windows.FrameworkElement.SizeChangedEvent>"
  syntax:
    content: public event System.Windows.SizeChangedEventHandler SizeChanged;
    return:
      type: System.Windows.SizeChangedEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SizeChangedEvent
  id: SizeChangedEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SizeChangedEvent
  nameWithType: FrameworkElement.SizeChangedEvent
  fullName: System.Windows.FrameworkElement.SizeChangedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref href=&quot;System.Windows.FrameworkElement.SizeChanged&quot;> </xref> 라우트된 이벤트입니다."
  remarks: "라우트된 이벤트 식별자는 라우트된 이벤트가 등록 될 때 생성 됩니다. 이러한 식별자는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드가 포함 됩니다. 클래스 처리기를 추가 하려면 이러한 식별자를 사용할 수 있습니다.       라우트된 이벤트를 등록 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 을 참조 하십시오. 라우트된 이벤트 식별자를 사용 하 여 클래스 처리기를 추가 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A> 을 참조 하십시오."
  syntax:
    content: public static readonly System.Windows.RoutedEvent SizeChangedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SourceUpdated
  id: SourceUpdated
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SourceUpdated
  nameWithType: FrameworkElement.SourceUpdated
  fullName: System.Windows.FrameworkElement.SourceUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소에 있는 바인딩 기존 속성에 대 한 소스 값이 변경 될 때 발생 합니다."
  remarks: "이 이벤트에 대 한 별칭을 만들어는 <xref:System.Windows.Data.Binding.SourceUpdated>의해 발생 하는 이벤트 <xref:System.Windows.Data.Binding>이 요소와 관련 된.</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.SourceUpdated>      <a name=&quot;xamlAttributeUsage_SourceUpdated&quot;></a># # XAML 특성 사용```   <object SourceUpdated=&quot;eventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> SourceUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Style
  id: Style
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Style
  nameWithType: FrameworkElement.Style
  fullName: System.Windows.FrameworkElement.Style
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "렌더링 될 때이 요소에서 사용 되는 스타일을 가져오거나 설정 합니다."
  remarks: "컨트롤에 대 한 현재 스타일은 보통 제어 테마 설정의 기본 스타일 제공 또는 스타일에서 리소스 페이지 또는 응용 프로그램 수준 (암시적 스타일)에 의해 일반적으로 컨트롤 형식에 적용 됩니다. 이 속성은 설정 하거나 반환 하지 기본 (테마) 스타일 않지만 요소에 사용 되는 명시적 스타일 또는 암시적 스타일 반환 합니다. 암시적 또는 명시적 스타일의 경우 스타일은 지정 된 이름이 든 리소스로 로컬 정의 중요지 않습니다.       스타일 정의는 몇 가지 제한 사항이 있습니다. 새 전체 스타일 속성을 다시 설정할 수 있습니다 <xref:System.Windows.Style>언제 든 지는 됩니다 언제.</xref:System.Windows.Style> 그러나 가능한 한 즉시 해당 스타일 로드 된 요소에서 사용 하 게 되는 <xref:System.Windows.Style>고려해 야 봉인.</xref:System.Windows.Style> 사용 중인 스타일의 개별 속성을 변경 하려고 (컬렉션 내에서 아무 것도 같은 <xref:System.Windows.Style.Setters%2A>) 예외를 throw 합니다.</xref:System.Windows.Style.Setters%2A> 태그에 정의 된 스타일 (리소스)에 대 한 리소스 사전에서 로드 하거나 내에 포함 된 페이지가 (인라인 스타일)에 대 한 로드 사용 중인 것으로 간주 됩니다.       스타일은 특별 한 우선 순위가 종속성 속성입니다. 로컬로 설정 된 스타일은 일반적으로 가장 높은 우선 순위에서 속성 시스템 작동 합니다. 스타일 null 인 경우이 시점에서 속성을 로드 하는 동안 시스템 확인 암시적 스타일이 해당 유형을 지정 하는 로컬 또는 응용 프로그램 리소스에 대 한 합니다. 이 단계를 수행한 후 스타일 여전히 null 이면 기본 (테마) 스타일에서 실행 되며 스타일 프레젠테이션을 위해를 일반적으로 제공 다음 되지만 기본 스타일의 스타일 속성 값에 반환 되지 않습니다. 참조 [종속성 속성 값 우선 순위](~/add/includes/ajax-current-ext-md.md) 또는 [스타일 및 템플릿](~/add/includes/ajax-current-ext-md.md)합니다.      <a name=&quot;xamlAttributeUsage_Style&quot;></a># # XAML 특성 사용 ```   <object Style=&quot;{resourceExtension styleResourceKey}&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_Style&quot;> </a> # # XAML 속성 요소 사용 <a name=&quot;xamlValues_Style&quot;> </a> # # XAML 값 *resourceExtension* 다음 중 하나:, 또는.       참조 [XAML 리소스](~/add/includes/ajax-current-ext-md.md)합니다.       *styleResourceKey* 요청 되는 스타일을 식별 하는 키입니다. 에 <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> 의 기존 리소스를이 키는      > [!NOTE] > 속성 요소 구문을 기술적으로 가능 하지만 대부분의 스타일 시나리오에 대 한 권장 하지는 않습니다. 참조 [인라인 스타일 및 템플릿](~/add/includes/ajax-current-ext-md.md)합니다. 사용 하 여 바인딩 참조 또는 <xref:System.Windows.Data.Binding>가능 하지만 일반적이 지 않은 이기도 합니다.</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_Style&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.StyleProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.StyleProperty>"
  example:
  - "The following example defines a style in a resource dictionary.  \n  \n [!code-xml[FEResource#StyleProperty](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty)]  \n[!code-xml[FEResource#StyleProperty2](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty2)]  \n[!code-xml[FEResource#StyleProperty3](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty3)]  \n[!code-xml[FEResource#StyleProperty4](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty4)]"
  syntax:
    content: public System.Windows.Style Style { get; set; }
    return:
      type: System.Windows.Style
      description: "있는 경우 요소에 대 한 적용 된 기본값이 아닌 스타일입니다. 그렇지 않으면 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다. 기본 생성 된 기본 <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.FrameworkElement.Style*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.StyleProperty
  id: StyleProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: StyleProperty
  nameWithType: FrameworkElement.StyleProperty
  fullName: System.Windows.FrameworkElement.StyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.Style*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.Style*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty StyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  id: System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  isEii: true
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 멤버에 대 한 참조는 <xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>메서드.</xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>"
  remarks: "이 멤버는 명시적 인터페이스 멤버 구현 이며 사용할 수 있습니다 경우에만 <xref:System.Windows.FrameworkElement>인스턴스로 캐스팅 되는 <xref:System.Windows.Markup.IQueryAmbient>인터페이스.</xref:System.Windows.Markup.IQueryAmbient> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);
    parameters:
    - id: propertyName
      type: System.String
      description: "요청된 된 앰비언트 속성의 이름입니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우 <code> propertyName </code> 사용할 수 없으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Tag
  id: Tag
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Tag
  nameWithType: FrameworkElement.Tag
  fullName: System.Windows.FrameworkElement.Tag
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소에 대 한 사용자 지정 정보를 저장 하는 데 사용할 수 있는 임의의 개체 값을 가져오거나 설정 합니다."
  remarks: "이 속성은 다른 태그 속성과 유사 [!INCLUDE[TLA#tla_ms](~/add/includes/tlasharptla-ms-md.md)] 프로그래밍 모델을 같은 [!INCLUDE[TLA#tla_vba](~/add/includes/ajax-current-ext-md.md)] 또는 [!INCLUDE[TLA#tla_winforms](~/add/includes/ajax-current-ext-md.md)]합니다. 태그에 대 한 몇 가지 기본 사용자 지정 정보를 저장할 수 있는 기존 속성 위치를 제공 하기 위한 용도가 <xref:System.Windows.FrameworkElement>요소 하위 클래스를 요구 하지 않고.</xref:System.Windows.FrameworkElement>       이 속성은 개체, 않으므로 속성 요소 사용에서 태그 속성을 설정 하려면 사용 하도록 해야 [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] , 문자열 등의 알려진된 기본 제공 형식 변환기를 가진 개체가 아닌 다른 값으로. 이런이 방식으로 사용 되는 개체가 아닌 일반적으로 표준 [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] 네임 스페이스 따라서으로 외부 네임 스페이스에 대 한 네임 스페이스 매핑을 필요할 수 있습니다 및 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 요소입니다. 자세한 내용은 참조 [XAML 네임 스페이스 및 WPF XAML에 대 한 매핑 Namespace](~/add/includes/ajax-current-ext-md.md) 및 [XAML을 WPF에 대 한 사용자 지정 클래스](~/add/includes/ajax-current-ext-md.md)합니다.      <a name=&quot;dependencyPropertyInfo_Tag&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.TagProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.FrameworkElement.TagProperty>"
  syntax:
    content: public object Tag { get; set; }
    return:
      type: System.Object
      description: "원하는 값입니다. 이 속성에 기본값이 없습니다."
  overload: System.Windows.FrameworkElement.Tag*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TagProperty
  id: TagProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TagProperty
  nameWithType: FrameworkElement.TagProperty
  fullName: System.Windows.FrameworkElement.TagProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.Tag*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.Tag*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TagProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TargetUpdated
  id: TargetUpdated
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TargetUpdated
  nameWithType: FrameworkElement.TargetUpdated
  fullName: System.Windows.FrameworkElement.TargetUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소의 속성 바인딩에 대 한 대상 값이 변경 될 때 발생 합니다."
  remarks: "이 이벤트에 대 한 별칭을 만들어는 <xref:System.Windows.Data.Binding.TargetUpdated>의해 발생 하는 이벤트 <xref:System.Windows.Data.Binding>이 요소와 관련 된.</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.TargetUpdated> 이 일반적으로 해당 바인딩이 양방향 바인딩에 바인딩된 종속성 속성은 하는 이전 속성 값이 이제 모든 유효성 검사 또는 캐싱 체계를 지 원하는 속성 또는 데이터 원본에 유효 의미 합니다.       TargetUpdated 이벤트의 이벤트 데이터를 사용 하 여 대상 값 업데이트를 보고 하는 특정 속성을 결정 합니다.      <a name=&quot;xamlAttributeUsage_TargetUpdated&quot;></a># # XAML 특성 사용```   <object TargetUpdated=&quot;eventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> TargetUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TemplatedParent
  id: TemplatedParent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TemplatedParent
  nameWithType: FrameworkElement.TemplatedParent
  fullName: System.Windows.FrameworkElement.TemplatedParent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소의 템플릿 부모에 대 한 참조를 가져옵니다. 이 속성은 요소 템플릿을 통해 만들어지지 않은 경우와 관련이 없습니다."
  remarks: "TemplatedParent는 자주 `null` 응용 프로그램 태그 또는 코드에서 만든 개체에 대 한 합니다. 템플릿을 통해 직접 해당 개체를 만들기 때문입니다. 루트, 논리적 트리를 탐색 하 여 가져온 개체 참조 또는 일반 이름으로 참조를 서식 파일에서 제공 되지 않습니다.       TemplatedParent 되지 수 없는 경우 `null` 작업 등의 시각적 트리를 탐색 낮은 수준의 특정 입력된 이벤트에 대 한 이벤트 처리 적중 테스트, <xref:System.Windows.Media.VisualTreeHelper>, 열거자, 작업을 반환할 수 있는 템플릿에서 생성 되는 요소 또는.</xref:System.Windows.Media.VisualTreeHelper> 경우에도 명시적으로 호출 하는 경우 <xref:System.Windows.FrameworkTemplate.FindName%2A>기존에 대해 <xref:System.Windows.FrameworkTemplate>하며 반환 된 개체를 사용 하는.</xref:System.Windows.FrameworkTemplate> </xref:System.Windows.FrameworkTemplate.FindName%2A>       템플릿은 실제로 공유 개체를 서식 파일의 내용을 한 번만 생성 됩니다. 따라서 서식 파일에서 생성 된 요소에 대 한 개체 참조를 가져오는 경우 명백한 논리적 트리 루트 페이지에 도달 하지 않도록 알 수 있습니다. 이러한 서식 파일 참조 페이지의 논리 트리를 연결 하려면 먼저 TemplatedParent 값을 가져올를 계속를 원하는 대로 해당 요소 트리를 탐색 합니다."
  syntax:
    content: public System.Windows.DependencyObject TemplatedParent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "요소를 <xref href=&quot;System.Windows.FrameworkTemplate&quot;> </xref> <xref:System.Windows.FrameworkTemplate.VisualTree*>이 요소를 만들 수 있습니다.</xref:System.Windows.FrameworkTemplate.VisualTree*> 이 값은 대개 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; 설명을 참조 하십시오."
  overload: System.Windows.FrameworkElement.TemplatedParent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTip
  id: ToolTip
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTip
  nameWithType: FrameworkElement.ToolTip
  fullName: System.Windows.FrameworkElement.ToolTip
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소에 대해 표시 되는 도구 설명 개체를 가져오거나 설정 합니다.는 [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]합니다."
  remarks: "이 속성의 값 형식인 경우 <xref:System.Windows.Controls.ToolTip>, 해당 값은에 사용 되는 도구 설명의 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)].</xref:System.Windows.Controls.ToolTip>  값이 다른 형식의 경우 해당 값으로 사용 됩니다는 *콘텐츠* 에 대 한는 <xref:System.Windows.Controls.ToolTip>제공 (생성 된) 시스템에 의해.</xref:System.Windows.Controls.ToolTip> 자세한 내용은 <xref:System.Windows.Controls.ToolTipService>.</xref:System.Windows.Controls.ToolTipService> 을 참조 하십시오. 추가적으로 사용자 지정할 <xref:System.Windows.Controls.ToolTip>.</xref:System.Windows.Controls.ToolTip> 사용할 수 있는 연결 된 속성을 제공 하는 서비스 클래스      <a name=&quot;xamlAttributeUsage_ToolTip&quot;></a># # XAML 특성 사용 ```   <object ToolTip=&quot;toolTipContent&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_ToolTip&quot;> </a> # # XAML 속성 요소 사용 ```   <object>     <object.ToolTip>       <ToolTip .../>     </object.ToolTip>   </object>   - or -   <object>     <object.ToolTip>       toolTipObjectContent     </object.ToolTip>   </object>   ``` <a name=&quot;xamlValues_ToolTip&quot;> </a> # # XAML 값 *toolTipContent* 도구 설명 텍스트 표시 되는 문자열입니다.                   *toolTipObjectContent* <xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement> 에 대 한 내용으로 사용 해야 하는 개체 요소 형태에 제공 된 몇 가지 개체 이 수는 일반적으로 <xref:System.Windows.FrameworkElement>또는 다른 요소는 콘텐츠 결국 텍스트가 포함 된 도구 설명에 대 한 레이아웃 합치기를 만드는.</xref:System.Windows.FrameworkElement> 이 사용법에서는 <xref:System.Windows.Controls.ToolTip>요소가 만들어집니다 구문 분석 된에서 암시적으로 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], 및 *toolTipObjectContent* 내용이 설정으로 해당 <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName>속성.</xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName> </xref:System.Windows.Controls.ToolTip>       `ToolTip`.../>    See <xref:System.Windows.Controls.ToolTip>.</xref:System.Windows.Controls.ToolTip>      <a name=&quot;dependencyPropertyInfo_ToolTip&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.ToolTipProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.FrameworkElement.ToolTipProperty>"
  example:
  - "The following example creates a <xref:System.Windows.Controls.ToolTip> in code and then sets the ToolTip property on a <xref:System.Windows.Controls.Primitives.StatusBar> control.  \n  \n [!code-vb[StatusBar#MakeProgressBar](~/add/codesnippet/visualbasic/statusbar/window1.xaml.vb#makeprogressbar)]\n [!code-cs[StatusBar#MakeProgressBar](~/add/codesnippet/csharp/StatusBar/Window1.xaml.cs#makeprogressbar)]"
  syntax:
    content: public object ToolTip { get; set; }
    return:
      type: System.Object
      description: "도구 설명 개체입니다. 왜이 매개 변수는 강력한 형식이 아니며 대 한 자세한 내용은 아래 설명 부분을 참조 하십시오."
  overload: System.Windows.FrameworkElement.ToolTip*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipClosing
  id: ToolTipClosing
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipClosing
  nameWithType: FrameworkElement.ToolTipClosing
  fullName: System.Windows.FrameworkElement.ToolTipClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "요소에 도구 설명이 닫히기 바로 전에 발생 합니다."
  remarks: "ToolTipClosing 이벤트 처리로 표시 도구 설명 닫기 취소 되지 않습니다. 도구 설명이 표시 되 면 도구 설명 닫기 사용자 UI와 상호 작용에 대 한 응답에만 작업 수행 됩니다.       이 이벤트는 <xref:System.Windows.EventTrigger>스타일에서.</xref:System.Windows.EventTrigger> 이 이벤트의 식별자 필드에는 다시 서비스 수준 이벤트에 대 한 추가/제거 이벤트 메서드를 노출 하지 않는 서비스의 구현을 사용 하기 때문입니다.      <a name=&quot;routedEventInfo_ToolTipClosing&quot;></a># # 이벤트 정보 라우트된 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|   | 라우팅 전략 | 직접 |   | 대리자 | <xref:System.Windows.Controls.ToolTipEventHandler>|      -재정의 <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>파생된 클래스에서이 이벤트를 처리 하는 클래스를 구현 합니다.</xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> </xref:System.Windows.Controls.ToolTipEventHandler> </xref:System.Windows.FrameworkElement.ToolTipClosingEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipClosingEvent
  id: ToolTipClosingEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipClosingEvent
  nameWithType: FrameworkElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkElement.ToolTipClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref href=&quot;System.Windows.FrameworkElement.ToolTipClosing&quot;> </xref> 라우트된 이벤트입니다."
  remarks: "라우트된 이벤트 식별자는 라우트된 이벤트가 등록 될 때 생성 됩니다. 이러한 식별자는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드가 포함 됩니다. 클래스 처리기를 추가 하려면 이러한 식별자를 사용할 수 있습니다.       라우트된 이벤트를 등록 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 을 참조 하십시오. 라우트된 이벤트 식별자를 사용 하 여 클래스 처리기를 추가 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A> 을 참조 하십시오."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipOpening
  id: ToolTipOpening
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipOpening
  nameWithType: FrameworkElement.ToolTipOpening
  fullName: System.Windows.FrameworkElement.ToolTipOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "요소에 도구 설명이 열릴 때 발생 합니다."
  remarks: "도구 설명 UI에 표시 되지 않도록 하려면의 처리기에 표시할 수는 <xref:System.Windows.Controls.ToolTipEventArgs>이벤트 데이터를 처리 합니다.</xref:System.Windows.Controls.ToolTipEventArgs> 그렇지 않으면, 도구 설명 표시 됩니다, 값을 사용 하 여 <xref:System.Windows.FrameworkElement.ToolTip%2A>도구 설명 콘텐츠로 속성.</xref:System.Windows.FrameworkElement.ToolTip%2A> 다른 가능한 시나리오는의 값을 기본값으로 다시 설정 하는 처리기를 작성할 수는 <xref:System.Windows.FrameworkElement.ToolTip%2A>도구 설명이 표시 되는 바로 전에 이벤트 원본에 있는 요소에 대 한 속성.</xref:System.Windows.FrameworkElement.ToolTip%2A>       경우에 발생 하지 것입니다 값 <xref:System.Windows.FrameworkElement.ToolTip%2A>은 `null` 명시적 이거나 설정 되지 않은.</xref:System.Windows.FrameworkElement.ToolTip%2A> 의도적으로 설정 하지 않으면 <xref:System.Windows.FrameworkElement.ToolTip%2A>를 `null` 도구 설명이 현재 열려 있거나 열기;이 도구 설명, 닫히고 없으며 UI에는 원하지 않는 시각적 요소가 만들어집니다 대신 동안.</xref:System.Windows.FrameworkElement.ToolTip%2A>       에 이벤트 일 수 없습니다는 <xref:System.Windows.EventTrigger>스타일에서.</xref:System.Windows.EventTrigger> 이 이벤트의 식별자 필드에는 다시 서비스 수준 이벤트에 대 한 추가/제거 이벤트 메서드를 노출 하지 않는 서비스의 구현을 사용 하기 때문입니다.      <a name=&quot;routedEventInfo_ToolTipOpening&quot;></a># # 이벤트 정보 라우트된 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|   | 라우팅 전략 | 직접 |   | 대리자 | <xref:System.Windows.Controls.ToolTipEventHandler>|      -재정의 <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>파생된 클래스에서이 이벤트를 처리 하는 클래스를 구현 합니다.</xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> </xref:System.Windows.Controls.ToolTipEventHandler> </xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipOpeningEvent
  id: ToolTipOpeningEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipOpeningEvent
  nameWithType: FrameworkElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkElement.ToolTipOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref href=&quot;System.Windows.FrameworkElement.ToolTipOpening&quot;> </xref> 라우트된 이벤트입니다."
  remarks: "라우트된 이벤트 식별자는 라우트된 이벤트가 등록 될 때 생성 됩니다. 이러한 식별자는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드가 포함 됩니다. 클래스 처리기를 추가 하려면 이러한 식별자를 사용할 수 있습니다.       라우트된 이벤트를 등록 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 을 참조 하십시오. 라우트된 이벤트 식별자를 사용 하 여 클래스 처리기를 추가 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A> 을 참조 하십시오."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipProperty
  id: ToolTipProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipProperty
  nameWithType: FrameworkElement.ToolTipProperty
  fullName: System.Windows.FrameworkElement.ToolTipProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.ToolTip*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.ToolTip*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ToolTipProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Triggers
  id: Triggers
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Triggers
  nameWithType: FrameworkElement.Triggers
  fullName: System.Windows.FrameworkElement.Triggers
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소에 직접 또는 자식 요소에 설정 된 트리거의 컬렉션을 가져옵니다."
  remarks: "> [!NOTE]>이 속성 설정할 수 있습니다 [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] 또는 컬렉션 개체에 액세스 하 고 추가 등의 다양 한 메서드를 사용 하 여 표시 된 컬렉션 구문을 통해 합니다. 컬렉션 개체 자체를 액세스 하는 속성은 읽기 전용, 컬렉션 자체는 읽기 / 쓰기입니다. 속성이 루트 요소에만 있습니다. 찾거나 다른 곳에서 설정 하려고 하면 예외가 throw 됩니다.       이 속성에서는 없습니다이 요소에 사용 중인 스타일의 일부로 존재 하는 트리거를 검사할 수 없습니다. 태그 또는 코드에서 컬렉션에 추가 된 트리거의 컬렉션만 보고 합니다. 요소 기본적으로 기존 등의 요소에 일반적으로 없습니다 (템플릿을 통해 예를 들어); 것이 더 일반적 컨트롤 대신 스타일에 설정 하는 합성에서 제공 하는 트리거에 대 한 합니다.       동작 (및 어느 요소 선언 하는 트리거 컬렉션에서 생성 되는 효과 설정 하려고) 측면에서 트리거 조건 및 트리거 효과 모두이 요소에 있을 수 있습니다 또는 논리적 트리에서 자식 요소에 있을 수 있습니다. 와 같은 수명 이벤트를 사용 하는 경우 <xref:System.Windows.FrameworkElement.Loaded>이 컬렉션을 가져오려면 자식 요소의 트리거 아직 완전히 로드와 되지 컬렉션은 런타임 시 실제로 것 보다 더 작은 됩니다.</xref:System.Windows.FrameworkElement.Loaded>       요소에 설정 된 트리거의 컬렉션만 지원 합니다. 이때 <xref:System.Windows.EventTrigger>, 하지 속성 트리거 (<xref:System.Windows.Trigger>).</xref:System.Windows.Trigger> </xref:System.Windows.EventTrigger> 속성 트리거를 필요로 하는 경우 스타일이 나 템플릿 내에서이 배치 하 고 다음 할당 해야 스타일이 나 템플릿을 요소에 하거나 통해 직접는 <xref:System.Windows.FrameworkElement.Style%2A>속성, 암시적 스타일 참조를 통해 간접적으로 또는.</xref:System.Windows.FrameworkElement.Style%2A>      <a name=&quot;xamlPropertyElementUsage_Triggers&quot;></a># # XAML 속성 요소 사용 ```   <object>     <object.Triggers>       oneOrMoreTriggers     </object.Triggers>   </object>   ``` <a name=&quot;xamlValues_Triggers&quot;> </a> # # XAML 값 *oneOrMoreTriggers* 하나 이상의 정의 된 <xref:System.Windows.EventTrigger>요소.</xref:System.Windows.EventTrigger>       이러한 각 트리거에서 올바른 스토리 보드의 작업 및 참조를 포함 해야 합니다. 참고가이 컬렉션 페이지의 루트 요소에만 설정할 수 있습니다. 자세한 내용은 참조 [적기](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public System.Windows.TriggerCollection Triggers { get; }
    return:
      type: System.Windows.TriggerCollection
      description: "강력한 형식의 컬렉션 <xref href=&quot;System.Windows.Trigger&quot;> </xref> 개체입니다."
  overload: System.Windows.FrameworkElement.Triggers*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TryFindResource(System.Object)
  id: TryFindResource(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TryFindResource(Object)
  nameWithType: FrameworkElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkElement.TryFindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "지정된 된 키와 리소스를 검색 하 고 해당 리소스를 반환 찾을 수 있습니다."
  remarks: "호출 하는 요소에는 리소스를 찾을 수 없습니다, 논리 트리를 통해 부모 리소스 트리를 위쪽으로 검색, 트리 것 동일한 방식으로 검색 결과 리소스 된 요청 하는 경우 키에 의해 런타임 시. 메서드가 반환 `null` 만 리소스 트리에 아무 곳 이나 해당 키의 리소스가 존재 하는 경우 시간에는 트리의 기존 조건 당 해당 TryFindResource 라고 합니다.       일반적으로 반환 값을 반환 되는 리소스 값으로 설정 하 려 했던 하는 속성의 형식 캐스팅 즉시 것입니다.       <xref:System.Windows.FrameworkElement.FindResource%2A>메서드가 비슷한 동작을 제외 하 고 제공 된 키에 리소스가 반환 된 경우 예외를 throw 합니다.</xref:System.Windows.FrameworkElement.FindResource%2A>"
  example:
  - "The following example is implemented as a button handler, where the button being clicked sets its background to a resource-defined brush obtained by calling TryFindResource on itself. This walks the element tree and finds the resource (the resource itself is defined in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] and is not shown).  \n  \n [!code-cs[BaseElementsSmorgasbord#FETryFindResource](~/add/codesnippet/csharp/BaseElementsSmorgasbord/Page1.xaml.cs#fetryfindresource)]\n [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/add/codesnippet/visualbasic/baseelementssmorgasbord/page1.xaml.vb#fetryfindresource)]"
  syntax:
    content: public object TryFindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "찾을 리소스의 키 식별자입니다."
    return:
      type: System.Object
      description: "찾은 리소스 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 제공 된 리소스가 없으면 <code> key </code> 를 찾을 수 있습니다."
  overload: System.Windows.FrameworkElement.TryFindResource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Unloaded
  id: Unloaded
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Unloaded
  nameWithType: FrameworkElement.Unloaded
  fullName: System.Windows.FrameworkElement.Unloaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "로드 된 요소의 요소 트리에서 요소에서 제거 될 때 발생 합니다."
  remarks: "라우트된 이벤트를 직접 경로 따르지 않는, 에서만 발생 하는 동일한 요소 내에서 처리 됩니다. 라우트된 이벤트에 다른 라우트된 이벤트 동작 지원 않는 직접: 액세스할 수 있는 처리기 컬렉션을 지원 하며으로 사용할 수는 <xref:System.Windows.EventTrigger>스타일에서.</xref:System.Windows.EventTrigger>       <xref:System.Windows.FrameworkElement.Loaded>및 Unloaded 시스템 사용자가 시작한 테마 변경의 결과로 컨트롤에서 발생할 수 있습니다.</xref:System.Windows.FrameworkElement.Loaded> 테마를 변경 하면 컨트롤 템플릿 및 포함 된 시각적 트리가 그러면 언로드하고 다시 로드 하기 위해 전체 컨트롤의 무효화 합니다. 따라서 페이지 탐색에 대해서만 발생 하도록 언로드를 가정할 수 없습니다.       Note 응용 프로그램 종료를 시작한 후 Unloaded 이벤트 발생 하지 않습니다. 응용 프로그램 종료 조건에 정의 된 경우에 수행 된 <xref:System.Windows.Application.ShutdownMode%2A>속성이 발생 합니다.</xref:System.Windows.Application.ShutdownMode%2A> 에 대 한와 같은 Unloaded 이벤트에 대 한 처리기 내에서 정리 코드를 배치 하는 경우는 <xref:System.Windows.Window>또는 <xref:System.Windows.Controls.UserControl>, 예상 대로 하지 호출 수도 있습니다.</xref:System.Windows.Controls.UserControl> </xref:System.Windows.Window>      <a name=&quot;routedEventInfo_Unloaded&quot;></a># # 이벤트 정보 라우트된 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.UnloadedEvent>|   | 라우팅 전략 | 직접 |   | 대리자 | <xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkElement.UnloadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Unloaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UnloadedEvent
  id: UnloadedEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UnloadedEvent
  nameWithType: FrameworkElement.UnloadedEvent
  fullName: System.Windows.FrameworkElement.UnloadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref href=&quot;System.Windows.FrameworkElement.Unloaded&quot;> </xref> 라우트된 이벤트입니다."
  remarks: "라우트된 이벤트 식별자는 라우트된 이벤트가 등록 될 때 생성 됩니다. 이러한 식별자는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드가 포함 됩니다. 클래스 처리기를 추가 하려면 이러한 식별자를 사용할 수 있습니다.       라우트된 이벤트를 등록 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 을 참조 하십시오. 라우트된 이벤트 식별자를 사용 하 여 클래스 처리기를 추가 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A> 을 참조 하십시오."
  syntax:
    content: public static readonly System.Windows.RoutedEvent UnloadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UnregisterName(System.String)
  id: UnregisterName(System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UnregisterName(String)
  nameWithType: FrameworkElement.UnregisterName(String)
  fullName: System.Windows.FrameworkElement.UnregisterName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "에 대 한 액세스를 간소화 된 <xref:System.Windows.NameScope>등록 취소 메서드에.</xref:System.Windows.NameScope>"
  remarks: "하기만 하면 등록을 취소할 이름에 동일한 이름 갖는 다른 요소의 하려는 경우."
  syntax:
    content: public void UnregisterName (string name);
    parameters:
    - id: name
      type: System.String
      description: "현재 범위에서 제거 하는 이름-개체 쌍의 이름입니다."
  overload: System.Windows.FrameworkElement.UnregisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UpdateDefaultStyle
  id: UpdateDefaultStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UpdateDefaultStyle()
  nameWithType: FrameworkElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkElement.UpdateDefaultStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "현재 기본 스타일을 다시 적용 <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>합니다."
  syntax:
    content: public void UpdateDefaultStyle ();
    parameters: []
  overload: System.Windows.FrameworkElement.UpdateDefaultStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UseLayoutRounding
  id: UseLayoutRounding
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UseLayoutRounding
  nameWithType: FrameworkElement.UseLayoutRounding
  fullName: System.Windows.FrameworkElement.UseLayoutRounding
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "여부 레이아웃 반올림에 적용 해야이 요소의 크기와 위치 레이아웃 하는 동안 여부를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "요소에 대 한 사항은 속성이 `true`, 중에 계산 되는 모든 정수 계열이 아닌 픽셀 값은 <xref:System.Windows.UIElement.Measure%2A>및 <xref:System.Windows.UIElement.Arrange%2A>전달 정수 픽셀 값으로 반올림 됩니다.</xref:System.Windows.UIElement.Arrange%2A> </xref:System.Windows.UIElement.Measure%2A>       이 속성은 자식 요소에 의해 상속 됩니다.      > [!NOTE] >으로 설정 해야 사항은 `true` 루트 요소에 있습니다. 부모 좌표로; 자식 좌표를 추가 하는 레이아웃 시스템 따라서 부모 좌표는 픽셀 경계에 없는 경우 자식 좌표가 픽셀 경계에 있습니다. 사항은 루트에 설정할 수 없는 경우 설정 <xref:System.Windows.UIElement.SnapsToDevicePixels%2A>자식 원하는 효과 가져올 수 있습니다.</xref:System.Windows.UIElement.SnapsToDevicePixels%2A>       픽셀 경계에 개체를 그리기는 지 장치 픽셀 중간 포함 때 앤티 앨리어싱에 의해 생성 되는 반투명 가장자리 제거 합니다. 다음 그림을 장치 픽셀의 중간에 단일 픽셀 너비 줄의 출력을 보여 줍니다. 왼쪽에 줄 레이아웃 반올림을 사용 하지 않는 되며 앤티 앨리어싱 있습니다. 오른쪽에 있는 줄 레이아웃 반올림을 사용 합니다.       ![단일 픽셀 선에 비교한 앤티 앨리어싱된 선입니다. ] (~/add/media/pixelsnaplinecompare.PNG &quot;단일 픽셀 선에 비교한 앤티 앨리어싱된 선입니다.&quot;)       레이아웃 반올림을 사용 하는 경우 및 <xref:System.Windows.GridUnitType>크기 조정, 레이아웃 시스템 약간 변동에에서 만듭니다 하위 픽셀 렌더링 하지 않으려면 열 또는 행 측정.</xref:System.Windows.GridUnitType> 예를 들어 눈금 크기의 3 열이 있는 100의 전체 너비 <xref:System.Windows.GridUnitType>, 3 개의 열을 만드는 대신 33.3의 같은 너비를 가진, 레이아웃 시스템은 33 모델과 34의 너비의 너비는 2 개의 열을 만듭니다.</xref:System.Windows.GridUnitType>      > [!NOTE] >에서.NET 4.6을 변경한 레이아웃 반올림 테두리가 있는 컨트롤에 클리핑 인스턴스를 줄일 수 있습니다. 기본적으로 대상 프레임 워크는.NET Framework 4.6 이상이 경우이 기능이 설정 됩니다. 이전 버전의 framework 대상으로 하는 응용 프로그램 app.config 파일에 다음 설정을 추가 하 여 새 동작을에 선택할 수: `<runtime>``<AppContextSwitchOverrides      value=&quot;Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false&quot;/>``</runtime>` 응용 프로그램은.NET Framework 4.6에서 실행 되는 하면 설정이 적용 됩니다."
  example:
  - "The following example demonstrates the effect that the UseLayoutRounding property has on a single pixel-width line. The line on the left does not use layout rounding and the line on the right uses layout rounding. If you slowly resize the window, you can see the difference that layout rounding makes.  \n  \n```xaml  \n  \n<Page x:Class=\"LayoutRounding.Lines\"  \n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"  \n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"  \n    Title=\"Lines\" Name=\"linesPage\"  \n    >  \n  <StackPanel Width=\"150\"  Margin=\"7\" Orientation=\"Horizontal\">  \n    <!-- Single pixel line with layout rounding turned OFF.-->  \n    <Rectangle UseLayoutRounding=\"False\"  \n       Width=\"45.5\" Margin=\"10\" Height=\"1\" Fill=\"Red\"/>  \n    <!-- Single pixel line with layout rounding turned ON.-->  \n    <Rectangle UseLayoutRounding=\"True\"  \n      Width=\"45.5\" Margin=\"10\" Height=\"1\" Fill=\"Red\"/>  \n  </StackPanel>  \n  <!-- Background Grid -->  \n  <Page.Background>  \n    <DrawingBrush  Viewport=\"0,0,10,10\" ViewportUnits=\"Absolute\" TileMode=\"Tile\">  \n      <DrawingBrush.Drawing>  \n        <DrawingGroup>  \n          <GeometryDrawing Brush=\"White\">  \n            <GeometryDrawing.Geometry>  \n              <RectangleGeometry Rect=\"0,0,1,1\" />  \n            </GeometryDrawing.Geometry>  \n          </GeometryDrawing>  \n          <GeometryDrawing Geometry=\"M0,0 L1,0 1,0.1, 0,0.1Z \" Brush=\"#CCCCFF\" />  \n          <GeometryDrawing Geometry=\"M0,0 L0,1 0.1,1, 0.1,0Z\" Brush=\"#CCCCFF\" />  \n        </DrawingGroup>  \n      </DrawingBrush.Drawing>  \n    </DrawingBrush>  \n  </Page.Background>  \n</Page>  \n```"
  syntax:
    content: public bool UseLayoutRounding { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>레이아웃 반올림이 적용 된; 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.FrameworkElement.UseLayoutRounding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UseLayoutRoundingProperty
  id: UseLayoutRoundingProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UseLayoutRoundingProperty
  nameWithType: FrameworkElement.UseLayoutRoundingProperty
  fullName: System.Windows.FrameworkElement.UseLayoutRoundingProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.UseLayoutRounding*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.UseLayoutRounding*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.VerticalAlignment
  id: VerticalAlignment
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: VerticalAlignment
  nameWithType: FrameworkElement.VerticalAlignment
  fullName: System.Windows.FrameworkElement.VerticalAlignment
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "패널 또는 항목 컨트롤 같은 부모 요소에서 작성 하는 경우이 요소에 적용 되는 세로 맞춤 특징을 가져오거나 설정 합니다."
  remarks: "때 <xref:System.Windows.FrameworkElement.Height%2A> <xref:System.Windows.FrameworkElement.Width%2A>속성 요소에 명시적으로 설정 되어, 이러한 값 이전의 레이아웃을 선택 하 고 <xref:System.Windows.VerticalAlignment>.</xref:System.Windows.VerticalAlignment> 이 속성을 설정 하 여 일반적인 효과 취소</xref:System.Windows.FrameworkElement.Width%2A> 하 고</xref:System.Windows.FrameworkElement.Height%2A>       VerticalAlignment는는 [!INCLUDE[TLA#tla_net](~/add/includes/tlasharptla-net-md.md)] 이란 현실에서 종속성 속성에 대 한 속성 접근자입니다. 이 특정 종속성 속성에는 해당 &quot;기본값이&quot;이 파생 된 요소 클래스, 특히 컨트롤에서에서 서로 다르게 설정 많습니다. 일반적으로이 두 가지 방법 중 하나에서 발생 합니다: 종속성 속성은 해당 기본값을 설정 하기 위한 여러 가지 메타 데이터 사용 하면서도 특정 파생된 클래스에 다시 등록 있거나 해당 종속성 속성 값을 다르게 설정 하는 기본 스타일 적용 되 고 있습니다. 예를 들어 명백한 &quot;기본값인&quot;에 대 한 VerticalAlignment는 <xref:System.Windows.Controls.ComboBoxItem>컨트롤 됩니다 <xref:System.Windows.VerticalAlignment>경우라도, <xref:System.Windows.Controls.ComboBoxItem> <xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement> VerticalAlignment 직접 상속</xref:System.Windows.Controls.ComboBoxItem> </xref:System.Windows.VerticalAlignment> </xref:System.Windows.Controls.ComboBoxItem> 즉, 해당 값의 기본 스타일 내에서 다시 설정 된 <xref:System.Windows.Controls.ComboBoxItem>, 스타일의 컨트롤 템플릿 내에서.</xref:System.Windows.Controls.ComboBoxItem>       <xref:System.Windows.Controls.Canvas>되므로 사용 하지 않습니다 VerticalAlignment 레이아웃을 구성할 때 <xref:System.Windows.Controls.Canvas>절대 위치에 따라.</xref:System.Windows.Controls.Canvas></xref:System.Windows.Controls.Canvas>       <xref:System.Windows.Controls.ComboBoxItem>또는 <xref:System.Windows.Controls.ComboBoxItem> <xref:System.Windows.VerticalAlignment>.</xref:System.Windows.VerticalAlignment> 되려면이 속성의 기본값 다시 정의 하는</xref:System.Windows.Controls.ComboBoxItem> 모든 파생된 클래스에서</xref:System.Windows.Controls.ComboBoxItem> 상속 되는 경우      <a name=&quot;dependencyPropertyInfo_VerticalAlignment&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> </xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>"
  syntax:
    content: public System.Windows.VerticalAlignment VerticalAlignment { get; set; }
    return:
      type: System.Windows.VerticalAlignment
      description: "세로 맞춤 설정입니다. 기본값은 <xref href=&quot;System.Windows.VerticalAlignment&quot;> </xref>합니다."
  overload: System.Windows.FrameworkElement.VerticalAlignment*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.VerticalAlignmentProperty
  id: VerticalAlignmentProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: VerticalAlignmentProperty
  nameWithType: FrameworkElement.VerticalAlignmentProperty
  fullName: System.Windows.FrameworkElement.VerticalAlignmentProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.VerticalAlignment*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.VerticalAlignment*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.VisualChildrenCount
  id: VisualChildrenCount
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: VisualChildrenCount
  nameWithType: FrameworkElement.VisualChildrenCount
  fullName: System.Windows.FrameworkElement.VisualChildrenCount
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 요소 내 시각적 자식 요소의 수를 가져옵니다."
  remarks: "<xref:System.Windows.FrameworkElement>VisualChildrenCount의 구현에서는 항상&0; 이나&1;을 반환 합니다.</xref:System.Windows.FrameworkElement> 이 속성 및 <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.</xref:System.Windows.FrameworkElement.GetVisualChild%2A> 하나 초과 하는 시각적 자식 컬렉션을 유지 관리 하는 클래스를 재정의 해야       이 속성은 레이아웃 재정의 구현 하기 위해 현재 자식 컬렉션의 상한값을 확인 하려면 일반적으로 사용 됩니다 (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>, <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>).</xref:System.Windows.FrameworkElement.ArrangeOverride%2A> </xref:System.Windows.FrameworkElement.MeasureOverride%2A>"
  example:
  - "The following example shows how a custom adorner uses the values declared by a <xref:System.Windows.Media.VisualCollection> that it maintains for its multiple visual children and reports these values through overrides of VisualChildrenCount and <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  \n  \n [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverridespre)]\n [!code-cs[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverridespre)]  \n[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverrides)]\n[!code-cs[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverrides)]"
  syntax:
    content: protected override int VisualChildrenCount { get; }
    return:
      type: System.Int32
      description: "이 요소에 대 한 시각적 자식 요소의 수입니다."
  overload: System.Windows.FrameworkElement.VisualChildrenCount*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Width
  id: Width
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Width
  nameWithType: FrameworkElement.Width
  fullName: System.Windows.FrameworkElement.Width
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "요소의 너비를 가져오거나 설정 합니다."
  remarks: "이 세 가지 속성 중 하나에 <xref:System.Windows.FrameworkElement>너비 정보를 지정 하는.</xref:System.Windows.FrameworkElement>  다른 두 <xref:System.Windows.FrameworkElement.MinWidth%2A>및 <xref:System.Windows.FrameworkElement.MaxWidth%2A>.</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.MinWidth%2A> 은  이러한 값 간에 충돌이 발생 하는 경우 실제 너비 결정 하기 위한 응용 프로그램의 순서는 첫 번째 <xref:System.Windows.FrameworkElement.MinWidth%2A>다음, 해야 <xref:System.Windows.FrameworkElement.MaxWidth%2A>, 마지막으로 너비 범위 내에 있는 이러한 각 경우.</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.MinWidth%2A>       이 속성의 반환 값은 항상에 대해 설정 된 값과 동일 합니다. 반대로,의 값은 <xref:System.Windows.FrameworkElement.ActualWidth%2A>다를 수 있습니다.</xref:System.Windows.FrameworkElement.ActualWidth%2A> 레이아웃은 몇 가지 이유로 제안된 크기를 거부 있을 수 있습니다. 또한이 레이아웃 시스템 자체 너비의 속성 시스템 집합을 기준으로 비동기적으로 작동 하 고 해당 특정 크기 조정 속성 변경 내용을 아직 처리 되지 않을 수 있습니다.       <xref:System.Double>이 속성 값 또한 <xref:System.Double.NaN?displayProperty=fullName>.</xref:System.Double.NaN?displayProperty=fullName> 수</xref:System.Double> 허용 하는 것 외에도 자동 크기 조정 동작을 지정 하는 방법입니다. [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 는 값을 설정 하면 문자열 &quot;Auto&quot; (대/소문자 구분)로 자동 크기 조정 동작을 사용 하도록 설정 합니다. 자동 크기 조정 동작 요소를 사용할 수 있는 너비 가득 찰 의미 합니다. 그러나 note 특정 컨트롤을 구체적으로 다시 설정 된 경우가 아니라면 크기 조정 동작은 자동 수 없게 하는 기본 스타일에서 기본값 제공 하는 경우가 많습니다.       유효성 검사 이외에 비결 정적 상한 값이 레이아웃 시스템에 의해 적용 되는 너비에 대 한 경계 (이 보다 큰 매우 큰 숫자 <xref:System.Single.MaxValue?displayProperty=fullName>보다 높지만 <xref:System.Double.MaxValue?displayProperty=fullName>).</xref:System.Double.MaxValue?displayProperty=fullName> </xref:System.Single.MaxValue?displayProperty=fullName> 이 경계를 초과 하면 요소가 렌더링 되지 하 고 예외가 throw 되지 않습니다. 가능한 시각적 표시의 최대 크기 보다 훨씬 큰 값으로 너비를 설정 하지 않으면 또는 비결 정적이 상한 값을 초과할 수 있습니다.      <a name=&quot;xamlAttributeUsage_Width&quot;></a># # XAML 특성 사용 ```   <object Width=&quot;double&quot;/>   - or –   <object Width =&quot;qualifiedDouble&quot;/>   - or -   <object Width =&quot;Auto&quot;/>   ``` <a name=&quot;xamlValues_Width&quot;> </a> # # XAML 값 *double* <xref:System.Double> 의 문자열 표현은 <xref:System.Double>0.0 보다 크거나 같은 값.</xref:System.Double> </xref:System.Double>           상한 정보에 대 한 설명을 참조 하세요. 이 값으로 해석 되는 [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] 측정 합니다. 문자열은 소수점이 하를 명시적으로 포함 하지 않아야 합니다. 예를 들어 값의 `1` 허용 됩니다.       *도* A *double* 단위 선언 문자열 중 하나에 의해 다음 위에서 설명한 대로 값: `px`, `in`, `cm`, `pt`합니다.       `px`(기본값)은 [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` 인치; 1in 96px = = `cm` 센티미터; 1cm==(96/2.54) px `pt` 은 포인트; 1pt==(96/72) px `Auto` 자동 크기 조정 동작을 사용 합니다.        설명 부분을 참조 하십시오.      <a name=&quot;dependencyPropertyInfo_Width&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.FrameworkElement.WidthProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.WidthProperty>"
  syntax:
    content: public double Width { get; set; }
    return:
      type: System.Double
      description: "요소의 너비에 [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]합니다. 기본값은 &lt;xref:System.Double?displayProperty=fullName&gt;합니다. 이 값은 0.0 보다 크거나 같은 이어야 합니다. 상한 정보에 대 한 설명을 참조 하세요."
  overload: System.Windows.FrameworkElement.Width*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.WidthProperty
  id: WidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: WidthProperty
  nameWithType: FrameworkElement.WidthProperty
  fullName: System.Windows.FrameworkElement.WidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.FrameworkElement.Width*>종속성 속성입니다.</xref:System.Windows.FrameworkElement.Width*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty WidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.UIElement
  isExternal: false
  name: System.Windows.UIElement
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.ResourceReferenceKeyNotFoundException
  parent: System.Windows
  isExternal: false
  name: ResourceReferenceKeyNotFoundException
  nameWithType: ResourceReferenceKeyNotFoundException
  fullName: System.Windows.ResourceReferenceKeyNotFoundException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Windows.FrameworkElement.#ctor
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FrameworkElement()
  nameWithType: FrameworkElement.FrameworkElement()
  fullName: System.Windows.FrameworkElement.FrameworkElement()
- uid: System.Windows.FrameworkElement.ActualHeight
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualHeight
  nameWithType: FrameworkElement.ActualHeight
  fullName: System.Windows.FrameworkElement.ActualHeight
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Windows.FrameworkElement.ActualHeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualHeightProperty
  nameWithType: FrameworkElement.ActualHeightProperty
  fullName: System.Windows.FrameworkElement.ActualHeightProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.FrameworkElement.ActualWidth
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualWidth
  nameWithType: FrameworkElement.ActualWidth
  fullName: System.Windows.FrameworkElement.ActualWidth
- uid: System.Windows.FrameworkElement.ActualWidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualWidthProperty
  nameWithType: FrameworkElement.ActualWidthProperty
  fullName: System.Windows.FrameworkElement.ActualWidthProperty
- uid: System.Windows.FrameworkElement.AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: AddLogicalChild(Object)
  nameWithType: FrameworkElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.AddLogicalChild(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.FrameworkElement.ApplyTemplate
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ApplyTemplate()
  nameWithType: FrameworkElement.ApplyTemplate()
  fullName: System.Windows.FrameworkElement.ApplyTemplate()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeCore(Rect)
  nameWithType: FrameworkElement.ArrangeCore(Rect)
  fullName: System.Windows.FrameworkElement.ArrangeCore(Rect)
- uid: System.Windows.Rect
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect
- uid: System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeOverride(Size)
  nameWithType: FrameworkElement.ArrangeOverride(Size)
  fullName: System.Windows.FrameworkElement.ArrangeOverride(Size)
- uid: System.Windows.Size
  parent: System.Windows
  isExternal: false
  name: Size
  nameWithType: Size
  fullName: System.Windows.Size
- uid: System.Windows.FrameworkElement.BeginInit
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginInit()
  nameWithType: FrameworkElement.BeginInit()
  fullName: System.Windows.FrameworkElement.BeginInit()
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard)
- uid: System.Windows.Media.Animation.Storyboard
  parent: System.Windows.Media.Animation
  isExternal: false
  name: Storyboard
  nameWithType: Storyboard
  fullName: System.Windows.Media.Animation.Storyboard
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
- uid: System.Windows.Media.Animation.HandoffBehavior
  parent: System.Windows.Media.Animation
  isExternal: false
  name: HandoffBehavior
  nameWithType: HandoffBehavior
  fullName: System.Windows.Media.Animation.HandoffBehavior
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
- uid: System.Windows.FrameworkElement.BindingGroup
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkElement.BindingGroup
  fullName: System.Windows.FrameworkElement.BindingGroup
- uid: System.Windows.Data.BindingGroup
  parent: System.Windows.Data
  isExternal: false
  name: BindingGroup
  nameWithType: BindingGroup
  fullName: System.Windows.Data.BindingGroup
- uid: System.Windows.FrameworkElement.BindingGroupProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BindingGroupProperty
  nameWithType: FrameworkElement.BindingGroupProperty
  fullName: System.Windows.FrameworkElement.BindingGroupProperty
- uid: System.Windows.FrameworkElement.BringIntoView
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BringIntoView()
  nameWithType: FrameworkElement.BringIntoView()
  fullName: System.Windows.FrameworkElement.BringIntoView()
- uid: System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BringIntoView(Rect)
  nameWithType: FrameworkElement.BringIntoView(Rect)
  fullName: System.Windows.FrameworkElement.BringIntoView(Rect)
- uid: System.Windows.FrameworkElement.ContextMenu
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkElement.ContextMenu
  fullName: System.Windows.FrameworkElement.ContextMenu
- uid: System.Windows.Controls.ContextMenu
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenu
  nameWithType: ContextMenu
  fullName: System.Windows.Controls.ContextMenu
- uid: System.Windows.FrameworkElement.ContextMenuClosing
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuClosing
  nameWithType: FrameworkElement.ContextMenuClosing
  fullName: System.Windows.FrameworkElement.ContextMenuClosing
- uid: System.Windows.Controls.ContextMenuEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventHandler
  nameWithType: ContextMenuEventHandler
  fullName: System.Windows.Controls.ContextMenuEventHandler
- uid: System.Windows.FrameworkElement.ContextMenuClosingEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuClosingEvent
  nameWithType: FrameworkElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkElement.ContextMenuClosingEvent
- uid: System.Windows.RoutedEvent
  parent: System.Windows
  isExternal: false
  name: RoutedEvent
  nameWithType: RoutedEvent
  fullName: System.Windows.RoutedEvent
- uid: System.Windows.FrameworkElement.ContextMenuOpening
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuOpening
  nameWithType: FrameworkElement.ContextMenuOpening
  fullName: System.Windows.FrameworkElement.ContextMenuOpening
- uid: System.Windows.FrameworkElement.ContextMenuOpeningEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkElement.ContextMenuOpeningEvent
- uid: System.Windows.FrameworkElement.ContextMenuProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuProperty
  nameWithType: FrameworkElement.ContextMenuProperty
  fullName: System.Windows.FrameworkElement.ContextMenuProperty
- uid: System.Windows.FrameworkElement.Cursor
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkElement.Cursor
  fullName: System.Windows.FrameworkElement.Cursor
- uid: System.Windows.Input.Cursor
  parent: System.Windows.Input
  isExternal: false
  name: Cursor
  nameWithType: Cursor
  fullName: System.Windows.Input.Cursor
- uid: System.Windows.FrameworkElement.CursorProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: CursorProperty
  nameWithType: FrameworkElement.CursorProperty
  fullName: System.Windows.FrameworkElement.CursorProperty
- uid: System.Windows.FrameworkElement.DataContext
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkElement.DataContext
  fullName: System.Windows.FrameworkElement.DataContext
- uid: System.Windows.FrameworkElement.DataContextChanged
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContextChanged
  nameWithType: FrameworkElement.DataContextChanged
  fullName: System.Windows.FrameworkElement.DataContextChanged
- uid: System.Windows.DependencyPropertyChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventHandler
  nameWithType: DependencyPropertyChangedEventHandler
  fullName: System.Windows.DependencyPropertyChangedEventHandler
- uid: System.Windows.FrameworkElement.DataContextProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContextProperty
  nameWithType: FrameworkElement.DataContextProperty
  fullName: System.Windows.FrameworkElement.DataContextProperty
- uid: System.Windows.FrameworkElement.DefaultStyleKey
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkElement.DefaultStyleKey
  fullName: System.Windows.FrameworkElement.DefaultStyleKey
- uid: System.Windows.FrameworkElement.DefaultStyleKeyProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkElement.DefaultStyleKeyProperty
- uid: System.Windows.FrameworkElement.EndInit
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: EndInit()
  nameWithType: FrameworkElement.EndInit()
  fullName: System.Windows.FrameworkElement.EndInit()
- uid: System.Windows.FrameworkElement.FindName(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindName(String)
  nameWithType: FrameworkElement.FindName(String)
  fullName: System.Windows.FrameworkElement.FindName(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.FrameworkElement.FindResource(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindResource(Object)
  nameWithType: FrameworkElement.FindResource(Object)
  fullName: System.Windows.FrameworkElement.FindResource(Object)
- uid: System.Windows.FrameworkElement.FlowDirection
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FlowDirection
  nameWithType: FrameworkElement.FlowDirection
  fullName: System.Windows.FrameworkElement.FlowDirection
- uid: System.Windows.FlowDirection
  parent: System.Windows
  isExternal: false
  name: FlowDirection
  nameWithType: FlowDirection
  fullName: System.Windows.FlowDirection
- uid: System.Windows.FrameworkElement.FlowDirectionProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FlowDirectionProperty
  nameWithType: FrameworkElement.FlowDirectionProperty
  fullName: System.Windows.FrameworkElement.FlowDirectionProperty
- uid: System.Windows.FrameworkElement.FocusVisualStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkElement.FocusVisualStyle
  fullName: System.Windows.FrameworkElement.FocusVisualStyle
- uid: System.Windows.Style
  parent: System.Windows
  isExternal: false
  name: Style
  nameWithType: Style
  fullName: System.Windows.Style
- uid: System.Windows.FrameworkElement.FocusVisualStyleProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FocusVisualStyleProperty
  nameWithType: FrameworkElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkElement.FocusVisualStyleProperty
- uid: System.Windows.FrameworkElement.ForceCursor
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkElement.ForceCursor
  fullName: System.Windows.FrameworkElement.ForceCursor
- uid: System.Windows.FrameworkElement.ForceCursorProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ForceCursorProperty
  nameWithType: FrameworkElement.ForceCursorProperty
  fullName: System.Windows.FrameworkElement.ForceCursorProperty
- uid: System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkElement.GetBindingExpression(DependencyProperty)
- uid: System.Windows.Data.BindingExpression
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpression
  nameWithType: BindingExpression
  fullName: System.Windows.Data.BindingExpression
- uid: System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetFlowDirection(DependencyObject)
  nameWithType: FrameworkElement.GetFlowDirection(DependencyObject)
  fullName: System.Windows.FrameworkElement.GetFlowDirection(DependencyObject)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetLayoutClip(Size)
  nameWithType: FrameworkElement.GetLayoutClip(Size)
  fullName: System.Windows.FrameworkElement.GetLayoutClip(Size)
- uid: System.Windows.Media.Geometry
  parent: System.Windows.Media
  isExternal: false
  name: Geometry
  nameWithType: Geometry
  fullName: System.Windows.Media.Geometry
- uid: System.Windows.FrameworkElement.GetTemplateChild(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetTemplateChild(String)
  nameWithType: FrameworkElement.GetTemplateChild(String)
  fullName: System.Windows.FrameworkElement.GetTemplateChild(String)
- uid: System.Windows.FrameworkElement.GetUIParentCore
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetUIParentCore()
  nameWithType: FrameworkElement.GetUIParentCore()
  fullName: System.Windows.FrameworkElement.GetUIParentCore()
- uid: System.Windows.FrameworkElement.GetVisualChild(System.Int32)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetVisualChild(Int32)
  nameWithType: FrameworkElement.GetVisualChild(Int32)
  fullName: System.Windows.FrameworkElement.GetVisualChild(Int32)
- uid: System.Windows.Media.Visual
  parent: System.Windows.Media
  isExternal: false
  name: Visual
  nameWithType: Visual
  fullName: System.Windows.Media.Visual
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.FrameworkElement.Height
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Height
  nameWithType: FrameworkElement.Height
  fullName: System.Windows.FrameworkElement.Height
- uid: System.Windows.FrameworkElement.HeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HeightProperty
  nameWithType: FrameworkElement.HeightProperty
  fullName: System.Windows.FrameworkElement.HeightProperty
- uid: System.Windows.FrameworkElement.HorizontalAlignment
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HorizontalAlignment
  nameWithType: FrameworkElement.HorizontalAlignment
  fullName: System.Windows.FrameworkElement.HorizontalAlignment
- uid: System.Windows.HorizontalAlignment
  parent: System.Windows
  isExternal: false
  name: HorizontalAlignment
  nameWithType: HorizontalAlignment
  fullName: System.Windows.HorizontalAlignment
- uid: System.Windows.FrameworkElement.HorizontalAlignmentProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HorizontalAlignmentProperty
  nameWithType: FrameworkElement.HorizontalAlignmentProperty
  fullName: System.Windows.FrameworkElement.HorizontalAlignmentProperty
- uid: System.Windows.FrameworkElement.InheritanceBehavior
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InheritanceBehavior
  nameWithType: FrameworkElement.InheritanceBehavior
  fullName: System.Windows.FrameworkElement.InheritanceBehavior
- uid: System.Windows.InheritanceBehavior
  parent: System.Windows
  isExternal: false
  name: InheritanceBehavior
  nameWithType: InheritanceBehavior
  fullName: System.Windows.InheritanceBehavior
- uid: System.Windows.FrameworkElement.Initialized
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Initialized
  nameWithType: FrameworkElement.Initialized
  fullName: System.Windows.FrameworkElement.Initialized
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.FrameworkElement.InputScope
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkElement.InputScope
  fullName: System.Windows.FrameworkElement.InputScope
- uid: System.Windows.Input.InputScope
  parent: System.Windows.Input
  isExternal: false
  name: InputScope
  nameWithType: InputScope
  fullName: System.Windows.Input.InputScope
- uid: System.Windows.FrameworkElement.InputScopeProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InputScopeProperty
  nameWithType: FrameworkElement.InputScopeProperty
  fullName: System.Windows.FrameworkElement.InputScopeProperty
- uid: System.Windows.FrameworkElement.IsInitialized
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkElement.IsInitialized
  fullName: System.Windows.FrameworkElement.IsInitialized
- uid: System.Windows.FrameworkElement.IsLoaded
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkElement.IsLoaded
  fullName: System.Windows.FrameworkElement.IsLoaded
- uid: System.Windows.FrameworkElement.Language
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Language
  nameWithType: FrameworkElement.Language
  fullName: System.Windows.FrameworkElement.Language
- uid: System.Windows.Markup.XmlLanguage
  parent: System.Windows.Markup
  isExternal: false
  name: XmlLanguage
  nameWithType: XmlLanguage
  fullName: System.Windows.Markup.XmlLanguage
- uid: System.Windows.FrameworkElement.LanguageProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LanguageProperty
  nameWithType: FrameworkElement.LanguageProperty
  fullName: System.Windows.FrameworkElement.LanguageProperty
- uid: System.Windows.FrameworkElement.LayoutTransform
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LayoutTransform
  nameWithType: FrameworkElement.LayoutTransform
  fullName: System.Windows.FrameworkElement.LayoutTransform
- uid: System.Windows.Media.Transform
  parent: System.Windows.Media
  isExternal: false
  name: Transform
  nameWithType: Transform
  fullName: System.Windows.Media.Transform
- uid: System.Windows.FrameworkElement.LayoutTransformProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LayoutTransformProperty
  nameWithType: FrameworkElement.LayoutTransformProperty
  fullName: System.Windows.FrameworkElement.LayoutTransformProperty
- uid: System.Windows.FrameworkElement.Loaded
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Loaded
  nameWithType: FrameworkElement.Loaded
  fullName: System.Windows.FrameworkElement.Loaded
- uid: System.Windows.RoutedEventHandler
  parent: System.Windows
  isExternal: false
  name: RoutedEventHandler
  nameWithType: RoutedEventHandler
  fullName: System.Windows.RoutedEventHandler
- uid: System.Windows.FrameworkElement.LoadedEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LoadedEvent
  nameWithType: FrameworkElement.LoadedEvent
  fullName: System.Windows.FrameworkElement.LoadedEvent
- uid: System.Windows.FrameworkElement.LogicalChildren
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkElement.LogicalChildren
  fullName: System.Windows.FrameworkElement.LogicalChildren
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Windows.FrameworkElement.Margin
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Margin
  nameWithType: FrameworkElement.Margin
  fullName: System.Windows.FrameworkElement.Margin
- uid: System.Windows.Thickness
  parent: System.Windows
  isExternal: false
  name: Thickness
  nameWithType: Thickness
  fullName: System.Windows.Thickness
- uid: System.Windows.FrameworkElement.MarginProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MarginProperty
  nameWithType: FrameworkElement.MarginProperty
  fullName: System.Windows.FrameworkElement.MarginProperty
- uid: System.Windows.FrameworkElement.MaxHeight
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxHeight
  nameWithType: FrameworkElement.MaxHeight
  fullName: System.Windows.FrameworkElement.MaxHeight
- uid: System.Windows.FrameworkElement.MaxHeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxHeightProperty
  nameWithType: FrameworkElement.MaxHeightProperty
  fullName: System.Windows.FrameworkElement.MaxHeightProperty
- uid: System.Windows.FrameworkElement.MaxWidth
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxWidth
  nameWithType: FrameworkElement.MaxWidth
  fullName: System.Windows.FrameworkElement.MaxWidth
- uid: System.Windows.FrameworkElement.MaxWidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxWidthProperty
  nameWithType: FrameworkElement.MaxWidthProperty
  fullName: System.Windows.FrameworkElement.MaxWidthProperty
- uid: System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureCore(Size)
  nameWithType: FrameworkElement.MeasureCore(Size)
  fullName: System.Windows.FrameworkElement.MeasureCore(Size)
- uid: System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureOverride(Size)
  nameWithType: FrameworkElement.MeasureOverride(Size)
  fullName: System.Windows.FrameworkElement.MeasureOverride(Size)
- uid: System.Windows.FrameworkElement.MinHeight
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinHeight
  nameWithType: FrameworkElement.MinHeight
  fullName: System.Windows.FrameworkElement.MinHeight
- uid: System.Windows.FrameworkElement.MinHeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinHeightProperty
  nameWithType: FrameworkElement.MinHeightProperty
  fullName: System.Windows.FrameworkElement.MinHeightProperty
- uid: System.Windows.FrameworkElement.MinWidth
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinWidth
  nameWithType: FrameworkElement.MinWidth
  fullName: System.Windows.FrameworkElement.MinWidth
- uid: System.Windows.FrameworkElement.MinWidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinWidthProperty
  nameWithType: FrameworkElement.MinWidthProperty
  fullName: System.Windows.FrameworkElement.MinWidthProperty
- uid: System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkElement.MoveFocus(TraversalRequest)
- uid: System.Windows.Input.TraversalRequest
  parent: System.Windows.Input
  isExternal: false
  name: TraversalRequest
  nameWithType: TraversalRequest
  fullName: System.Windows.Input.TraversalRequest
- uid: System.Windows.FrameworkElement.Name
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Name
  nameWithType: FrameworkElement.Name
  fullName: System.Windows.FrameworkElement.Name
- uid: System.Windows.FrameworkElement.NameProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: NameProperty
  nameWithType: FrameworkElement.NameProperty
  fullName: System.Windows.FrameworkElement.NameProperty
- uid: System.Windows.FrameworkElement.OnApplyTemplate
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnApplyTemplate()
  nameWithType: FrameworkElement.OnApplyTemplate()
  fullName: System.Windows.FrameworkElement.OnApplyTemplate()
- uid: System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
- uid: System.Windows.Controls.ContextMenuEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventArgs
  nameWithType: ContextMenuEventArgs
  fullName: System.Windows.Controls.ContextMenuEventArgs
- uid: System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
- uid: System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkElement.OnGotFocus(RoutedEventArgs)
- uid: System.Windows.RoutedEventArgs
  parent: System.Windows
  isExternal: false
  name: RoutedEventArgs
  nameWithType: RoutedEventArgs
  fullName: System.Windows.RoutedEventArgs
- uid: System.Windows.FrameworkElement.OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkElement.OnInitialized(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.DependencyPropertyChangedEventArgs
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventArgs
  nameWithType: DependencyPropertyChangedEventArgs
  fullName: System.Windows.DependencyPropertyChangedEventArgs
- uid: System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnRenderSizeChanged(SizeChangedInfo)
  nameWithType: FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
  fullName: System.Windows.FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
- uid: System.Windows.SizeChangedInfo
  parent: System.Windows
  isExternal: false
  name: SizeChangedInfo
  nameWithType: SizeChangedInfo
  fullName: System.Windows.SizeChangedInfo
- uid: System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkElement.OnStyleChanged(Style,Style)
- uid: System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
- uid: System.Windows.Controls.ToolTipEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventArgs
  nameWithType: ToolTipEventArgs
  fullName: System.Windows.Controls.ToolTipEventArgs
- uid: System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
- uid: System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnVisualParentChanged(DependencyObject)
  nameWithType: FrameworkElement.OnVisualParentChanged(DependencyObject)
  fullName: System.Windows.FrameworkElement.OnVisualParentChanged(DependencyObject)
- uid: System.Windows.FrameworkElement.OverridesDefaultStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
- uid: System.Windows.FrameworkElement.Parent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkElement.Parent
  fullName: System.Windows.FrameworkElement.Parent
- uid: System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ParentLayoutInvalidated(UIElement)
  nameWithType: FrameworkElement.ParentLayoutInvalidated(UIElement)
  fullName: System.Windows.FrameworkElement.ParentLayoutInvalidated(UIElement)
- uid: System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkElement.PredictFocus(FocusNavigationDirection)
- uid: System.Windows.Input.FocusNavigationDirection
  parent: System.Windows.Input
  isExternal: false
  name: FocusNavigationDirection
  nameWithType: FocusNavigationDirection
  fullName: System.Windows.Input.FocusNavigationDirection
- uid: System.Windows.FrameworkElement.RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RegisterName(String,Object)
  nameWithType: FrameworkElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkElement.RegisterName(String,Object)
- uid: System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.RemoveLogicalChild(Object)
- uid: System.Windows.FrameworkElement.RequestBringIntoView
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RequestBringIntoView
  nameWithType: FrameworkElement.RequestBringIntoView
  fullName: System.Windows.FrameworkElement.RequestBringIntoView
- uid: System.Windows.RequestBringIntoViewEventHandler
  parent: System.Windows
  isExternal: false
  name: RequestBringIntoViewEventHandler
  nameWithType: RequestBringIntoViewEventHandler
  fullName: System.Windows.RequestBringIntoViewEventHandler
- uid: System.Windows.FrameworkElement.RequestBringIntoViewEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RequestBringIntoViewEvent
  nameWithType: FrameworkElement.RequestBringIntoViewEvent
  fullName: System.Windows.FrameworkElement.RequestBringIntoViewEvent
- uid: System.Windows.FrameworkElement.Resources
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkElement.Resources
  fullName: System.Windows.FrameworkElement.Resources
- uid: System.Windows.ResourceDictionary
  parent: System.Windows
  isExternal: false
  name: ResourceDictionary
  nameWithType: ResourceDictionary
  fullName: System.Windows.ResourceDictionary
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,String)
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,BindingBase)
- uid: System.Windows.Data.BindingExpressionBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpressionBase
  nameWithType: BindingExpressionBase
  fullName: System.Windows.Data.BindingExpressionBase
- uid: System.Windows.Data.BindingBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingBase
  nameWithType: BindingBase
  fullName: System.Windows.Data.BindingBase
- uid: System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetFlowDirection(DependencyObject,FlowDirection)
  nameWithType: FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
  fullName: System.Windows.FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
- uid: System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkElement.SetResourceReference(DependencyProperty,Object)
- uid: System.Windows.FrameworkElement.ShouldSerializeResources
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeResources()
  nameWithType: FrameworkElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkElement.ShouldSerializeResources()
- uid: System.Windows.FrameworkElement.ShouldSerializeStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeStyle()
  nameWithType: FrameworkElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkElement.ShouldSerializeStyle()
- uid: System.Windows.FrameworkElement.ShouldSerializeTriggers
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeTriggers()
  nameWithType: FrameworkElement.ShouldSerializeTriggers()
  fullName: System.Windows.FrameworkElement.ShouldSerializeTriggers()
- uid: System.Windows.FrameworkElement.SizeChanged
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SizeChanged
  nameWithType: FrameworkElement.SizeChanged
  fullName: System.Windows.FrameworkElement.SizeChanged
- uid: System.Windows.SizeChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: SizeChangedEventHandler
  nameWithType: SizeChangedEventHandler
  fullName: System.Windows.SizeChangedEventHandler
- uid: System.Windows.FrameworkElement.SizeChangedEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SizeChangedEvent
  nameWithType: FrameworkElement.SizeChangedEvent
  fullName: System.Windows.FrameworkElement.SizeChangedEvent
- uid: System.Windows.FrameworkElement.SourceUpdated
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SourceUpdated
  nameWithType: FrameworkElement.SourceUpdated
  fullName: System.Windows.FrameworkElement.SourceUpdated
- uid: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<DataTransferEventArgs>
  nameWithType: EventHandler<DataTransferEventArgs>
  fullName: System.EventHandler<System.Windows.Data.DataTransferEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Data.DataTransferEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Data.DataTransferEventArgs
    name: DataTransferEventArgs
    nameWithType: DataTransferEventArgs
    fullName: DataTransferEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.FrameworkElement.Style
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Style
  nameWithType: FrameworkElement.Style
  fullName: System.Windows.FrameworkElement.Style
- uid: System.Windows.FrameworkElement.StyleProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: StyleProperty
  nameWithType: FrameworkElement.StyleProperty
  fullName: System.Windows.FrameworkElement.StyleProperty
- uid: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
- uid: System.Windows.FrameworkElement.Tag
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkElement.Tag
  fullName: System.Windows.FrameworkElement.Tag
- uid: System.Windows.FrameworkElement.TagProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TagProperty
  nameWithType: FrameworkElement.TagProperty
  fullName: System.Windows.FrameworkElement.TagProperty
- uid: System.Windows.FrameworkElement.TargetUpdated
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TargetUpdated
  nameWithType: FrameworkElement.TargetUpdated
  fullName: System.Windows.FrameworkElement.TargetUpdated
- uid: System.Windows.FrameworkElement.TemplatedParent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkElement.TemplatedParent
  fullName: System.Windows.FrameworkElement.TemplatedParent
- uid: System.Windows.FrameworkElement.ToolTip
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkElement.ToolTip
  fullName: System.Windows.FrameworkElement.ToolTip
- uid: System.Windows.FrameworkElement.ToolTipClosing
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipClosing
  nameWithType: FrameworkElement.ToolTipClosing
  fullName: System.Windows.FrameworkElement.ToolTipClosing
- uid: System.Windows.Controls.ToolTipEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventHandler
  nameWithType: ToolTipEventHandler
  fullName: System.Windows.Controls.ToolTipEventHandler
- uid: System.Windows.FrameworkElement.ToolTipClosingEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipClosingEvent
  nameWithType: FrameworkElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkElement.ToolTipClosingEvent
- uid: System.Windows.FrameworkElement.ToolTipOpening
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipOpening
  nameWithType: FrameworkElement.ToolTipOpening
  fullName: System.Windows.FrameworkElement.ToolTipOpening
- uid: System.Windows.FrameworkElement.ToolTipOpeningEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipOpeningEvent
  nameWithType: FrameworkElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkElement.ToolTipOpeningEvent
- uid: System.Windows.FrameworkElement.ToolTipProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipProperty
  nameWithType: FrameworkElement.ToolTipProperty
  fullName: System.Windows.FrameworkElement.ToolTipProperty
- uid: System.Windows.FrameworkElement.Triggers
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Triggers
  nameWithType: FrameworkElement.Triggers
  fullName: System.Windows.FrameworkElement.Triggers
- uid: System.Windows.TriggerCollection
  parent: System.Windows
  isExternal: false
  name: TriggerCollection
  nameWithType: TriggerCollection
  fullName: System.Windows.TriggerCollection
- uid: System.Windows.FrameworkElement.TryFindResource(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TryFindResource(Object)
  nameWithType: FrameworkElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkElement.TryFindResource(Object)
- uid: System.Windows.FrameworkElement.Unloaded
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Unloaded
  nameWithType: FrameworkElement.Unloaded
  fullName: System.Windows.FrameworkElement.Unloaded
- uid: System.Windows.FrameworkElement.UnloadedEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UnloadedEvent
  nameWithType: FrameworkElement.UnloadedEvent
  fullName: System.Windows.FrameworkElement.UnloadedEvent
- uid: System.Windows.FrameworkElement.UnregisterName(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UnregisterName(String)
  nameWithType: FrameworkElement.UnregisterName(String)
  fullName: System.Windows.FrameworkElement.UnregisterName(String)
- uid: System.Windows.FrameworkElement.UpdateDefaultStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UpdateDefaultStyle()
  nameWithType: FrameworkElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkElement.UpdateDefaultStyle()
- uid: System.Windows.FrameworkElement.UseLayoutRounding
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UseLayoutRounding
  nameWithType: FrameworkElement.UseLayoutRounding
  fullName: System.Windows.FrameworkElement.UseLayoutRounding
- uid: System.Windows.FrameworkElement.UseLayoutRoundingProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UseLayoutRoundingProperty
  nameWithType: FrameworkElement.UseLayoutRoundingProperty
  fullName: System.Windows.FrameworkElement.UseLayoutRoundingProperty
- uid: System.Windows.FrameworkElement.VerticalAlignment
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VerticalAlignment
  nameWithType: FrameworkElement.VerticalAlignment
  fullName: System.Windows.FrameworkElement.VerticalAlignment
- uid: System.Windows.VerticalAlignment
  parent: System.Windows
  isExternal: false
  name: VerticalAlignment
  nameWithType: VerticalAlignment
  fullName: System.Windows.VerticalAlignment
- uid: System.Windows.FrameworkElement.VerticalAlignmentProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VerticalAlignmentProperty
  nameWithType: FrameworkElement.VerticalAlignmentProperty
  fullName: System.Windows.FrameworkElement.VerticalAlignmentProperty
- uid: System.Windows.FrameworkElement.VisualChildrenCount
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VisualChildrenCount
  nameWithType: FrameworkElement.VisualChildrenCount
  fullName: System.Windows.FrameworkElement.VisualChildrenCount
- uid: System.Windows.FrameworkElement.Width
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Width
  nameWithType: FrameworkElement.Width
  fullName: System.Windows.FrameworkElement.Width
- uid: System.Windows.FrameworkElement.WidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: WidthProperty
  nameWithType: FrameworkElement.WidthProperty
  fullName: System.Windows.FrameworkElement.WidthProperty
- uid: System.Windows.FrameworkElement.#ctor*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FrameworkElement
  nameWithType: FrameworkElement.FrameworkElement
- uid: System.Windows.FrameworkElement.ActualHeight*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualHeight
  nameWithType: FrameworkElement.ActualHeight
- uid: System.Windows.FrameworkElement.ActualWidth*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualWidth
  nameWithType: FrameworkElement.ActualWidth
- uid: System.Windows.FrameworkElement.AddLogicalChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: AddLogicalChild
  nameWithType: FrameworkElement.AddLogicalChild
- uid: System.Windows.FrameworkElement.ApplyTemplate*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ApplyTemplate
  nameWithType: FrameworkElement.ApplyTemplate
- uid: System.Windows.FrameworkElement.ArrangeCore*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeCore
  nameWithType: FrameworkElement.ArrangeCore
- uid: System.Windows.FrameworkElement.ArrangeOverride*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeOverride
  nameWithType: FrameworkElement.ArrangeOverride
- uid: System.Windows.FrameworkElement.BeginInit*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginInit
  nameWithType: FrameworkElement.BeginInit
- uid: System.Windows.FrameworkElement.BeginStoryboard*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard
  nameWithType: FrameworkElement.BeginStoryboard
- uid: System.Windows.FrameworkElement.BindingGroup*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkElement.BindingGroup
- uid: System.Windows.FrameworkElement.BringIntoView*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BringIntoView
  nameWithType: FrameworkElement.BringIntoView
- uid: System.Windows.FrameworkElement.ContextMenu*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkElement.ContextMenu
- uid: System.Windows.FrameworkElement.Cursor*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkElement.Cursor
- uid: System.Windows.FrameworkElement.DataContext*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkElement.DataContext
- uid: System.Windows.FrameworkElement.DefaultStyleKey*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkElement.DefaultStyleKey
- uid: System.Windows.FrameworkElement.EndInit*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: EndInit
  nameWithType: FrameworkElement.EndInit
- uid: System.Windows.FrameworkElement.FindName*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindName
  nameWithType: FrameworkElement.FindName
- uid: System.Windows.FrameworkElement.FindResource*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindResource
  nameWithType: FrameworkElement.FindResource
- uid: System.Windows.FrameworkElement.FlowDirection*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FlowDirection
  nameWithType: FrameworkElement.FlowDirection
- uid: System.Windows.FrameworkElement.FocusVisualStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkElement.FocusVisualStyle
- uid: System.Windows.FrameworkElement.ForceCursor*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkElement.ForceCursor
- uid: System.Windows.FrameworkElement.GetBindingExpression*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetBindingExpression
  nameWithType: FrameworkElement.GetBindingExpression
- uid: System.Windows.FrameworkElement.GetFlowDirection*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetFlowDirection
  nameWithType: FrameworkElement.GetFlowDirection
- uid: System.Windows.FrameworkElement.GetLayoutClip*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetLayoutClip
  nameWithType: FrameworkElement.GetLayoutClip
- uid: System.Windows.FrameworkElement.GetTemplateChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetTemplateChild
  nameWithType: FrameworkElement.GetTemplateChild
- uid: System.Windows.FrameworkElement.GetUIParentCore*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetUIParentCore
  nameWithType: FrameworkElement.GetUIParentCore
- uid: System.Windows.FrameworkElement.GetVisualChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetVisualChild
  nameWithType: FrameworkElement.GetVisualChild
- uid: System.Windows.FrameworkElement.Height*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Height
  nameWithType: FrameworkElement.Height
- uid: System.Windows.FrameworkElement.HorizontalAlignment*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HorizontalAlignment
  nameWithType: FrameworkElement.HorizontalAlignment
- uid: System.Windows.FrameworkElement.InheritanceBehavior*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InheritanceBehavior
  nameWithType: FrameworkElement.InheritanceBehavior
- uid: System.Windows.FrameworkElement.InputScope*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkElement.InputScope
- uid: System.Windows.FrameworkElement.IsInitialized*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkElement.IsInitialized
- uid: System.Windows.FrameworkElement.IsLoaded*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkElement.IsLoaded
- uid: System.Windows.FrameworkElement.Language*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Language
  nameWithType: FrameworkElement.Language
- uid: System.Windows.FrameworkElement.LayoutTransform*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LayoutTransform
  nameWithType: FrameworkElement.LayoutTransform
- uid: System.Windows.FrameworkElement.LogicalChildren*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkElement.LogicalChildren
- uid: System.Windows.FrameworkElement.Margin*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Margin
  nameWithType: FrameworkElement.Margin
- uid: System.Windows.FrameworkElement.MaxHeight*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxHeight
  nameWithType: FrameworkElement.MaxHeight
- uid: System.Windows.FrameworkElement.MaxWidth*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxWidth
  nameWithType: FrameworkElement.MaxWidth
- uid: System.Windows.FrameworkElement.MeasureCore*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureCore
  nameWithType: FrameworkElement.MeasureCore
- uid: System.Windows.FrameworkElement.MeasureOverride*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureOverride
  nameWithType: FrameworkElement.MeasureOverride
- uid: System.Windows.FrameworkElement.MinHeight*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinHeight
  nameWithType: FrameworkElement.MinHeight
- uid: System.Windows.FrameworkElement.MinWidth*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinWidth
  nameWithType: FrameworkElement.MinWidth
- uid: System.Windows.FrameworkElement.MoveFocus*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MoveFocus
  nameWithType: FrameworkElement.MoveFocus
- uid: System.Windows.FrameworkElement.Name*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Name
  nameWithType: FrameworkElement.Name
- uid: System.Windows.FrameworkElement.OnApplyTemplate*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnApplyTemplate
  nameWithType: FrameworkElement.OnApplyTemplate
- uid: System.Windows.FrameworkElement.OnContextMenuClosing*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuClosing
  nameWithType: FrameworkElement.OnContextMenuClosing
- uid: System.Windows.FrameworkElement.OnContextMenuOpening*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuOpening
  nameWithType: FrameworkElement.OnContextMenuOpening
- uid: System.Windows.FrameworkElement.OnGotFocus*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnGotFocus
  nameWithType: FrameworkElement.OnGotFocus
- uid: System.Windows.FrameworkElement.OnInitialized*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnInitialized
  nameWithType: FrameworkElement.OnInitialized
- uid: System.Windows.FrameworkElement.OnPropertyChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnPropertyChanged
  nameWithType: FrameworkElement.OnPropertyChanged
- uid: System.Windows.FrameworkElement.OnRenderSizeChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnRenderSizeChanged
  nameWithType: FrameworkElement.OnRenderSizeChanged
- uid: System.Windows.FrameworkElement.OnStyleChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnStyleChanged
  nameWithType: FrameworkElement.OnStyleChanged
- uid: System.Windows.FrameworkElement.OnToolTipClosing*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipClosing
  nameWithType: FrameworkElement.OnToolTipClosing
- uid: System.Windows.FrameworkElement.OnToolTipOpening*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipOpening
  nameWithType: FrameworkElement.OnToolTipOpening
- uid: System.Windows.FrameworkElement.OnVisualParentChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnVisualParentChanged
  nameWithType: FrameworkElement.OnVisualParentChanged
- uid: System.Windows.FrameworkElement.OverridesDefaultStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkElement.Parent*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkElement.Parent
- uid: System.Windows.FrameworkElement.ParentLayoutInvalidated*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ParentLayoutInvalidated
  nameWithType: FrameworkElement.ParentLayoutInvalidated
- uid: System.Windows.FrameworkElement.PredictFocus*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: PredictFocus
  nameWithType: FrameworkElement.PredictFocus
- uid: System.Windows.FrameworkElement.RegisterName*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RegisterName
  nameWithType: FrameworkElement.RegisterName
- uid: System.Windows.FrameworkElement.RemoveLogicalChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RemoveLogicalChild
  nameWithType: FrameworkElement.RemoveLogicalChild
- uid: System.Windows.FrameworkElement.Resources*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkElement.Resources
- uid: System.Windows.FrameworkElement.SetBinding*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetBinding
  nameWithType: FrameworkElement.SetBinding
- uid: System.Windows.FrameworkElement.SetFlowDirection*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetFlowDirection
  nameWithType: FrameworkElement.SetFlowDirection
- uid: System.Windows.FrameworkElement.SetResourceReference*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetResourceReference
  nameWithType: FrameworkElement.SetResourceReference
- uid: System.Windows.FrameworkElement.ShouldSerializeResources*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeResources
  nameWithType: FrameworkElement.ShouldSerializeResources
- uid: System.Windows.FrameworkElement.ShouldSerializeStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeStyle
  nameWithType: FrameworkElement.ShouldSerializeStyle
- uid: System.Windows.FrameworkElement.ShouldSerializeTriggers*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeTriggers
  nameWithType: FrameworkElement.ShouldSerializeTriggers
- uid: System.Windows.FrameworkElement.Style*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Style
  nameWithType: FrameworkElement.Style
- uid: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
  nameWithType: FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
- uid: System.Windows.FrameworkElement.Tag*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkElement.Tag
- uid: System.Windows.FrameworkElement.TemplatedParent*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkElement.TemplatedParent
- uid: System.Windows.FrameworkElement.ToolTip*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkElement.ToolTip
- uid: System.Windows.FrameworkElement.Triggers*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Triggers
  nameWithType: FrameworkElement.Triggers
- uid: System.Windows.FrameworkElement.TryFindResource*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TryFindResource
  nameWithType: FrameworkElement.TryFindResource
- uid: System.Windows.FrameworkElement.UnregisterName*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UnregisterName
  nameWithType: FrameworkElement.UnregisterName
- uid: System.Windows.FrameworkElement.UpdateDefaultStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UpdateDefaultStyle
  nameWithType: FrameworkElement.UpdateDefaultStyle
- uid: System.Windows.FrameworkElement.UseLayoutRounding*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UseLayoutRounding
  nameWithType: FrameworkElement.UseLayoutRounding
- uid: System.Windows.FrameworkElement.VerticalAlignment*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VerticalAlignment
  nameWithType: FrameworkElement.VerticalAlignment
- uid: System.Windows.FrameworkElement.VisualChildrenCount*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VisualChildrenCount
  nameWithType: FrameworkElement.VisualChildrenCount
- uid: System.Windows.FrameworkElement.Width*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Width
  nameWithType: FrameworkElement.Width
