### YamlMime:ManagedReference
items:
- uid: System.Security.AccessControl.MutexSecurity
  id: MutexSecurity
  children:
  - System.Security.AccessControl.MutexSecurity.#ctor
  - System.Security.AccessControl.MutexSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.MutexSecurity.AccessRightType
  - System.Security.AccessControl.MutexSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  - System.Security.AccessControl.MutexSecurity.AccessRuleType
  - System.Security.AccessControl.MutexSecurity.AddAccessRule(System.Security.AccessControl.MutexAccessRule)
  - System.Security.AccessControl.MutexSecurity.AddAuditRule(System.Security.AccessControl.MutexAuditRule)
  - System.Security.AccessControl.MutexSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  - System.Security.AccessControl.MutexSecurity.AuditRuleType
  - System.Security.AccessControl.MutexSecurity.RemoveAccessRule(System.Security.AccessControl.MutexAccessRule)
  - System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll(System.Security.AccessControl.MutexAccessRule)
  - System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.MutexAccessRule)
  - System.Security.AccessControl.MutexSecurity.RemoveAuditRule(System.Security.AccessControl.MutexAuditRule)
  - System.Security.AccessControl.MutexSecurity.RemoveAuditRuleAll(System.Security.AccessControl.MutexAuditRule)
  - System.Security.AccessControl.MutexSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.MutexAuditRule)
  - System.Security.AccessControl.MutexSecurity.ResetAccessRule(System.Security.AccessControl.MutexAccessRule)
  - System.Security.AccessControl.MutexSecurity.SetAccessRule(System.Security.AccessControl.MutexAccessRule)
  - System.Security.AccessControl.MutexSecurity.SetAuditRule(System.Security.AccessControl.MutexAuditRule)
  langs:
  - csharp
  name: MutexSecurity
  nameWithType: MutexSecurity
  fullName: System.Security.AccessControl.MutexSecurity
  type: Class
  summary: "명명 된 뮤텍스에 대 한 Windows 액세스 제어 보안을 나타냅니다. 이 클래스는 상속 될 수 없습니다."
  remarks: "MutexSecurity 개체 명명 된 시스템 뮤텍스에 대 한 액세스 권한을 지정 하 고 액세스 시도 감사 하는 방법을 지정 합니다. 뮤텍스에 액세스 권한을 규칙 각 액세스 규칙으로 표시 됩니다는 <xref:System.Security.AccessControl.MutexAccessRule>개체입니다.</xref:System.Security.AccessControl.MutexAccessRule> 각 감사 규칙으로 표시 됩니다는 <xref:System.Security.AccessControl.MutexAuditRule>개체입니다.</xref:System.Security.AccessControl.MutexAuditRule>       각 보안 개체에 최대 한 임의 액세스 제어 목록 (DACL)가 최대 하나의 시스템 액세스 제어 목록 SACL ()는 액세스 시도 감사를 지정 하 고 보안된 개체 액세스를 제어 하는 기본 Windows 보안 시스템을 미러링합니다. DACL과 SACL는 액세스 및 사용자 및 그룹에 대 한 감사를 지정 하는 액세스 제어 항목 (ACE)의 목록을 정렬 하는 데 사용 됩니다. A <xref:System.Security.AccessControl.MutexAccessRule>또는 <xref:System.Security.AccessControl.MutexAuditRule>개체는 둘 이상의 ACE를 나타낼 수 있습니다.</xref:System.Security.AccessControl.MutexAuditRule> </xref:System.Security.AccessControl.MutexAccessRule>      > [!NOTE] > A <xref:System.Threading.Mutex>로컬 뮤텍스가 또는 명명된 된 시스템 뮤텍스 개체를 나타낼 수 있습니다.</xref:System.Threading.Mutex> Windows 액세스 제어 보안은 명명 된 시스템 뮤텍스에 대해서만 의미가 있습니다.       MutexSecurity <xref:System.Security.AccessControl.MutexAccessRule>, 및 <xref:System.Security.AccessControl.MutexAuditRule>클래스 Acl 및 Ace의 구현 세부 정보를 숨깁니다.</xref:System.Security.AccessControl.MutexAuditRule> </xref:System.Security.AccessControl.MutexAccessRule> 17 다양 한 ACE 유형 및 상속 및 액세스 권한의 전파를 올바르게 유지 관리의 복잡성을 무시할 수 있습니다. 또한 이러한 개체는 다음과 같은 일반적인 액세스 제어 오류를 방지 하도록 설계:-null DACL을 사용 하 여 보안 설명자 만들기. DACL에 null 참조를 모든 사용자를 서비스 거부 공격을 잠재적으로 만드는 개체에 액세스 규칙을 추가할 수 있습니다. 새 MutexSecurity 개체는 항상 빈 DACL에서 모든 사용자에 대 한 모든 액세스를 거부로 시작 합니다.      -Ace의 정식 순서 위반입니다. DACL 목록의 ACE가 정식 순서 대로 유지 되지 않을, 사용자가 실수로에 부여 될 수 액세스 보안된 개체입니다. 예를 들어, 거부 된 액세스 권한은 항상 액세스 권한이 허용된 하기 전에 나타나야 합니다. MutexSecurity 개체는 내부적으로 올바른 순서를 유지합니다.      리소스 관리자 컨트롤 에서만 있어야 하 고 보안 설명자 플래그를 조작 합니다.      -만들기 ACE 플래그의 잘못 된 조합입니다.      -상속 된 Ace를 조작 합니다. 상속 및 전파 리소스 관리자의 액세스 및 감사 규칙을 적용 한 변경 내용에 대 한 응답에 의해 처리 됩니다.      -Acl에 의미 없는 Ace를 삽입 합니다.       보안 개체를.NET에서 지원 되지 않습니다 유일한 기능은 다음과 같은 응용 프로그램 개발자의 과반수가 피해 야 하는 위험한 작업:-리소스 관리자가 정상적으로 수행 되는 하위 수준 작업입니다.      -추가 또는 정식 순서를 유지 하지 않는 방법으로 액세스 제어 항목을 제거 합니다.       명명 된 뮤텍스에 대 한 Windows 액세스 제어 보안을 수정 하려면 사용 하 여는 <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=fullName>메서드 MutexSecurity 개체를 가져옵니다.</xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=fullName> 추가 하 고 규칙을 제거 하 여 보안 개체를 수정 하 고 <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=fullName>합니다. 다시 연결 하는 메서드</xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=fullName> 를 사용 합니다      > [!IMPORTANT] > MutexSecurity 개체에 변경 되지 않습니다 명명 된 뮤텍스의 액세스 수준을 호출 하기 전에 <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=fullName>메서드를 변경 된 보안 개체에서 명명 된 뮤텍스를 할당 합니다.</xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=fullName>       뮤텍스에서 액세스 제어 보안을 다른 위치로 복사를 사용 하 여는 <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=fullName>첫 번째 뮤텍스에 대 한 액세스 및 감사 규칙을 나타내는 MutexSecurity 개체를 가져오고 다음 메서드는 <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=fullName>메서드나 MutexSecurity 개체를 이러한 규칙을 두 번째 뮤텍스 할당을 허용 하는 생성자입니다.</xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=fullName> </xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=fullName>       보안 설명자 정의 언어 (SDDL)에 투자 사용자가 사용할 수는 <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>명명 된 뮤텍스에 대 한 액세스 규칙을 설정 하는 메서드 및 <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>메서드 SDDL 형식의 액세스 규칙을 나타내는 문자열입니다.</xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> </xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> 새로운 개발에는 권장 되지 않습니다.      > [!NOTE] > 동기화 개체에 대 한 보안은 Windows 98 또는 Windows Millennium Edition에 대 한 지원 되지 않습니다."
  example:
  - "The following code example demonstrates the separation between <xref:System.Security.AccessControl.AccessControlType> rules and <xref:System.Security.AccessControl.AccessControlType> rules, and shows the combination of rights in compatible rules. The example creates a MutexSecurity object, adds rules that allow and deny various rights for the current user, and displays the resulting pair of rules. The example then allows new rights for the current user and displays the result, showing that the new rights are merged with the existing <xref:System.Security.AccessControl.AccessControlType> rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Mutex> object. Examples that attach security objects can be found in <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.MutexSecurity.AddAccessRule#1](~/add/codesnippet/visualbasic/t-system.security.access_12_1.vb)]\n [!code-cs[System.Security.AccessControl.MutexSecurity.AddAccessRule#1](~/add/codesnippet/csharp/t-system.security.access_12_1.cs)]"
  syntax:
    content: 'public sealed class MutexSecurity : System.Security.AccessControl.NativeObjectSecurity'
  inheritance:
  - System.Object
  - System.Security.AccessControl.ObjectSecurity
  - System.Security.AccessControl.CommonObjectSecurity
  - System.Security.AccessControl.NativeObjectSecurity
  implements: []
  inheritedMembers:
  - System.Security.AccessControl.CommonObjectSecurity.AddAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.AddAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.GetAccessRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.GetAuditRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAccess(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAudit(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleAll(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleAll(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.ResetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.ObjectSecurity.AccessRulesModified
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AuditRulesModified
  - System.Security.AccessControl.ObjectSecurity.GetGroup(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetOwner(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm(System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.GroupModified
  - System.Security.AccessControl.ObjectSecurity.IsContainer
  - System.Security.AccessControl.ObjectSecurity.IsDS
  - System.Security.AccessControl.ObjectSecurity.IsSddlConversionSupported
  - System.Security.AccessControl.ObjectSecurity.ModifyAccessRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.ModifyAuditRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.OwnerModified
  - System.Security.AccessControl.ObjectSecurity.Persist(System.Boolean,System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.PurgeAccessRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.PurgeAuditRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.ReadLock
  - System.Security.AccessControl.ObjectSecurity.ReadUnlock
  - System.Security.AccessControl.ObjectSecurity.SetAccessRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetAuditRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetGroup(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetOwner(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[])
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[],System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.WriteLock
  - System.Security.AccessControl.ObjectSecurity.WriteUnlock
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.#ctor
  id: '#ctor'
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: MutexSecurity()
  nameWithType: MutexSecurity.MutexSecurity()
  fullName: System.Security.AccessControl.MutexSecurity.MutexSecurity()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Security.AccessControl.MutexSecurity&quot;> </xref> 클래스 기본값을 사용 합니다."
  remarks: "새 <xref:System.Security.AccessControl.MutexSecurity>개체는 항상 모든 사용자에 대 한 모든 액세스를 거부 하는 빈 임의 액세스 목록 (DACL)으로 시작 합니다.</xref:System.Security.AccessControl.MutexSecurity>"
  syntax:
    content: public MutexSecurity ();
    parameters: []
  overload: System.Security.AccessControl.MutexSecurity.#ctor*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "이 클래스는 Windows 98 또는 Windows Millennium Edition에서 지원 되지 않습니다."
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)
  id: '#ctor(System.String,System.Security.AccessControl.AccessControlSections)'
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: MutexSecurity(String,AccessControlSections)
  nameWithType: MutexSecurity.MutexSecurity(String,AccessControlSections)
  fullName: System.Security.AccessControl.MutexSecurity.MutexSecurity(String,AccessControlSections)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Security.AccessControl.MutexSecurity&quot;> </xref> 섹션에서 지정 된 이름의 시스템 뮤텍스에 액세스 제어 보안 규칙의 클래스입니다."
  remarks: "이 생성자를 사용 하면 먼저 만들지 않고 명명 된 시스템 뮤텍스에 대 한 액세스 제어 보안을 가져올 수 있습니다는 <xref:System.Threading.Mutex>개체입니다.</xref:System.Threading.Mutex>       명명 된 시스템 개체로 작업할 때 주의가 필요 합니다. 명명 된 시스템 개체 인지 여부 `name` 뮤텍스 즉, 액세스 제어 보안이 검색 될 수 있습니다."
  syntax:
    content: public MutexSecurity (string name, System.Security.AccessControl.AccessControlSections includeSections);
    parameters:
    - id: name
      type: System.String
      description: "해당 액세스 제어 보안 규칙을 검색할 수는 시스템 뮤텍스의 이름입니다."
    - id: includeSections
      type: System.Security.AccessControl.AccessControlSections
      description: "조합을 <xref href=&quot;System.Security.AccessControl.AccessControlSections&quot;> </xref> 검색할 섹션을 지정 하는 플래그입니다."
  overload: System.Security.AccessControl.MutexSecurity.#ctor*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "지정 된 이름의 시스템 개체가 없습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "이 클래스는 Windows 98 또는 Windows Millennium Edition에서 지원 되지 않습니다."
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.AccessRightType
  id: AccessRightType
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: AccessRightType
  nameWithType: MutexSecurity.AccessRightType
  fullName: System.Security.AccessControl.MutexSecurity.AccessRightType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "열거형을 가져옵니다는 <xref href=&quot;System.Security.AccessControl.MutexSecurity&quot;> </xref> 액세스 권한을 나타내는 데 사용 하 여 합니다."
  remarks: "파생 된 클래스는 <xref:System.Security.AccessControl.ObjectSecurity>재정의 클래스는 <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A>속성 및 액세스 권한을 나타내는 데 사용 하는 형식 반환 합니다.</xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> </xref:System.Security.AccessControl.ObjectSecurity> 배열 또는 여러 유형의 보안 개체를 포함 하는 컬렉션으로 작업할 때 각 보안 개체에 사용할 올바른 열거형 형식을 확인 하려면이 속성을 사용 합니다."
  syntax:
    content: public override Type AccessRightType { get; }
    return:
      type: System.Type
      description: "A <xref:System.Type>나타내는 개체는 <xref href=&quot;System.Security.AccessControl.MutexRights&quot;> </xref> 열거형.</xref:System.Type>"
  overload: System.Security.AccessControl.MutexSecurity.AccessRightType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  id: AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: MutexSecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.MutexSecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "지정 된 액세스 권한, 액세스 제어 및 플래그가 지정된 된 사용자에 대 한 새 액세스 제어 규칙을 만듭니다."
  remarks: "<xref:System.Security.AccessControl.MutexAccessRule>클래스</xref:System.Security.AccessControl.MutexAccessRule> 의 생성자를 사용 하는 액세스 제어 규칙을 작성 하는 권장된 방법      > [!NOTE] > 상속 및 전파 플래그는 명명 된 뮤텍스에 대 한 의미가, 없지만 권한을 지정할 수는 있습니다. 이 권장 되지 않습니다을 불필요 하 게 복잡 유지 관리, 규칙의 예를 들어 호환 될 수 있는 규칙의 조합에 영향을 주어 때문에 있습니다."
  syntax:
    content: public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "<xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref> 식별 하는 사용자 또는 규칙 그룹에 적용 됩니다."
    - id: accessMask
      type: System.Int32
      description: "비트 조합 <xref href=&quot;System.Security.AccessControl.MutexRights&quot;> </xref> 액세스 권한을 허용 하거나 거부할를 지정 하는 값을 정수로 캐스팅 합니다."
    - id: isInherited
      type: System.Boolean
      description: "명명 된 뮤텍스는 계층이 의미가 없습니다."
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "명명 된 뮤텍스는 계층이 의미가 없습니다."
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "명명 된 뮤텍스는 계층이 의미가 없습니다."
    - id: type
      type: System.Security.AccessControl.AccessControlType
      description: "중 하나는 <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> 권한 허용 여부를 지정 하는 값입니다."
    return:
      type: System.Security.AccessControl.AccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.MutexAccessRule&quot;> </xref> 지정된 된 사용자에 대 한 지정된 된 권한을 나타내는 개체입니다."
  overload: System.Security.AccessControl.MutexSecurity.AccessRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code><code>inheritanceFlags</code>, <code>propagationFlags</code>, 또는 <code>type</code> 잘못 된 값을 지정 합니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -또는- <code>accessMask</code> 은&0;입니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>형식이 <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>, 아니고과 같은 형식 <xref href=&quot;System.Security.Principal.NTAccount&quot;> </xref> 변환할 수 있는 <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.AccessRuleType
  id: AccessRuleType
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: AccessRuleType
  nameWithType: MutexSecurity.AccessRuleType
  fullName: System.Security.AccessControl.MutexSecurity.AccessRuleType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "형식을 가져옵니다는 <xref href=&quot;System.Security.AccessControl.MutexSecurity&quot;> </xref> 액세스 규칙을 나타내는 클래스입니다."
  remarks: "파생 된 클래스는 <xref:System.Security.AccessControl.ObjectSecurity>재정의 클래스는 <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A>속성과 액세스 규칙을 나타내는 데 사용 하는 형식 반환 합니다.</xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> 배열 또는 여러 유형의 보안 개체를 포함 하는 컬렉션으로 작업할 때 각 보안 개체에 사용할 올바른 액세스 규칙을 확인 하려면이 속성을 사용 합니다."
  syntax:
    content: public override Type AccessRuleType { get; }
    return:
      type: System.Type
      description: "A <xref:System.Type>나타내는 개체는 <xref href=&quot;System.Security.AccessControl.MutexAccessRule&quot;> </xref> 클래스</xref:System.Type>"
  overload: System.Security.AccessControl.MutexSecurity.AccessRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.AddAccessRule(System.Security.AccessControl.MutexAccessRule)
  id: AddAccessRule(System.Security.AccessControl.MutexAccessRule)
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: AddAccessRule(MutexAccessRule)
  nameWithType: MutexSecurity.AddAccessRule(MutexAccessRule)
  fullName: System.Security.AccessControl.MutexSecurity.AddAccessRule(MutexAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "새 규칙을 병합할 수 일치 하는 액세스 제어 규칙을 검색 합니다. 검색 된 항목이 없는 경우 새 규칙을 추가 합니다."
  remarks: "AddAccessRule 메서드를 사용 하 여 동일한 사용자 또는 그룹 및 동일한 규칙에 대 한 검색 <xref:System.Security.AccessControl.AccessControlType>으로 `rule`.</xref:System.Security.AccessControl.AccessControlType> 발견 되 면 `rule` 추가 됩니다. 일치 하는 규칙 발견 되 면 권한에 `rule` 기존 규칙과 함께 병합 됩니다."
  example:
  - "The following code example demonstrates the separation between <xref:System.Security.AccessControl.AccessControlType> rules and <xref:System.Security.AccessControl.AccessControlType> rules, and shows the combination of rights in compatible rules. The example creates a <xref:System.Security.AccessControl.MutexSecurity> object, adds rules that allow and deny various rights for the current user, and displays the resulting pair of rules. The example then allows new rights for the current user and displays the result, showing that the new rights are merged with the existing <xref:System.Security.AccessControl.AccessControlType> rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Mutex> object. Examples that attach security objects can be found in <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=fullName><xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.MutexSecurity.AddAccessRule#1](~/add/codesnippet/visualbasic/a07c477f-17a9-4bd4-908e-_1.vb)]\n [!code-cs[System.Security.AccessControl.MutexSecurity.AddAccessRule#1](~/add/codesnippet/csharp/a07c477f-17a9-4bd4-908e-_1.cs)]"
  syntax:
    content: public void AddAccessRule (System.Security.AccessControl.MutexAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.MutexAccessRule
      description: "액세스 제어 규칙 추가입니다."
  overload: System.Security.AccessControl.MutexSecurity.AddAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Principal.IdentityNotMappedException
    commentId: T:System.Security.Principal.IdentityNotMappedException
    description: "<code>rule </code>알려진된 id에 매핑할 수 없습니다."
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.AddAuditRule(System.Security.AccessControl.MutexAuditRule)
  id: AddAuditRule(System.Security.AccessControl.MutexAuditRule)
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: AddAuditRule(MutexAuditRule)
  nameWithType: MutexSecurity.AddAuditRule(MutexAuditRule)
  fullName: System.Security.AccessControl.MutexSecurity.AddAuditRule(MutexAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "새 규칙을 병합할 수는 감사 규칙을 검색 합니다. 검색 된 항목이 없는 경우 새 규칙을 추가 합니다."
  remarks: "AddAuditRule 메서드 같은 사용자 또는 그룹을 사용 하 여 규칙에 대 한 검색 `rule`합니다. 발견 되 면 `rule` 추가 됩니다. 일치 하는 규칙 발견 되 면 플래그에 `rule` 기존 규칙에 병합 됩니다."
  syntax:
    content: public void AddAuditRule (System.Security.AccessControl.MutexAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.MutexAuditRule
      description: "추가 된 감사 규칙입니다. 이 규칙에 의해 지정 된 사용자가 검색을 결정 합니다."
  overload: System.Security.AccessControl.MutexSecurity.AddAuditRule*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  id: AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: MutexSecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.MutexSecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "규칙을 적용할 감사, 액세스 권한 및 감사 규칙을 트리거할 결과 사용자 지정 하는 새 감사 규칙을 만듭니다."
  remarks: "<xref:System.Security.AccessControl.MutexAuditRule>클래스</xref:System.Security.AccessControl.MutexAuditRule> 의 생성자를 사용 하는 감사 규칙을 만드는 권장된 방법을      > [!NOTE] > 상속 및 전파 플래그는 명명 된 뮤텍스에 대 한 의미가, 없지만 권한을 지정할 수는 있습니다. 이 권장 되지 않습니다을 불필요 하 게 복잡 유지 관리, 규칙의 예를 들어 호환 될 수 있는 규칙의 조합에 영향을 주어 때문에 있습니다."
  syntax:
    content: public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "<xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref> 식별 하는 사용자 또는 규칙 그룹에 적용 됩니다."
    - id: accessMask
      type: System.Int32
      description: "비트 조합 <xref href=&quot;System.Security.AccessControl.MutexRights&quot;> </xref> 를 감사 하려면 액세스 권한을 지정 하는 값을 정수로 캐스팅 합니다."
    - id: isInherited
      type: System.Boolean
      description: "계층이 없으므로 때문에 명명 된 대기 핸들에 대 한 의미가 없습니다."
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "계층이 없으므로 때문에 명명 된 대기 핸들에 대 한 의미가 없습니다."
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "계층이 없으므로 때문에 명명 된 대기 핸들에 대 한 의미가 없습니다."
    - id: flags
      type: System.Security.AccessControl.AuditFlags
      description: "비트 조합 <xref href=&quot;System.Security.AccessControl.AuditFlags&quot;> </xref> 성공한 액세스, 실패 한 액세스 또는 둘 다 감사 여부를 지정 하는 값입니다."
    return:
      type: System.Security.AccessControl.AuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.MutexAuditRule&quot;> </xref> 지정된 된 사용자에 대 한 지정 된 감사 규칙을 나타내는 개체입니다. 메서드의 반환 형식이 기본 클래스 <xref href=&quot;System.Security.AccessControl.AuditRule&quot;> </xref>, 하지만 파생 클래스로 반환 값을 안전 하 게 캐스팅할 수 있습니다."
  overload: System.Security.AccessControl.MutexSecurity.AuditRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code><code>inheritanceFlags</code>, <code>propagationFlags</code>, 또는 <code>flags</code> 잘못 된 값을 지정 합니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -또는- <code>accessMask</code> 은&0;입니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>형식이 <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>, 아니고과 같은 형식 <xref href=&quot;System.Security.Principal.NTAccount&quot;> </xref> 변환할 수 있는 <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.AuditRuleType
  id: AuditRuleType
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: AuditRuleType
  nameWithType: MutexSecurity.AuditRuleType
  fullName: System.Security.AccessControl.MutexSecurity.AuditRuleType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "형식을 가져옵니다는 <xref href=&quot;System.Security.AccessControl.MutexSecurity&quot;> </xref> 감사 규칙을 나타내는 클래스입니다."
  remarks: "파생 된 클래스는 <xref:System.Security.AccessControl.ObjectSecurity>재정의 클래스는 <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A>속성 및 감사 권한을 나타내는 데 사용 하는 형식 반환 합니다.</xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> 배열 또는 여러 유형의 보안 개체를 포함 하는 컬렉션으로 작업할 때 각 보안 개체에 사용할 올바른 감사 규칙을 확인 하려면이 속성을 사용 합니다."
  syntax:
    content: public override Type AuditRuleType { get; }
    return:
      type: System.Type
      description: "A <xref:System.Type>나타내는 개체는 <xref href=&quot;System.Security.AccessControl.MutexAuditRule&quot;> </xref> 클래스</xref:System.Type>"
  overload: System.Security.AccessControl.MutexSecurity.AuditRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.RemoveAccessRule(System.Security.AccessControl.MutexAccessRule)
  id: RemoveAccessRule(System.Security.AccessControl.MutexAccessRule)
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: RemoveAccessRule(MutexAccessRule)
  nameWithType: MutexSecurity.RemoveAccessRule(MutexAccessRule)
  fullName: System.Security.AccessControl.MutexSecurity.RemoveAccessRule(MutexAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "동일한 사용자와 액세스 제어 규칙으로 검색 하 고 <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (허용 또는 거부) 이러한 규칙이 없으면 지정된 된 액세스 규칙에 포함 된 권한으로 지정된 된 규칙 및 호환 상속 및 전파 플래그;에서 제거 됩니다."
  remarks: "현재 <xref:System.Security.AccessControl.MutexSecurity>된 동일한 사용자와 동일한 규칙에 대 한 검색 <xref:System.Security.AccessControl.AccessControlType>값 `rule`.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.MutexSecurity> 그러한 규칙이 아무 작업도 및 메서드 반환 `false`합니다. 일치 하는 규칙 발견 되 면 해당 상속 및 호환성 플래그에 지정 된 플래그와의 호환성에 대 한 확인 `rule`합니다. 호환 가능한 규칙이 아무 작업도 및 메서드 반환 `false`합니다. 에 지정 된 호환 플래그와 함께 규칙이 없으면 권한은 `rule` 호환 되는 규칙에서 제거 됩니다 메서드에서 반환 `true`합니다. 경우 `rule` 아무 작업도 수행 해당 권리에 대해, 호환 되는 규칙에 포함 되지 않은 권한을 지정 합니다. 현재에서 전체 규칙을 제거할 모든 권리를 호환 되는 규칙에서 제거 하면 <xref:System.Security.AccessControl.MutexSecurity>개체입니다.</xref:System.Security.AccessControl.MutexSecurity>      > [!IMPORTANT] > 뮤텍스 액세스 규칙에 대 한 상속 및 전파 플래그를 만들어 지정할 수는 있지만 <xref:System.Security.AccessControl.MutexSecurity.AccessRuleFactory%2A>메서드를 권장 되지 않습니다.</xref:System.Security.AccessControl.MutexSecurity.AccessRuleFactory%2A> 상속 및 전파 한 의미가 없으며 명명 된 뮤텍스에 대 한 액세스 규칙의 유지 관리 보다 복잡 하 게 합니다."
  example:
  - "The following code example demonstrates the use of the RemoveAccessRule method to remove rights from an <xref:System.Security.AccessControl.AccessControlType> rule in a <xref:System.Security.AccessControl.MutexSecurity> object. It also shows that other rights in `rule` are ignored.  \n  \n The example creates a <xref:System.Security.AccessControl.MutexSecurity> object and adds rules that allow and deny various rights for the current user. The rights allowed include <xref:System.Security.AccessControl.MutexRights>, <xref:System.Security.AccessControl.MutexRights>, and <xref:System.Security.AccessControl.MutexRights>. The example then creates a new rule for the current user, including <xref:System.Security.AccessControl.MutexRights> and <xref:System.Security.AccessControl.MutexRights> rights, and uses that rule with the RemoveAccessRule method to remove <xref:System.Security.AccessControl.MutexRights> from the <xref:System.Security.AccessControl.AccessControlType> rule in the <xref:System.Security.AccessControl.MutexSecurity> object. The extraneous <xref:System.Security.AccessControl.MutexRights> right in `rule` is ignored.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Mutex> object. Examples that attach security objects can be found in <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.MutexSecurity.RemoveAccessRule#1](~/add/codesnippet/visualbasic/02c8df82-84a8-4212-a3e0-_1.vb)]\n [!code-cs[System.Security.AccessControl.MutexSecurity.RemoveAccessRule#1](~/add/codesnippet/csharp/02c8df82-84a8-4212-a3e0-_1.cs)]"
  syntax:
    content: public bool RemoveAccessRule (System.Security.AccessControl.MutexAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.MutexAccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.MutexAccessRule&quot;> </xref> 사용자 지정 하 고 <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> 검색 및 일치 하는 규칙을 하는 경우 상속 및 전파 플래그 집합을 찾을와 호환 되어야 합니다. 발견 하는 경우 호환 되는 규칙에서 제거할 수 있는 권한을 지정 합니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>호환 되는 규칙이 없으면; 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Security.AccessControl.MutexSecurity.RemoveAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll(System.Security.AccessControl.MutexAccessRule)
  id: RemoveAccessRuleAll(System.Security.AccessControl.MutexAccessRule)
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: RemoveAccessRuleAll(MutexAccessRule)
  nameWithType: MutexSecurity.RemoveAccessRuleAll(MutexAccessRule)
  fullName: System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll(MutexAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "사용자가 제어 규칙을 액세스 하는 모든 검색 및 <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (허용 또는 거부) 지정 된 규칙 및 경우 제거 합니다 해당 합니다."
  remarks: "현재 <xref:System.Security.AccessControl.MutexSecurity>개체가 동일한 사용자와 동일한 규칙에 대 한 검색 됩니다 <xref:System.Security.AccessControl.AccessControlType>값 `rule`.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.MutexSecurity> 지정한 모든 권한은 `rule` 이 검색을 수행할 때 무시 됩니다. 일치 하는 규칙 발견 되 면 아무 작업도 수행 합니다."
  example:
  - "The following code example shows that the RemoveAccessRuleAll method removes all rules that match user and <xref:System.Security.AccessControl.AccessControlType>, ignoring rights.  \n  \n The example creates a <xref:System.Security.AccessControl.MutexSecurity> object, adds rules that allow and deny various rights for the current user, and then merges additional rights into the <xref:System.Security.AccessControl.AccessControlType> rule. The example then creates a new rule that allows the current user to take ownership, and uses that rule to remove the <xref:System.Security.AccessControl.AccessControlType> rule from the <xref:System.Security.AccessControl.MutexSecurity> object.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Mutex> object. Examples that attach security objects can be found in <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-cs[System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll#1](~/add/codesnippet/csharp/6d97fdf7-4cee-497f-898e-_1.cs)]\n [!code-vb[System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll#1](~/add/codesnippet/visualbasic/6d97fdf7-4cee-497f-898e-_1.vb)]"
  syntax:
    content: public void RemoveAccessRuleAll (System.Security.AccessControl.MutexAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.MutexAccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.MutexAccessRule&quot;> </xref> 사용자 지정 하 고 <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> 을 찾으려고 합니다. 이 규칙에 지정 된 모든 권한은 무시 됩니다."
  overload: System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.MutexAccessRule)
  id: RemoveAccessRuleSpecific(System.Security.AccessControl.MutexAccessRule)
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: RemoveAccessRuleSpecific(MutexAccessRule)
  nameWithType: MutexSecurity.RemoveAccessRuleSpecific(MutexAccessRule)
  fullName: System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific(MutexAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "지정 된과 정확히 일치 하는 액세스 제어 규칙에 대 한 검색 규칙 및 경우 제거 합니다 것입니다."
  remarks: "정확히 일치 하는 규칙을 제거할 `rule` 모든 세부 정보에 플래그를 포함 합니다. 동일한 사용자와 다른 규칙 및 <xref:System.Security.AccessControl.AccessControlType>영향을 받지 않습니다.</xref:System.Security.AccessControl.AccessControlType>      > [!IMPORTANT] > 규칙을 나타내는 하나 이상의 기본 액세스 제어 항목 (ACE) 및 이러한 항목은 분할 되거나 사용자에 대 한 액세스 보안 규칙을 수정 하는 경우 필요에 따라 조합 합니다. 따라서 규칙 추가 될 때 특정 폼에 더 이상 존재 하 고이 경우 RemoveAccessRuleSpecific 메서드는 제거할 수 없습니다."
  example:
  - "The following code example shows that the RemoveAccessRuleSpecific method requires an exact match in order to remove a rule, and that rules to allow and deny rights are independent of each other.  \n  \n The example creates a <xref:System.Security.AccessControl.MutexSecurity> object, adds rules that allow and deny various rights for the current user, and then merges additional rights into the <xref:System.Security.AccessControl.AccessControlType> access rule. The example then passes the original <xref:System.Security.AccessControl.AccessControlType> rule to the RemoveAccessRuleSpecific method, and displays the results, showing that nothing is deleted. The example then constructs a rule that matches the <xref:System.Security.AccessControl.AccessControlType> rule in the <xref:System.Security.AccessControl.MutexSecurity> object, and successfully uses the RemoveAccessRuleSpecific method to remove the rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Mutex> object. Examples that attach security objects can be found in <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/visualbasic/fa20d5ab-0fa1-47be-9c16-_1.vb)]\n [!code-cs[System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/csharp/fa20d5ab-0fa1-47be-9c16-_1.cs)]"
  syntax:
    content: public void RemoveAccessRuleSpecific (System.Security.AccessControl.MutexAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.MutexAccessRule
      description: "<xref href=&quot;System.Security.AccessControl.MutexAccessRule&quot;> </xref> 를 제거 합니다."
  overload: System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.RemoveAuditRule(System.Security.AccessControl.MutexAuditRule)
  id: RemoveAuditRule(System.Security.AccessControl.MutexAuditRule)
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: RemoveAuditRule(MutexAuditRule)
  nameWithType: MutexSecurity.RemoveAuditRule(MutexAuditRule)
  fullName: System.Security.AccessControl.MutexSecurity.RemoveAuditRule(MutexAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "감사 제어 규칙을 사용자 지정된 규칙와 동일한 사용자와 호환 상속 및 전파 플래그;에 대 한 검색 호환 되는 규칙이 없는 경우 여기에서 지정된 된 규칙에 포함 된 권한이 제거 됩니다."
  remarks: "현재 <xref:System.Security.AccessControl.MutexSecurity>사용자와 동일한 사용자가 감사 규칙에 대 한 검색 `rule`.</xref:System.Security.AccessControl.MutexSecurity> 그러한 규칙이 아무 작업도 및 메서드 반환 `false`합니다. 일치 하는 규칙 발견 되 면 해당 상속 및 호환성 플래그에 지정 된 플래그와의 호환성에 대 한 확인 `rule`합니다. 호환 가능한 규칙이 아무 작업도 및 메서드 반환 `false`합니다. 에 지정 된 호환 플래그와 함께 규칙이 없으면 권한은 `rule` 호환 되는 규칙에서 제거 됩니다 메서드에서 반환 `true`합니다. 경우 `rule` 아무 작업도 수행 해당 권리에 대해, 호환 되는 규칙에 포함 되지 않은 권한을 지정 합니다. 현재에서 전체 규칙을 제거할 모든 권리를 호환 되는 규칙에서 제거 하면 <xref:System.Security.AccessControl.MutexSecurity>개체입니다.</xref:System.Security.AccessControl.MutexSecurity>      > [!IMPORTANT] > 뮤텍스 감사 규칙의 상속 및 전파 플래그를 만들어 지정할 수는 있지만 <xref:System.Security.AccessControl.MutexSecurity.AccessRuleFactory%2A>메서드를 권장 되지 않습니다.</xref:System.Security.AccessControl.MutexSecurity.AccessRuleFactory%2A> 상속 및 전파 한 의미가 없으며 명명 된 뮤텍스에 대 한 감사 규칙의 유지 관리 보다 복잡 하 게 합니다."
  syntax:
    content: public bool RemoveAuditRule (System.Security.AccessControl.MutexAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.MutexAuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.MutexAuditRule&quot;> </xref> 검색할 사용자와 일치 하는 규칙, 상속 및 전파 플래그 집합이 지정 하는 경우 발견와 호환 되어야 합니다. 발견 하는 경우 호환 되는 규칙에서 제거할 수 있는 권한을 지정 합니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>호환 되는 규칙이 없으면; 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Security.AccessControl.MutexSecurity.RemoveAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.RemoveAuditRuleAll(System.Security.AccessControl.MutexAuditRule)
  id: RemoveAuditRuleAll(System.Security.AccessControl.MutexAuditRule)
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: RemoveAuditRuleAll(MutexAuditRule)
  nameWithType: MutexSecurity.RemoveAuditRuleAll(MutexAuditRule)
  fullName: System.Security.AccessControl.MutexSecurity.RemoveAuditRuleAll(MutexAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "검색이 모든 감사 규칙은 지정 된 규칙으로 같은 사용자가 있으며 하는 경우 제거 합니다."
  remarks: "현재 <xref:System.Security.AccessControl.MutexSecurity>는 동일한 사용자로 포함 하는 감사 규칙에 대 한 검색 `rule`.</xref:System.Security.AccessControl.MutexSecurity> 지정한 모든 권한은 `rule` 이 검색을 수행할 때 무시 됩니다. 모든 일치 규칙 제거 됩니다. 일치 하는 규칙 발견 되 면 아무 작업도 수행 합니다."
  syntax:
    content: public void RemoveAuditRuleAll (System.Security.AccessControl.MutexAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.MutexAuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.MutexAuditRule&quot;> </xref> 검색할 사용자 지정 하는 합니다. 이 규칙에 지정 된 모든 권한은 무시 됩니다."
  overload: System.Security.AccessControl.MutexSecurity.RemoveAuditRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.MutexAuditRule)
  id: RemoveAuditRuleSpecific(System.Security.AccessControl.MutexAuditRule)
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: RemoveAuditRuleSpecific(MutexAuditRule)
  nameWithType: MutexSecurity.RemoveAuditRuleSpecific(MutexAuditRule)
  fullName: System.Security.AccessControl.MutexSecurity.RemoveAuditRuleSpecific(MutexAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "지정 된과 정확히 일치 하는 감사 규칙에 대 한 검색 규칙 및 경우 제거 합니다 것입니다."
  remarks: "정확히 일치 하는 규칙을 제거할 `rule` 모든 세부 정보에 플래그를 포함 합니다. 동일한 사용자에 대 한 다른 감사 규칙의 영향을 받지 않습니다.      > [!IMPORTANT] > 규칙을 나타내는 하나 이상의 기본 액세스 제어 항목 (ACE) 및 이러한 항목은 분할 되거나 사용자에 대 한 감사 보안 규칙을 수정 하는 경우 필요에 따라 조합 합니다. 따라서 규칙 추가 될 때 특정 폼에 더 이상 존재 하 고이 경우 RemoveAuditRuleSpecific 메서드는 제거할 수 없습니다."
  syntax:
    content: public void RemoveAuditRuleSpecific (System.Security.AccessControl.MutexAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.MutexAuditRule
      description: "<xref href=&quot;System.Security.AccessControl.MutexAuditRule&quot;> </xref> 제거 됩니다."
  overload: System.Security.AccessControl.MutexSecurity.RemoveAuditRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.ResetAccessRule(System.Security.AccessControl.MutexAccessRule)
  id: ResetAccessRule(System.Security.AccessControl.MutexAccessRule)
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: ResetAccessRule(MutexAccessRule)
  nameWithType: MutexSecurity.ResetAccessRule(MutexAccessRule)
  fullName: System.Security.AccessControl.MutexSecurity.ResetAccessRule(MutexAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "에 관계 없이 사용자가 지정된 된 규칙으로 모든 액세스 제어 규칙을 제거 <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref>, 다음은 지정 된 규칙을 추가 합니다."
  remarks: "사용자가 지정한 규칙과 일치 하는 액세스 규칙이 없으면 없으면 `rule` 추가 됩니다."
  example:
  - "The following code example shows how the ResetAccessRule method replaces all rules for the matching user with the rule specified for the match.  \n  \n The example creates a <xref:System.Security.AccessControl.MutexSecurity> object and adds rules that allow and deny various rights for the current user. The example then creates a new rule that allows the current user full control, and uses the ResetAccessRule method to replace both of the existing rules with the new rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Mutex> object. Examples that attach security objects can be found in <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-cs[System.Security.AccessControl.MutexSecurity.ResetAccessRule#1](~/add/codesnippet/csharp/382093ed-47a5-4dd0-aee6-_1.cs)]\n [!code-vb[System.Security.AccessControl.MutexSecurity.ResetAccessRule#1](~/add/codesnippet/visualbasic/382093ed-47a5-4dd0-aee6-_1.vb)]"
  syntax:
    content: public void ResetAccessRule (System.Security.AccessControl.MutexAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.MutexAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.MutexAccessRule&quot;></xref> to add. 이 규칙에 의해 지정 된 사용자를이 규칙을 추가 하기 전에 제거 하는 규칙을 결정 합니다."
  overload: System.Security.AccessControl.MutexSecurity.ResetAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.SetAccessRule(System.Security.AccessControl.MutexAccessRule)
  id: SetAccessRule(System.Security.AccessControl.MutexAccessRule)
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: SetAccessRule(MutexAccessRule)
  nameWithType: MutexSecurity.SetAccessRule(MutexAccessRule)
  fullName: System.Security.AccessControl.MutexSecurity.SetAccessRule(MutexAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "사용자가 모든 액세스 제어 규칙을 제거 하 고 <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (허용 또는 거부) 지정된 된 규칙으로 다음 지정된 된 규칙을 추가 합니다."
  remarks: "지정 된 규칙의 경우 <xref:System.Security.AccessControl.AccessControlType>,이 방법의 효과 모두 제거 하는 <xref:System.Security.AccessControl.AccessControlType>지정한 규칙으로 대체 하는 지정 된 사용자에 대 한 규칙.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType> 지정 된 규칙의 경우 <xref:System.Security.AccessControl.AccessControlType>모든 <xref:System.Security.AccessControl.AccessControlType>지정된 된 사용자에 대 한 규칙은 지정 된 규칙으로 대체 됩니다.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType>       있는 경우 규칙이 없으면 해당 사용자 및 <xref:System.Security.AccessControl.AccessControlType>지정 된 규칙과 일치 `rule` 추가 됩니다.</xref:System.Security.AccessControl.AccessControlType>"
  example:
  - "The following code example shows how the SetAccessRule method removes all rules that match both the user and the <xref:System.Security.AccessControl.AccessControlType> of `rule`, replacing them with `rule`.  \n  \n The example creates a <xref:System.Security.AccessControl.MutexSecurity> object and adds rules that allow and deny various rights for the current user. The example then creates a new rule that allows the current user full control, and uses the SetAccessRule method to replace the existing Allow rule with the new rule. The rule that denies access is not affected.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Mutex> object. Examples that attach security objects can be found in <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.MutexSecurity.SetAccessRule#1](~/add/codesnippet/visualbasic/5e6eedb1-8b35-40cc-b676-_1.vb)]\n [!code-cs[System.Security.AccessControl.MutexSecurity.SetAccessRule#1](~/add/codesnippet/csharp/5e6eedb1-8b35-40cc-b676-_1.cs)]"
  syntax:
    content: public void SetAccessRule (System.Security.AccessControl.MutexAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.MutexAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.MutexAccessRule&quot;></xref> to add. 사용자 및 <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> 이 규칙의이 규칙은 추가 되기 전에 제거 하는 규칙을 결정 합니다."
  overload: System.Security.AccessControl.MutexSecurity.SetAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.MutexSecurity.SetAuditRule(System.Security.AccessControl.MutexAuditRule)
  id: SetAuditRule(System.Security.AccessControl.MutexAuditRule)
  parent: System.Security.AccessControl.MutexSecurity
  langs:
  - csharp
  name: SetAuditRule(MutexAuditRule)
  nameWithType: MutexSecurity.SetAuditRule(MutexAuditRule)
  fullName: System.Security.AccessControl.MutexSecurity.SetAuditRule(MutexAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "모든 감사 사용자가 지정된 된 규칙으로 규칙에 관계 없이 제거는 <xref href=&quot;System.Security.AccessControl.AuditFlags&quot;> </xref> 값을 복사한 다음 지정 된 규칙을 추가 합니다."
  remarks: "사용자가 지정한 규칙과 일치 하는 감사 규칙이 없으면 없으면 `rule` 추가 됩니다."
  syntax:
    content: public void SetAuditRule (System.Security.AccessControl.MutexAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.MutexAuditRule
      description: "The <xref href=&quot;System.Security.AccessControl.MutexAuditRule&quot;></xref> to add. 이 규칙에 의해 지정 된 사용자를이 규칙을 추가 하기 전에 제거 하는 규칙을 결정 합니다."
  overload: System.Security.AccessControl.MutexSecurity.SetAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
references:
- uid: System.Security.AccessControl.NativeObjectSecurity
  isExternal: false
  name: System.Security.AccessControl.NativeObjectSecurity
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.Principal.IdentityNotMappedException
  parent: System.Security.Principal
  isExternal: false
  name: IdentityNotMappedException
  nameWithType: IdentityNotMappedException
  fullName: System.Security.Principal.IdentityNotMappedException
- uid: System.Security.AccessControl.MutexSecurity.#ctor
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: MutexSecurity()
  nameWithType: MutexSecurity.MutexSecurity()
  fullName: System.Security.AccessControl.MutexSecurity.MutexSecurity()
- uid: System.Security.AccessControl.MutexSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: MutexSecurity(String,AccessControlSections)
  nameWithType: MutexSecurity.MutexSecurity(String,AccessControlSections)
  fullName: System.Security.AccessControl.MutexSecurity.MutexSecurity(String,AccessControlSections)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Security.AccessControl.AccessControlSections
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessControlSections
  nameWithType: AccessControlSections
  fullName: System.Security.AccessControl.AccessControlSections
- uid: System.Security.AccessControl.MutexSecurity.AccessRightType
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: AccessRightType
  nameWithType: MutexSecurity.AccessRightType
  fullName: System.Security.AccessControl.MutexSecurity.AccessRightType
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Security.AccessControl.MutexSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: MutexSecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.MutexSecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
- uid: System.Security.AccessControl.AccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessRule
  nameWithType: AccessRule
  fullName: System.Security.AccessControl.AccessRule
- uid: System.Security.Principal.IdentityReference
  parent: System.Security.Principal
  isExternal: false
  name: IdentityReference
  nameWithType: IdentityReference
  fullName: System.Security.Principal.IdentityReference
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.AccessControl.InheritanceFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: InheritanceFlags
  nameWithType: InheritanceFlags
  fullName: System.Security.AccessControl.InheritanceFlags
- uid: System.Security.AccessControl.PropagationFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: PropagationFlags
  nameWithType: PropagationFlags
  fullName: System.Security.AccessControl.PropagationFlags
- uid: System.Security.AccessControl.AccessControlType
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessControlType
  nameWithType: AccessControlType
  fullName: System.Security.AccessControl.AccessControlType
- uid: System.Security.AccessControl.MutexSecurity.AccessRuleType
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: MutexSecurity.AccessRuleType
  fullName: System.Security.AccessControl.MutexSecurity.AccessRuleType
- uid: System.Security.AccessControl.MutexSecurity.AddAccessRule(System.Security.AccessControl.MutexAccessRule)
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: AddAccessRule(MutexAccessRule)
  nameWithType: MutexSecurity.AddAccessRule(MutexAccessRule)
  fullName: System.Security.AccessControl.MutexSecurity.AddAccessRule(MutexAccessRule)
- uid: System.Security.AccessControl.MutexAccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: MutexAccessRule
  nameWithType: MutexAccessRule
  fullName: System.Security.AccessControl.MutexAccessRule
- uid: System.Security.AccessControl.MutexSecurity.AddAuditRule(System.Security.AccessControl.MutexAuditRule)
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: AddAuditRule(MutexAuditRule)
  nameWithType: MutexSecurity.AddAuditRule(MutexAuditRule)
  fullName: System.Security.AccessControl.MutexSecurity.AddAuditRule(MutexAuditRule)
- uid: System.Security.AccessControl.MutexAuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: MutexAuditRule
  nameWithType: MutexAuditRule
  fullName: System.Security.AccessControl.MutexAuditRule
- uid: System.Security.AccessControl.MutexSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: MutexSecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.MutexSecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
- uid: System.Security.AccessControl.AuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditRule
  nameWithType: AuditRule
  fullName: System.Security.AccessControl.AuditRule
- uid: System.Security.AccessControl.AuditFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditFlags
  nameWithType: AuditFlags
  fullName: System.Security.AccessControl.AuditFlags
- uid: System.Security.AccessControl.MutexSecurity.AuditRuleType
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: MutexSecurity.AuditRuleType
  fullName: System.Security.AccessControl.MutexSecurity.AuditRuleType
- uid: System.Security.AccessControl.MutexSecurity.RemoveAccessRule(System.Security.AccessControl.MutexAccessRule)
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: RemoveAccessRule(MutexAccessRule)
  nameWithType: MutexSecurity.RemoveAccessRule(MutexAccessRule)
  fullName: System.Security.AccessControl.MutexSecurity.RemoveAccessRule(MutexAccessRule)
- uid: System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll(System.Security.AccessControl.MutexAccessRule)
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: RemoveAccessRuleAll(MutexAccessRule)
  nameWithType: MutexSecurity.RemoveAccessRuleAll(MutexAccessRule)
  fullName: System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll(MutexAccessRule)
- uid: System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.MutexAccessRule)
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: RemoveAccessRuleSpecific(MutexAccessRule)
  nameWithType: MutexSecurity.RemoveAccessRuleSpecific(MutexAccessRule)
  fullName: System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific(MutexAccessRule)
- uid: System.Security.AccessControl.MutexSecurity.RemoveAuditRule(System.Security.AccessControl.MutexAuditRule)
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: RemoveAuditRule(MutexAuditRule)
  nameWithType: MutexSecurity.RemoveAuditRule(MutexAuditRule)
  fullName: System.Security.AccessControl.MutexSecurity.RemoveAuditRule(MutexAuditRule)
- uid: System.Security.AccessControl.MutexSecurity.RemoveAuditRuleAll(System.Security.AccessControl.MutexAuditRule)
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: RemoveAuditRuleAll(MutexAuditRule)
  nameWithType: MutexSecurity.RemoveAuditRuleAll(MutexAuditRule)
  fullName: System.Security.AccessControl.MutexSecurity.RemoveAuditRuleAll(MutexAuditRule)
- uid: System.Security.AccessControl.MutexSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.MutexAuditRule)
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: RemoveAuditRuleSpecific(MutexAuditRule)
  nameWithType: MutexSecurity.RemoveAuditRuleSpecific(MutexAuditRule)
  fullName: System.Security.AccessControl.MutexSecurity.RemoveAuditRuleSpecific(MutexAuditRule)
- uid: System.Security.AccessControl.MutexSecurity.ResetAccessRule(System.Security.AccessControl.MutexAccessRule)
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: ResetAccessRule(MutexAccessRule)
  nameWithType: MutexSecurity.ResetAccessRule(MutexAccessRule)
  fullName: System.Security.AccessControl.MutexSecurity.ResetAccessRule(MutexAccessRule)
- uid: System.Security.AccessControl.MutexSecurity.SetAccessRule(System.Security.AccessControl.MutexAccessRule)
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: SetAccessRule(MutexAccessRule)
  nameWithType: MutexSecurity.SetAccessRule(MutexAccessRule)
  fullName: System.Security.AccessControl.MutexSecurity.SetAccessRule(MutexAccessRule)
- uid: System.Security.AccessControl.MutexSecurity.SetAuditRule(System.Security.AccessControl.MutexAuditRule)
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: SetAuditRule(MutexAuditRule)
  nameWithType: MutexSecurity.SetAuditRule(MutexAuditRule)
  fullName: System.Security.AccessControl.MutexSecurity.SetAuditRule(MutexAuditRule)
- uid: System.Security.AccessControl.MutexSecurity.#ctor*
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: MutexSecurity
  nameWithType: MutexSecurity.MutexSecurity
- uid: System.Security.AccessControl.MutexSecurity.AccessRightType*
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: AccessRightType
  nameWithType: MutexSecurity.AccessRightType
- uid: System.Security.AccessControl.MutexSecurity.AccessRuleFactory*
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: AccessRuleFactory
  nameWithType: MutexSecurity.AccessRuleFactory
- uid: System.Security.AccessControl.MutexSecurity.AccessRuleType*
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: MutexSecurity.AccessRuleType
- uid: System.Security.AccessControl.MutexSecurity.AddAccessRule*
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: AddAccessRule
  nameWithType: MutexSecurity.AddAccessRule
- uid: System.Security.AccessControl.MutexSecurity.AddAuditRule*
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: AddAuditRule
  nameWithType: MutexSecurity.AddAuditRule
- uid: System.Security.AccessControl.MutexSecurity.AuditRuleFactory*
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: AuditRuleFactory
  nameWithType: MutexSecurity.AuditRuleFactory
- uid: System.Security.AccessControl.MutexSecurity.AuditRuleType*
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: MutexSecurity.AuditRuleType
- uid: System.Security.AccessControl.MutexSecurity.RemoveAccessRule*
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: RemoveAccessRule
  nameWithType: MutexSecurity.RemoveAccessRule
- uid: System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll*
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: RemoveAccessRuleAll
  nameWithType: MutexSecurity.RemoveAccessRuleAll
- uid: System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific*
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: RemoveAccessRuleSpecific
  nameWithType: MutexSecurity.RemoveAccessRuleSpecific
- uid: System.Security.AccessControl.MutexSecurity.RemoveAuditRule*
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: RemoveAuditRule
  nameWithType: MutexSecurity.RemoveAuditRule
- uid: System.Security.AccessControl.MutexSecurity.RemoveAuditRuleAll*
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: RemoveAuditRuleAll
  nameWithType: MutexSecurity.RemoveAuditRuleAll
- uid: System.Security.AccessControl.MutexSecurity.RemoveAuditRuleSpecific*
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: RemoveAuditRuleSpecific
  nameWithType: MutexSecurity.RemoveAuditRuleSpecific
- uid: System.Security.AccessControl.MutexSecurity.ResetAccessRule*
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: ResetAccessRule
  nameWithType: MutexSecurity.ResetAccessRule
- uid: System.Security.AccessControl.MutexSecurity.SetAccessRule*
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: SetAccessRule
  nameWithType: MutexSecurity.SetAccessRule
- uid: System.Security.AccessControl.MutexSecurity.SetAuditRule*
  parent: System.Security.AccessControl.MutexSecurity
  isExternal: false
  name: SetAuditRule
  nameWithType: MutexSecurity.SetAuditRule
