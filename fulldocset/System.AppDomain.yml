### YamlMime:ManagedReference
items:
- uid: System.AppDomain
  id: AppDomain
  children:
  - System.AppDomain.ActivationContext
  - System.AppDomain.AppendPrivatePath(System.String)
  - System.AppDomain.ApplicationIdentity
  - System.AppDomain.ApplicationTrust
  - System.AppDomain.ApplyPolicy(System.String)
  - System.AppDomain.AssemblyLoad
  - System.AppDomain.AssemblyResolve
  - System.AppDomain.BaseDirectory
  - System.AppDomain.ClearPrivatePath
  - System.AppDomain.ClearShadowCopyPath
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.CreateDomain(System.String)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  - System.AppDomain.CreateInstance(System.String,System.String)
  - System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CurrentDomain
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  - System.AppDomain.DomainManager
  - System.AppDomain.DomainUnload
  - System.AppDomain.DynamicDirectory
  - System.AppDomain.Evidence
  - System.AppDomain.ExecuteAssembly(System.String)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssembly(System.String,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssemblyByName(System.String)
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.FirstChanceException
  - System.AppDomain.FriendlyName
  - System.AppDomain.GetAssemblies
  - System.AppDomain.GetCurrentThreadId
  - System.AppDomain.GetData(System.String)
  - System.AppDomain.GetType
  - System.AppDomain.Id
  - System.AppDomain.InitializeLifetimeService
  - System.AppDomain.IsCompatibilitySwitchSet(System.String)
  - System.AppDomain.IsDefaultAppDomain
  - System.AppDomain.IsFinalizingForUnload
  - System.AppDomain.IsFullyTrusted
  - System.AppDomain.IsHomogenous
  - System.AppDomain.Load(System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName)
  - System.AppDomain.Load(System.String)
  - System.AppDomain.Load(System.Byte[],System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  - System.AppDomain.MonitoringIsEnabled
  - System.AppDomain.MonitoringSurvivedMemorySize
  - System.AppDomain.MonitoringSurvivedProcessMemorySize
  - System.AppDomain.MonitoringTotalAllocatedMemorySize
  - System.AppDomain.MonitoringTotalProcessorTime
  - System.AppDomain.PermissionSet
  - System.AppDomain.ProcessExit
  - System.AppDomain.ReflectionOnlyAssemblyResolve
  - System.AppDomain.ReflectionOnlyGetAssemblies
  - System.AppDomain.RelativeSearchPath
  - System.AppDomain.ResourceResolve
  - System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  - System.AppDomain.SetCachePath(System.String)
  - System.AppDomain.SetData(System.String,System.Object)
  - System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  - System.AppDomain.SetDynamicBase(System.String)
  - System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  - System.AppDomain.SetShadowCopyFiles
  - System.AppDomain.SetShadowCopyPath(System.String)
  - System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  - System.AppDomain.SetupInformation
  - System.AppDomain.ShadowCopyFiles
  - System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  - System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.AppDomain.ToString
  - System.AppDomain.TypeResolve
  - System.AppDomain.UnhandledException
  - System.AppDomain.Unload(System.AppDomain)
  langs:
  - csharp
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
  type: Class
  summary: "격리 된 환경 응용 프로그램이 실행 되는 응용 프로그램 도메인을 나타냅니다. 이 클래스는 상속 될 수 없습니다."
  remarks: "AppDomain 개체에 표시 되는 응용 프로그램 도메인을 관리 코드를 실행 하는 것에 대 한 격리, 언로드 및 보안 경계를 제공 합니다.      -프로세스를 중단 시킬 수 있는 작업을 격리 하려면 응용 프로그램 도메인을 사용 합니다. 작업을 실행 하는 AppDomain의 상태가 불안정 해지, AppDomain 언로드할 수는 프로세스에 영향을 주지 않고 합니다. 프로세스 다시 시작 하지 않고 오래 동안 실행 해야 하는 경우에 유용 합니다. 또한 데이터를 공유 해야 하는 작업을 격리 하려면 응용 프로그램 도메인을 사용할 수 있습니다.      -어셈블리를 기본 응용 프로그램 도메인에 로드 하는 경우 프로세스가 실행 되는 동안 메모리에서 언로드할 수 없습니다. 그러나 로드 하 고 어셈블리를 실행 하는 두 번째 응용 프로그램 도메인을 열면 해당 응용 프로그램 도메인이 언로드될 때 어셈블리 로드 않습니다. 이 기술을 사용 하 여 때 큰 Dll을 사용 하 여 장기 실행 프로세스의 작업 집합을 최소화 합니다.       여러 응용 프로그램 도메인은 단일 프로세스;에서 실행할 수 있습니다. 그러나 응용 프로그램 도메인과 스레드 간에 일대일 상관 하지 않습니다. 여러 스레드는 단일 응용 프로그램 도메인에 속할 수 있습니다 및 단일 응용 프로그램 도메인에 스레드를 실행 하는 동안 지정된 된 스레드가 지정된 된 시간에는 단일 응용 프로그램 도메인으로 제한 되지 않습니다.       사용 하 여 응용 프로그램 도메인이 만들어집니다는 <xref:System.AppDomain.CreateDomain%2A>메서드.</xref:System.AppDomain.CreateDomain%2A> AppDomain 인스턴스 로드 하 고 어셈블리를 실행 하는 데 사용 됩니다 (<xref:System.Reflection.Assembly>).</xref:System.Reflection.Assembly> AppDomain 더 이상 사용 중일 때 로드 되지 않습니다 수 없습니다.       AppDomain 클래스에는 응용 프로그램이 응용 프로그램 도메인이 언로드되면, 또는 처리 되지 않은 예외가 throw 되 면 어셈블리를 로드할 때 응답할 수 있도록 하는 이벤트 집합을 구현 합니다.       응용 프로그램 도메인 사용에 대 한 자세한 내용은 참조 하십시오. [응용 프로그램 도메인](~/add/includes/ajax-current-ext-md.md)합니다.       이 클래스가 구현 하는 <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, 및 <xref:System.Security.IEvidenceFactory>인터페이스.</xref:System.Security.IEvidenceFactory> </xref:System._AppDomain> </xref:System.MarshalByRefObject>       AppDomain 개체에 대 한 원격 가능 래퍼를 만들지 마십시오. 이렇게 하면와 같은 메서드를 노출 하는 AppDomain에 대 한 원격 참조를 게시할 수 <xref:System.AppDomain.CreateInstance%2A>원격 액세스 및 AppDomain에 대 한 코드 액세스 보안을 효과적으로 제거 합니다.</xref:System.AppDomain.CreateInstance%2A> 원격으로 실행할 AppDomain에 연결 되는 악성 클라이언트 자체는 AppDomain에 액세스할 수 있는 리소스에 대 한 액세스를 얻을 수 있습니다. 확장 하는 모든 형식에 대 한 원격 가능 래퍼를 만들지 마십시오 <xref:System.MarshalByRefObject>보안 시스템을 무시 하는 악의적인 클라이언트가 사용할 수 있는 메서드를 구현 하 고.</xref:System.MarshalByRefObject>      > [!CAUTION] >에 대 한 기본값은 <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>속성은 `false`.</xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName> 이 설정은 서비스에 대 한 안전 하지 않습니다. 서비스에서 부분적으로 신뢰할 수 있는 코드가 다운로드를 방지 하려면이 속성을 설정 `true`합니다."
  example:
  - "This example shows how to create a new AppDomain, instantiate a type in that new AppDomain, and communicate with that type’s object. In addition, this example shows how to unload the AppDomain causing the object to be garbage collected.  \n  \n [!code-vb[AppDomainX#1](~/add/codesnippet/visualbasic/t-system.appdomain_1.vb)]\n [!code-cs[AppDomainX#1](~/add/codesnippet/csharp/t-system.appdomain_1.cs)]\n [!code-cpp[AppDomainX#1](~/add/codesnippet/cpp/t-system.appdomain_1.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  implements:
  - System._AppDomain
  - System.Security.IEvidenceFactory
  inheritedMembers:
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.AppDomain.ActivationContext
  id: ActivationContext
  parent: System.AppDomain
  langs:
  - csharp
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "현재 응용 프로그램 도메인에 대해 활성화 컨텍스트를 가져옵니다."
  syntax:
    content: public ActivationContext ActivationContext { get; }
    return:
      type: System.ActivationContext
      description: "현재 응용 프로그램 도메인의 활성화 컨텍스트를 나타내는 개체 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 도메인에 활성화 컨텍스트가 없는 경우."
  overload: System.AppDomain.ActivationContext*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AppendPrivatePath(System.String)
  id: AppendPrivatePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정 된 디렉터리 이름을 전용 경로 목록에 추가 합니다."
  remarks: "이 속성의 사용에 이미 로드 된 후 어셈블리 검색 경로 변경 될 수 있으므로 권장 되지 않습니다. 사용 하 여 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>속성 대신.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>       전용 경로 또는 상대 검색 경로 어셈블리 확인자에서 전용 어셈블리를 조사 하는 위치는 기본 디렉터리에 상대적인 경로입니다."
  syntax:
    content: public void AppendPrivatePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "전용 경로에 추가 되는 디렉터리의 이름입니다."
  overload: System.AppDomain.AppendPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.ApplicationIdentity
  id: ApplicationIdentity
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "응용 프로그램 도메인에서 응용 프로그램의 id를 가져옵니다."
  syntax:
    content: public ApplicationIdentity ApplicationIdentity { get; }
    return:
      type: System.ApplicationIdentity
      description: "응용 프로그램 도메인에서 응용 프로그램을 식별 하는 개체입니다."
  overload: System.AppDomain.ApplicationIdentity*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplicationTrust
  id: ApplicationTrust
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "응용 프로그램 및 응용 프로그램을 실행할 수 있게 하는 신뢰 수준에 있는지 여부에 부여 된 사용 권한을 설명 하는 정보를 가져옵니다."
  syntax:
    content: public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }
    return:
      type: System.Security.Policy.ApplicationTrust
      description: "응용 프로그램 도메인에서 응용 프로그램에 대 한 권한과 신뢰 정보를 캡슐화 하는 개체입니다."
  overload: System.AppDomain.ApplicationTrust*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplyPolicy(System.String)
  id: ApplyPolicy(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "정책이 적용 된 후 어셈블리 표시 이름을 반환 합니다."
  remarks: "메서드는 어셈블리를 사용 하며 ApplyPolicy 표시 이름, 사후 정책 표시 이름을 반환 합니다. 리플렉션 전용 컨텍스트에 정책을 적용 하지 않습니다 때문에 정책을 사용 하 여 어셈블리를 로드 해야 할 경우에 유용 합니다."
  syntax:
    content: public string ApplyPolicy (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "제공 하는 형식에서 표시 이름, 어셈블리는 &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt; 속성입니다."
    return:
      type: System.String
      description: "정책이 적용 된 후 이름을 표시 하는 어셈블리를 포함 하는 문자열입니다."
  overload: System.AppDomain.ApplyPolicy*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyLoad
  id: AssemblyLoad
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "어셈블리가 로드 될 때 발생 합니다."
  remarks: "<xref:System.AssemblyLoadEventHandler>대리자이 이벤트는 어떤 어셈블리가 로드 되었는지 나타냅니다.</xref:System.AssemblyLoadEventHandler>       이 이벤트에 대 한 이벤트 처리기를 등록 하려면 필요한 사용 권한이 있어야 또는 <xref:System.Security.SecurityException>throw 됩니다.</xref:System.Security.SecurityException>       이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following sample demonstrates the AssemblyLoad event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_AssemblyLoad#1](~/add/codesnippet/csharp/e-system.appdomain.assem_1_1.cs)]\n [!code-vb[AppDomain_AssemblyLoad#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_1_1.vb)]\n [!code-cpp[AppDomain_AssemblyLoad#1](~/add/codesnippet/cpp/e-system.appdomain.assem_1_1.cpp)]"
  syntax:
    content: public event AssemblyLoadEventHandler AssemblyLoad;
    return:
      type: System.AssemblyLoadEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyResolve
  id: AssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "어셈블리 확인이 실패 하면 발생 합니다."
  remarks: "책임은 <xref:System.ResolveEventHandler>는 어셈블리를 반환 하 여 지정 된이 이벤트에 대 한는 <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>속성 또는 어셈블리가 인식 되지 않으면 null을 반환 합니다.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> </xref:System.ResolveEventHandler> 어셈블리는 실행 컨텍스트에 로드 해야 합니다. 리플렉션 전용 컨텍스트에 로드 하는 경우이 이벤트를 발생 시킨 로드는 실패 합니다.       이 이벤트의 사용에 대 한 지침을 참조 하십시오. [어셈블리 로드 해결](~/add/includes/ajax-current-ext-md.md)합니다.       부터는 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>속성을 확인할 수 없는 어셈블리 로드를 요청한 어셈블리를 반환 합니다.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> 예를 들어 로더 수 요청 어셈블리와 해당 종속성 검색 경로에 없기 때문에 요청한 어셈블리의 종속성을 로드할 수 없습니다. 요청한 어셈블리의 id를 알면 종속성의 둘 이상의 버전을 사용할 수 있는 경우 올바른 버전을 확인 또는 종속성을 찾거나에 유용할 수 있습니다. 자세한 내용은 <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> 을 참조 하십시오.      > [!IMPORTANT] > 부터는 [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], <xref:System.ResolveEventHandler>리소스 어셈블리를 포함 하는 모든 어셈블리에 대 한 이벤트가 발생 합니다.</xref:System.ResolveEventHandler> 이전 버전에서는 리소스 어셈블리에 대 한 이벤트가 발생 하지 않습니다. 운영 체제에 지역화 된 처리기에 여러 번 호출할 수 있습니다: 대체 (fallback) 체인의 각 문화권에 대해 한 번씩입니다.       이 이벤트는 <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>속성 정책 적용 하기 전에 어셈블리 이름을 반환 합니다.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>      > [!IMPORTANT] > 둘 이상의 이벤트 처리기가이 이벤트에 대 한 등록을 하는 경우 이벤트 처리기는 값을 반환할 때까지 순서 대로 이벤트 handlersarecalled 반드시 그럴 `null`합니다. 후속 이벤트 처리기는 무시 됩니다.       이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following sample demonstrates the AssemblyResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cpp[AssemblyResolve#1](~/add/codesnippet/cpp/e-system.appdomain.assem_0_1.cpp)]\n [!code-cs[AssemblyResolve#1](~/add/codesnippet/csharp/e-system.appdomain.assem_0_1.cs)]\n [!code-vb[AssemblyResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_0_1.vb)]"
  syntax:
    content: public event ResolveEventHandler AssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.BaseDirectory
  id: BaseDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "어셈블리 확인자에서 사용 하 여 어셈블리를 조사 하는 기본 디렉터리를 가져옵니다."
  remarks: "이 속성에 해당 하는 <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>속성.</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> 또한 검색할 수 있습니다를 사용 하는 <xref:System.AppDomain.GetData%2A>메서드에 &quot;APPBASE&quot; 문자열.</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain. The example then uses the BaseDirectory property to obtain the base directory path, for display to the console.  \n  \n [!code-cs[ADSetup#1](~/add/codesnippet/csharp/p-system.appdomain.based_1.cs)]\n [!code-cpp[ADSetup#1](~/add/codesnippet/cpp/p-system.appdomain.based_1.cpp)]\n [!code-vb[ADSetup#1](~/add/codesnippet/visualbasic/p-system.appdomain.based_1.vb)]"
  syntax:
    content: public string BaseDirectory { get; }
    return:
      type: System.String
      description: "어셈블리 확인자에서 어셈블리를 조사 사용 되는 기본 디렉터리입니다."
  overload: System.AppDomain.BaseDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.ClearPrivatePath
  id: ClearPrivatePath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "빈 문자열을 전용 어셈블리의 위치를 지정 하는 경로 다시 설정 (&quot;&quot;)."
  remarks: "전용 경로 공용 언어 런타임에서 전용 어셈블리를 찾는 검색 하는 기본 디렉터리의 상대 경로입니다.       자세한 내용은 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName> 을 참조 하십시오."
  example:
  - "The following code example demonstrates how to use the ClearPrivatePath method to remove all entries from the list of private paths to search when assemblies are loaded.  \n  \n This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADClearPrivatePath#1](~/add/codesnippet/cpp/m-system.appdomain.clear_1.cpp)]\n [!code-cs[ADClearPrivatePath#1](~/add/codesnippet/csharp/m-system.appdomain.clear_1.cs)]\n [!code-vb[ADClearPrivatePath#1](~/add/codesnippet/visualbasic/m-system.appdomain.clear_1.vb)]"
  syntax:
    content: public void ClearPrivatePath ();
    parameters: []
  overload: System.AppDomain.ClearPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.ClearShadowCopyPath
  id: ClearShadowCopyPath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "섀도 복사 된 어셈블리를 빈 문자열을 포함 하는 디렉터리 목록을 다시 설정 (&quot;&quot;)."
  remarks: "섀도 복사본 경로가 어셈블리 섀도 복사 디렉터리의 목록이 저장 됩니다.       자세한 내용은 참조 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>및 [어셈블리 섀도 복사](~/add/includes/ajax-current-ext-md.md).</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>"
  syntax:
    content: public void ClearShadowCopyPath ();
    parameters: []
  overload: System.AppDomain.ClearShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  id: CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 COM 형식의 새 인스턴스를 만듭니다. 매개 변수 형식을 포함 하는 어셈블리가 포함 된 파일의 이름 및 형식의 이름을 지정 합니다."
  remarks: "이 메서드를 사용 하 여 형식을 로컬로 로드할 필요 없이 개체를 원격으로 만들려는 합니다.       반환 값은 래핑되지 실제 개체에 액세스 해야 합니다.       A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName> 의 값을 가진 특성 `true` ; 해당 형식의 인스턴스를 만들려면이 메서드에 대 한 COM 형식으로 명시적으로 나 기본적으로 적용할 해야 그렇지 <xref:System.TypeLoadException>throw 됩니다.</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  example:
  - "The following sample demonstrates  \n  \n [!code-cs[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/csharp/m-system.appdomain.creat_4_1.cs)]\n [!code-vb[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_4_1.vb)]\n [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/cpp/m-system.appdomain.creat_4_1.cpp)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "요청된 된 형식을 정의 하는 어셈블리를 포함 하는 파일의 이름입니다."
    - id: typeName
      type: System.String
      description: "요청 된 형식의 이름입니다."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "지정한 새 인스턴스의 래퍼인 개체 <code> typeName </code>합니다. 반환 값은 실제 개체에 액세스 하기 위해 래핑이 있어야 합니다."
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "형식을 로드할 수 없습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "매개 변수가 없는 public 생성자가 없습니다 찾았습니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>´ ù."
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>클래스는 추상 클래스는입니다.       -또는-이 멤버가 런타임에 바인딩 메커니즘으로 호출 되었습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "호출자에서 상속 되지 않는 개체에 대 한 활성화 특성을 제공할 수 없는 <xref href=&quot;System.MarshalByRefObject&quot;> </xref>합니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyName</code>빈 문자열 (&quot;&quot;)."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>유효한 어셈블리가 않습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "참조 되는 COM 개체는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 COM 형식의 새 인스턴스를 만듭니다. 매개 변수 형식을 포함 하는 어셈블리가 포함 된 파일의 이름 및 형식의 이름을 지정 합니다."
  remarks: "이 메서드를 사용 하 여 형식을 로컬로 로드할 필요 없이 개체를 원격으로 만들려는 합니다.       반환 값은 래핑되지 실제 개체에 액세스 해야 합니다.       A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>의 값을 가진 특성 `true` ; 해당 형식의 인스턴스를 만들려면이 메서드에 대 한 COM 형식으로 명시적으로 나 기본적으로 적용할 해야 그렇지 <xref:System.TypeLoadException>throw 됩니다.</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "요청된 된 형식을 정의 하는 어셈블리를 포함 하는 파일의 이름입니다."
    - id: typeName
      type: System.String
      description: "요청 된 형식의 이름입니다."
    - id: hashValue
      type: System.Byte[]
      description: "계산된 된 해시 코드 값을 나타냅니다."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "어셈블리 매니페스트에 사용 되는 해시 알고리즘을 나타냅니다."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "지정한 새 인스턴스의 래퍼인 개체 <code> typeName </code>합니다. 반환 값은 실제 개체에 액세스 하기 위해 래핑이 있어야 합니다."
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "형식을 로드할 수 없습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "매개 변수가 없는 public 생성자가 없습니다 찾았습니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>´ ù."
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>클래스는 추상 클래스는입니다.       -또는-이 멤버가 런타임에 바인딩 메커니즘으로 호출 되었습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "호출자에서 상속 되지 않는 개체에 대 한 활성화 특성을 제공할 수 없는 <xref href=&quot;System.MarshalByRefObject&quot;> </xref>합니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyFile</code>가 빈 문자열 (&quot;&quot;)."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>유효한 어셈블리가 않습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "참조 되는 COM 개체는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String)
  id: CreateDomain(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 이름을 가진 새 응용 프로그램 도메인을 만듭니다."
  remarks: "`friendlyName` 매개 변수는 사용자에 게 의미 있는 방식으로 도메인을 식별 하기 위한 것이 있습니다. 이 문자열은 사용자 인터페이스에 표시 하기에 적합 해야 합니다.       이 메서드 오버 로드는 <xref:System.AppDomainSetup>기본 응용 프로그램 도메인에서 정보.</xref:System.AppDomainSetup>"
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_1_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_1_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_1_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName);
    parameters:
    - id: friendlyName
      type: System.String
      description: "도메인의 이름입니다."
    return:
      type: System.AppDomain
      description: "새로 만든된 응용 프로그램 도메인입니다."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  id: CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "제공 된 증명 정보를 사용 하 여 지정한 이름을 가진 새 응용 프로그램 도메인을 만듭니다."
  remarks: "This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the CreateDomain overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_0_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_0_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_0_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);
    parameters:
    - id: friendlyName
      type: System.String
      description: "도메인의 이름입니다. 이 이름은 도메인을 식별 하기 위해 사용자 인터페이스에 표시할 수 있습니다. 자세한 내용은 <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*> 을 참조 하십시오."
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "응용 프로그램 도메인에서 실행 되는 코드의 id를 설정 하는 증명 정보입니다. 전달 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 를 현재 응용 프로그램 도메인의 증거를 사용 합니다."
    return:
      type: System.AppDomain
      description: "새로 만든된 응용 프로그램 도메인입니다."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 이름, 증명 정보 및 응용 프로그램 도메인 설치 정보를 사용 하 여 새 응용 프로그램 도메인을 만듭니다."
  remarks: "If `info` is not supplied, this method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/f22a5c12-7605-4011-8d1c-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/f22a5c12-7605-4011-8d1c-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/f22a5c12-7605-4011-8d1c-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);
    parameters:
    - id: friendlyName
      type: System.String
      description: "도메인의 이름입니다. 이 이름은 도메인을 식별 하기 위해 사용자 인터페이스에 표시할 수 있습니다. 자세한 내용은 <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*> 을 참조 하십시오."
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "응용 프로그램 도메인에서 실행 되는 코드의 id를 설정 하는 증명 정보입니다. 전달 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 를 현재 응용 프로그램 도메인의 증거를 사용 합니다."
    - id: info
      type: System.AppDomainSetup
      description: "응용 프로그램 도메인 초기화 정보를 포함 하는 개체입니다."
    return:
      type: System.AppDomain
      description: "새로 만든된 응용 프로그램 도메인입니다."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 이름, 증명 정보, 응용 프로그램 도메인 설치 정보, 기본 권한 집합 및 완전히 신뢰할 수 있는 어셈블리의 배열을 사용 하 여 새 응용 프로그램 도메인을 만듭니다."
  remarks: "설정 해야 합니다는 <xref:System.AppDomainSetup.ApplicationBase%2A>의 속성은 <xref:System.AppDomainSetup>에 대해 제공 하는 개체 `info`.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ApplicationBase%2A> 그렇지 않으면 예외가 throw 됩니다.       경우 `securityInfo` 가 제공 되지 않으면 현재 응용 프로그램 도메인의 증명 사용 됩니다.       에 제공 된 정보의 `grantSet` 및 `fullTrustAssemblies` 만드는 데 사용 되는 <xref:System.Security.Policy.ApplicationTrust>새 응용 프로그램 도메인에 대 한 개체입니다.</xref:System.Security.Policy.ApplicationTrust>"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, System.Security.Policy.StrongName[] fullTrustAssemblies);
    parameters:
    - id: friendlyName
      type: System.String
      description: "도메인의 이름입니다. 이 이름은 도메인을 식별 하기 위해 사용자 인터페이스에 표시할 수 있습니다. 자세한 내용은 <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*> 설명은 참조 하십시오."
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "응용 프로그램 도메인에서 실행 되는 코드의 id를 설정 하는 증명 정보입니다. 전달 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 를 현재 응용 프로그램 도메인의 증거를 사용 합니다."
    - id: info
      type: System.AppDomainSetup
      description: "응용 프로그램 도메인 초기화 정보를 포함 하는 개체입니다."
    - id: grantSet
      type: System.Security.PermissionSet
      description: "기본 권한 집합을 부여 된 모든 어셈블리에 로드 특정 권한이 없는 새 응용 프로그램 도메인입니다."
    - id: fullTrustAssemblies
      type: System.Security.Policy.StrongName[]
      description: "완전히 간주할 어셈블리를 나타내는 강력한 이름의 배열을 새 응용 프로그램 도메인에서 신뢰할 수 있는 합니다."
    return:
      type: System.AppDomain
      description: "새로 만든된 응용 프로그램 도메인입니다."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "응용 프로그램 도메인이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다.       -또는- <xref:System.AppDomainSetup.ApplicationBase*>속성에 설정 되어 있지는 <xref href=&quot;System.AppDomainSetup&quot;> </xref> 개체에 대해 제공한 <code> info </code>.</xref:System.AppDomainSetup.ApplicationBase*>"
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "증명 정보, 응용 프로그램 기본 경로, 상대 검색 경로 및 어셈블리의 섀도 복사본이 응용 프로그램 도메인에 로드 되는지를 지정 하는 매개 변수를 사용 하 여 지정 된 이름의 새 응용 프로그램 도메인을 만듭니다."
  remarks: "If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/9bed52ed-b275-4e3a-b9e6-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/9bed52ed-b275-4e3a-b9e6-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/9bed52ed-b275-4e3a-b9e6-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);
    parameters:
    - id: friendlyName
      type: System.String
      description: "도메인의 이름입니다. 이 이름은 도메인을 식별 하기 위해 사용자 인터페이스에 표시할 수 있습니다. 자세한 내용은 <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*> 을 참조 하십시오."
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "응용 프로그램 도메인에서 실행 되는 코드의 id를 설정 하는 증명 정보입니다. 전달 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 를 현재 응용 프로그램 도메인의 증거를 사용 합니다."
    - id: appBasePath
      type: System.String
      description: "어셈블리 확인자에서 어셈블리를 조사 사용 되는 기본 디렉터리입니다. 자세한 내용은 <xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*> 을 참조 하십시오."
    - id: appRelativeSearchPath
      type: System.String
      description: "전용 어셈블리를 어셈블리 확인자에서 조사할 기본 디렉터리는 상대 경로입니다. 자세한 내용은 <xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*> 을 참조 하십시오."
    - id: shadowCopyFiles
      type: System.Boolean
      description: "경우 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, 어셈블리의 섀도 복사본이이 응용 프로그램 도메인에 로드 됩니다."
    return:
      type: System.AppDomain
      description: "새로 만든된 응용 프로그램 도메인입니다."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "증명 정보, 응용 프로그램 기본 경로, 상대 검색 경로 및 어셈블리의 섀도 복사본이 응용 프로그램 도메인에 로드 되는지를 지정 하는 매개 변수를 사용 하 여 지정 된 이름의 새 응용 프로그램 도메인을 만듭니다. 응용 프로그램 도메인이 초기화 될 때 호출 되는 콜백 메서드와 콜백 메서드를 전달할 문자열 인수의 배열을 지정 합니다."
  remarks: "The method represented by `adInit` is executed in the context of the newly created application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);
    parameters:
    - id: friendlyName
      type: System.String
      description: "도메인의 이름입니다. 이 이름은 도메인을 식별 하기 위해 사용자 인터페이스에 표시할 수 있습니다. 자세한 내용은 <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*> 을 참조 하십시오."
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "응용 프로그램 도메인에서 실행 되는 코드의 id를 설정 하는 증명 정보입니다. 전달 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 를 현재 응용 프로그램 도메인의 증거를 사용 합니다."
    - id: appBasePath
      type: System.String
      description: "어셈블리 확인자에서 어셈블리를 조사 사용 되는 기본 디렉터리입니다. 자세한 내용은 <xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*> 을 참조 하십시오."
    - id: appRelativeSearchPath
      type: System.String
      description: "전용 어셈블리를 어셈블리 확인자에서 조사할 기본 디렉터리는 상대 경로입니다. 자세한 내용은 <xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*> 을 참조 하십시오."
    - id: shadowCopyFiles
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>어셈블리의 섀도 복사본이 응용 프로그램 도메인에 로드 합니다."
    - id: adInit
      type: System.AppDomainInitializer
      description: "<xref href=&quot;System.AppDomainInitializer&quot;> </xref> 될 때 호출할 콜백 메서드를 나타내는 대리자 새 <xref href=&quot;System.AppDomain&quot;> </xref> 개체가 초기화 되었습니다."
    - id: adInitArgs
      type: System.String[]
      description: "배열에서 나타내는 콜백으로 전달할 문자열 인수의 `adInit`때 새 <xref href=&quot;System.AppDomain&quot;> </xref> 개체가 초기화 합니다."
    return:
      type: System.AppDomain
      description: "새로 만든된 응용 프로그램 도메인입니다."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  id: CreateInstance(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정된 된 어셈블리에 정의 된 지정 된 형식의 새 인스턴스를 만듭니다."
  remarks: "이 메서드 호출에 대 한 기본 생성자 `typeName`합니다.       참조 <xref:System.Reflection.AssemblyName>형식의 `assemblyName`.</xref:System.Reflection.AssemblyName>       대상 응용 프로그램 도메인에 있는 어셈블리의 성공적인 부하를 CreateInstance은 현재 어플리케이션 도메인 되지 않은 대상 응용 프로그램 도메인에서 호출 하려는 경우 발생 합니다. 이후는 <xref:System.Reflection.Assembly>않습니다 <xref:System.MarshalByRefObject>이 메서드를 반환 하려고 시도 하는 경우는 <xref:System.Reflection.Assembly>은 현재 어플리케이션 도메인에 로드 된 어셈블리에 대 한 공용 언어 런타임은 하려고은 현재 어플리케이션 도메인에 어셈블리를 로드 및 로드가 실패할 수 있습니다.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> 현재 어플리케이션 도메인에 로드 된 어셈블리는 두 응용 프로그램 도메인에 대 한 경로 설정을 서로 다른 경우 먼저 로드 된 어셈블리와 다를 수 있습니다."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "어셈블리의 표시 이름입니다. 참조 &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;합니다."
    - id: typeName
      type: System.String
      description: "반환 된 네임 스페이스만 어셈블리가 아닌 포함 하 여 요청 된 형식의 정규화 된 이름에서 &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; 속성입니다."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "지정한 새 인스턴스의 래퍼인 개체 <code> typeName </code>합니다. 반환 값은 실제 개체에 액세스 하기 위해 래핑이 있어야 합니다."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyName</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>찾을 수 없습니다."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "호출자에 게가이 생성자를 호출할 수 있는 권한이 없습니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "일치 하는 공용 생성자가 없습니다 찾았습니다."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>찾을 수 없습니다 <code>assemblyName</code>합니다."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "이 인스턴스는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  id: CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정된 된 어셈블리에 정의 된 지정 된 형식의 새 인스턴스를 만듭니다. 매개 변수는 활성화 특성의 배열을 지정 합니다."
  remarks: "이 메서드 호출에 대 한 기본 생성자 `typeName`합니다.       참조 <xref:System.Reflection.AssemblyName>형식의 `assemblyName`.</xref:System.Reflection.AssemblyName>       호출 하려고 <xref:System.AppDomain.CreateInstance%2A>응용 프로그램 도메인은 현재 어플리케이션 도메인에 없는 대상에 대상 응용 프로그램 도메인에 있는 어셈블리의 성공적인 로드 발생 합니다.</xref:System.AppDomain.CreateInstance%2A> 이후는 <xref:System.Reflection.Assembly>않습니다 <xref:System.MarshalByRefObject>이 메서드를 반환 하려고 시도 하는 경우는 <xref:System.Reflection.Assembly>은 현재 어플리케이션 도메인에 로드 된 어셈블리에 대 한 공용 언어 런타임은 하려고은 현재 어플리케이션 도메인에 어셈블리를 로드 및 로드가 실패할 수 있습니다.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> 현재 어플리케이션 도메인에 로드 된 어셈블리는 두 응용 프로그램 도메인에 대 한 경로 설정을 서로 다른 경우 먼저 로드 된 어셈블리와 다를 수 있습니다."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "어셈블리의 표시 이름입니다. 참조 &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;합니다."
    - id: typeName
      type: System.String
      description: "반환 된 네임 스페이스만 어셈블리가 아닌 포함 하 여 요청 된 형식의 정규화 된 이름에서 &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; 속성입니다."
    - id: activationAttributes
      type: System.Object[]
      description: "활성화에 참여할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로 포함 된 배열을 단일 <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> 원격 개체를 활성화 하는 데 필요한 URL을 지정 하는 개체입니다.       이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과 호환성을 위해 유지 되지만 새로운 개발에 권장 되지 않습니다는 레거시 기술입니다. 분산된 응용 프로그램 Windows Communication Foundation을 사용 해야 합니다."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "지정한 새 인스턴스의 래퍼인 개체 <code> typeName </code>합니다. 반환 값은 실제 개체에 액세스 하기 위해 래핑이 있어야 합니다."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyName</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>찾을 수 없습니다."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "호출자에 게가이 생성자를 호출할 수 있는 권한이 없습니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "일치 하는 공용 생성자가 없습니다 찾았습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "호출자에서 상속 되지 않는 개체에 대 한 활성화 특성을 제공할 수 없는 <xref href=&quot;System.MarshalByRefObject&quot;> </xref>합니다."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>찾을 수 없습니다 <code>assemblyName</code>합니다."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "이 인스턴스는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정된 된 어셈블리에 정의 된 지정 된 형식의 새 인스턴스를 만듭니다. 매개 변수는 바인더, 바인딩 플래그, 생성자 인수, 인수 및 선택적 활성화 특성을 해석 하는 데 사용 되는 culture 관련 정보를 지정 합니다."
  remarks: "참조 <xref:System.Reflection.AssemblyName>형식의 `assemblyName`.</xref:System.Reflection.AssemblyName>       호출 하려고 <xref:System.AppDomain.CreateInstance%2A>응용 프로그램 도메인은 현재 어플리케이션 도메인에 없는 대상에 대상 응용 프로그램 도메인에 있는 어셈블리의 성공적인 로드 발생 합니다.</xref:System.AppDomain.CreateInstance%2A> 이후는 <xref:System.Reflection.Assembly>않습니다 <xref:System.MarshalByRefObject>이 메서드를 반환 하려고 시도 하는 경우는 <xref:System.Reflection.Assembly>은 현재 어플리케이션 도메인에 로드 된 어셈블리에 대 한 공용 언어 런타임은 하려고은 현재 어플리케이션 도메인에 어셈블리를 로드 및 로드가 실패할 수 있습니다.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> 현재 어플리케이션 도메인에 로드 된 어셈블리는 두 응용 프로그램 도메인에 대 한 경로 설정을 서로 다른 경우 먼저 로드 된 어셈블리와 다를 수 있습니다."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "어셈블리의 표시 이름입니다. 참조 &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;합니다."
    - id: typeName
      type: System.String
      description: "반환 된 네임 스페이스만 어셈블리가 아닌 포함 하 여 요청 된 형식의 정규화 된 이름에서 &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; 속성입니다."
    - id: ignoreCase
      type: System.Boolean
      description: "대/소문자 구분 검색을 수행할지 여부를 지정 하는 부울 값입니다."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "에 대 한 검색에 영향을 미치는&0; 또는 그 이상의 비트 플래그의 조합 된 `typeName` 생성자입니다. 경우 `bindingAttr` 수행 하는 public 생성자가&0; 이면 대/소문자 구분 검색 합니다."
    - id: binder
      type: System.Reflection.Binder
      description: "바인딩, 인수 강제 변환 하는 개체 형식, 멤버 호출 및 검색 <xref:System.Reflection.MemberInfo>리플렉션을 사용 하 여 개체.</xref:System.Reflection.MemberInfo> 경우 `binder` 가 null 이면 기본 바인더가 사용 됩니다."
    - id: args
      type: System.Object[]
      description: "생성자에 전달할 인수입니다. 이 인수 배열은 호출할 생성자의 매개 변수를 입력 및 번호, 순서 일치 해야 합니다. 기본 생성자가 기본 방법 `args` 빈 배열 이거나 null 이어야 합니다."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "강제 변환을 제어 하는 문화권별 정보 `args` 에 대해 선언 된 공식적인 형식에는 `typeName` 생성자입니다. 경우 `culture` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>현재 스레드가 사용 됩니다.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "활성화에 참여할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로 포함 된 배열을 단일 <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> 원격 개체를 활성화 하는 데 필요한 URL을 지정 하는 개체입니다.       이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과 호환성을 위해 유지 되지만 새로운 개발에 권장 되지 않습니다는 레거시 기술입니다. 분산된 응용 프로그램 Windows Communication Foundation을 사용 해야 합니다."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "지정한 새 인스턴스의 래퍼인 개체 <code> typeName </code>합니다. 반환 값은 실제 개체에 액세스 하기 위해 래핑이 있어야 합니다."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>유효한 어셈블리가 않습니다.       -또는- <code>assemblyName</code> 공용 언어 런타임이 현재 로드 되어 있는 버전 보다 이후 버전으로 컴파일 되었습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>찾을 수 없습니다."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "호출자에 게가이 생성자를 호출할 수 있는 권한이 없습니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "일치 하는 생성자를 찾을 수 있습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "호출자에서 상속 되지 않는 개체에 대 한 활성화 특성을 제공할 수 없는 <xref href=&quot;System.MarshalByRefObject&quot;> </xref>합니다."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>찾을 수 없습니다 <code>assemblyName</code>합니다."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "이 인스턴스는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정된 된 어셈블리에 정의 된 지정 된 형식의 새 인스턴스를 만듭니다. 매개 변수는 바인더, 바인딩 플래그, 생성자 인수, 인수, 활성화 특성 및 형식을 만들기 위한 인증을 해석 하는 데 사용 되는 culture 관련 정보를 지정 합니다."
  remarks: "참조 <xref:System.Reflection.AssemblyName>형식의 `assemblyName`.</xref:System.Reflection.AssemblyName>       호출 하려고 <xref:System.AppDomain.CreateInstance%2A>응용 프로그램 도메인은 현재 어플리케이션 도메인에 없는 대상에 대상 응용 프로그램 도메인에 있는 어셈블리의 성공적인 로드 발생 합니다.</xref:System.AppDomain.CreateInstance%2A> 이후는 <xref:System.Reflection.Assembly>않습니다 <xref:System.MarshalByRefObject>이 메서드를 반환 하려고 시도 하는 경우는 <xref:System.Reflection.Assembly>은 현재 어플리케이션 도메인에 로드 된 어셈블리에 대 한 공용 언어 런타임은 하려고은 현재 어플리케이션 도메인에 어셈블리를 로드 및 로드가 실패할 수 있습니다.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> 현재 어플리케이션 도메인에 로드 된 어셈블리는 두 응용 프로그램 도메인에 대 한 경로 설정을 서로 다른 경우 먼저 로드 된 어셈블리와 다를 수 있습니다."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "어셈블리의 표시 이름입니다. 참조 &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;합니다."
    - id: typeName
      type: System.String
      description: "반환 된 네임 스페이스만 어셈블리가 아닌 포함 하 여 요청 된 형식의 정규화 된 이름에서 &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; 속성입니다."
    - id: ignoreCase
      type: System.Boolean
      description: "대/소문자 구분 검색을 수행할지 여부를 지정 하는 부울 값입니다."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "에 대 한 검색에 영향을 미치는&0; 또는 그 이상의 비트 플래그의 조합 된 `typeName` 생성자입니다. 경우 `bindingAttr` 수행 하는 public 생성자가&0; 이면 대/소문자 구분 검색 합니다."
    - id: binder
      type: System.Reflection.Binder
      description: "바인딩, 인수 강제 변환 하는 개체 형식, 멤버 호출 및 검색 <xref:System.Reflection.MemberInfo>리플렉션을 사용 하 여 개체.</xref:System.Reflection.MemberInfo> 경우 `binder` 가 null 이면 기본 바인더가 사용 됩니다."
    - id: args
      type: System.Object[]
      description: "생성자에 전달할 인수입니다. 이 인수 배열은 호출할 생성자의 매개 변수를 입력 및 번호, 순서 일치 해야 합니다. 기본 생성자가 기본 방법 `args` 빈 배열 이거나 null 이어야 합니다."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "강제 변환을 제어 하는 문화권별 정보 `args` 에 대해 선언 된 공식적인 형식에는 `typeName` 생성자입니다. 경우 `culture` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>현재 스레드가 사용 됩니다.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "활성화에 참여할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로 포함 된 배열을 단일 <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> 원격 개체를 활성화 하는 데 필요한 URL을 지정 하는 개체입니다.       이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과 호환성을 위해 유지 되지만 새로운 개발에 권장 되지 않습니다는 레거시 기술입니다. 분산된 응용 프로그램 Windows Communication Foundation을 사용 해야 합니다."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "생성을 인증 하는 데 사용 되는 정보 `typeName`합니다."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "지정한 새 인스턴스의 래퍼인 개체 <code> typeName </code>합니다. 반환 값은 실제 개체에 액세스 하기 위해 래핑이 있어야 합니다."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyName</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>찾을 수 없습니다."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "호출자에 게가이 생성자를 호출할 수 있는 권한이 없습니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "일치 하는 생성자를 찾을 수 있습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "호출자에서 상속 되지 않는 개체에 대 한 활성화 특성을 제공할 수 없는 <xref href=&quot;System.MarshalByRefObject&quot;> </xref>합니다.       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 레거시 CAS 정책을 설정 하지 않으면 <code> securityAttributes </code> 이어야 합니다<xref uid=&quot;langword_csharp_null.&quot; name=&quot;null.&quot; href=&quot;&quot;></xref>"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>찾을 수 없습니다 <code>assemblyName</code>합니다."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "이 인스턴스는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  id: CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정 된 형식의 새 인스턴스를 만듭니다. 매개 변수는 형식이 정의 되어 있는 어셈블리 및 형식의 이름을 지정 합니다."
  remarks: "이 메서드 <xref:System.AppDomain.CreateInstance%2A>및 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> 는 이 메서드 호출에 대 한 기본 생성자 `typeName`합니다.       참조 <xref:System.Reflection.AssemblyName>형식의 `assemblyName`.</xref:System.Reflection.AssemblyName> 참조는 <xref:System.Type.FullName%2A?displayProperty=fullName>속성의 형식에 대 한 `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > 메서드에 대 한 초기 바인딩 호출을 확인 하는 경우 `M` 형식의 개체의 `T1` CreateInstanceAndUnwrap, 반환한 및 해당 메서드를 사용 하면 형식의 개체의 메서드에 대 한 초기 바인딩 호출 `T2` 어셈블리에 `C` 현재 어셈블리 또는 포함 된 어셈블리 이외의 `T1`, 어셈블리 `C` 은 현재 어플리케이션 도메인에 로드 됩니다. 이 로드에 대 한 초기 바인딩 호출 하는 경우에 발생 `T1.M()` 의 본문에서 만들어진는 <xref:System.Reflection.Emit.DynamicMethod>, 또는 다른 동적으로 생성 된 코드에서.</xref:System.Reflection.Emit.DynamicMethod> 현재 도메인 어셈블리는 기본 도메인 인지 `C` 프로세스가 끝날 때까지 언로드할 수 없습니다. 현재 도메인 나중에 어셈블리를 로드 하려고 할 경우 `C`, 하지만 실패 합니다."
  example:
  - "The following code example shows the simplest way to execute code in another application domain. The example defines a class named `Worker` that inherits from <xref:System.MarshalByRefObject>. The `Worker` class defines a method that displays the name of the application domain in which it is executing. The example creates instances of `Worker` in the default application domain and in a new application domain.  \n  \n> [!NOTE]\n>  The assembly that contains `Worker` must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.  \n  \n [!code-cpp[CreateInstanceAndUnwrap2#1](~/add/codesnippet/cpp/m-system.appdomain.creat_2_1.cpp)]\n [!code-cs[CreateInstanceAndUnwrap2#1](~/add/codesnippet/csharp/m-system.appdomain.creat_2_1.cs)]\n [!code-vb[CreateInstanceAndUnwrap2#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_2_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "어셈블리의 표시 이름입니다. 참조 &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;합니다."
    - id: typeName
      type: System.String
      description: "반환 된 네임 스페이스만 어셈블리가 아닌 포함 하 여 요청 된 형식의 정규화 된 이름에서 &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; 속성입니다."
    return:
      type: System.Object
      description: "지정한 개체의 인스턴스 <code> typeName </code>합니다."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "일치 하는 공용 생성자가 없습니다 찾았습니다."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>찾을 수 없습니다 <code>assemblyName</code>합니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>찾을 수 없습니다."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "호출자에 게가이 생성자를 호출할 수 있는 권한이 없습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyName</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정 된 형식의 새 인스턴스를 만듭니다. 매개 변수는 형식이 정의 되어 있는 어셈블리, 형식, 이름 및 활성화 특성의 배열을 지정 합니다."
  remarks: "이 메서드 <xref:System.AppDomain.CreateInstance%2A>및 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> 는 이 메서드 호출에 대 한 기본 생성자 `typeName`합니다.       참조 <xref:System.Reflection.AssemblyName>형식의 `assemblyName`.</xref:System.Reflection.AssemblyName> 참조는 <xref:System.Type.FullName%2A?displayProperty=fullName>속성의 형식에 대 한 `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > 메서드에 대 한 초기 바인딩 호출을 확인 하는 경우 `M` 형식의 개체의 `T1` 반환한 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, 고, 해당 메서드 형식의 개체의 메서드에 대 한 초기 바인딩 호출 `T2` 어셈블리에 `C` 현재 어셈블리 또는 포함 된 어셈블리 이외의 `T1`, 어셈블리 `C` 은 현재 어플리케이션 도메인에 로드 됩니다.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 이 로드에 대 한 초기 바인딩 호출 하는 경우에 발생 `T1.M()` 의 본문에서 만들어진는 <xref:System.Reflection.Emit.DynamicMethod>, 또는 다른 동적으로 생성 된 코드에서.</xref:System.Reflection.Emit.DynamicMethod> 현재 도메인 어셈블리는 기본 도메인 인지 `C` 프로세스가 끝날 때까지 언로드할 수 없습니다. 현재 도메인 나중에 어셈블리를 로드 하려고 할 경우 `C`, 하지만 실패 합니다."
  example:
  - >-
    [!code-cpp[ADDyno#1](~/add/codesnippet/cpp/ec186439-6d54-4090-82e0-_1.cpp)]
     [!code-cs[ADDyno#1](~/add/codesnippet/csharp/ec186439-6d54-4090-82e0-_1.cs)]
     [!code-vb[ADDyno#1](~/add/codesnippet/visualbasic/ec186439-6d54-4090-82e0-_1.vb)]
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "어셈블리의 표시 이름입니다. 참조 &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;합니다."
    - id: typeName
      type: System.String
      description: "반환 된 네임 스페이스만 어셈블리가 아닌 포함 하 여 요청 된 형식의 정규화 된 이름에서 &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; 속성입니다."
    - id: activationAttributes
      type: System.Object[]
      description: "활성화에 참여할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로 포함 된 배열을 단일 <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> 원격 개체를 활성화 하는 데 필요한 URL을 지정 하는 개체입니다.       이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과 호환성을 위해 유지 되지만 새로운 개발에 권장 되지 않습니다는 레거시 기술입니다. 분산된 응용 프로그램 Windows Communication Foundation을 사용 해야 합니다."
    return:
      type: System.Object
      description: "지정한 개체의 인스턴스 <code> typeName </code>합니다."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "일치 하는 공용 생성자가 없습니다 찾았습니다."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>찾을 수 없습니다 <code>assemblyName</code>합니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>찾을 수 없습니다."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "호출자에 게가이 생성자를 호출할 수 있는 권한이 없습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "호출자에서 상속 되지 않는 개체에 대 한 활성화 특성을 제공할 수 없는 <xref href=&quot;System.MarshalByRefObject&quot;> </xref>합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyName</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "때 형식 이름의 대/소문자 무시 되는지 여부를 지정 하 여 지정 된 어셈블리에 정의 된 지정 된 형식의 새 인스턴스를 만듭니다. 만들; 유형을 선택 하는 데 사용 되는 바인더와 바인딩 특성 생성자의 인수 문화권 및 활성화 특성을 추가 합니다."
  remarks: "이 메서드 <xref:System.AppDomain.CreateInstance%2A>및 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> 는       참조 <xref:System.Reflection.AssemblyName>형식의 `assemblyName`.</xref:System.Reflection.AssemblyName> 참조는 <xref:System.Type.FullName%2A?displayProperty=fullName>속성의 형식에 대 한 `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > 메서드에 대 한 초기 바인딩 호출을 확인 하는 경우 `M` 형식의 개체의 `T1` 반환한 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, 고, 해당 메서드 형식의 개체의 메서드에 대 한 초기 바인딩 호출 `T2` 어셈블리에 `C` 현재 어셈블리 또는 포함 된 어셈블리 이외의 `T1`, 어셈블리 `C` 은 현재 어플리케이션 도메인에 로드 됩니다.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 이 로드에 대 한 초기 바인딩 호출 하는 경우에 발생 `T1.M()` 의 본문에서 만들어진는 <xref:System.Reflection.Emit.DynamicMethod>, 또는 다른 동적으로 생성 된 코드에서.</xref:System.Reflection.Emit.DynamicMethod> 현재 도메인 어셈블리는 기본 도메인 인지 `C` 프로세스가 끝날 때까지 언로드할 수 없습니다. 현재 도메인 나중에 어셈블리를 로드 하려고 할 경우 `C`, 하지만 실패 합니다."
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/7b1dcc86-9680-463d-b78c-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/7b1dcc86-9680-463d-b78c-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/7b1dcc86-9680-463d-b78c-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "어셈블리의 표시 이름입니다. 참조 &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;합니다."
    - id: typeName
      type: System.String
      description: "반환 된 네임 스페이스만 어셈블리가 아닌 포함 하 여 요청 된 형식의 정규화 된 이름에서 &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; 속성입니다."
    - id: ignoreCase
      type: System.Boolean
      description: "대/소문자 구분 검색을 수행할지 여부를 지정 하는 부울 값입니다."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "에 대 한 검색에 영향을 미치는&0; 또는 그 이상의 비트 플래그의 조합 된 `typeName` 생성자입니다. 경우 `bindingAttr` 수행 하는 public 생성자가&0; 이면 대/소문자 구분 검색 합니다."
    - id: binder
      type: System.Reflection.Binder
      description: "바인딩, 인수 강제 변환 하는 개체 형식, 멤버 호출 및 검색 <xref:System.Reflection.MemberInfo>리플렉션을 사용 하 여 개체.</xref:System.Reflection.MemberInfo> 경우 `binder` 가 null 이면 기본 바인더가 사용 됩니다."
    - id: args
      type: System.Object[]
      description: "생성자에 전달할 인수입니다. 이 인수 배열은 호출할 생성자의 매개 변수를 입력 및 번호, 순서 일치 해야 합니다. 기본 생성자가 기본 방법 `args` 빈 배열 이거나 null 이어야 합니다."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "형식의 강제 변환을 제어 하는 데 사용 되는 문화권별 개체입니다. 경우 `culture` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> 현재 스레드가 사용 됩니다."
    - id: activationAttributes
      type: System.Object[]
      description: "활성화에 참여할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로 포함 된 배열을 단일 <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> 개체입니다. 원격 개체를 활성화 하는 데 필요한 URL을 지정 합니다.       이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과 호환성을 위해 유지 되지만 새로운 개발에 권장 되지 않습니다는 레거시 기술입니다. 분산된 응용 프로그램 Windows Communication Foundation을 사용 해야 합니다."
    return:
      type: System.Object
      description: "지정한 개체의 인스턴스 <code> typeName </code>합니다."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "일치 하는 생성자를 찾을 수 있습니다."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>찾을 수 없습니다 <code>assemblyName</code>합니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>찾을 수 없습니다."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "호출자에 게가이 생성자를 호출할 수 있는 권한이 없습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "호출자에서 상속 되지 않는 개체에 대 한 활성화 특성을 제공할 수 없는 <xref href=&quot;System.MarshalByRefObject&quot;> </xref>합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>유효한 어셈블리가 않습니다.       -또는- <code>assemblyName</code> 공용 언어 런타임이 현재 로드 되어 있는 버전 보다 이후 버전으로 컴파일 되었습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정 된 형식의 새 인스턴스를 만듭니다. 매개 변수는 형식과 발견 및 생성 방법의 이름을 지정 합니다."
  remarks: "이 메서드 <xref:System.AppDomain.CreateInstance%2A>및 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> 는       참조 <xref:System.Reflection.AssemblyName>형식의 `assemblyName`.</xref:System.Reflection.AssemblyName> 참조는 <xref:System.Type.FullName%2A?displayProperty=fullName>속성의 형식에 대 한 `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > 메서드에 대 한 초기 바인딩 호출을 확인 하는 경우 `M` 형식의 개체의 `T1` 반환한 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, 고, 해당 메서드 형식의 개체의 메서드에 대 한 초기 바인딩 호출 `T2` 어셈블리에 `C` 현재 어셈블리 또는 포함 된 어셈블리 이외의 `T1`, 어셈블리 `C` 은 현재 어플리케이션 도메인에 로드 됩니다.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 이 로드에 대 한 초기 바인딩 호출 하는 경우에 발생 `T1.M()` 의 본문에서 만들어진는 <xref:System.Reflection.Emit.DynamicMethod>, 또는 다른 동적으로 생성 된 코드에서.</xref:System.Reflection.Emit.DynamicMethod> 현재 도메인 어셈블리는 기본 도메인 인지 `C` 프로세스가 끝날 때까지 언로드할 수 없습니다. 현재 도메인 나중에 어셈블리를 로드 하려고 할 경우 `C`, 하지만 실패 합니다."
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/8e0d44ad-3def-4658-8d9d-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/8e0d44ad-3def-4658-8d9d-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/8e0d44ad-3def-4658-8d9d-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "어셈블리의 표시 이름입니다. 참조 &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;합니다."
    - id: typeName
      type: System.String
      description: "반환 된 네임 스페이스만 어셈블리가 아닌 포함 하 여 요청 된 형식의 정규화 된 이름에서 &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; 속성입니다."
    - id: ignoreCase
      type: System.Boolean
      description: "대/소문자 구분 검색을 수행할지 여부를 지정 하는 부울 값입니다."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "에 대 한 검색에 영향을 미치는&0; 또는 그 이상의 비트 플래그의 조합 된 `typeName` 생성자입니다. 경우 `bindingAttr` 수행 하는 public 생성자가&0; 이면 대/소문자 구분 검색 합니다."
    - id: binder
      type: System.Reflection.Binder
      description: "바인딩, 인수 강제 변환 하는 개체 형식, 멤버 호출 및 검색 <xref:System.Reflection.MemberInfo>리플렉션을 사용 하 여 개체.</xref:System.Reflection.MemberInfo> 경우 `binder` 가 null 이면 기본 바인더가 사용 됩니다."
    - id: args
      type: System.Object[]
      description: "생성자에 전달할 인수입니다. 이 인수 배열은 호출할 생성자의 매개 변수를 입력 및 번호, 순서 일치 해야 합니다. 기본 생성자가 기본 방법 `args` 빈 배열 이거나 null 이어야 합니다."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "형식의 강제 변환을 제어 하는 데 사용 되는 문화권별 개체입니다. 경우 `culture` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> 현재 스레드가 사용 됩니다."
    - id: activationAttributes
      type: System.Object[]
      description: "활성화에 참여할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로 포함 된 배열을 단일 <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> 원격 개체를 활성화 하는 데 필요한 URL을 지정 하는 개체입니다.       이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과 호환성을 위해 유지 되지만 새로운 개발에 권장 되지 않습니다는 레거시 기술입니다. 분산된 응용 프로그램 Windows Communication Foundation을 사용 해야 합니다."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "생성을 인증 하는 데 사용 되는 정보 `typeName`합니다."
    return:
      type: System.Object
      description: "지정한 개체의 인스턴스 <code> typeName </code>합니다."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "일치 하는 생성자를 찾을 수 있습니다."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>찾을 수 없습니다 <code>assemblyName</code>합니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>찾을 수 없습니다."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "호출자에 게가이 생성자를 호출할 수 있는 권한이 없습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "호출자에서 상속 되지 않는 개체에 대 한 활성화 특성을 제공할 수 없는 <xref href=&quot;System.MarshalByRefObject&quot;> </xref>합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyName</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  id: CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 어셈블리 파일에 정의 된 지정 된 형식의 새 인스턴스를 만듭니다."
  remarks: "에 대 한 기본 생성자 `typeName` 가 호출 됩니다.       자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>메서드.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       다른 응용 프로그램 도메인, 호출이 수행 된 대상 응용 프로그램 도메인에 인스턴스를 만들려고 CreateInstanceFrom 메서드를 사용할 때 어셈블리가 대상 응용 프로그램 도메인에 로드 됩니다. 그러나 인스턴스가 호출 응용 프로그램 도메인에서 래핑 해제 된 경우 래핑 해제 된 인스턴스를 사용 하 여 다양 한 방식으로 호출 응용 프로그램 도메인에 로드 될 어셈블리를 발생할 수 있습니다. 예를 들어, 형식 정보를 요청, 해당 메서드를 호출 하기 위해 런타임에 바인딩된 인스턴스 래핑 해제 된 후입니다. 어셈블리를 호출 응용 프로그램 도메인에 로드 하는 경우 예외가 발생할 수 있습니다.      -동일한 어셈블리의 다른 버전이 이전에 호출 응용 프로그램 도메인에 로드 하는 경우 또는 호출 응용 프로그램 도메인의 로드 경로 같은 다른 예외 대상 응용 프로그램 도메인의 경우 <xref:System.MissingMethodException>발생할 수 있습니다.</xref:System.MissingMethodException>      -호출 응용 프로그램 도메인에서 초기 바인딩 호출 인스턴스 유형으로 하는 경우 <xref:System.InvalidCastException>인스턴스 캐스팅 하려고 시도 하는 경우에 throw 될 수 있습니다.</xref:System.InvalidCastException>"
  example:
  - "The following example shows how to use the CreateInstanceFrom method overload to create an instance of an object in a target application domain and call its methods.  \n  \n The example defines the `MarshallableExample` class, which can be marshaled across application domain boundaries. The example builds a path to the currently executing assembly, creates a target application domain, and uses the CreateInstanceFrom method overload to load the example assembly into the target application domain and create an instance of `MarshallableExample`.  \n  \n> [!NOTE]\n>  The path is absolute in this example, but a relative path would also work because the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=fullName> method is used to load the assembly.  \n  \n After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:  \n  \n-   Invoking a method with late binding, using reflection. This requires type information, which causes the assembly to be loaded into the application domain of the caller. (In this example, it is already loaded.)  \n  \n-   Casting the object to an interface known to both the caller and the callee. If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.  \n  \n-   Using the object directly when its type is known to the caller. The assembly must be loaded into the application domain of the caller.  \n  \n Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <xref:System.MarshalByRefObject> class and to define a method that can be run in the target application domain. That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain. See the example for the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cs[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/csharp/m-system.appdomain.creat_3_1.cs)]\n [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/cpp/m-system.appdomain.creat_3_1.cpp)]\n [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_3_1.vb)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "요청된 된 형식을 정의 하는 어셈블리가 포함 된 파일의 경로 포함 하는 이름입니다. 사용 하는 어셈블리가 로드 되는 <xref:System.Reflection.Assembly.LoadFrom*>메서드.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "반환 된 네임 스페이스만 어셈블리가 아닌 포함 하 여 요청 된 형식의 정규화 된 이름에서 &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; 속성입니다."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "새 인스턴스의 래퍼인 개체 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 경우 <code> typeName </code> 찾을 수 없습니다. 반환 값은 실제 개체에 액세스 하기 위해 래핑이 있어야 합니다."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>찾을 수 없습니다."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>찾을 수 없습니다 <code>assemblyFile</code>합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "매개 변수가 없는 public 생성자가 없습니다 찾았습니다."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "호출자에 게가이 생성자를 호출 하 충분 한 권한이 없습니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyFile</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "이 인스턴스는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 어셈블리 파일에 정의 된 지정 된 형식의 새 인스턴스를 만듭니다."
  remarks: "에 대 한 기본 생성자 `typeName` 가 호출 됩니다.       이 메서드에 대 한 자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>메서드.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       경우는 <xref:System.AppDomain.CreateInstanceFrom%2A>메서드를 호출 하는 응용 프로그램 도메인 외에 대상 응용 프로그램 도메인에 인스턴스를 만드는 데 사용 됩니다, 어셈블리는 대상 응용 프로그램 도메인에 로드 됩니다.</xref:System.AppDomain.CreateInstanceFrom%2A> 그러나 인스턴스가 호출 응용 프로그램 도메인에서 래핑 해제 된 경우 래핑 해제 된 인스턴스를 사용 하 여 다양 한 방식으로 호출 응용 프로그램 도메인에 로드 될 어셈블리를 발생할 수 있습니다. 예를 들어, 형식 정보를 요청, 해당 메서드를 호출 하기 위해 런타임에 바인딩된 인스턴스 래핑 해제 된 후입니다. 어셈블리를 호출 응용 프로그램 도메인에 로드 하는 경우 예외가 발생할 수 있습니다.      -동일한 어셈블리의 다른 버전이 이전에 호출 응용 프로그램 도메인에 로드 하는 경우 또는 호출 응용 프로그램 도메인의 로드 경로 같은 다른 예외 대상 응용 프로그램 도메인의 경우 <xref:System.MissingMethodException>발생할 수 있습니다.</xref:System.MissingMethodException>      -호출 응용 프로그램 도메인에서 초기 바인딩 호출 인스턴스 유형으로 하는 경우 <xref:System.InvalidCastException>인스턴스 캐스팅 하려고 시도 하는 경우에 throw 될 수 있습니다.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "요청된 된 형식을 정의 하는 어셈블리가 포함 된 파일의 경로 포함 하는 이름입니다. 사용 하는 어셈블리가 로드 되는 <xref:System.Reflection.Assembly.LoadFrom*>메서드.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "반환 된 네임 스페이스만 어셈블리가 아닌 포함 하 여 요청 된 형식의 정규화 된 이름에서 &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; 속성입니다."
    - id: activationAttributes
      type: System.Object[]
      description: "활성화에 참여할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로 포함 된 배열을 단일 <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> 원격 개체를 활성화 하는 데 필요한 URL을 지정 하는 개체입니다.       이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과 호환성을 위해 유지 되지만 새로운 개발에 권장 되지 않습니다는 레거시 기술입니다. 분산된 응용 프로그램 Windows Communication Foundation을 사용 해야 합니다."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "새 인스턴스의 래퍼인 개체 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 경우 <code> typeName </code> 찾을 수 없습니다. 반환 값은 실제 개체에 액세스 하기 위해 래핑이 있어야 합니다."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>찾을 수 없습니다."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>찾을 수 없습니다 <code>assemblyFile</code>합니다."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "호출자에 게가이 생성자를 호출 하 충분 한 권한이 없습니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "일치 하는 공용 생성자가 없습니다 찾았습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "호출자에서 상속 되지 않는 개체에 대 한 활성화 특성을 제공할 수 없는 <xref href=&quot;System.MarshalByRefObject&quot;> </xref>합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyFile</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "이 인스턴스는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 어셈블리 파일에 정의 된 지정 된 형식의 새 인스턴스를 만듭니다."
  remarks: "자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>메서드.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       경우는 <xref:System.AppDomain.CreateInstanceFrom%2A>메서드를 호출 하는 응용 프로그램 도메인 외에 대상 응용 프로그램 도메인에 인스턴스를 만드는 데 사용 됩니다, 어셈블리는 대상 응용 프로그램 도메인에 로드 됩니다.</xref:System.AppDomain.CreateInstanceFrom%2A> 그러나 인스턴스가 호출 응용 프로그램 도메인에서 래핑 해제 된 경우 래핑 해제 된 인스턴스를 사용 하 여 다양 한 방식으로 호출 응용 프로그램 도메인에 로드 될 어셈블리를 발생할 수 있습니다. 예를 들어, 형식 정보를 요청, 해당 메서드를 호출 하기 위해 런타임에 바인딩된 인스턴스 래핑 해제 된 후입니다. 어셈블리를 호출 응용 프로그램 도메인에 로드 하는 경우 예외가 발생할 수 있습니다.      -동일한 어셈블리의 다른 버전이 이전에 호출 응용 프로그램 도메인에 로드 하는 경우 또는 호출 응용 프로그램 도메인의 로드 경로 같은 다른 예외 대상 응용 프로그램 도메인의 경우 <xref:System.MissingMethodException>발생할 수 있습니다.</xref:System.MissingMethodException>      -호출 응용 프로그램 도메인에서 초기 바인딩 호출 인스턴스 유형으로 하는 경우 <xref:System.InvalidCastException>인스턴스 캐스팅 하려고 시도 하는 경우에 throw 될 수 있습니다.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "요청된 된 형식을 정의 하는 어셈블리가 포함 된 파일의 경로 포함 하는 이름입니다. 사용 하는 어셈블리가 로드 되는 <xref:System.Reflection.Assembly.LoadFrom*>메서드.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "반환 된 네임 스페이스만 어셈블리가 아닌 포함 하 여 요청 된 형식의 정규화 된 이름에서 &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; 속성입니다."
    - id: ignoreCase
      type: System.Boolean
      description: "대/소문자 구분 검색을 수행할지 여부를 지정 하는 부울 값입니다."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "에 대 한 검색에 영향을 미치는&0; 또는 그 이상의 비트 플래그의 조합 된 `typeName` 생성자입니다. 경우 `bindingAttr` 수행 하는 public 생성자가&0; 이면 대/소문자 구분 검색 합니다."
    - id: binder
      type: System.Reflection.Binder
      description: "바인딩, 인수 강제 변환 하는 개체 형식, 멤버 호출 및 검색 <xref:System.Reflection.MemberInfo>리플렉션을 통해.</xref:System.Reflection.MemberInfo> 경우 `binder` 가 null 이면 기본 바인더가 사용 됩니다."
    - id: args
      type: System.Object[]
      description: "생성자에 전달할 인수입니다. 이 인수 배열은 호출할 생성자의 매개 변수를 입력 및 번호, 순서 일치 해야 합니다. 기본 생성자가 기본 방법 `args` 빈 배열 이거나 null 이어야 합니다."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "강제 변환을 제어 하는 문화권별 정보 `args` 에 대해 선언 된 공식적인 형식에는 `typeName` 생성자입니다. 경우 `culture` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>현재 스레드가 사용 됩니다.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "활성화에 참여할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로 포함 된 배열을 단일 <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> 원격 개체를 활성화 하는 데 필요한 URL을 지정 하는 개체입니다.       이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과 호환성을 위해 유지 되지만 새로운 개발에 권장 되지 않습니다는 레거시 기술입니다. 분산된 응용 프로그램 Windows Communication Foundation을 사용 해야 합니다."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "새 인스턴스의 래퍼인 개체 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 경우 <code> typeName </code> 찾을 수 없습니다. 반환 값은 실제 개체에 액세스 하기 위해 래핑이 있어야 합니다."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "호출자에서 상속 되지 않는 개체에 대 한 활성화 특성을 제공할 수 없는 <xref href=&quot;System.MarshalByRefObject&quot;> </xref>합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>찾을 수 없습니다."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>찾을 수 없습니다 <code>assemblyFile</code>합니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "일치 하는 공용 생성자가 없습니다 찾았습니다."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "호출자에 게가이 생성자를 호출 하 충분 한 권한이 없습니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>유효한 어셈블리가 않습니다.       -또는- <code>assemblyFile</code> 공용 언어 런타임이 현재 로드 되어 있는 버전 보다 이후 버전으로 컴파일 되었습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "이 인스턴스는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 어셈블리 파일에 정의 된 지정 된 형식의 새 인스턴스를 만듭니다."
  remarks: "이 메서드에 대 한 자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>메서드.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       경우는 <xref:System.AppDomain.CreateInstanceFrom%2A>메서드를 호출 하는 응용 프로그램 도메인 외에 대상 응용 프로그램 도메인에 인스턴스를 만드는 데 사용 됩니다, 어셈블리는 대상 응용 프로그램 도메인에 로드 됩니다.</xref:System.AppDomain.CreateInstanceFrom%2A> 그러나 인스턴스가 호출 응용 프로그램 도메인에서 래핑 해제 된 경우 래핑 해제 된 인스턴스를 사용 하 여 다양 한 방식으로 호출 응용 프로그램 도메인에 로드 될 어셈블리를 발생할 수 있습니다. 예를 들어, 형식 정보를 요청, 해당 메서드를 호출 하기 위해 런타임에 바인딩된 인스턴스 래핑 해제 된 후입니다. 어셈블리를 호출 응용 프로그램 도메인에 로드 하는 경우 예외가 발생할 수 있습니다.      -동일한 어셈블리의 다른 버전이 이전에 호출 응용 프로그램 도메인에 로드 하는 경우 또는 호출 응용 프로그램 도메인의 로드 경로 같은 다른 예외 대상 응용 프로그램 도메인의 경우 <xref:System.MissingMethodException>발생할 수 있습니다.</xref:System.MissingMethodException>      -호출 응용 프로그램 도메인에서 초기 바인딩 호출 인스턴스 유형으로 하는 경우 <xref:System.InvalidCastException>인스턴스 캐스팅 하려고 시도 하는 경우에 throw 될 수 있습니다.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "요청된 된 형식을 정의 하는 어셈블리가 포함 된 파일의 경로 포함 하는 이름입니다. 사용 하는 어셈블리가 로드 되는 <xref:System.Reflection.Assembly.LoadFrom*>메서드.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "반환 된 네임 스페이스만 어셈블리가 아닌 포함 하 여 요청 된 형식의 정규화 된 이름에서 &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; 속성입니다."
    - id: ignoreCase
      type: System.Boolean
      description: "대/소문자 구분 검색을 수행할지 여부를 지정 하는 부울 값입니다."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "에 대 한 검색에 영향을 미치는&0; 또는 그 이상의 비트 플래그의 조합 된 `typeName` 생성자입니다. 경우 `bindingAttr` 수행 하는 public 생성자가&0; 이면 대/소문자 구분 검색 합니다."
    - id: binder
      type: System.Reflection.Binder
      description: "바인딩, 인수 강제 변환 하는 개체 형식, 멤버 호출 및 검색 <xref:System.Reflection.MemberInfo>리플렉션을 통해.</xref:System.Reflection.MemberInfo> 경우 `binder` 가 null 이면 기본 바인더가 사용 됩니다."
    - id: args
      type: System.Object[]
      description: "생성자에 전달할 인수입니다. 이 인수 배열은 호출할 생성자의 매개 변수를 입력 및 번호, 순서 일치 해야 합니다. 기본 생성자가 기본 방법 `args` 빈 배열 이거나 null 이어야 합니다."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "강제 변환을 제어 하는 문화권별 정보 `args` 에 대해 선언 된 공식적인 형식에는 `typeName` 생성자입니다. 경우 `culture` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>현재 스레드가 사용 됩니다.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "활성화에 참여할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로 포함 된 배열을 단일 <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> 원격 개체를 활성화 하는 데 필요한 URL을 지정 하는 개체입니다.       이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과 호환성을 위해 유지 되지만 새로운 개발에 권장 되지 않습니다는 레거시 기술입니다. 분산된 응용 프로그램 Windows Communication Foundation을 사용 해야 합니다."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "생성을 인증 하는 데 사용 되는 정보 `typeName`합니다."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "새 인스턴스의 래퍼인 개체 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 경우 <code> typeName </code> 찾을 수 없습니다. 반환 값은 실제 개체에 액세스 하기 위해 래핑이 있어야 합니다."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "호출자에서 상속 되지 않는 개체에 대 한 활성화 특성을 제공할 수 없는 <xref href=&quot;System.MarshalByRefObject&quot;> </xref>합니다.       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 레거시 CAS 정책을 설정 하지 않으면 <code> securityAttributes </code> 해야 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>찾을 수 없습니다."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>찾을 수 없습니다 <code>assemblyFile</code>합니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "일치 하는 공용 생성자가 없습니다 찾았습니다."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "호출자에 게가이 생성자를 호출 하 충분 한 권한이 없습니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyFile</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "이 인스턴스는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  id: CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 어셈블리 파일에 정의 된 지정 된 형식의 새 인스턴스를 만듭니다."
  remarks: "이 메서드 <xref:System.AppDomain.CreateInstanceFrom%2A>및 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> 는 이 메서드 호출에 대 한 기본 생성자 `typeName`합니다.       자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>메서드.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "파일 이름과 요청된 된 형식을 정의 하는 어셈블리의 경로입니다."
    - id: typeName
      type: System.String
      description: "반환 된 네임 스페이스만 어셈블리가 아닌 포함 하 여 요청 된 형식의 정규화 된 이름에서 &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; 속성입니다."
    return:
      type: System.Object
      description: "요청된 된 개체 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 경우 <code> typeName </code> 찾을 수 없습니다."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>찾을 수 없습니다."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>찾을 수 없습니다 <code>assemblyName</code>합니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "매개 변수가 없는 public 생성자가 없습니다 찾았습니다."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "호출자에 게가이 생성자를 호출 하 충분 한 권한이 없습니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyName</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 어셈블리 파일에 정의 된 지정 된 형식의 새 인스턴스를 만듭니다."
  remarks: "이 메서드 <xref:System.AppDomain.CreateInstanceFrom%2A>및 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> 는 이 메서드 호출에 대 한 기본 생성자 `typeName`합니다.       이 메서드에 대 한 자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>메서드.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "파일 이름과 요청된 된 형식을 정의 하는 어셈블리의 경로입니다."
    - id: typeName
      type: System.String
      description: "어셈블리를 제외한 네임 스페이스를 포함 하 여 요청 된 형식의 정규화 된 이름 (참조는 &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; 속성)."
    - id: activationAttributes
      type: System.Object[]
      description: "활성화에 참여할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로 포함 된 배열을 단일 <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> 원격 개체를 활성화 하는 데 필요한 URL을 지정 하는 개체입니다.       이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과 호환성을 위해 유지 되지만 새로운 개발에 권장 되지 않습니다는 레거시 기술입니다. 분산된 응용 프로그램 Windows Communication Foundation을 사용 해야 합니다."
    return:
      type: System.Object
      description: "요청된 된 개체 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 경우 <code> typeName </code> 찾을 수 없습니다."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "호출자에서 상속 되지 않는 개체에 대 한 활성화 특성을 제공할 수 없는 <xref href=&quot;System.MarshalByRefObject&quot;> </xref>합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>찾을 수 없습니다."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>찾을 수 없습니다 <code>assemblyName</code>합니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "매개 변수가 없는 public 생성자가 없습니다 찾았습니다."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "호출자에 게가이 생성자를 호출 하 충분 한 권한이 없습니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyName</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정 된 형식의 지정 된 어셈블리 파일에 정의 된; 때 형식 이름의 대/소문자 무시 되는지 여부를 지정 하는 새 인스턴스를 만듭니다. 만들; 유형을 선택 하는 데 사용 되는 바인더와 바인딩 특성 생성자의 인수 문화권 및 활성화 특성을 추가 합니다."
  remarks: "이 메서드 <xref:System.AppDomain.CreateInstanceFrom%2A>및 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> 는       이 메서드에 대 한 자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>메서드.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "파일 이름과 요청된 된 형식을 정의 하는 어셈블리의 경로입니다."
    - id: typeName
      type: System.String
      description: "반환 된 네임 스페이스만 어셈블리가 아닌 포함 하 여 요청 된 형식의 정규화 된 이름에서 &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; 속성입니다."
    - id: ignoreCase
      type: System.Boolean
      description: "대/소문자 구분 검색을 수행할지 여부를 지정 하는 부울 값입니다."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "에 대 한 검색에 영향을 미치는&0; 또는 그 이상의 비트 플래그의 조합 된 `typeName` 생성자입니다. 경우 `bindingAttr` 수행 하는 public 생성자가&0; 이면 대/소문자 구분 검색 합니다."
    - id: binder
      type: System.Reflection.Binder
      description: "바인딩, 인수 강제 변환 하는 개체 형식, 멤버 호출 및 검색 <xref:System.Reflection.MemberInfo>리플렉션을 통해.</xref:System.Reflection.MemberInfo> 경우 `binder` 가 null 이면 기본 바인더가 사용 됩니다."
    - id: args
      type: System.Object[]
      description: "생성자에 전달할 인수입니다. 이 인수 배열은 호출할 생성자의 매개 변수를 입력 및 번호, 순서 일치 해야 합니다. 기본 생성자가 기본 방법 `args` 빈 배열 이거나 null 이어야 합니다."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "강제 변환을 제어 하는 문화권별 정보 `args` 에 대해 선언 된 공식적인 형식에는 `typeName` 생성자입니다. 경우 `culture` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>현재 스레드가 사용 됩니다.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "활성화에 참여할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로 포함 된 배열을 단일 <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> 원격 개체를 활성화 하는 데 필요한 URL을 지정 하는 개체입니다.       이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과 호환성을 위해 유지 되지만 새로운 개발에 권장 되지 않습니다는 레거시 기술입니다. 분산된 응용 프로그램 Windows Communication Foundation을 사용 해야 합니다."
    return:
      type: System.Object
      description: "요청된 된 개체 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 경우 <code> typeName </code> 찾을 수 없습니다."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "호출자에서 상속 되지 않는 개체에 대 한 활성화 특성을 제공할 수 없는 <xref href=&quot;System.MarshalByRefObject&quot;> </xref>합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>찾을 수 없습니다."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>찾을 수 없습니다 <code>assemblyName</code>합니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "일치 하는 공용 생성자가 없습니다 찾았습니다."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "호출자에 게가이 생성자를 호출 하 충분 한 권한이 없습니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>유효한 어셈블리가 않습니다.       -또는- <code>assemblyName</code> 공용 언어 런타임의 이후 버전으로 컴파일된 버전 되는 현재 로드 합니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 어셈블리 파일에 정의 된 지정 된 형식의 새 인스턴스를 만듭니다."
  remarks: "이 메서드 <xref:System.AppDomain.CreateInstanceFrom%2A>및 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> 는       이 메서드에 대 한 자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>메서드.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "파일 이름과 요청된 된 형식을 정의 하는 어셈블리의 경로입니다."
    - id: typeName
      type: System.String
      description: "반환 된 네임 스페이스만 어셈블리가 아닌 포함 하 여 요청 된 형식의 정규화 된 이름에서 &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; 속성입니다."
    - id: ignoreCase
      type: System.Boolean
      description: "대/소문자 구분 검색을 수행할지 여부를 지정 하는 부울 값입니다."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "에 대 한 검색에 영향을 미치는&0; 또는 그 이상의 비트 플래그의 조합 된 `typeName` 생성자입니다. 경우 `bindingAttr` 수행 하는 public 생성자가&0; 이면 대/소문자 구분 검색 합니다."
    - id: binder
      type: System.Reflection.Binder
      description: "바인딩, 인수 강제 변환 하는 개체 형식, 멤버 호출 및 검색 <xref:System.Reflection.MemberInfo>리플렉션을 통해.</xref:System.Reflection.MemberInfo> 경우 `binder` 가 null 이면 기본 바인더가 사용 됩니다."
    - id: args
      type: System.Object[]
      description: "생성자에 전달할 인수입니다. 이 인수 배열은 호출할 생성자의 매개 변수를 입력 및 번호, 순서 일치 해야 합니다. 기본 생성자가 기본 방법 `args` 빈 배열 이거나 null 이어야 합니다."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "강제 변환을 제어 하는 문화권별 정보 `args` 에 대해 선언 된 공식적인 형식에는 `typeName` 생성자입니다. 경우 `culture` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>현재 스레드가 사용 됩니다.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "활성화에 참여할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로 포함 된 배열을 단일 <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> 원격 개체를 활성화 하는 데 필요한 URL을 지정 하는 개체입니다.       이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과 호환성을 위해 유지 되지만 새로운 개발에 권장 되지 않습니다는 레거시 기술입니다. 분산된 응용 프로그램 Windows Communication Foundation을 사용 해야 합니다."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "생성을 인증 하는 데 사용 되는 정보 `typeName`합니다."
    return:
      type: System.Object
      description: "요청된 된 개체 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 경우 <code> typeName </code> 찾을 수 없습니다."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "호출자에서 상속 되지 않는 개체에 대 한 활성화 특성을 제공할 수 없는 <xref href=&quot;System.MarshalByRefObject&quot;> </xref>합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>찾을 수 없습니다."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>찾을 수 없습니다 <code>assemblyName</code>합니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "일치 하는 공용 생성자가 없습니다 찾았습니다."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "호출자에 게가이 생성자를 호출 하 충분 한 권한이 없습니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyName</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  platform:
  - net462
- uid: System.AppDomain.CurrentDomain
  id: CurrentDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "현재 응용 프로그램 도메인에 대 한 현재 가져옵니다 <xref href=&quot;System.Threading.Thread&quot;> </xref>합니다."
  remarks: ''
  example:
  - "The following code example creates a new application domain. The CurrentDomain property is used to obtain an <xref:System.AppDomain> object that represents the current application domain. The <xref:System.AppDomain.FriendlyName%2A> property provides the name of the current application domain, which is then displayed at the command line.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.curre_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.curre_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.curre_1.cs)]"
  syntax:
    content: public static AppDomain CurrentDomain { get; }
    return:
      type: System.AppDomain
      description: "현재 응용 프로그램 도메인입니다."
  overload: System.AppDomain.CurrentDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정된 된 이름 및 액세스 모드를 사용 하는 동적 어셈블리를 정의합니다."
  remarks: "이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>메서드 오버 로드.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > 동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하는 <xref:System.AppDomain.DefineDynamicAssembly%2A>증명 정보 및 사용 권한을 지정 하는 메서드를 포함 하는 동적 어셈블리를 개발할 때는 제공 <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>에 `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag>에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다.</xref:System.Security.Permissions.SecurityPermissionFlag> 이 방법의 제한 사항은은 <xref:System.Security.SecurityException>완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the DefineDynamicAssembly method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/ec69fa93-4aea-4fc8-90e1-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/ec69fa93-4aea-4fc8-90e1-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/ec69fa93-4aea-4fc8-90e1-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "동적 어셈블리의 고유 id입니다."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "동적 어셈블리에 대 한 액세스 모드입니다."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "지정한 이름 및 액세스 모드를 사용 하는 동적 어셈블리입니다."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -또는- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> 속성 <code> name </code> 공백으로 시작 하거나 슬래시 또는 백슬래시를 포함 합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 이름, 액세스 모드 및 사용자 지정 특성을 갖는 동적 어셈블리를 정의합니다."
  remarks: "이 메서드 오버 로드를 사용 하 여 동적 어셈블리를 만들 때 적용 하지 않으면 올바르게 작동 하지 않는 특성을 지정 합니다. 예를 들어 같은 보안 특성 <xref:System.Security.SecurityTransparentAttribute>및 <xref:System.Security.SecurityCriticalAttribute>동적 어셈블리를 만든 후에 추가 된 경우 제대로 작동 하지 않습니다.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 이 제한에 대 한 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>메서드 오버 로드.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>       이 메서드는 오버 로드는 [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]합니다."
  example:
  - "The following code sample shows how to create a dynamic assembly that has the <xref:System.Security.SecurityTransparentAttribute>. The attribute must be specified as an element of an array of <xref:System.Reflection.Emit.CustomAttributeBuilder> objects.  \n  \n The first step in creating the <xref:System.Reflection.Emit.CustomAttributeBuilder> is to obtain a constructor for the attribute. The constructor has no parameters, so the <xref:System.Type.GetConstructor%2A> method is called with an empty array of <xref:System.Type> objects to represent the types of the parameters. The second step is to pass the resulting <xref:System.Reflection.ConstructorInfo> object to the constructor for the <xref:System.Reflection.Emit.CustomAttributeBuilder> class, together with an empty array of type <xref:System.Object> to represent the arguments.  \n  \n The resulting <xref:System.Reflection.Emit.CustomAttributeBuilder> is then passed to the DefineDynamicAssembly method as the only element of an array.  \n  \n The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.  \n  \n [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/cpp/02b9ff71-a699-4692-a2ae-_1.cpp)]\n [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/visualbasic/02b9ff71-a699-4692-a2ae-_1.vb)]\n [!code-cs[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/csharp/02b9ff71-a699-4692-a2ae-_1.cs)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "동적 어셈블리의 고유 id입니다."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "동적 어셈블리에 대 한 액세스 모드입니다."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "어셈블리에 적용 될 특성의 열거형 목록 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 특성이 없는 경우."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "지정한 이름 및 기능을 사용 하는 동적 어셈블리입니다."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -또는- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> 속성 <code> name </code> 공백으로 시작 하거나 슬래시 또는 백슬래시를 포함 합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 이름, 액세스 모드 및 증명 정보를 사용 하 여 동적 어셈블리를 정의 합니다."
  remarks: "호출자가 제공할 수를 완전히 신뢰할 수 있는 해당 `evidence` 동적 <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> 를 정의 하는 경우 런타임에 매핑될는 <xref:System.Security.Policy.Evidence>부여 된 권한을 확인 하기 위해 보안 정책을 통해.</xref:System.Security.Policy.Evidence> 호출자가 null을 제공 해야 합니다를 부분적으로 신뢰할 수 있는 `evidence`합니다. 경우 `evidence` 은 `null`, 런타임에서 사용 권한 집합을 복사, 즉, 현재 허용 / 거부 호출자의에서 <xref:System.Reflection.Assembly>동적 <xref:System.Reflection.Assembly>정의 되 고 정책을 해결 된 것으로 표시 합니다.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       경우 동적 <xref:System.Reflection.Assembly>은 디스크에 저장 다음 로드 받아볼 위치에 연결 된 정책에 따라 승인 위치는 <xref:System.Reflection.Assembly>저장 되었습니다.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>메서드 오버 로드.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > 동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하는 <xref:System.AppDomain.DefineDynamicAssembly%2A>증명 정보 및 사용 권한을 지정 하는 메서드를 포함 하는 동적 어셈블리를 개발할 때는 제공 <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>에 `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag>에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다.</xref:System.Security.Permissions.SecurityPermissionFlag> 이 방법의 제한 사항은은 <xref:System.Security.SecurityException>완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.  \n  \n First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.  \n  \n The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`. During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly. The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly. The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/1d1d705b-aac9-4233-8756-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/1d1d705b-aac9-4233-8756-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/1d1d705b-aac9-4233-8756-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "동적 어셈블리의 고유 id입니다."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "동적 어셈블리 액세스 되는 모드입니다."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "동적 어셈블리에 제공 된 증명 정보입니다. 증명 정보는 변경 되지 않고 정책 결정에 사용할 증명 정보는 최종로 사용 됩니다."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "지정한 이름 및 기능을 사용 하는 동적 어셈블리입니다."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -또는- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> 속성 <code> name </code> 공백으로 시작 하거나 슬래시 또는 백슬래시를 포함 합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 이름, 액세스 모드 및 저장소 디렉터리를 사용 하 여 동적 어셈블리를 정의 합니다."
  remarks: "이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>메서드 오버 로드.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > 동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하는 <xref:System.AppDomain.DefineDynamicAssembly%2A>증명 정보 및 사용 권한을 지정 하는 메서드를 포함 하는 동적 어셈블리를 개발할 때는 제공 <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>에 `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag>에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다.</xref:System.Security.Permissions.SecurityPermissionFlag> 이 방법의 제한 사항은은 <xref:System.Security.SecurityException>완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/f3a30d18-28ff-4503-b1c6-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/f3a30d18-28ff-4503-b1c6-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/f3a30d18-28ff-4503-b1c6-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "동적 어셈블리의 고유 id입니다."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "동적 어셈블리 액세스 되는 모드입니다."
    - id: dir
      type: System.String
      description: "어셈블리를 저장할 디렉터리의 이름입니다. 경우 `dir` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, 현재 디렉터리가 기본값으로 합니다."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "지정한 이름 및 기능을 사용 하는 동적 어셈블리입니다."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -또는- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> 속성 <code> name </code> 공백으로 시작 하거나 슬래시 또는 백슬래시를 포함 합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 이름, 액세스 모드 및 사용자 지정 특성을 사용 하 여 동적 어셈블리를 정의 하 고 보안 컨텍스트에 대해 지정된 된 소스를 사용 합니다."
  remarks: "이 메서드 오버 로드를 사용 하 여 동적 어셈블리를 만들 때 적용 하지 않으면 올바르게 작동 하지 않는 특성을 지정 합니다. 예를 들어 같은 보안 특성 <xref:System.Security.SecurityTransparentAttribute>및 <xref:System.Security.SecurityCriticalAttribute>동적 어셈블리를 만든 후에 추가 된 경우 제대로 작동 하지 않습니다.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 이 제한에 대 한 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>메서드 오버 로드.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes, System.Security.SecurityContextSource securityContextSource);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "동적 어셈블리의 고유 id입니다."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "동적 어셈블리에 대 한 액세스 모드입니다."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "어셈블리에 적용 될 특성의 열거형 목록 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 특성이 없는 경우."
    - id: securityContextSource
      type: System.Security.SecurityContextSource
      description: "보안 컨텍스트의 소스입니다."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "지정한 이름 및 기능을 사용 하는 동적 어셈블리입니다."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -또는- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> 속성 <code> name </code> 공백으로 시작 하거나 슬래시 또는 백슬래시를 포함 합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "값 <code> securityContextSource </code> 열거형 값 중 하나가 없습니다."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 이름, 액세스 모드, 저장소 디렉터리 및 증명 정보를 사용 하 여 동적 어셈블리를 정의 합니다."
  remarks: "호출자가 제공할 수를 완전히 신뢰할 수 있는 해당 `evidence` 동적 <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> 를 정의 하는 경우 런타임에 매핑될는 <xref:System.Security.Policy.Evidence>부여 된 권한을 확인 하기 위해 보안 정책을 통해.</xref:System.Security.Policy.Evidence> 호출자가 null을 제공 해야 합니다를 부분적으로 신뢰할 수 있는 `evidence`합니다. 경우 `evidence` 은 `null`, 런타임에서 사용 권한 집합을 복사, 즉, 현재 허용 / 거부 호출자의에서 <xref:System.Reflection.Assembly>동적 <xref:System.Reflection.Assembly>정의 되 고 정책을 해결 된 것으로 표시 합니다.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       경우 동적 <xref:System.Reflection.Assembly>은 디스크에 저장 다음 로드 받아볼 위치에 연결 된 정책에 따라 승인 위치는 <xref:System.Reflection.Assembly>저장 되었습니다.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>메서드 오버 로드.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > 동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하는 <xref:System.AppDomain.DefineDynamicAssembly%2A>증명 정보 및 사용 권한을 지정 하는 메서드를 포함 하는 동적 어셈블리를 개발할 때는 제공 <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>에 `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag>에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다.</xref:System.Security.Permissions.SecurityPermissionFlag> 이 방법의 제한 사항은은 <xref:System.Security.SecurityException>완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/2cf98986-7843-48cf-a73f-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/2cf98986-7843-48cf-a73f-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/2cf98986-7843-48cf-a73f-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "동적 어셈블리의 고유 id입니다."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "동적 어셈블리 액세스 되는 모드입니다."
    - id: dir
      type: System.String
      description: "어셈블리를 저장할 디렉터리의 이름입니다. 경우 `dir` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, 현재 디렉터리가 기본값으로 합니다."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "동적 어셈블리에 제공 된 증명 정보입니다. 증명 정보는 변경 되지 않고 정책 결정에 사용할 증명 정보는 최종로 사용 됩니다."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "지정한 이름 및 기능을 사용 하는 동적 어셈블리입니다."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -또는- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> 속성 <code> name </code> 공백으로 시작 하거나 슬래시 또는 백슬래시를 포함 합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 이름, 액세스 모드 및 권한 요청을 사용 하 여 동적 어셈블리를 정의 합니다."
  remarks: "에 대 한 지정 된 권한 요청 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 동적 어셈블리 저장 되 고 메모리에 다시 로드 하지 않는 한 사용 되지 않습니다. 임시 어셈블리의 오버 로드를 사용 하는 디스크에 저장 되지 않은 대 한 권한 요청을 지정 하는 <xref:System.AppDomain.DefineDynamicAssembly%2A>요청 된 사용 권한 및 공급으로 증명 정보를 지정 하는 메서드는 <xref:System.Security.Policy.Evidence>개체입니다.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > 동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하는 <xref:System.AppDomain.DefineDynamicAssembly%2A>증명 정보 및 사용 권한을 지정 하는 메서드를 포함 하는 동적 어셈블리를 개발할 때는 제공 <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>에 `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag>에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다.</xref:System.Security.Permissions.SecurityPermissionFlag> 이 방법의 제한 사항은은 <xref:System.Security.SecurityException>완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.</xref:System.Security.SecurityException>       이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>메서드 오버 로드.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/be48f0dd-e58f-4a8c-bdad-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/be48f0dd-e58f-4a8c-bdad-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/be48f0dd-e58f-4a8c-bdad-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "동적 어셈블리의 고유 id입니다."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "동적 어셈블리 액세스 되는 모드입니다."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "필수 권한 요청입니다."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "선택적 권한 요청입니다."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "거부 된 권한 요청입니다."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "지정한 이름 및 기능을 사용 하는 동적 어셈블리입니다."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -또는- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> 속성 <code> name </code> 공백으로 시작 하거나 슬래시 또는 백슬래시를 포함 합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 이름, 액세스 모드, 저장소 디렉터리 및 동기화 옵션을 사용 하 여 동적 어셈블리를 정의 합니다."
  remarks: "이 메서드 오버 로드를 사용 하 여 동적 어셈블리를 만들 때 적용 하지 않으면 올바르게 작동 하지 않는 특성을 지정 합니다. 예를 들어 같은 보안 특성 <xref:System.Security.SecurityTransparentAttribute>및 <xref:System.Security.SecurityCriticalAttribute>동적 어셈블리를 만든 후에 추가 된 경우 제대로 작동 하지 않습니다.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       경우 `isSynchronized` 은 `true`, 결과 다음과 같은 방법을 <xref:System.Reflection.Emit.AssemblyBuilder>동기화 됩니다: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, 및 <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> 이러한 방법 중 두 가지 서로 다른 스레드에서 호출 하는 경우 다른 완료 될 때까지 차단 됩니다."
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "동적 어셈블리의 고유 id입니다."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "동적 어셈블리 액세스 되는 모드입니다."
    - id: dir
      type: System.String
      description: "동적 어셈블리를 저장할 디렉터리의 이름입니다. 경우 `dir` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, 현재 디렉터리가 사용 됩니다."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>모듈, 형식 및 멤버에 동적 어셈블리의 만들기를 동기화 하려면 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "어셈블리에 적용 될 특성의 열거형 목록 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 특성이 없는 경우."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "지정한 이름 및 기능을 사용 하는 동적 어셈블리입니다."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -또는- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> 속성 <code> name </code> 공백으로 시작 하거나 슬래시 또는 백슬래시를 포함 합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 이름, 액세스 모드, 증명 정보 및 권한 요청을 사용 하 여 동적 어셈블리를 정의 합니다."
  remarks: "에 대 한 지정 된 권한 요청 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 경우에 사용 `evidence` 에서도 제공 되는 동적 어셈블리를 저장 하 고 다시 메모리에 로드 하는 경우 또는 합니다.      > [!NOTE] > 동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다 포함 하는 <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>에 `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag>에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다.</xref:System.Security.Permissions.SecurityPermissionFlag> 이 방법의 제한 사항은은 <xref:System.Security.SecurityException>완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.</xref:System.Security.SecurityException>       호출자가 제공할 수를 완전히 신뢰할 수 있는 해당 `evidence` 동적 <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> 를 정의 하는 경우 런타임에 매핑될는 <xref:System.Security.Policy.Evidence>부여 된 권한을 확인 하기 위해 보안 정책을 통해.</xref:System.Security.Policy.Evidence> 호출자가 null을 제공 해야 합니다를 부분적으로 신뢰할 수 있는 `evidence`합니다. 경우 `evidence` 은 `null`, 런타임에서 사용 권한 집합을 복사, 즉, 현재 허용 / 거부 호출자의에서 <xref:System.Reflection.Assembly>동적 <xref:System.Reflection.Assembly>정의 되 고 정책을 해결 된 것으로 표시 합니다.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       경우 동적 <xref:System.Reflection.Assembly>은 디스크에 저장 다음 로드 받아볼 위치에 연결 된 정책에 따라 승인 위치는 <xref:System.Reflection.Assembly>저장 되었습니다.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>메서드 오버 로드.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/7d7c7162-9e00-4b91-93d0-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/7d7c7162-9e00-4b91-93d0-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/7d7c7162-9e00-4b91-93d0-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "동적 어셈블리의 고유 id입니다."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "동적 어셈블리 액세스 되는 모드입니다."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "동적 어셈블리에 제공 된 증명 정보입니다. 증명 정보는 변경 되지 않고 정책 결정에 사용할 증명 정보는 최종로 사용 됩니다."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "필수 권한 요청입니다."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "선택적 권한 요청입니다."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "거부 된 권한 요청입니다."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "지정한 이름 및 기능을 사용 하는 동적 어셈블리입니다."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -또는- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> 속성 <code> name </code> 공백으로 시작 하거나 슬래시 또는 백슬래시를 포함 합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 이름, 액세스 모드, 저장소 디렉터리 및 권한 요청을 사용 하 여 동적 어셈블리를 정의 합니다."
  remarks: "에 대 한 지정 된 권한 요청 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 동적 어셈블리 저장 되 고 메모리에 다시 로드 하지 않는 한 사용 되지 않습니다. 임시 어셈블리의 오버 로드를 사용 하는 디스크에 저장 되지 않은 대 한 권한 요청을 지정 하는 <xref:System.AppDomain.DefineDynamicAssembly%2A>요청 된 사용 권한 및 공급으로 증명 정보를 지정 하는 메서드는 <xref:System.Security.Policy.Evidence>개체입니다.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > 동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하는 <xref:System.AppDomain.DefineDynamicAssembly%2A>증명 정보 및 사용 권한을 지정 하는 메서드를 포함 하는 동적 어셈블리를 개발할 때는 제공 <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>에 `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag>에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다.</xref:System.Security.Permissions.SecurityPermissionFlag> 이 방법의 제한 사항은은 <xref:System.Security.SecurityException>완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.</xref:System.Security.SecurityException>       이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>메서드 오버 로드.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0fc3676e-96ff-42c6-ad25-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0fc3676e-96ff-42c6-ad25-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0fc3676e-96ff-42c6-ad25-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "동적 어셈블리의 고유 id입니다."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "동적 어셈블리 액세스 되는 모드입니다."
    - id: dir
      type: System.String
      description: "어셈블리를 저장할 디렉터리의 이름입니다. 경우 `dir` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, 현재 디렉터리가 기본값으로 합니다."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "필수 권한 요청입니다."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "선택적 권한 요청입니다."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "거부 된 권한 요청입니다."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "지정한 이름 및 기능을 사용 하는 동적 어셈블리입니다."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -또는- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> 속성 <code> name </code> 공백으로 시작 하거나 슬래시 또는 백슬래시를 포함 합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 이름, 액세스 모드, 저장소 디렉터리, 증명 정보 및 권한 요청을 사용 하 여 동적 어셈블리를 정의 합니다."
  remarks: "에 대 한 지정 된 권한 요청 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 경우에 사용 `evidence` 에서도 제공 되는 동적 어셈블리를 저장 하 고 다시 메모리에 로드 하는 경우 또는 합니다.      > [!NOTE] > 동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다 포함 하는 <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>에 `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag>에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다.</xref:System.Security.Permissions.SecurityPermissionFlag> 이 방법의 제한 사항은은 <xref:System.Security.SecurityException>완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.</xref:System.Security.SecurityException>       호출자가 제공할 수를 완전히 신뢰할 수 있는 해당 `evidence` 동적 <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> 를 정의 하는 경우 런타임에 매핑될는 <xref:System.Security.Policy.Evidence>부여 된 권한을 확인 하기 위해 보안 정책을 통해.</xref:System.Security.Policy.Evidence> 호출자가 null을 제공 해야 합니다를 부분적으로 신뢰할 수 있는 `evidence`합니다. 경우 `evidence` 은 `null`, 런타임에서 사용 권한 집합을 복사, 즉, 현재 허용 / 거부 호출자의에서 <xref:System.Reflection.Assembly>동적 <xref:System.Reflection.Assembly>정의 되 고 정책을 해결 된 것으로 표시 합니다.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       경우 동적 <xref:System.Reflection.Assembly>은 디스크에 저장 다음 로드 받아볼 위치에 연결 된 정책에 따라 승인 위치는 <xref:System.Reflection.Assembly>저장 되었습니다.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>메서드 오버 로드.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0baa3466-02cf-4d9c-bb66-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0baa3466-02cf-4d9c-bb66-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0baa3466-02cf-4d9c-bb66-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "동적 어셈블리의 고유 id입니다."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "동적 어셈블리 액세스 되는 모드입니다."
    - id: dir
      type: System.String
      description: "어셈블리를 저장할 디렉터리의 이름입니다. 경우 `dir` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, 현재 디렉터리가 기본값으로 합니다."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "동적 어셈블리에 제공 된 증명 정보입니다. 증명 정보는 변경 되지 않고 정책 결정에 사용할 증명 정보는 최종로 사용 됩니다."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "필수 권한 요청입니다."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "선택적 권한 요청입니다."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "거부 된 권한 요청입니다."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "지정한 이름 및 기능을 사용 하는 동적 어셈블리입니다."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -또는- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> 속성 <code> name </code> 공백으로 시작 하거나 슬래시 또는 백슬래시를 포함 합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 이름, 액세스 모드, 저장소 디렉터리, 증명 정보, 권한 요청 및 동기화 옵션을 사용 하 여 동적 어셈블리를 정의 합니다."
  remarks: "에 대 한 지정 된 권한 요청 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 경우에 사용 `evidence` 에서도 제공 되는 동적 어셈블리를 저장 하 고 다시 메모리에 로드 하는 경우 또는 합니다.      > [!NOTE] > 동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다 포함 하는 <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>에 `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag>에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다.</xref:System.Security.Permissions.SecurityPermissionFlag> 이 방법의 제한 사항은은 <xref:System.Security.SecurityException>완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.</xref:System.Security.SecurityException>       완전히 신뢰할 수 있는 호출자만 동적 <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> 정의할 때 해당 증명 정보를 제공할 수 있습니다. 런타임에 매핑될는 <xref:System.Security.Policy.Evidence>부여 된 권한을 확인 하기 위해 보안 정책을 통해.</xref:System.Security.Policy.Evidence> 호출자를 부분적으로 신뢰할 수 있는 `null` 에 대 한는 `evidence` 매개 변수입니다. 경우 `evidence` 은 `null`, 런타임에서 사용 권한 집합을 복사, 즉, 현재 허용 / 거부 호출자의에서 <xref:System.Reflection.Assembly>동적 <xref:System.Reflection.Assembly>정의 되 고 정책을 해결 된 것으로 표시 합니다.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       경우 동적 <xref:System.Reflection.Assembly>은 디스크에 저장 다음 로드 받아볼 위치에 연결 된 정책에 따라 승인 위치는 <xref:System.Reflection.Assembly>저장 되었습니다.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       경우 `isSynchronized` 은 `true`, 결과 다음과 같은 방법을 <xref:System.Reflection.Emit.AssemblyBuilder>동기화 됩니다: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, 및 <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> 이러한 방법 중 두 가지 서로 다른 스레드에서 호출 하는 경우 다른 완료 될 때까지 차단 됩니다."
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/84dd3b17-5601-467b-b1e3-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/84dd3b17-5601-467b-b1e3-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/84dd3b17-5601-467b-b1e3-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "동적 어셈블리의 고유 id입니다."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "동적 어셈블리 액세스 되는 모드입니다."
    - id: dir
      type: System.String
      description: "동적 어셈블리를 저장할 디렉터리의 이름입니다. 경우 `dir` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, 현재 디렉터리가 기본값으로 합니다."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "동적 어셈블리에 제공 된 증명 정보입니다. 증명 정보는 변경 되지 않고 정책 결정에 사용할 증명 정보는 최종로 사용 됩니다."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "필수 권한 요청입니다."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "선택적 권한 요청입니다."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "거부 된 권한 요청입니다."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>모듈, 형식 및 멤버에 동적 어셈블리의 만들기를 동기화 하려면 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "지정한 이름 및 기능을 사용 하는 동적 어셈블리입니다."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -또는- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> 속성 <code> name </code> 공백으로 시작 하거나 슬래시 또는 백슬래시를 포함 합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 이름, 액세스 모드, 저장소 디렉터리, 증명 정보, 권한 요청, 동기화 옵션 및 사용자 지정 특성을 갖는 동적 어셈블리를 정의합니다."
  remarks: "이 메서드 오버 로드를 사용 하 여 동적 어셈블리를 만들 때 적용 하지 않으면 올바르게 작동 하지 않는 특성을 지정 합니다. 예를 들어 같은 보안 특성 <xref:System.Security.SecurityTransparentAttribute>및 <xref:System.Security.SecurityCriticalAttribute>동적 어셈블리를 만든 후에 추가 된 경우 제대로 작동 하지 않습니다.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       에 대 한 지정 된 권한 요청은 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 경우에 사용 되는 매개 변수는 `evidence` 매개 변수도 제공한, 또는 동적 어셈블리를 저장 하 고 다시 메모리에 로드 하는 경우.      > [!NOTE] > 동적 어셈블리를 내보내는 코드를 개발 하는 경우 포함 하는 것이 좋습니다는 <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>플래그는 `refusedPermissions` 매개 변수.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> 이 플래그를 포함 하면 Microsoft MSIL (intermediate language)를 확인 합니다. 이 기술은 있는 파악 하기가 매우 어렵습니다 비안정형 코드의 의도 하지 않게 생성을 검색 합니다. 이 방법의 제한 사항은은 <xref:System.Security.SecurityException>를 완전 신뢰를 요청 하는 코드를 함께 사용 하는 경우.</xref:System.Security.SecurityException>       완전히 신뢰할 수 있는 호출자만 동적 <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> 정의할 때 증명 정보를 제공할 수 있습니다. 런타임에 매핑되는 <xref:System.Security.Policy.Evidence>부여 된 권한을 확인 하기 위해 보안 정책을 통해.</xref:System.Security.Policy.Evidence> 호출자를 부분적으로 신뢰할 수 있는 `null` 에 대 한는 `evidence` 매개 변수입니다. 경우 `evidence` 은 `null`, 런타임에서 호출자의 어셈블리에서 정의 되 고 확인 된 것으로 고 정책을 표시 하는 동적 어셈블리에 (즉, 즉 현재 부여 및 거부 집합) 사용 권한 집합을 복사 합니다.       동적 어셈블리 후속 디스크에 저장 됩니다 부하는 동적 어셈블리를 저장할 위치와 연결 된 정책을 기반으로 하는 권한을 부여 받습니다.       경우 `isSynchronized` 은 `true`, 결과 다음과 같은 방법을 <xref:System.Reflection.Emit.AssemblyBuilder>동기화 됩니다: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, 및 <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> 이러한 방법 중 두 가지 서로 다른 스레드에서 호출 하는 경우 다른 완료 될 때까지 차단 됩니다.       이 메서드는 오버 로드는 [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]합니다."
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "동적 어셈블리의 고유 id입니다."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "동적 어셈블리 액세스 되는 모드입니다."
    - id: dir
      type: System.String
      description: "동적 어셈블리를 저장할 디렉터리의 이름입니다. 경우 `dir` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, 현재 디렉터리가 사용 됩니다."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "동적 어셈블리에 제공 된 증거입니다. 증명 정보는 변경 되지 않고 정책 결정에 사용할 증명 정보는 최종로 사용 됩니다."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "필수 권한 요청입니다."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "선택적 권한 요청입니다."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "거부 된 권한 요청입니다."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>모듈, 형식 및 멤버에 동적 어셈블리의 만들기를 동기화 하려면 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "어셈블리에 적용 될 특성의 열거형 목록 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 특성이 없는 경우."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "지정한 이름 및 기능을 사용 하는 동적 어셈블리입니다."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -또는- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> 속성 <code> name </code> 공백으로 시작 하거나 슬래시 또는 백슬래시를 포함 합니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  id: DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  langs:
  - csharp
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 대리자에서 식별 되는 다른 응용 프로그램 도메인에서 코드를 실행 합니다."
  remarks: '`callBackDelegate`마샬링-by-값을 지정할 수 <xref:System.MarshalByRefObject>, 또는 <xref:System.ContextBoundObject>.</xref:System.ContextBoundObject> </xref:System.MarshalByRefObject>'
  example:
  - "The following sample demonstrates using a static DoCallBack method.  \n  \n [!code-vb[AppDomain_DoCallBack#1](~/add/codesnippet/visualbasic/m-system.appdomain.docal_1.vb)]\n [!code-cpp[AppDomain_DoCallBack#1](~/add/codesnippet/cpp/m-system.appdomain.docal_1.cpp)]\n [!code-cs[AppDomain_DoCallBack#1](~/add/codesnippet/csharp/m-system.appdomain.docal_1.cs)]  \n  \n The following sample demonstrates using the DoCallBack method by value.  \n  \n [!code-vb[AppDomain_DoCallBack#2](~/add/codesnippet/visualbasic/m-system.appdomain.docal_2.vb)]\n [!code-cs[AppDomain_DoCallBack#2](~/add/codesnippet/csharp/m-system.appdomain.docal_2.cs)]\n [!code-cpp[AppDomain_DoCallBack#2](~/add/codesnippet/cpp/m-system.appdomain.docal_2.cpp)]  \n  \n The following sample demonstrates using the DoCallBack method by reference.  \n  \n [!code-cpp[AppDomain_DoCallBack#3](~/add/codesnippet/cpp/m-system.appdomain.docal_3.cpp)]\n [!code-cs[AppDomain_DoCallBack#3](~/add/codesnippet/csharp/m-system.appdomain.docal_3.cs)]\n [!code-vb[AppDomain_DoCallBack#3](~/add/codesnippet/visualbasic/m-system.appdomain.docal_3.vb)]"
  syntax:
    content: public void DoCallBack (CrossAppDomainDelegate callBackDelegate);
    parameters:
    - id: callBackDelegate
      type: System.CrossAppDomainDelegate
      description: "호출할 메서드를 지정 하는 대리자입니다."
  overload: System.AppDomain.DoCallBack*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBackDelegate</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.DomainManager
  id: DomainManager
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "응용 프로그램 도메인이 초기화 될 때 호스트에서 제공한 도메인 관리자를 가져옵니다."
  remarks: "공용 언어 런타임 (CLR)의 관리 되지 않는 호스트는 도메인 관리자를 제공할 수 있습니다. 도메인 관리자는 새 응용 프로그램 도메인 초기화에 참여할 고와 같은 다른 관리자를 제공할 수는 <xref:System.Security.HostSecurityManager>, 응용 프로그램 도메인의 작업에 참여 하는.</xref:System.Security.HostSecurityManager>"
  syntax:
    content: public AppDomainManager DomainManager { get; }
    return:
      type: System.AppDomainManager
      description: "응용 프로그램 도메인이 초기화 되었을 때 호스트에서 제공한 도메인 관리자를 나타내는 개체 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 없는 도메인 관리자가 제공 하는 경우."
  overload: System.AppDomain.DomainManager*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DomainUnload
  id: DomainUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "발생 경우는 <xref href=&quot;System.AppDomain&quot;> </xref> 언로드 되려고 합니다."
  remarks: "<xref:System.EventHandler>대리자이 이벤트는 응용 프로그램 도메인 로드 되기 전에 종료 동작을 수행할 수 있습니다.</xref:System.EventHandler>       각 응용 프로그램 도메인에 로드 되지 않았을 때 처리를 수행 해야 하는이 이벤트에 대 한 이벤트 처리기를 등록 해야 합니다. 공유 이벤트 처리기 해야 하지 때문에 사용할 수는 <xref:System.EventHandler>대리자 언로드되고 도메인을 식별 하지 않습니다.</xref:System.EventHandler>      > [!NOTE] > 기본 응용 프로그램 도메인에서이 이벤트는 발생 하지 않습니다.       에 이벤트가 발생 하는 스레드에 대 한 가정을 만들지 마십시오. 호출한 스레드가 아닌 다른 스레드에서 이벤트가 발생할 수 있습니다는 <xref:System.AppDomain.Unload%2A>메서드.</xref:System.AppDomain.Unload%2A>       이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public event EventHandler DomainUnload;
    return:
      type: System.EventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DynamicDirectory
  id: DynamicDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "어셈블리 확인자에서 사용 하 여 동적으로 만든된 어셈블리를 조사 하는 디렉터리를 가져옵니다."
  remarks: "동적 디렉터리를 설정 하려면 기본 디렉터리 경로를 할당는 <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>의 속성은 <xref:System.AppDomainSetup>새 응용 프로그램 도메인을 만드는 데 사용할 개체입니다.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> 속성에 할당 하는 기본 디렉터리 경로 단순 이름인에 할당 하는 문자열의 해시 코드 하위 디렉터리를 추가 하 여 수정 되는 <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>기본 디렉터리의 형식은 속성 *원래 경로*\\\\*해시 코드*.</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName> 동적 디렉터리에는이 기본 디렉터리의 하위 디렉터리입니다. 간단한 이름은의 값인는 <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>속성, 해당 형식은입니다 *원래 경로*\\\\*해시 코드*\\\\*응용 프로그램 이름*.</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>"
  example:
  - "The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.  \n  \n The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to \"Example\" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to \"C:\\DynamicAssemblyDir\". The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.  \n  \n> [!NOTE]\n>  The base directory in this example is intended to be outside the probing path for the example application. Be sure to compile the example in a different location. Delete the base directory and all its subdirectories each time you run the example.  \n  \n The example creates a new application domain, using the <xref:System.AppDomainSetup> object. The example uses the DynamicDirectory property to retrieve the name of the directory, so it can create the directory. (The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)  \n  \n The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory. The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`. Calling this method displays the name of the application domain.  \n  \n The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method. The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.  \n  \n You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example. The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`. This method does not have to have the same functionality as the one in the example; it can simply display a string to the console. The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0. When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/p-system.appdomain.dynam_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/p-system.appdomain.dynam_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.dynam_1.vb)]"
  syntax:
    content: public string DynamicDirectory { get; }
    return:
      type: System.String
      description: "어셈블리 확인자에서 동적으로 생성된 된 어셈블리를 조사 사용 되는 디렉터리입니다."
  overload: System.AppDomain.DynamicDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.Evidence
  id: Evidence
  parent: System.AppDomain
  langs:
  - csharp
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "가져옵니다는 <xref href=&quot;System.Security.Policy.Evidence&quot;> </xref> 이 응용 프로그램 도메인에 연결 합니다."
  syntax:
    content: public System.Security.Policy.Evidence Evidence { get; }
    return:
      type: System.Security.Policy.Evidence
      description: "이 응용 프로그램 도메인과 관련 된 증거입니다."
  overload: System.AppDomain.Evidence*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String)
  id: ExecuteAssembly(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정된 된 파일에 포함 된 어셈블리를 실행 합니다."
  remarks: "어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.       이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.       이 메서드를 사용 하 여 어셈블리 로드는 <xref:System.Reflection.Assembly.LoadFile%2A>메서드.</xref:System.Reflection.Assembly.LoadFile%2A> 사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A>메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A>메서드.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       만들려는 <xref:System.AppDomain>로드 하 고 실행을 사용 하 여는 <xref:System.AppDomain.CreateDomain%2A>메서드.</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  example:
  - "The following sample demonstrates using one of the overloads of ExecuteAssembly on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_0_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_0_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_0_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "실행할 어셈블리가 포함 된 파일의 이름입니다."
    return:
      type: System.Int32
      description: "어셈블리의 진입점에서 반환한 값입니다."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>´ ù."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyFile</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "지정된 된 어셈블리에 진입점을 없습니다."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 증명 정보를 사용 하 여 지정된 된 파일에 포함 된 어셈블리를 실행 합니다."
  remarks: "어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.       <xref:System.AppDomain.ExecuteAssembly%2A>메서드는 새 프로세스 또는 응용 프로그램 도메인을 만들지 않습니다을 진입점 메서드 새 스레드에서 실행 되지 않습니다.</xref:System.AppDomain.ExecuteAssembly%2A>       이 메서드를 사용 하 여 어셈블리 로드는 <xref:System.Reflection.Assembly.LoadFile%2A>메서드.</xref:System.Reflection.Assembly.LoadFile%2A> 사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A>메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A>메서드.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/8a3b95e3-eb51-4f5b-bb93-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/8a3b95e3-eb51-4f5b-bb93-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/8a3b95e3-eb51-4f5b-bb93-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "실행할 어셈블리가 포함 된 파일의 이름입니다."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "어셈블리 로드에 대 한 증명 정보입니다."
    return:
      type: System.Int32
      description: "어셈블리의 진입점에서 반환한 값입니다."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>´ ù."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyFile</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "지정된 된 어셈블리에 진입점을 없습니다."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  id: ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정된 된 인수를 사용 하 여 지정된 된 파일에 포함 된 어셈블리를 실행 합니다."
  remarks: "어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.       이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.       이 메서드를 사용 하 여 어셈블리 로드는 <xref:System.Reflection.Assembly.LoadFile%2A>메서드.</xref:System.Reflection.Assembly.LoadFile%2A> 사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A>메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A>메서드.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_1_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_1_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_1_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "실행할 어셈블리가 포함 된 파일의 이름입니다."
    - id: args
      type: System.String[]
      description: "어셈블리의 진입점에 대 한 인수입니다."
    return:
      type: System.Int32
      description: "어셈블리의 진입점에서 반환 되는 값입니다."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>´ ù."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>유효한 어셈블리가 않습니다.       -또는- <code>assemblyFile</code> 공용 언어 런타임이 현재 로드 되어 있는 버전 보다 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "지정된 된 어셈블리에 진입점을 없습니다."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 증거와 인수를 사용 하 여 지정된 된 파일에 포함 된 어셈블리를 실행 합니다."
  remarks: "어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.       이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.       이 메서드를 사용 하 여 어셈블리 로드는 <xref:System.Reflection.Assembly.LoadFile%2A>메서드.</xref:System.Reflection.Assembly.LoadFile%2A> 사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A>메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A>메서드.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/cb15b913-548c-4cb1-bbc5-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/cb15b913-548c-4cb1-bbc5-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/cb15b913-548c-4cb1-bbc5-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "실행할 어셈블리가 포함 된 파일의 이름입니다."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "어셈블리에 대 한 제공 된 증명 정보입니다."
    - id: args
      type: System.String[]
      description: "어셈블리의 진입점에 대 한 인수입니다."
    return:
      type: System.Int32
      description: "어셈블리의 진입점에서 반환한 값입니다."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>´ ù."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyFile</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 레거시 CAS 정책을 설정 하지 않으면 <code>assemblySecurity</code> 해야 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "지정된 된 어셈블리에 진입점을 없습니다."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정 된 인수, 해시 값 및 해시 알고리즘을 사용 하 여 지정된 된 파일에 포함 된 어셈블리를 실행 합니다."
  remarks: "어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.       이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.       이 메서드를 사용 하 여 어셈블리 로드는 <xref:System.Reflection.Assembly.LoadFile%2A>메서드.</xref:System.Reflection.Assembly.LoadFile%2A> 사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A>메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A>메서드.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/ccb3b356-1169-4d65-9fdd-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/ccb3b356-1169-4d65-9fdd-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/ccb3b356-1169-4d65-9fdd-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "실행할 어셈블리가 포함 된 파일의 이름입니다."
    - id: args
      type: System.String[]
      description: "어셈블리의 진입점에 대 한 인수입니다."
    - id: hashValue
      type: System.Byte[]
      description: "계산된 된 해시 코드 값을 나타냅니다."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "어셈블리 매니페스트에 사용 되는 해시 알고리즘을 나타냅니다."
    return:
      type: System.Int32
      description: "어셈블리의 진입점에서 반환 되는 값입니다."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>´ ù."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>유효한 어셈블리가 않습니다.       -또는- <code>assemblyFile</code> 공용 언어 런타임이 현재 로드 되어 있는 버전 보다 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "지정된 된 어셈블리에 진입점을 없습니다."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 증명 정보, 인수, 해시 값 및 해시 알고리즘을 사용 하 여 지정된 된 파일에 포함 된 어셈블리를 실행 합니다."
  remarks: "어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.       이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.       이 메서드를 사용 하 여 어셈블리 로드는 <xref:System.Reflection.Assembly.LoadFile%2A>메서드.</xref:System.Reflection.Assembly.LoadFile%2A> 사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A>메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A>메서드.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "Thefollowing sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/c176353b-cef5-4b78-b4a8-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/c176353b-cef5-4b78-b4a8-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/c176353b-cef5-4b78-b4a8-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "실행할 어셈블리가 포함 된 파일의 이름입니다."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "어셈블리에 대 한 제공 된 증명 정보입니다."
    - id: args
      type: System.String[]
      description: "어셈블리의 진입점에 대 한 인수입니다."
    - id: hashValue
      type: System.Byte[]
      description: "계산된 된 해시 코드 값을 나타냅니다."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "어셈블리 매니페스트에 사용 되는 해시 알고리즘을 나타냅니다."
    return:
      type: System.Int32
      description: "어셈블리의 진입점에서 반환한 값입니다."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>´ ù."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyFile</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 레거시 CAS 정책을 설정 하지 않으면 <code>assemblySecurity</code> 해야 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "지정된 된 어셈블리에 진입점을 없습니다."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  id: ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "표시 이름이 지정 된 어셈블리를 실행 합니다."
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>에 유사한 기능을 제공 하는 메서드는 <xref:System.AppDomain.ExecuteAssembly%2A>메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName>아닌 파일 위치에 따라.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A>여 어셈블리를 로드는 <xref:System.Reflection.Assembly.Load%2A>메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A>메서드.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.       이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.       만들려는 <xref:System.AppDomain>로드 하 고 실행을 사용 하 여는 <xref:System.AppDomain.CreateDomain%2A>메서드.</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "어셈블리의 표시 이름입니다. 참조 &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;합니다."
    return:
      type: System.Int32
      description: "어셈블리의 진입점에서 반환한 값입니다."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 찾을 수 없습니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 유효한 어셈블리가 아닙니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code> assemblyName </code> 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 를 찾았지만 로드할 수 없습니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "지정된 된 어셈블리에 진입점을 없습니다."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정 된 어셈블리를 실행 한 <xref:System.Reflection.AssemblyName>, 지정된 된 인수를 사용 하 여.</xref:System.Reflection.AssemblyName>"
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>에 유사한 기능을 제공 하는 메서드는 <xref:System.AppDomain.ExecuteAssembly%2A>메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName>아닌 파일 위치에 따라.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A>여 어셈블리를 로드는 <xref:System.Reflection.Assembly.Load%2A>메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A>메서드.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.       이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다."
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "<xref:System.Reflection.AssemblyName>어셈블리의 이름을 나타내는 개체입니다.</xref:System.Reflection.AssemblyName>"
    - id: args
      type: System.String[]
      description: "프로세스를 시작할 때 전달할 명령줄 인수입니다."
    return:
      type: System.Int32
      description: "어셈블리의 진입점에서 반환 되는 값입니다."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 찾을 수 없습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 를 찾았지만 로드할 수 없습니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 유효한 어셈블리가 아닙니다.       -또는- <code> assemblyName </code> 공용 언어 런타임이 현재 로드 되어 있는 버전 보다 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "지정된 된 어셈블리에 진입점을 없습니다."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 증명 정보를 사용 하 여 표시 이름이 지정 된 어셈블리를 실행 합니다."
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>에 유사한 기능을 제공 하는 메서드는 <xref:System.AppDomain.ExecuteAssembly%2A>메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName>아닌 파일 위치에 따라.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A>여 어셈블리를 로드는 <xref:System.Reflection.Assembly.Load%2A>메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A>메서드.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.       <xref:System.AppDomain.ExecuteAssemblyByName%2A>메서드는 새 프로세스 또는 응용 프로그램 도메인을 만들지 않습니다을 진입점 메서드 새 스레드에서 실행 되지 않습니다.</xref:System.AppDomain.ExecuteAssemblyByName%2A>      > [!NOTE] > 사용 하는 경우는 <xref:System.AppDomain.ExecuteAssemblyByName%2A>메서드는 <xref:System.Security.Policy.Evidence>매개 변수, 증명 정보가 병합 됩니다.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 증명 정보에는 인수로 제공 되는 <xref:System.AppDomain.ExecuteAssemblyByName%2A>메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyName
      type: System.String
      description: "어셈블리의 표시 이름입니다. 참조 &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;합니다."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "어셈블리 로드에 대 한 증명 정보입니다."
    return:
      type: System.Int32
      description: "어셈블리의 진입점에서 반환한 값입니다."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 찾을 수 없습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 를 찾았지만 로드할 수 없습니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 유효한 어셈블리가 아닙니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code> assemblyName </code> 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "지정된 된 어셈블리에 진입점을 없습니다."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  id: ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정된 된 인수를 사용 하 여 지정 된 표시 이름, 어셈블리를 실행 합니다."
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>에 유사한 기능을 제공 하는 메서드는 <xref:System.AppDomain.ExecuteAssembly%2A>메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName>아닌 파일 위치에 따라.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A>여 어셈블리를 로드는 <xref:System.Reflection.Assembly.Load%2A>메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A>메서드.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.       이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다."
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "어셈블리의 표시 이름입니다. 참조 &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;합니다."
    - id: args
      type: System.String[]
      description: "프로세스를 시작할 때 전달할 명령줄 인수입니다."
    return:
      type: System.Int32
      description: "어셈블리의 진입점에서 반환 되는 값입니다."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 찾을 수 없습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 를 찾았지만 로드할 수 없습니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 유효한 어셈블리가 아닙니다.       -또는- <code> assemblyName </code> 공용 언어 런타임이 현재 로드 되어 있는 버전 보다 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "지정된 된 어셈블리에 진입점을 없습니다."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정 된 어셈블리를 실행 한 <xref:System.Reflection.AssemblyName>, 지정한 증거와 인수를 사용 하 여.</xref:System.Reflection.AssemblyName>"
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>에 유사한 기능을 제공 하는 메서드는 <xref:System.AppDomain.ExecuteAssembly%2A>메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName>아닌 파일 위치에 따라.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A>여 어셈블리를 로드는 <xref:System.Reflection.Assembly.Load%2A>메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A>메서드.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.       이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.      > [!NOTE] > 사용 하는 경우는 <xref:System.AppDomain.ExecuteAssemblyByName%2A>메서드는 <xref:System.Security.Policy.Evidence>매개 변수, 증명 정보가 병합 됩니다.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 증명 정보에는 인수로 제공 되는 <xref:System.AppDomain.ExecuteAssemblyByName%2A>메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "<xref:System.Reflection.AssemblyName>어셈블리의 이름을 나타내는 개체입니다.</xref:System.Reflection.AssemblyName>"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "어셈블리 로드에 대 한 증명 정보입니다."
    - id: args
      type: System.String[]
      description: "프로세스를 시작할 때 전달할 명령줄 인수입니다."
    return:
      type: System.Int32
      description: "어셈블리의 진입점에서 반환한 값입니다."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 찾을 수 없습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 를 찾았지만 로드할 수 없습니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 유효한 어셈블리가 아닙니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code> assemblyName </code> 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 레거시 CAS 정책을 설정 하지 않으면 <code>assemblySecurity</code> 해야 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "지정된 된 어셈블리에 진입점을 없습니다."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 증거와 인수를 사용 하 여 지정 된 표시 이름, 어셈블리를 실행 합니다."
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>에 유사한 기능을 제공 하는 메서드는 <xref:System.AppDomain.ExecuteAssembly%2A>메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName>아닌 파일 위치에 따라.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A>여 어셈블리를 로드는 <xref:System.Reflection.Assembly.Load%2A>메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A>메서드.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.       이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.      > [!NOTE] > 사용 하는 경우는 <xref:System.AppDomain.ExecuteAssemblyByName%2A>메서드는 <xref:System.Security.Policy.Evidence>매개 변수, 증명 정보가 병합 됩니다.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 증명 정보에는 인수로 제공 되는 <xref:System.AppDomain.ExecuteAssemblyByName%2A>메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "어셈블리의 표시 이름입니다. 참조 &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;합니다."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "어셈블리 로드에 대 한 증명 정보입니다."
    - id: args
      type: System.String[]
      description: "프로세스를 시작할 때 전달할 명령줄 인수입니다."
    return:
      type: System.Int32
      description: "어셈블리의 진입점에서 반환한 값입니다."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 찾을 수 없습니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 를 찾았지만 로드할 수 없습니다."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "로 지정 된 어셈블리 <code> assemblyName </code> 유효한 어셈블리가 아닙니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code> assemblyName </code> 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 레거시 CAS 정책을 설정 하지 않으면 <code>assemblySecurity</code> 해야 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "지정된 된 어셈블리에 진입점을 없습니다."
  platform:
  - net462
- uid: System.AppDomain.FirstChanceException
  id: FirstChanceException
  parent: System.AppDomain
  langs:
  - csharp
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "런타임에서 응용 프로그램 도메인에서 예외 처리기에 대 한 호출 스택을 검색 하기 전에 관리 코드에서 예외가 throw 될 때 발생 합니다."
  remarks: "이 이벤트는 알림만 합니다. 이 이벤트를 처리 해도 예외를 처리 하거나 후속 예외 어떤 식으로든에서 처리 영향을 주지 않습니다. 이벤트가 발생 하 고 이벤트 처리기가 호출 된 후에 공용 언어 런타임 (CLR) 예외에 대 한 처리기를 검색 하기 시작 합니다. FirstChanceException 모든 관리 되는 예외를 검사 하는 첫 번째 기회를 사용 하 여 응용 프로그램 도메인을 제공 합니다.       응용 프로그램 도메인 별로 이벤트를 처리할 수 있습니다. 스레드를 통과 하면 여러 응용 프로그램 도메인을 통해 호출을 실행 하는 동안 CLR에서 해당 응용 프로그램 도메인에 일치 하는 예외 처리기에 대 한 검색을 시작 하기 전에 이벤트 처리기를 등록 된 각 응용 프로그램 도메인에서 발생 합니다. 이벤트 처리 된 후 해당 응용 프로그램 도메인에 일치 하는 예외 처리기에 대 한 검색이 수행 됩니다. 검색 된 항목이 없는 경우 다음 응용 프로그램 도메인에서 발생 합니다.       FirstChanceException 이벤트에 대 한 처리기를 이벤트 발생 하는 모든 예외를 처리 해야 합니다. 그렇지 않으면 FirstChanceException이 재귀적으로 발생된 합니다. 이 스택 오버플로 및 응용 프로그램이 종료 될 수 있습니다. 메모리 부족 또는 스택 오버플로와 같은 인프라 관련 예외 예외 알림을 처리 되는 동안 가상 컴퓨터에 영향을 주지 않도록 하기 위해 제약이 있는 실행 영역 (Cer)으로이 이벤트에 대 한 이벤트 처리기를 구현 하는 것이 좋습니다.       이벤트 처리기가 보안에 중요 한 및 하지 않는 한 손상 액세스 위반과 같이 프로세스 상태를 나타내는 예외에 대 한이 이벤트는 <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>특성.</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       스레드 중단 알림 이벤트가이 처리 되는 동안 일시 중단 하는 공용 언어 런타임."
  example:
  - "The following example creates a series of application domains named `AD0` through `AD3`, with a `Worker` object in each application domain. Each `Worker` object has a reference to the `Worker` object in the next application domain, except for the `Worker` in the last application domain. The FirstChanceException event is handled in all application domains except `AD1`.  \n  \n> [!NOTE]\n>  In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in [How to: Receive First-Chance Exception Notifications](~/add/includes/ajax-current-ext-md.md).  \n  \n When the application domains have been created, the default application domain calls the `TestException` method for the first application domain. Each `Worker` object calls the `TestException` method for the next application domain, until the last `Worker` throws an exception that is either handled or unhandled. Thus, the current thread passes through all the application domains, and `TestException` is added to the stack in each application domain.  \n  \n When the last `Worker` object handles the exception, the FirstChanceException event is raised only in the last application domain. The other application domains never get a chance to handle the exception, so the event is not raised.  \n  \n When the last `Worker` object does not handle the exception, the FirstChanceException event is raised in each application domain that has an event handler. After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.  \n  \n> [!NOTE]\n>  To see how the stack display grows as the event is raised closer and closer to the default application domain, change `e.Exception.Message` to `e.Exception` in the `FirstChanceHandler` event handlers. Notice that when `TestException` is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.  \n  \n [!code-vb[System.AppDomain.FirstChanceException#1](~/add/codesnippet/visualbasic/e-system.appdomain.first_1.vb)]\n [!code-cs[System.AppDomain.FirstChanceException#1](~/add/codesnippet/csharp/e-system.appdomain.first_1.cs)]"
  syntax:
    content: public event EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs> FirstChanceException;
    return:
      type: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.FriendlyName
  id: FriendlyName
  parent: System.AppDomain
  langs:
  - csharp
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "이 응용 프로그램 도메인의 이름을 가져옵니다."
  remarks: "기본 응용 프로그램 도메인의 이름을 프로세스 실행 파일의 파일 이름입니다. 예를 들어 파일을 실행 하는 프로세스를 시작 하는 데는 `&quot;c:\\MyAppDirectory\\MyAssembly.exe&quot;`, 기본 응용 프로그램 도메인의 대화명은 `&quot;MyAssembly.exe&quot;`합니다."
  example:
  - "The following code example uses the FriendlyName property to get the friendly name of the current application domain. For the default application domain, the friendly name is the name of the application's executable file. The code example also displays additional information about the application domain.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.frien_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.frien_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.frien_1.cs)]"
  syntax:
    content: public string FriendlyName { get; }
    return:
      type: System.String
      description: "이 응용 프로그램 도메인의 이름입니다."
  overload: System.AppDomain.FriendlyName*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.GetAssemblies
  id: GetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "이 응용 프로그램 도메인의 실행 컨텍스트에 로드 된 어셈블리를 가져옵니다."
  remarks: ''
  example:
  - "The following code example uses the GetAssemblies method to get a list of all assemblies that have been loaded into the application domain. The assemblies are then displayed to the console.  \n  \n To run this code example, you need to create an assembly named `CustomLibrary.dll`, or change the assembly name that is passed to the GetAssemblies method.  \n  \n [!code-cpp[ADGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.getas_1.cpp)]\n [!code-cs[ADGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.getas_1.cs)]\n [!code-vb[ADGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.getas_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] GetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "이 응용 프로그램 도메인에서 어셈블리의 배열입니다."
  overload: System.AppDomain.GetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.GetCurrentThreadId
  id: GetCurrentThreadId
  parent: System.AppDomain
  langs:
  - csharp
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "현재 스레드 식별자를 가져옵니다."
  remarks: "사용 하 여는 <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>속성을.NET Framework이 지 원하는 파이버 (즉, 경량 스레드) 환경에서 호스트 된 경우에 안정적입니다.</xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>"
  syntax:
    content: public static int GetCurrentThreadId ();
    parameters: []
    return:
      type: System.Int32
      description: "현재 스레드의 식별자가 32 비트 부호 있는 정수입니다."
  overload: System.AppDomain.GetCurrentThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.GetData(System.String)
  id: GetData(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정 된 이름에 대 한 현재 응용 프로그램 도메인에 저장 된 값을 가져옵니다."
  remarks: "이 메서드를 사용 하 여 <xref:System.AppDomain>안내 하십시오.</xref:System.AppDomain> 이 인스턴스의 속성을 설명 하는 이름-데이터 쌍의 내부 캐시에 있는 항목의 값을 검색 하려면 비교 `name` 키-값 쌍의 이름으로는 대/소문자 구분 합니다.       캐시는 자동으로 응용 프로그램 도메인이 만들어질 때 삽입 하는 미리 정의 된 시스템 항목을 포함 합니다. GetData 메서드 또는 해당 하는 해당 값을 검사할 수 <xref:System.AppDomainSetup>속성.</xref:System.AppDomainSetup>       삽입 하거나 사용자 정의 이름-데이터 쌍으로 수정할 수는 <xref:System.AppDomain.SetData%2A>메서드 GetData 방법으로 해당 값을 검사할 및.</xref:System.AppDomain.SetData%2A>       다음 표에서 `name` 미리 정의 된 각 시스템 항목 및 해당 <xref:System.AppDomainSetup>속성.</xref:System.AppDomainSetup>      | 값 &quot;n&quot;의 | 속성 |   |---------------------|--------------|   |&quot; APPBASE &quot;| <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>|   |&quot; APP_CONFIG_FILE &quot;| <xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName>|   |&quot; APP_LAUNCH_URL &quot;| (속성 없음)</xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName> </xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName><br /><br /> &quot;APP_LAUNCH_URL&quot;는 리디렉션 하기 전에 사용자가 원래 요청한 URL을 나타냅니다. Internet Explorer와 같은 브라우저 응용 프로그램 시작 되었습니다 하는 경우에 사용할 수 있는 유용 합니다. 이 값을 제공 하지 않는 브라우저. |   |&quot; APP_NAME &quot;| <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>|   |&quot; BINPATH_PROBE_ONLY &quot;| <xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName>|   |&quot; CACHE_BASE &quot;| <xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>|   |&quot; CODE_DOWNLOAD_DISABLED &quot;| <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>|   |&quot; DEV_PATH &quot;| (속성 없음) |   |&quot; DISALLOW_APP &quot;| <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName>|   |&quot; DISALLOW_APP_BASE_PROBING &quot;| <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName>|   |&quot; DISALLOW_APP_REDIRECTS &quot;| <xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName>|   |&quot; DYNAMIC_BASE &quot;| <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>|   |&quot; FORCE_CACHE_INSTALL &quot;| <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>|   |&quot; LICENSE_FILE&quot;또는 응용 프로그램별 문자열 | <xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName>|   |&quot; LOADER_OPTIMIZATION &quot;| <xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName>|   |&quot; LOCATION_URI &quot;| (속성 없음) |   |&quot; PRIVATE_BINPATH &quot;| <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>|   |&quot; REGEX_DEFAULT_MATCH_TIMEOUT &quot;| <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName></xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName></xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName></xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName></xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName></xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName></xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName><br /><br /> &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; 시스템 항목 아니며 <xref:System.AppDomain.SetData%2A>메서드를 호출 하 여 해당 값을 설정할 수 있습니다. |   |&quot; SHADOW_COPY_DIRS &quot;| <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>|</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName></xref:System.AppDomain.SetData%2A>"
  example:
  - "The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain. The example then demonstrates how to use the GetData method to retrieve the data from these value pairs and display them to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.getda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.getda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.getda_1.cs)]"
  syntax:
    content: public object GetData (string name);
    parameters:
    - id: name
      type: System.String
      description: "미리 정의 된 응용 프로그램 도메인 속성의 이름 또는 응용 프로그램 도메인 속성의 이름을 정의 했습니다."
    return:
      type: System.Object
      description: "값은 <code> name </code> 속성 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 속성이 존재 하지 않는 경우."
  overload: System.AppDomain.GetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.GetType
  id: GetType
  parent: System.AppDomain
  langs:
  - csharp
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "현재 인스턴스의 형식을 가져옵니다."
  syntax:
    content: public Type GetType ();
    parameters: []
    return:
      type: System.Type
      description: "현재 인스턴스의 형식입니다."
  overload: System.AppDomain.GetType*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Id
  id: Id
  parent: System.AppDomain
  langs:
  - csharp
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "프로세스 내에서 응용 프로그램 도메인을 고유 하 게 식별 하는 정수를 가져옵니다."
  remarks: ''
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/p-system.appdomain.id_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/p-system.appdomain.id_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/p-system.appdomain.id_1.cs)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "응용 프로그램 도메인을 식별 하는 정수입니다."
  overload: System.AppDomain.Id*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.InitializeLifetimeService
  id: InitializeLifetimeService
  parent: System.AppDomain
  langs:
  - csharp
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "제공 된 <xref href=&quot;System.AppDomain&quot;> </xref> 임대가 만들어지는 것을 방지 하 여 무한 수명을 합니다."
  syntax:
    content: public override object InitializeLifetimeService ();
    parameters: []
    return:
      type: System.Object
      description: "Always <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  overload: System.AppDomain.InitializeLifetimeService*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  id: IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 호환성 스위치가 설정 되어 있는지 여부 그리고 있다면 호환성 스위치가 설정 되어 있는지 여부를 나타내는 nullable 부울 값을 가져옵니다."
  remarks: "This method tests whether the specified compatibility switch has been set for the current application domain. Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.  They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=fullName> method before creating an application domain.  \n  \n The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.  \n  \n|Switch|Meaning|  \n|------------|-------------|  \n|\"NetFx40_LegacySecurityPolicy\"|Code access security (CAS) for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain. See [\\&lt;NetFx40_LegacySecurityPolicy\\&gt; Element](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md).|  \n|\"NetFx40_Legacy20SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] are enabled in this application domain. Its success requires sort00001000.dll to be installed. See [\\&lt;CompatSortNLSVersion\\&gt; Element](../Topic/%3CCompatSortNLSVersion%3E%20Element.md).|  \n|\"NetFx40_Legacy40SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain. Its success requires sort00060101.dll to be installed.|  \n|\"NetFx40_TimeSpanLegacyFormatMode\"|<xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain.  See [\\&lt;TimeSpan_LegacyFormatMode\\&gt; Element](../Topic/%3CTimeSpan_LegacyFormatMode%3E%20Element.md) and the \"Restoring Legacy TimeSpan Formatting\" section of the <xref:System.TimeSpan> topic.|  \n|\"UseRandomizedStringHashAlgorithm\"|The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains. See [\\&lt;UseRandomizedStringHashAlgorithm\\&gt; Element](../Topic/%3CUseRandomizedStringHashAlgorithm%3E%20Element.md).|"
  syntax:
    content: public Nullable<bool> IsCompatibilitySwitchSet (string value);
    parameters:
    - id: value
      type: System.String
      description: "테스트할 호환성 스위치입니다."
    return:
      type: System.Nullable{System.Boolean}
      description: "Null 참조 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> Visual basic에서) 호환성 스위치가 설정; 그렇지 않으면 부울 값을 나타내는 지정 된 호환성 스위치가 있는 여부 <code> value </code> 설정 됩니다."
  overload: System.AppDomain.IsCompatibilitySwitchSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsDefaultAppDomain
  id: IsDefaultAppDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "응용 프로그램 도메인의 프로세스에 대 한 기본 응용 프로그램 도메인 인지 여부를 나타내는 값을 반환 합니다."
  remarks: "모든 관리 되는 프로세스에 기본 응용 프로그램 도메인을 포함 합니다. 기본 도메인에서 실행을 시작 합니다."
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/m-system.appdomain.isdef_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/m-system.appdomain.isdef_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/m-system.appdomain.isdef_1.cs)]"
  syntax:
    content: public bool IsDefaultAppDomain ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>하는 경우 현재 <xref href=&quot;System.AppDomain&quot;> </xref> 개체가 프로세스;에 대 한 기본 응용 프로그램 도메인을 나타내면 그렇지 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.AppDomain.IsDefaultAppDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFinalizingForUnload
  id: IsFinalizingForUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "이 응용 프로그램 도메인의 언로드 여부 및 공용 언어 런타임에 의해 포함 된 개체를 종료 하 고 있는지 여부를 나타냅니다."
  remarks: "개체에 대 한 종료 메서드는 개체가 가비지 수집 되기 전에 필요한 정리 작업을 수행할 수 있습니다를 제공 합니다. 종료 된 후 개체는 액세스할 수 있지만 잘못 된 상태에 있고 사용할 수 없습니다. 결국 가비지 수집을 완료 하 고 개체를 회수 합니다.       개체의 종료 메서드는 다음과 같은 상황 중 하나에서: 가비지 수집 중 공용 언어 런타임의 종료 될 때 또는 개체가 포함 된 응용 프로그램 도메인이 언로드될 때. IsFinalizingForUnload 메서드가 반환 `true` ; 지난 경우에만 반환 하지 않는 `true` 종료 CLR 종료 또는 일상적인 가비지 수집에서 발생 하는 경우.      > [!NOTE] > CLR 종료로 인해 종료 되는지 확인 하려면는 <xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName>속성.</xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName> 반환 `true` 또는 종료 하 고 CLR 응용 프로그램 도메인이 언로드되고으로 인해 종료 되는 경우.       언로드 작업이 수행 하는 동안 종료 메서드에서 실행을 하는 동안 정적 필드에서 참조 하 고 종료 메서드를 포함 하는 다른 개체에 액세스 하는 것이 좋습니다. 그러나 안정적 수 없습니다 액세스 한 개체가 종료 이미 수 있으므로 합니다.      > [!NOTE] >이 규칙의 예외는 <xref:System.Console>스트림 개체를 참조 하는 정적 필드가 포함 되어 있지만 도메인 언로드하거나 시스템 종료 하는 동안에 시스템 콘솔에 항상 작성할 수 있도록 특별히 구현 되는 클래스입니다.</xref:System.Console>       개체의 종료 메서드에 개체를 포함 하는 응용 프로그램 도메인이 언로드되고 있는지 여부를 확인 하려면이 메서드를 사용 합니다. 해당 되는 경우 종료 메서드를 포함 하는 정적 필드에서 참조 하는 모든 개체 안정적으로 액세스할 수 없습니다."
  syntax:
    content: public bool IsFinalizingForUnload ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>이 응용 프로그램 도메인이 언로드 및 공용 언어 런타임 프로세스 시작 여부 종료자를 호출 합니다. 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.AppDomain.IsFinalizingForUnload*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFullyTrusted
  id: IsFullyTrusted
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "현재 어플리케이션 도메인에 로드 된 어셈블리가 완전 신뢰로 실행 되는지를 나타내는 값을 가져옵니다."
  remarks: "이 메서드는 항상 반환 `true` 데스크톱에서 실행 하는 응용 프로그램의 기본 응용 프로그램 도메인에 대 한 합니다. 반환 `false` 를 사용 하 여 만든 샌드 박싱된 응용 프로그램 도메인에 대 한는 [AppDomain.CreateDomain (String, 증명 정보, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) 응용 프로그램 도메인에서 부여 된 권한을 완전 신뢰와 동일 하지 않으면 메서드 오버 로드 합니다."
  example:
  - "The following example demonstrates the IsFullyTrusted property and the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> property with fully trusted and partially trusted application domains. The fully trusted application domain is the default application domain for the application. The partially trusted application domain is created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload.  \n  \n The example uses a `Worker` class that derives from <xref:System.MarshalByRefObject>, so it can be marshaled across application domain boundaries. The example creates a `Worker` object in the default application domain. It then calls the `TestIsFullyTrusted` method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly. The application domain is fully trusted, so both assemblies are fully trusted.  \n  \n The example creates another `Worker` object in a sandboxed application domain and again calls the `TestIsFullyTrusted` method. Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.  \n  \n [!code-vb[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/visualbasic/p-system.appdomain.isful_1.vb)]\n [!code-cs[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/csharp/p-system.appdomain.isful_1.cs)]"
  syntax:
    content: public bool IsFullyTrusted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>완전 신뢰로; 현재 응용 프로그램 도메인에 로드 된 어셈블리를 실행 하는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.AppDomain.IsFullyTrusted*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsHomogenous
  id: IsHomogenous
  parent: System.AppDomain
  langs:
  - csharp
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "현재 어플리케이션 도메인에는 응용 프로그램 도메인에 로드 된 모든 어셈블리에 부여 된 사용 권한 집합에 있는지 여부를 나타내는 값을 가져옵니다."
  remarks: "This property returns `true` for sandboxed application domains that were created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload. Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain. A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.  \n  \n Fully trusted code can use the <xref:System.AppDomain.PermissionSet%2A> property to determine the homogenous grant set of a sandboxed application domain.  \n  \n This property also returns `true` for the default application domain of a desktop application, because that application domain grants full trust to all assemblies."
  syntax:
    content: public bool IsHomogenous { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>현재 응용 프로그램 도메인에는 형식이 같은 권한 집합이 있습니다. 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.AppDomain.IsHomogenous*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[])
  id: Load(System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "<xref:System.Reflection.Assembly>내보낸된 <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> 포함 된 공용 개체 파일 (COFF 형식) 기반 이미지가 포함 된</xref:System.Reflection.Assembly> 로드"
  remarks: "부터는 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)],이 메서드를 사용 하 여 로드 되는 어셈블리의 신뢰 수준은 응용 프로그램 도메인의 신뢰 수준을와 같습니다.       이 메서드는 현재 응용 프로그램 도메인에서 어셈블리를 로드에 사용 해야 합니다. 이 메서드는 정적을 호출할 수 없습니다 상호 운용성 호출자에 대 한 편의 위해 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>메서드.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 같은 메서드를 사용 하 여 다른 응용 프로그램 도메인에 어셈블리를 로드 하려면       이 메서드의 모든 오버 로드에 공통 된 정보를 참조 하십시오.는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>메서드 오버 로드.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_1_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_1_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_1_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "형식의 배열 <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> 즉 COFF 기반 이미지를 생성된 된 어셈블리가 들어 있습니다."
    return:
      type: System.Reflection.Assembly
      description: "로드 된 어셈블리입니다."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>rawAssembly</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  id: Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "<xref:System.Reflection.Assembly>해당 <xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> 지정</xref:System.Reflection.Assembly> 로드"
  remarks: "이 메서드는 현재 응용 프로그램 도메인에서 어셈블리를 로드에 사용 해야 합니다. 이 메서드는 정적을 호출할 수 없습니다 상호 운용성 호출자에 대 한 편의 위해 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>메서드.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 같은 메서드를 사용 하 여 다른 응용 프로그램 도메인에 어셈블리를 로드 하려면       이미 로드 되어 요청된 된 어셈블리의 버전 다른 버전이 요청 된 경우에이 메서드는 로드 된 어셈블리를 반환 합니다.       에 대 한 부분 어셈블리 이름을 제공 `assemblyRef` 권장 되지 않습니다. (부분 이름은 하나 이상의 culture, 버전, 사용 또는 공개 키 토큰을 생략 하는 데 사용 합니다. 대신 문자열을 허용 하는 오버 로드에 대 한는 <xref:System.Reflection.AssemblyName>개체를 &quot;MyAssembly, Version =&1;.0.0.0&quot;은 이름의 일부의 예 및 &quot;MyAssembly, Version =&1;.0.0.0, Culture = neutral, PublicKeyToken&18;ab3442da84b47 =&quot;은 예 전체 이름입니다.)</xref:System.Reflection.AssemblyName> 부분 이름을 사용 하면 성능에 부정적인 영향을 있습니다. 또한 부분 어셈블리 이름을 로드할 수 어셈블리를 전역 어셈블리 캐시에서 응용 프로그램 기본 디렉터리에 있는 어셈블리의 정확한 복사본 필요한 경우에 (<xref:System.AppDomain.BaseDirectory%2A> 또는 <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>).</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> </xref:System.AppDomain.BaseDirectory%2A>       하는 경우 현재 <xref:System.AppDomain>개체가 응용 프로그램 도메인을 나타내면 `A`, 및 <xref:System.AppDomain.Load%2A>메서드는 응용 프로그램 도메인에서 `B`, 어셈블리 두 응용 프로그램 도메인에 로드 됩니다.</xref:System.AppDomain.Load%2A> </xref:System.AppDomain> 예를 들어 다음 코드 로드 `MyAssembly` 새 응용 프로그램 도메인 `ChildDomain` 및 코드를 실행 하는 응용 프로그램 도메인에도: [!code-vb [System.AppDomain.Load#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_2_1.vb)][!code-cpp[System.AppDomain.Load#1](~/add/codesnippet/cpp/m-system.appdomain.load-_2_1.cpp)][!code-cs[System.AppDomain.Load#1](~/add/codesnippet/csharp/m-system.appdomain.load-_2_1.cs) ] 어셈블리가 로드 되는 두 도메인에 있으므로 <xref:System.Reflection.Assembly>에서 파생 되지 않은 <xref:System.MarshalByRefObject>, 따라서의 반환 값과는 <xref:System.AppDomain.Load%2A>메서드를 마샬링할 수 없습니다.</xref:System.AppDomain.Load%2A> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly>     대신, 공용 언어 런타임 어셈블리 호출 응용 프로그램 도메인에 로드 하려고 시도 합니다. 두 응용 프로그램 도메인에 로드 된 어셈블리는 두 응용 프로그램 도메인에 대 한 경로 설정을 서로 다른 경우 달라질 수 있습니다.      > [!NOTE] > 둘 다는 <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName>속성 및 <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName>속성이 설정 되어, 어셈블리를 로드할 첫 번째 시도 표시 이름을 사용 하 여 (에서 반환 된 버전, 문화권 및 등을 포함 하는 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName>속성).</xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName> 파일이 없는 경우는 <xref:System.Reflection.AssemblyName.CodeBase%2A>속성 어셈블리를 검색 하는 데 사용 됩니다.</xref:System.Reflection.AssemblyName.CodeBase%2A> 사용 하는 어셈블리가 있는 경우 <xref:System.Reflection.AssemblyName.CodeBase%2A>, 표시 이름은 어셈블리와 일치 합니다.</xref:System.Reflection.AssemblyName.CodeBase%2A> 일치가 실패 하면는 <xref:System.IO.FileLoadException>throw 됩니다.</xref:System.IO.FileLoadException>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "로드할 어셈블리를 설명 하는 개체입니다."
    return:
      type: System.Reflection.Assembly
      description: "로드 된 어셈블리입니다."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>´ ù."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyRef</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  platform:
  - net462
- uid: System.AppDomain.Load(System.String)
  id: Load(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "로드는 <xref:System.Reflection.Assembly>표시 이름이 지정 됩니다.</xref:System.Reflection.Assembly>"
  remarks: "이 메서드는 현재 응용 프로그램 도메인에서 어셈블리를 로드에 사용 해야 합니다. 이 메서드는 정적을 호출할 수 없습니다 상호 운용성 호출자에 대 한 편의 위해 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>메서드.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 같은 메서드를 사용 하 여 다른 응용 프로그램 도메인에 어셈블리를 로드 하려면       이 메서드의 모든 오버 로드에 공통 된 정보를 참조 하십시오.는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>메서드 오버 로드.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString);
    parameters:
    - id: assemblyString
      type: System.String
      description: "어셈블리의 표시 이름입니다. 참조 &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;합니다."
    return:
      type: System.Reflection.Assembly
      description: "로드 된 어셈블리입니다."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>은<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>´ ù."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyString</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  id: Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "<xref:System.Reflection.Assembly>내보낸된 <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> 포함 된 공용 개체 파일 (COFF 형식) 기반 이미지가 포함 된</xref:System.Reflection.Assembly> 로드 에 대 한 기호를 나타내는 원시 바이트는 <xref:System.Reflection.Assembly>도 로드 됩니다.</xref:System.Reflection.Assembly>"
  remarks: "부터는 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)],이 메서드를 사용 하 여 로드 되는 어셈블리의 신뢰 수준은 응용 프로그램 도메인의 신뢰 수준을와 같습니다.       이 메서드는 현재 응용 프로그램 도메인에서 어셈블리를 로드에 사용 해야 합니다. 이 메서드는 정적을 호출할 수 없습니다 상호 운용성 호출자에 대 한 편의 위해 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>메서드.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 같은 메서드를 사용 하 여 다른 응용 프로그램 도메인에 어셈블리를 로드 하려면       이 메서드의 모든 오버 로드에 공통 된 정보를 참조 하십시오.는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>메서드 오버 로드.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_0_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_0_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_0_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "형식의 배열 <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> 즉 COFF 기반 이미지를 생성된 된 어셈블리가 들어 있습니다."
    - id: rawSymbolStore
      type: System.Byte[]
      description: "형식의 배열 <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> 어셈블리에 대 한 기호를 나타내는 원시 바이트가 포함 된 합니다."
    return:
      type: System.Reflection.Assembly
      description: "로드 된 어셈블리입니다."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>rawAssembly</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  id: Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "<xref:System.Reflection.Assembly>해당 <xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> 지정</xref:System.Reflection.Assembly> 로드"
  remarks: "이 메서드는 현재 응용 프로그램 도메인에서 어셈블리를 로드에 사용 해야 합니다. 이 메서드는 정적을 호출할 수 없습니다 상호 운용성 호출자에 대 한 편의 위해 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>메서드.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 같은 메서드를 사용 하 여 다른 응용 프로그램 도메인에 어셈블리를 로드 하려면       이 메서드의 모든 오버 로드에 공통 된 정보를 참조 하십시오.는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>메서드 오버 로드.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "로드할 어셈블리를 설명 하는 개체입니다."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "어셈블리 로드에 대 한 증명 정보입니다."
    return:
      type: System.Reflection.Assembly
      description: "로드 된 어셈블리입니다."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>은<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>´ ù."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyRef</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  platform:
  - net462
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  id: Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "로드는 <xref:System.Reflection.Assembly>표시 이름이 지정 됩니다.</xref:System.Reflection.Assembly>"
  remarks: "이 메서드는 현재 응용 프로그램 도메인에서 어셈블리를 로드에 사용 해야 합니다. 이 메서드는 정적을 호출할 수 없습니다 상호 운용성 호출자에 대 한 편의 위해 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>메서드.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 같은 메서드를 사용 하 여 다른 응용 프로그램 도메인에 어셈블리를 로드 하려면       이 메서드의 모든 오버 로드에 공통 된 정보를 참조 하십시오.는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>메서드 오버 로드.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyString
      type: System.String
      description: "어셈블리의 표시 이름입니다. 참조 &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;합니다."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "어셈블리 로드에 대 한 증명 정보입니다."
    return:
      type: System.Reflection.Assembly
      description: "로드 된 어셈블리입니다."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>은<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>´ ù."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>assemblyString</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  id: Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "<xref:System.Reflection.Assembly>내보낸된 <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> 포함 된 공용 개체 파일 (COFF 형식) 기반 이미지가 포함 된</xref:System.Reflection.Assembly> 로드 에 대 한 기호를 나타내는 원시 바이트는 <xref:System.Reflection.Assembly>도 로드 됩니다.</xref:System.Reflection.Assembly>"
  remarks: "부터는 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)],이 메서드를 사용 하 여 로드 되는 어셈블리의 신뢰 수준은 응용 프로그램 도메인의 신뢰 수준을와 같습니다.       이 메서드는 현재 응용 프로그램 도메인에서 어셈블리를 로드에 사용 해야 합니다. 이 메서드는 정적을 호출할 수 없습니다 상호 운용성 호출자에 대 한 편의 위해 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>메서드.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 같은 메서드를 사용 하 여 다른 응용 프로그램 도메인에 어셈블리를 로드 하려면       이 메서드의 모든 오버 로드에 공통 된 정보를 참조 하십시오.는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>메서드 오버 로드.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/1e204365-b0ec-4650-8d52-_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/1e204365-b0ec-4650-8d52-_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/1e204365-b0ec-4650-8d52-_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "형식의 배열 <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> 즉 COFF 기반 이미지를 생성된 된 어셈블리가 들어 있습니다."
    - id: rawSymbolStore
      type: System.Byte[]
      description: "형식의 배열 <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> 어셈블리에 대 한 기호를 나타내는 원시 바이트가 포함 된 합니다."
    - id: securityEvidence
      type: System.Security.Policy.Evidence
      description: "어셈블리 로드에 대 한 증명 정보입니다."
    return:
      type: System.Reflection.Assembly
      description: "로드 된 어셈블리입니다."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>유효한 어셈블리가 않습니다.       -또는-버전 2.0 이상의 공용 언어 런타임이 현재 로드 되어 및 <code>rawAssembly</code> 이후 버전으로 컴파일 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드 되었습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>securityEvidence</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 레거시 CAS 정책을 설정 하지 않으면 <code>securityEvidence</code> 해야 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.AppDomain.MonitoringIsEnabled
  id: MonitoringIsEnabled
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "현재 프로세스의 CPU 및 메모리 모니터링 응용 프로그램 도메인 사용 되는지 여부를 나타내는 값을 가져오거나 설정 합니다. 모니터링 프로세스에 대 한 활성화 되 면 해제할 수 없습니다."
  remarks: "이 `static` 속성 (`Shared` Visual Basic에서 속성)의 CPU 및 메모리 모니터링 프로세스의 모든 응용 프로그램 도메인을 제어 합니다.       이 속성을 설정 하려고 하면 `false`, <xref:System.ArgumentException>예외가 throw 되는 속성의 현재 값은 경우에 `false`.</xref:System.ArgumentException>       모니터링이 활성화 되 면 사용할 수 있습니다는 <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, 및 <xref:System.AppDomain.MonitoringTotalProcessorTime%2A>인스턴스 개별 응용 프로그램 도메인의 CPU 및 메모리 사용을 모니터링 하는 속성.</xref:System.AppDomain.MonitoringTotalProcessorTime%2A> </xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>"
  syntax:
    content: public static bool MonitoringIsEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>모니터링을 사용 하면 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.AppDomain.MonitoringIsEnabled*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "현재 프로세스에 값을 할당 하려고 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 이 속성에 있습니다."
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  id: MonitoringSurvivedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "현재 응용 프로그램 도메인에서 참조 하도록 알려진 마지막 컬렉션 후에 유지 하는 바이트 수를 가져옵니다."
  remarks: "통계는 각 가비지 컬렉션으로 업데이트 됩니다. 그러나을 정확 하 게 한 전체 차단 컬렉션 후에 보장 됩니다. 즉, 모든 세대를 포함 하 고 수집 하는 동안 응용 프로그램을 중지 하는 컬렉션에 발생 합니다. 예를 들어는 <xref:System.GC.Collect?displayProperty=fullName>전체 차단 수집을 수행 하는 메서드 오버 로드.</xref:System.GC.Collect?displayProperty=fullName> (동시 컬렉션은 백그라운드에서 실행 및 응용 프로그램을 차단 하지 않습니다.)"
  syntax:
    content: public long MonitoringSurvivedMemorySize { get; }
    return:
      type: System.Int64
      description: "유지 되는 바이트의 수입니다."
  overload: System.AppDomain.MonitoringSurvivedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> Visual basic에서) <xref:System.AppDomain.MonitoringIsEnabled*>속성이 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  id: MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "프로세스의 모든 응용 프로그램 도메인에 대 한 마지막 컬렉션에서 유지 된 총 바이트를 가져옵니다."
  remarks: "힙의 관리 되는 바이트 수가 현재 보유 하에이 숫자 나타냅니다 전체 차단 수집 후 합니다. 보고 된 수에 가까운 것은 <xref:System.GC.GetTotalMemory%2A>메서드.</xref:System.GC.GetTotalMemory%2A> 임시 컬렉션 후이 수 바이트 수가 현재 저장 나타냅니다 라이브 임시 세대에서입니다."
  syntax:
    content: public static long MonitoringSurvivedProcessMemorySize { get; }
    return:
      type: System.Int64
      description: "프로세스에 대해 유지 되는 바이트의 총 수입니다."
  overload: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> Visual basic에서) <xref:System.AppDomain.MonitoringIsEnabled*>속성이 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  id: MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "수집 된 메모리를 제외 하지 않고 만들어진 후 응용 프로그램 도메인에서 실행 된 모든 메모리 할당의 바이트의 총 크기를 가져옵니다."
  syntax:
    content: public long MonitoringTotalAllocatedMemorySize { get; }
    return:
      type: System.Int64
      description: "모든 메모리 할당의 총 크기입니다."
  overload: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> Visual basic에서) <xref:System.AppDomain.MonitoringIsEnabled*>속성이 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalProcessorTime
  id: MonitoringTotalProcessorTime
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "프로세스가 시작 된 후 현재 응용 프로그램 도메인에서 실행 되는 동안 모든 스레드에서 사용 된 총 프로세서 시간을 가져옵니다."
  remarks: "각 스레드는 프로세스에서 해당 응용 프로그램 도메인에서 실행에 소요 된 시간을 포함 하는 응용 프로그램 도메인에 대 한 보고 되는 총 시간입니다.       비관리 코드를 호출 하는 스레드는 응용 프로그램 도메인에 여전히 연결 되며 비관리 코드 호출 여러분이 응용 프로그램 도메인에 대 한 보고를 실행 하는 데 프로세서 시간이 걸리는 합니다.       스레드가 차단 또는 중지는 사용 하지 않습니다 프로세서 시간 면 합니다."
  syntax:
    content: public TimeSpan MonitoringTotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "현재 어플리케이션 도메인에 대 한 총 프로세서 시간입니다."
  overload: System.AppDomain.MonitoringTotalProcessorTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> Visual basic에서) <xref:System.AppDomain.MonitoringIsEnabled*>속성이 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.PermissionSet
  id: PermissionSet
  parent: System.AppDomain
  langs:
  - csharp
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "샌드 박싱된 응용 프로그램 도메인의 권한 집합을 가져옵니다."
  remarks: "사용 하 여 만든 샌드 박싱된 응용 프로그램 도메인에서 [AppDomain.CreateDomain (문자열, 증명 정보, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) 메서드 오버 로드는 형식이 같은 권한 집합이 수 있으며 응용 프로그램 도메인에 로드 되는 부분적으로 신뢰할 수 있는 모든 어셈블리에 동일한 사용 권한 집합이 부여 됩니다 즉, 합니다. 샌드 박싱된 응용 프로그램 도메인에는 필요에 따라이 사용 권한을 설정 하 고 대신 완전 신뢰로 실행에서 제외 되는 강력한 이름의 어셈블리의 목록을 있습니다."
  syntax:
    content: public System.Security.PermissionSet PermissionSet { get; }
    return:
      type: System.Security.PermissionSet
      description: "샌드 박싱된 응용 프로그램 도메인의 권한 집합입니다."
  overload: System.AppDomain.PermissionSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ProcessExit
  id: ProcessExit
  parent: System.AppDomain
  langs:
  - csharp
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "기본 응용 프로그램 도메인의 부모 프로세스가 종료 될 때 발생 합니다."
  remarks: "<xref:System.EventHandler>이 이벤트는 파일 닫기 등의 종료 작업을 수행할 수에 대 한 프로세스가 종료 되기 전에 저장소를 등의 해제.</xref:System.EventHandler>       .NET Framework 버전 2.0부터,이 이벤트는 이벤트 처리기를 등록 하는 각 응용 프로그램 도메인에서 발생 합니다.      > [!NOTE] > 모든 종료자의 총 실행 시간 프로세스가 종료 될 때 제한 된 것 처럼 모든 ProcessExit 이벤트 처리기의 총 실행 시간 제한 되어 있습니다. 기본값은&2; 초입니다. 관리 되지 않는 호스트를 호출 하 여이 실행 시간을 변경할 수는 [iclrpolicymanager:: Settimeout](~/add/includes/ajax-current-ext-md.md) 메서드는 [OPR_ProcessExit](~/add/includes/ajax-current-ext-md.md) 열거형 값입니다.       .NET Framework 버전 1.0 및 1.1에서는이 이벤트는 기본 응용 프로그램 도메인 에서만 발생 하 고 기본 응용 프로그램 도메인에는 이벤트 처리기가 등록 하는 경우에 합니다.       이 이벤트에 대 한 이벤트 처리기를 등록 하려면 필요한 사용 권한이 있어야 또는 <xref:System.Security.SecurityException>throw 됩니다.</xref:System.Security.SecurityException>       이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public event EventHandler ProcessExit;
    return:
      type: System.EventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  id: ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "리플렉션 전용 컨텍스트에서 어셈블리 확인이 실패 하면 발생 합니다."
  remarks: "리플렉션 전용 컨텍스트에 종속성 자동으로 확인 되지 않습니다. 미리 로드 되거나이 이벤트 처리기에 의해 반환 될 해야 합니다. 이 이벤트는 어셈블리를 리플렉션 전용 컨텍스트에 로드 되지 않는 종속성에 있을 때 발생 합니다. 누락 된 종속성으로 지정 된 <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>속성.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> <xref:System.ResolveEventHandler>이 이벤트는 종속성을 충족 하는 어셈블리를 반환 해야 합니다.</xref:System.ResolveEventHandler> 반환 된 어셈블리를 리플렉션 전용 컨텍스트에 로드 해야 합니다.      > [!IMPORTANT] > 리플렉션 전용 컨텍스트에 로드 되는 어셈블리의 종속성이 누락에 대해서만 발생 합니다 (사용 하 여 예를 들어는 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName>메서드).</xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName> 로드 하는 어셈블리를 찾을 수 없는 경우에 발생 하지 않습니다.       부터는 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>속성을 확인할 수 없는 어셈블리 로드를 요청한 어셈블리를 반환 합니다.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> 요청한 어셈블리의 id를 알면 둘 이상의 버전을 사용할 수 있는 경우 올바른 버전의 종속성을 식별할 수 있습니다. 자세한 내용은 <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> 을 참조 하십시오.       이 이벤트는 <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>속성 정책 적용 하기 전에 어셈블리 이름을 반환 합니다.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>       이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public event ResolveEventHandler ReflectionOnlyAssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  id: ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "응용 프로그램 도메인의 리플렉션 전용 컨텍스트에 로드 된 어셈블리를 반환 합니다."
  remarks: "이 메서드는 리플렉션 전용 컨텍스트에 로드 된 어셈블리를 반환 합니다. 실행을 위해 로드 된 어셈블리를 가져오려면는 <xref:System.AppDomain.GetAssemblies%2A>메서드.</xref:System.AppDomain.GetAssemblies%2A>"
  example:
  - "The following code example loads the System.dll assembly into the execution context and then into the reflection-only context. The <xref:System.AppDomain.GetAssemblies%2A> and ReflectionOnlyGetAssemblies methods are used to display the assemblies loaded into each context.  \n  \n [!code-cs[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.refle_1.cs)]\n [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.refle_1.cpp)]\n [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.refle_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "배열을 <xref:System.Reflection.Assembly>응용 프로그램 도메인의 리플렉션 전용 컨텍스트에 로드 된 어셈블리를 나타내는 개체입니다.</xref:System.Reflection.Assembly>"
  overload: System.AppDomain.ReflectionOnlyGetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.RelativeSearchPath
  id: RelativeSearchPath
  parent: System.AppDomain
  langs:
  - csharp
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "전용 어셈블리 확인자에서 어셈블리를 조사할 기본 디렉터리 아래의 경로 가져옵니다."
  remarks: "전용 어셈블리는 응용 프로그램과 동일한 디렉터리 구조에 배포 됩니다. 없으면 RelativeSearchPath 속성에 지정 된 경로 아래에서 <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>, 무시 됩니다.</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>       이 속성은 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName> 를 사용 하 여 설정 된 값 반환"
  syntax:
    content: public string RelativeSearchPath { get; }
    return:
      type: System.String
      description: "전용 어셈블리를 어셈블리 확인자에서 조사할 기본 디렉터리 아래의 경로입니다."
  overload: System.AppDomain.RelativeSearchPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.ResourceResolve
  id: ResourceResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "리소스가 어셈블리에서 올바르게 링크 되거나 포함 된 리소스가 아니어서 리소스 확인이 실패 하면 발생 합니다."
  remarks: "<xref:System.ResolveEventHandler>이 이벤트에 대 한 하려고 할 수 있습니다는 리소스를 포함 하는 어셈블리를 찾아 반환 합니다.</xref:System.ResolveEventHandler>      > [!IMPORTANT] > 없습니다 파일이 유효한 연결 된 리소스에 대 한 확인이 실패 하는 경우이 이벤트가 발생 하지 않습니다. 이 이벤트는 발생 매니페스트 리소스 스트림을 찾을 수 없는 경우는 개별 리소스 키를 찾을 수 없는 경우는 발생 하지 않습니다.       부터는 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>속성에 리소스를 요청한 어셈블리를 포함 합니다.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> 자세한 내용은 <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> 을 참조 하십시오.       이 이벤트에 대 한 이벤트 처리기를 등록 하려면 필요한 사용 권한이 있어야 또는 <xref:System.Security.SecurityException>throw 됩니다.</xref:System.Security.SecurityException>       이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public event ResolveEventHandler ResourceResolve;
    return:
      type: System.ResolveEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  id: SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "이 응용 프로그램 도메인에 대 한 보안 정책 수준을 설정합니다."
  remarks: "어셈블리에 로드 되기 전에이 메서드는 <xref:System.AppDomain>보안 정책 적용 하기 위해에서.</xref:System.AppDomain>"
  example:
  - "The following example demonstrates how to use the SetAppDomainPolicymethod to set the security policy level of an application domain.  \n  \n [!code-cs[ADSetAppDomainPolicy#1](~/add/codesnippet/csharp/m-system.appdomain.setap_1.cs)]\n [!code-cpp[ADSetAppDomainPolicy#1](~/add/codesnippet/cpp/m-system.appdomain.setap_1.cpp)]\n [!code-vb[ADSetAppDomainPolicy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setap_1.vb)]"
  syntax:
    content: public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);
    parameters:
    - id: domainPolicy
      type: System.Security.Policy.PolicyLevel
      description: "보안 정책 수준입니다."
  overload: System.AppDomain.SetAppDomainPolicy*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domainPolicy</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "보안 정책 수준 이미 설정 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.SetCachePath(System.String)
  id: SetCachePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정한 디렉터리 경로 어셈블리가 섀도 복사 되는 위치로 설정 합니다."
  remarks: "캐시 경로 무시 됩니다는 <xref:System.AppDomainSetup.ApplicationName%2A>속성이 설정 되지 않았습니다.</xref:System.AppDomainSetup.ApplicationName%2A> 참조는 <xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>속성.</xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>       섀도 복사에 대 한 자세한 내용은 참조 [어셈블리 섀도 복사](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public void SetCachePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "섀도 복사본 위치에 대 한 정규화 된 경로입니다."
  overload: System.AppDomain.SetCachePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object)
  id: SetData(System.String,System.Object)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정 된 응용 프로그램 도메인 속성에 지정된 된 값을 할당 합니다."
  remarks: "를 삽입 하려면이 메서드를 사용 하거나 <xref:System.AppDomain>안내 하십시오.</xref:System.AppDomain> 이 인스턴스의 속성을 설명 하는 이름-데이터 쌍의 내부 캐시에 있는 항목의 값을 수정       캐시는 자동으로 응용 프로그램 도메인이 만들어질 때 삽입 하는 미리 정의 된 시스템 항목을 포함 합니다. 삽입 하거나이 메서드를 사용 하 여 시스템 항목을 수정할 수 없습니다. 시스템 항목을 수정 하려고 시도 하는 메서드 호출에 영향을 주지 않습니다. 메서드는 예외를 throw 하지 않습니다. <xref:System.AppDomain.GetData%2A>메서드 또는 해당 하는 <xref:System.AppDomainSetup>속성 <xref:System.AppDomain.GetData%2A>.</xref:System.AppDomain.GetData%2A> 에 설명 된</xref:System.AppDomainSetup> </xref:System.AppDomain.GetData%2A> 시스템 항목의 값을 검사할 수 있습니다.       값으로 &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; 공급으로 정규식 패턴을 평가 하기 위한 기본 제한 시간 간격의 값을 설정 하려면이 메서드를 호출할 수 있습니다는 `name` 인수 및 <xref:System.TimeSpan>값의 값으로 제한 시간 간격을 나타내는 `data` 인수.</xref:System.TimeSpan> 수도 삽입 또는 수정 사용자 정의 이름-데이터 쌍이 방법을 사용 하 고 수와 해당 값을 검사할는 <xref:System.AppDomain.GetData%2A>메서드.</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following example demonstrates how to use the SetData method to create a new value pair. The example then uses the <xref:System.AppDomain.GetData%2A> method to retrieve the value, and displays it to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.setda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.setda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.setda_1.cs)]"
  syntax:
    content: public void SetData (string name, object data);
    parameters:
    - id: name
      type: System.String
      description: "만들거나 변경할 사용자 정의 응용 프로그램 도메인 속성의 이름입니다."
    - id: data
      type: System.Object
      description: "속성의 값입니다."
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  id: SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정 된 권한 수요에 속성을 검색할 때 호출자의 지정 된 응용 프로그램 도메인 속성에 지정된 된 값을 할당 합니다."
  remarks: "이 메서드를 사용 하 여 응용 프로그램 도메인의 속성을 설명 하는 이름/데이터 쌍의 내부 캐시에 사용자 고유의 사용자 지정 항목을 삽입 하거나 수정할 합니다. 항목을 삽입 하는 경우 항목을 검색할 때 적용할 권한 요청을 지정할 수 있습니다. 값으로 &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; 공급으로 정규식 패턴을 평가 하기 위한 기본 제한 시간 간격의 값을 설정 하려면이 메서드를 호출할 수는 또한는 `name` 인수 및 <xref:System.TimeSpan>값의 값으로 제한 시간 간격을 나타내는 `data` 인수.</xref:System.TimeSpan>       시스템 정의 속성 문자열을 보안 요청을 할당 하려면이 메서드를 사용할 수 없습니다.       캐시는 자동으로 응용 프로그램 도메인이 만들어질 때 삽입 하는 미리 정의 된 시스템 항목을 포함 합니다. 삽입 하거나이 메서드를 사용 하 여 시스템 항목을 수정할 수 없습니다. 시스템 항목을 수정 하려고 시도 하는 메서드 호출에 영향을 주지 않습니다. 메서드는 예외를 throw 하지 않습니다. 와 시스템 항목의 값을 검사할 수는 <xref:System.AppDomain.GetData%2A>메서드 또는 해당 <xref:System.AppDomainSetup>에 대 한 설명 섹션에 설명 된 속성의 <xref:System.AppDomain.GetData%2A>메서드.</xref:System.AppDomain.GetData%2A> </xref:System.AppDomainSetup> </xref:System.AppDomain.GetData%2A>"
  syntax:
    content: public void SetData (string name, object data, System.Security.IPermission permission);
    parameters:
    - id: name
      type: System.String
      description: "만들거나 변경할 사용자 정의 응용 프로그램 도메인 속성의 이름입니다."
    - id: data
      type: System.Object
      description: "속성의 값입니다."
    - id: permission
      type: System.Security.IPermission
      description: "수요에 속성을 검색할 때 호출자의 권한입니다."
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>name</code>시스템 정의 속성 문자열을 지정 하 고 <code>permission</code> 않습니다 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.AppDomain.SetDynamicBase(System.String)
  id: SetDynamicBase(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "동적으로 생성 된 파일이 저장 되 고 액세스 하는 하위 디렉터리의 기본 디렉터리로 지정한 디렉터리 경로 설정 합니다."
  remarks: "이 메서드는 설정의 <xref:System.AppDomainSetup.DynamicBase%2A>내부 속성 <xref:System.AppDomainSetup>이 인스턴스와 연결 된.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A>"
  example:
  - "This method is now obsolete, and should not be used for new development. The following example shows how to use the non-obsolete alternative, the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property. For an explanation of this example, see the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property or the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/m-system.appdomain.setdy_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/m-system.appdomain.setdy_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/m-system.appdomain.setdy_1.vb)]"
  syntax:
    content: public void SetDynamicBase (string path);
    parameters:
    - id: path
      type: System.String
      description: "기본 디렉터리인 하위 디렉터리에 대 한 동적 어셈블리를 저장 하는 정규화 된 경로입니다."
  overload: System.AppDomain.SetDynamicBase*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  id: SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "어떻게 사용자 및 id 개체에 연결 되어야 스레드 스레드가 특정 보안 주체에이 응용 프로그램 도메인에서 실행 하는 동안 바인딩을 시도 하는 경우를 지정 합니다."
  remarks: "이 값으로 설정만 적용 됩니다 사용 하기 전에 설정 하는 경우는 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>속성.</xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> 예를 들어, 설정한 경우 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>주어진된 주 서버 (예: 일반 사용자)와 다음 사용 하 여 설정 하려면 SetPrincipalPolicy 메서드는 <xref:System.Security.Principal.PrincipalPolicy>를 <xref:System.Security.Principal.PrincipalPolicy>, 현재 보안 주체가 제너릭 주체 유지 됩니다.</xref:System.Security.Principal.PrincipalPolicy> </xref:System.Security.Principal.PrincipalPolicy> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>"
  example:
  - "The following example shows the effect on threads of using the SetPrincipalPolicy method to change the principal policy of the application domain. It also shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads in the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setpr_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setpr_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setpr_1.cs)]"
  syntax:
    content: public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);
    parameters:
    - id: policy
      type: System.Security.Principal.PrincipalPolicy
      description: "중 하나는 <xref href=&quot;System.Security.Principal.PrincipalPolicy&quot;> </xref> 스레드에 연결할 principal 개체의 형식을 지정 하는 값입니다."
  overload: System.AppDomain.SetPrincipalPolicy*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyFiles
  id: SetShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "섀도 복사를 설정 합니다."
  remarks: "섀도 복사에 대 한 자세한 내용은 참조 하십시오. [어셈블리 섀도 복사](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[adproperties#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_0_1.cpp)]\n [!code-vb[adproperties#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_0_1.vb)]\n [!code-cs[adproperties#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_0_1.cs)]"
  syntax:
    content: public void SetShadowCopyFiles ();
    parameters: []
  overload: System.AppDomain.SetShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  id: SetShadowCopyPath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "섀도 복사 되는 어셈블리의 위치와 지정 된 디렉터리 경로 설정 합니다."
  remarks: "섀도 복사본을 기본적으로 검색을 통해 발견 된 모든 어셈블리를 포함 합니다. SetShadowCopyPath 메서드 섀도 복사를 통해 지정 된 디렉터리의 어셈블리에 제한 `path`합니다.       SetShadowCopyPath 메서드는 어셈블리에 대 한 검색할 추가 디렉터리를 지정 하지 않습니다. 어셈블리가 섀도 복사 되는 검색 경로 <xref:System.AppDomain.BaseDirectory%2A>.</xref:System.AppDomain.BaseDirectory%2A> 아래 예를 들어 이미에 있어야 SetShadowCopyPath 메서드는 검색 경로 섀도 복사 하도록 지정 합니다.       이 메서드는 설정의 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>내부 속성 <xref:System.AppDomainSetup>이 인스턴스와 연결 된.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ShadowCopyDirectories%2A>       섀도 복사에 대 한 자세한 내용은 참조 하십시오. [어셈블리 섀도 복사](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADShadowCopy#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_1_1.cpp)]\n [!code-vb[ADShadowCopy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_1_1.vb)]\n [!code-cs[ADShadowCopy#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_1_1.cs)]"
  syntax:
    content: public void SetShadowCopyPath (string path);
    parameters:
    - id: path
      type: System.String
      description: "각 이름이 세미콜론으로 구분 되는 위치는 디렉터리 이름 목록입니다."
  overload: System.AppDomain.SetShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  id: SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "이 응용 프로그램 도메인에서 실행 하는 동안 보안 주체에 바인딩하려는 경우 스레드에 연결 수를 기본 principal 개체를 설정 합니다."
  remarks: ''
  example:
  - "The following example shows the effect of using the SetThreadPrincipal method to change the principal that is available for attaching to threads that are executing in the application domain. It also shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setth_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setth_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setth_1.cs)]"
  syntax:
    content: public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);
    parameters:
    - id: principal
      type: System.Security.Principal.IPrincipal
      description: "스레드에 연결할 principal 개체입니다."
  overload: System.AppDomain.SetThreadPrincipal*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>principal</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "스레드 보안 주체가 이미 설정 되었습니다."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.SetupInformation
  id: SetupInformation
  parent: System.AppDomain
  langs:
  - csharp
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "이 인스턴스에 대 한 응용 프로그램 도메인 구성 정보를 가져옵니다."
  syntax:
    content: public AppDomainSetup SetupInformation { get; }
    return:
      type: System.AppDomainSetup
      description: "응용 프로그램 도메인 초기화 정보입니다."
  overload: System.AppDomain.SetupInformation*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.ShadowCopyFiles
  id: ShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "응용 프로그램 도메인이 파일을 섀도 복사 구성 되어 있는지 여부를 나타내는 값을 가져옵니다."
  remarks: "자세한 내용은 참조 <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>및 [어셈블리 섀도 복사](~/add/includes/ajax-current-ext-md.md).</xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>"
  syntax:
    content: public bool ShadowCopyFiles { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>응용 프로그램 도메인이 파일을 섀도 복사; 구성 된 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.AppDomain.ShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "언로드된 응용 프로그램 도메인에서 작업이 시도 됩니다."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "이름 집합을 해당 디스패치 식별자 집합에 매핑합니다."
  remarks: "이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다."
  syntax:
    content: void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "나중에 사용하도록 예약되어 있습니다. IID_NULL 이어야 합니다."
    - id: rgszNames
      type: System.IntPtr
      description: "전달 된 이름의 배열을 매핑할 수 있습니다."
    - id: cNames
      type: System.UInt32
      description: "매핑할 이름의 수입니다."
    - id: lcid
      type: System.UInt32
      description: "이름을 해석할 로캘 컨텍스트."
    - id: rgDispId
      type: System.IntPtr
      description: "이름에 해당 하는 Id를 받는 호출자가 할당 된 배열입니다."
  overload: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "COM을 사용 하 여 런타임에 바인딩된 액세스 `IDispatch` 인터페이스가 지원 되지 않습니다."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "인터페이스에 대 한 형식 정보를 얻으려면 다음 사용할 수 있는 개체에 대 한 형식 정보를 검색 합니다."
  remarks: "이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다."
  syntax:
    content: void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "반환할 형식 정보입니다."
    - id: lcid
      type: System.UInt32
      description: "형식 정보에 대 한 로캘 식별자입니다."
    - id: ppTInfo
      type: System.IntPtr
      description: "요청 된 형식 정보 개체에 대 한 포인터를 받습니다."
  overload: System.AppDomain.System#_AppDomain#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "COM을 사용 하 여 런타임에 바인딩된 액세스 `IDispatch` 인터페이스가 지원 되지 않습니다."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  id: System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "개체 (0 또는 1)를 제공 하는 형식 정보 인터페이스의 수를 검색 합니다."
  remarks: "이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다."
  syntax:
    content: void _AppDomain.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "개체에서 제공 하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다."
  overload: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "COM을 사용 하 여 런타임에 바인딩된 액세스 `IDispatch` 인터페이스가 지원 되지 않습니다."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "개체에서 노출 하는 메서드와 속성에 대 한 액세스를 제공 합니다."
  remarks: "이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다."
  syntax:
    content: void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "멤버를 식별 합니다."
    - id: riid
      type: System.Guid
      description: "나중에 사용하도록 예약되어 있습니다. IID_NULL 이어야 합니다."
    - id: lcid
      type: System.UInt32
      description: "인수를 해석할 로캘 컨텍스트입니다."
    - id: wFlags
      type: System.Int16
      description: "호출의 컨텍스트를 설명 하는 플래그입니다."
    - id: pDispParams
      type: System.IntPtr
      description: "인수의 배열, 명명 된 인수 및 배열에 있는 요소 수에 대 한 수에 대 한 인수 Dispid의 배열에 포함 된 구조체에 대 한 포인터입니다."
    - id: pVarResult
      type: System.IntPtr
      description: "결과 저장 될 위치에 대 한 포인터입니다."
    - id: pExcepInfo
      type: System.IntPtr
      description: "예외 정보가 포함 된 구조에 대 한 포인터입니다."
    - id: puArgErr
      type: System.IntPtr
      description: "오류가 있는 첫 번째 인수의 인덱스입니다."
  overload: System.AppDomain.System#_AppDomain#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "COM을 사용 하 여 런타임에 바인딩된 액세스 `IDispatch` 인터페이스가 지원 되지 않습니다."
  platform:
  - net462
- uid: System.AppDomain.ToString
  id: ToString
  parent: System.AppDomain
  langs:
  - csharp
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "응용 프로그램 도메인과 컨텍스트 정책의 이름이 포함 된 문자열 표현을 가져옵니다."
  remarks: ''
  example:
  - "The following code example displays the return value of the ToString method.  \n  \n [!code-cpp[ADToString#1](~/add/codesnippet/cpp/m-system.appdomain.tostr_1.cpp)]\n [!code-cs[ADToString#1](~/add/codesnippet/csharp/m-system.appdomain.tostr_1.cs)]\n [!code-vb[ADToString#1](~/add/codesnippet/visualbasic/m-system.appdomain.tostr_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "리터럴 문자열을 연결 하 여 구성 되는 문자열 &quot;이름:&quot;는 친숙 한 이름 응용 프로그램 도메인 및 컨텍스트 정책의 문자열 표현 또는 문자열의 &quot;컨텍스트 정책이 없습니다.&quot;"
  overload: System.AppDomain.ToString*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "현재 응용 프로그램 도메인 <xref href=&quot;System.AppDomain&quot;> </xref> 언로드 되었습니다."
  platform:
  - net462
- uid: System.AppDomain.TypeResolve
  id: TypeResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "형식 확인이 실패 하면 발생 합니다."
  remarks: "TypeResolve 이벤트에는 공용 언어 런타임 요청된 된 형식을 만들 수 있는 어셈블리를 확인할 수 없는 경우 발생 합니다. 이 유형을 동적 어셈블리에 정의 되어 또는 유형을 동적 어셈블리에 정의 되지 않은 있지만 런타임 형식에 정의 되어 있는 어셈블리를 알지 못합니다 발생할 수 있습니다. 후자의 경우에 발생할 수 있습니다 때 <xref:System.Type.GetType%2A?displayProperty=fullName>어셈블리 이름으로 한정 되지 않았습니다. 형식 이름으로 호출 합니다.</xref:System.Type.GetType%2A?displayProperty=fullName>       <xref:System.ResolveEventHandler>에이 이벤트를 찾아 형식을 만드는 시도할 수 있습니다.</xref:System.ResolveEventHandler>       그러나 TypeResolve 이벤트 런타임에서 특정 어셈블리에서 형식을 찾을 수 없는 경우에 발생 하지 않습니다. 예를 들어이 이벤트는 런타임 형식을 정적 어셈블리에 동적으로 추가할 수 없습니다 알기 때문에 형식을 정적 어셈블리에 없는 경우에 발생 하지 않습니다.       부터는 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>속성 유형을 요청 하는 어셈블리를 포함 합니다.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> 자세한 내용은 <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> 을 참조 하십시오.       이 이벤트에 대 한 이벤트 처리기를 등록 하려면 필요한 사용 권한이 있어야 또는 <xref:System.Security.SecurityException>throw 됩니다.</xref:System.Security.SecurityException>       이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following sample demonstrates the TypeResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_TypeResolve#1](~/add/codesnippet/csharp/e-system.appdomain.typer_1.cs)]\n [!code-vb[AppDomain_TypeResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.typer_1.vb)]\n [!code-cpp[AppDomain_TypeResolve#1](~/add/codesnippet/cpp/e-system.appdomain.typer_1.cpp)]"
  syntax:
    content: public event ResolveEventHandler TypeResolve;
    return:
      type: System.ResolveEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.UnhandledException
  id: UnhandledException
  parent: System.AppDomain
  langs:
  - csharp
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "예외는 잡히지 때 발생 합니다."
  remarks: "이 이벤트를 확인할 수 없는 예외에 대 한 알림을 제공합니다. 시스템 기본 처리기는 사용자에 게 예외를 보고 하 고 응용 프로그램이 종료 되기 전에 예외에 대 한 정보를 기록 하도록 응용 프로그램 수 있습니다. 응용 프로그램의 상태에 대 한 충분 한 정보가 표시 되 면 다른 작업을 수행할 수 있습니다-나중에 복구에 대 한 프로그램 데이터를 저장 하는 등입니다. 예외 처리 되지 않은 프로그램 데이터 손상 될 수 있으므로 주의 해야 합니다.      > [!NOTE] >.NET Framework 버전 1.0 및 1.1에서는 응용 프로그램 종료 및 디버깅 옵션은 보고 사용자에 게이 이벤트를 발생 시키려면 이후 보다 합니다.       이 이벤트는 응용 프로그램 도메인에서 처리할 수 있습니다. 그러나 이벤트 예외가 발생 하는 응용 프로그램 도메인에서 반드시 발생 하지 않습니다. 스레드에 대 한 전체 스택을 정리 된 하므로 이벤트가 발생할 수 있는 첫 번째 위치는 스레드가 생성 된 응용 프로그램 도메인에 적절 한 예외 처리기를 찾지 않고 하는 경우에 예외가 처리 되지 않습니다.      > [!NOTE] > 응용 프로그램이 시작 될 때 시스템에서 생성 되는 기본 응용 프로그램 도메인에 대해서만.NET Framework 버전 1.0 및 1.1이이 이벤트가 발생 합니다. 응용 프로그램에 추가 응용 프로그램 도메인을 만드는 경우 해당 응용 프로그램 도메인에서이 이벤트에 대 한 대리자를 지정 하 효과가 없습니다.       기본 응용 프로그램 도메인에서 UnhandledException 이벤트가 처리 하는 경우 발생에서 스레드가 시작 응용 프로그램 도메인에 관계 없이 모든 스레드에서 처리 되지 않은 모든 예외에 대 한 합니다. 스레드가 UnhandledException에 대 한 이벤트 처리기가 응용 프로그램 도메인에서 시작 하는 경우 해당 응용 프로그램 도메인에서 발생 합니다. 해당 응용 프로그램 도메인 기본 응용 프로그램 도메인 아니며 기본 응용 프로그램 도메인에서 이벤트 처리기도는 경우이 이벤트는 두 응용 프로그램 도메인에서 발생 합니다.       예를 들어 가정 스레드를 시작할 응용 프로그램 도메인 &quot;AD1&quot; &quot;AD2&quot; 응용 프로그램 도메인의 메서드를 호출 및 거기서에서 메서드를 호출 하는 &quot;AD3&quot; 응용 프로그램 도메인에서 예외가 throw 되 합니다. UnhandledException 이벤트가 발생할 수 있습니다는 첫 번째 응용 프로그램 도메인은 &quot;AD1&quot;입니다. 해당 응용 프로그램 도메인의 기본 응용 프로그램 도메인에 있지 않은 경우 이벤트 기본 응용 프로그램 도메인에도 발생할 수 있습니다.      > [!NOTE] > 공용 언어 런타임 UnhandledException 이벤트에 대 한 이벤트 처리기를 실행 하는 동안 스레드 중단을 일시 중단 합니다.       이벤트 처리기의 경우는 <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>특성의 적절 한 플래그를 이벤트 처리기 제약이 있는 실행 영역으로 처리 됩니다.</xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>       부터는 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], 스택 오버플로 같은 프로세스의 상태가 손상 또는 액세스 위반, 이벤트 처리기가 보안에 중요 한 및 경우가 아니면 하는 예외에 대 한이 이벤트는 <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>특성.</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       .NET Framework 버전 1.0 및 1.1에서는 기본 응용 프로그램 스레드를 제외한 스레드에서 발생 하는 처리 되지 않은 예외 런타임에서 발생 하 고 따라서 응용 프로그램이 종료를 발생 하지 않습니다. 따라서 UnhandledException 이벤트를 응용 프로그램을 종료 하지 않고 발생 수는 있습니다. .NET Framework 버전 2.0 이상에서는 자식 스레드에서 처리 되지 않은 예외에 대 한이 백업을 제거 이러한 누적 된 효과가 포함 성능이 저하 되 고 손상 된 데이터는 모두 디버그 하기가 어렵기 때문에 있습니다. 런타임 종료 되지 않는 사례 목록을 비롯 한 자세한 내용은 참조 하십시오. [관리 되는 스레드의 예외](~/add/includes/ajax-current-ext-md.md)합니다.       이 이벤트에 대 한 이벤트 처리기를 등록 하려면 필요한 사용 권한이 있어야 또는 <xref:System.Security.SecurityException>throw 됩니다.</xref:System.Security.SecurityException>       이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트](~/add/includes/ajax-current-ext-md.md)합니다.      ## 다른 이벤트를 처리 되지 않은 예외에 대 한 특정 응용 프로그램 모델링, UnhandledException 이벤트 주 응용 프로그램 스레드에서 처리 되지 않은 예외가 발생 하는 경우 다른 이벤트에 의해 선점 될 수 있습니다.       Windows Forms를 사용 하는 응용 프로그램에서 처리 되지 않은 예외에서 기본 응용 프로그램 스레드는 <xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName>이벤트를 발생 합니다.</xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName> 이 이벤트를 처리 하는 경우 기본 동작은 예외로 인해 응용 프로그램을 종료 하지 않을 응용 프로그램은 알 수 없는 상태로 남아 있지만 합니다. 이 경우 UnhandledException 이벤트가 발생 하지 않습니다. 응용 프로그램 구성 파일을 사용 하 여 또는 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName>하기 <xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName>전에 <xref:System.Windows.Forms.Application.ThreadException>이벤트 처리기 후크 되는</xref:System.Windows.Forms.Application.ThreadException> </xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName> 모드를 변경 하는 메서드</xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName> 를 사용 하 여이 동작을 변경할 수 있습니다. 이 기본 응용 프로그램 스레드에만 적용 됩니다. 다른 스레드에서 throw 된 처리 되지 않은 예외에 대 한 UnhandledException 이벤트가 발생 합니다.       Microsoft Visual Studio 2005 이상에서는 Visual Basic 응용 프로그램 프레임 워크는 주 응용 프로그램 스레드에서 처리 되지 않은 예외에 대 한 다른 이벤트를 제공 합니다. 참조는 <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName>이벤트.</xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName> 이 이벤트는 이벤트 인수 개체 UnhandledException에서 사용 하는 이벤트 인수 개체와 동일한 이름의 같지만 서로 다른 속성에 있습니다. 특히이 이벤트 인수 개체에는 <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>속성을 사용 하 고 계속 실행, 처리 되지 않은 예외를 무시 합니다. (응용 프로그램 상태를 알 수)을 응용 프로그램.</xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> 이 경우 UnhandledException 이벤트가 발생 하지 않습니다."
  example:
  - "The followingexample demonstrates the UnhandledException event. It defines an event handler, `MyHandler`, that is invoked whenever an unhandled exception is thrown in the default application domain. It then throws two exceptions. The first is handled by a **try/catch** block. The second is unhandled and invokes the `MyHandle` routine before the application terminates.  \n  \n [!code-cs[AppDomain_UnhandledException#1](~/add/codesnippet/csharp/e-system.appdomain.unhan_1.cs)]\n [!code-vb[AppDomain_UnhandledException#1](~/add/codesnippet/visualbasic/e-system.appdomain.unhan_1.vb)]\n [!code-cpp[AppDomain_UnhandledException#1](~/add/codesnippet/cpp/e-system.appdomain.unhan_1.cpp)]"
  syntax:
    content: public event UnhandledExceptionEventHandler UnhandledException;
    return:
      type: System.UnhandledExceptionEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Unload(System.AppDomain)
  id: Unload(System.AppDomain)
  parent: System.AppDomain
  langs:
  - csharp
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "지정 된 응용 프로그램 도메인을 언로드합니다."
  remarks: ".NET Framework 버전 2.0에에서는 스레드가 없는 응용 프로그램 도메인 언로드 전용입니다. .NET Framework 호스팅되는 경우에 특히 안정성 향상 됩니다. 스레드 호출 언로드 대상 도메인을 언로드하 표시 됩니다. 전용된 스레드가 도메인의 언로드 하 고 도메인의 모든 스레드가 중단 합니다. 스레드 중단 되지 않는 예를 들어 비관리 코드를 실행 하는 경우 또는 실행 한 `finally` 일정 기간 후 다음 블록은 <xref:System.CannotUnloadAppDomainException>언로드를 원래 호출한 스레드에서에서 throw 된.</xref:System.CannotUnloadAppDomainException> 결국 중단 하지 스레드가 종료 되는 경우에 대상 도메인은 언로드되지 않습니다. 따라서.NET Framework 버전 2.0에서에서 `domain` 보장 되지 않는 언로드되도록 것 수 없는 경우에 실행 중인 스레드를 종료할 수 있습니다.      > [!NOTE] > 경우도 언로드를 호출 하면 즉시 <xref:System.CannotUnloadAppDomainException>, 예를 들어 종료자에서 호출 되 면.</xref:System.CannotUnloadAppDomainException>       스레드 `domain` 를 사용 하 여 종료 되는 <xref:System.Threading.Thread.Abort%2A>throw 하는 메서드는 <xref:System.Threading.ThreadAbortException>스레드에서.</xref:System.Threading.ThreadAbortException> </xref:System.Threading.Thread.Abort%2A> 하지 않은 시간에 실행을 계속할 수 있지만 스레드가 즉시 종료 되어야는 `finally` 절.      ## 버전 호환성.NET Framework 버전 1.0 및 1.1에서 언로드를 호출 하는 스레드에서 실행 중인 경우 `domain`, 다른 스레드 언로드 작업을 수행 하기 시작 합니다. 경우 `domain` 언로드할 수 없으며는 <xref:System.CannotUnloadAppDomainException>언로드를 호출한 원래 스레드가에 없는 해당 스레드에서 throw 됩니다.</xref:System.CannotUnloadAppDomainException> 그러나 Unload 외부에서 실행 되는 스레드를 호출 하는 경우에 `domain`, 스레드가 예외를 받습니다."
  example:
  - "The following code example shows how to unload an application domain.  \n  \n [!code-cpp[ADUnload#1](~/add/codesnippet/cpp/m-system.appdomain.unloa_1.cpp)]\n [!code-vb[ADUnload#1](~/add/codesnippet/visualbasic/m-system.appdomain.unloa_1.vb)]\n [!code-cs[ADUnload#1](~/add/codesnippet/csharp/m-system.appdomain.unloa_1.cs)]"
  syntax:
    content: public static void Unload (AppDomain domain);
    parameters:
    - id: domain
      type: System.AppDomain
      description: "응용 프로그램 도메인을 언로드합니다."
  overload: System.AppDomain.Unload*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domain</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.CannotUnloadAppDomainException
    commentId: T:System.CannotUnloadAppDomainException
    description: "<code>domain</code>언로드할 수 없습니다."
  - type: System.Exception
    commentId: T:System.Exception
    description: "언로드하는 동안 오류가 발생 했습니다."
  platform:
  - net462
references:
- uid: System.MarshalByRefObject
  isExternal: false
  name: System.MarshalByRefObject
- uid: System.AppDomainUnloadedException
  parent: System
  isExternal: false
  name: AppDomainUnloadedException
  nameWithType: AppDomainUnloadedException
  fullName: System.AppDomainUnloadedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.TypeLoadException
  isExternal: true
  name: System.TypeLoadException
- uid: System.MissingMethodException
  isExternal: true
  name: System.MissingMethodException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.MemberAccessException
  isExternal: true
  name: System.MemberAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.BadImageFormatException
  isExternal: true
  name: System.BadImageFormatException
- uid: System.IO.FileLoadException
  isExternal: true
  name: System.IO.FileLoadException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.MethodAccessException
  isExternal: true
  name: System.MethodAccessException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.Policy.PolicyException
  parent: System.Security.Policy
  isExternal: false
  name: PolicyException
  nameWithType: PolicyException
  fullName: System.Security.Policy.PolicyException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.CannotUnloadAppDomainException
  parent: System
  isExternal: false
  name: CannotUnloadAppDomainException
  nameWithType: CannotUnloadAppDomainException
  fullName: System.CannotUnloadAppDomainException
- uid: System.Exception
  isExternal: true
  name: System.Exception
- uid: System.AppDomain.ActivationContext
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
- uid: System.ActivationContext
  parent: System
  isExternal: false
  name: ActivationContext
  nameWithType: ActivationContext
  fullName: System.ActivationContext
- uid: System.AppDomain.AppendPrivatePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.AppDomain.ApplicationIdentity
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
- uid: System.ApplicationIdentity
  parent: System
  isExternal: false
  name: ApplicationIdentity
  nameWithType: ApplicationIdentity
  fullName: System.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
- uid: System.Security.Policy.ApplicationTrust
  parent: System.Security.Policy
  isExternal: false
  name: ApplicationTrust
  nameWithType: ApplicationTrust
  fullName: System.Security.Policy.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
- uid: System.AppDomain.AssemblyLoad
  parent: System.AppDomain
  isExternal: false
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
- uid: System.AssemblyLoadEventHandler
  parent: System
  isExternal: false
  name: AssemblyLoadEventHandler
  nameWithType: AssemblyLoadEventHandler
  fullName: System.AssemblyLoadEventHandler
- uid: System.AppDomain.AssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
- uid: System.ResolveEventHandler
  parent: System
  isExternal: false
  name: ResolveEventHandler
  nameWithType: ResolveEventHandler
  fullName: System.ResolveEventHandler
- uid: System.AppDomain.BaseDirectory
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
- uid: System.AppDomain.ClearShadowCopyPath
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
- uid: System.Runtime.Remoting.ObjectHandle
  parent: System.Runtime.Remoting
  isExternal: false
  name: ObjectHandle
  nameWithType: ObjectHandle
  fullName: System.Runtime.Remoting.ObjectHandle
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Configuration.Assemblies.AssemblyHashAlgorithm
  parent: System.Configuration.Assemblies
  isExternal: false
  name: AssemblyHashAlgorithm
  nameWithType: AssemblyHashAlgorithm
  fullName: System.Configuration.Assemblies.AssemblyHashAlgorithm
- uid: System.AppDomain.CreateDomain(System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
- uid: System.Security.Policy.Evidence
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
- uid: System.AppDomainSetup
  parent: System
  isExternal: false
  name: AppDomainSetup
  nameWithType: AppDomainSetup
  fullName: System.AppDomainSetup
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
- uid: System.Security.PermissionSet
  parent: System.Security
  isExternal: false
  name: PermissionSet
  nameWithType: PermissionSet
  fullName: System.Security.PermissionSet
- uid: System.Security.Policy.StrongName[]
  parent: System.Security.Policy
  isExternal: false
  name: StrongName
  nameWithType: StrongName
  fullName: System.Security.Policy.StrongName[]
  spec.csharp:
  - uid: System.Security.Policy.StrongName
    name: StrongName
    nameWithType: StrongName
    fullName: StrongName[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
- uid: System.AppDomainInitializer
  parent: System
  isExternal: false
  name: AppDomainInitializer
  nameWithType: AppDomainInitializer
  fullName: System.AppDomainInitializer
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.Reflection.BindingFlags
  parent: System.Reflection
  isExternal: false
  name: BindingFlags
  nameWithType: BindingFlags
  fullName: System.Reflection.BindingFlags
- uid: System.Reflection.Binder
  parent: System.Reflection
  isExternal: false
  name: Binder
  nameWithType: Binder
  fullName: System.Reflection.Binder
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CurrentDomain
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
- uid: System.Reflection.Emit.AssemblyBuilder
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilder
  nameWithType: AssemblyBuilder
  fullName: System.Reflection.Emit.AssemblyBuilder
- uid: System.Reflection.AssemblyName
  parent: System.Reflection
  isExternal: true
  name: AssemblyName
  nameWithType: AssemblyName
  fullName: System.Reflection.AssemblyName
- uid: System.Reflection.Emit.AssemblyBuilderAccess
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilderAccess
  nameWithType: AssemblyBuilderAccess
  fullName: System.Reflection.Emit.AssemblyBuilderAccess
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
- uid: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<CustomAttributeBuilder>
  nameWithType: IEnumerable<CustomAttributeBuilder>
  fullName: System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Reflection.Emit.CustomAttributeBuilder
    name: CustomAttributeBuilder
    nameWithType: CustomAttributeBuilder
    fullName: CustomAttributeBuilder
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
- uid: System.Security.SecurityContextSource
  parent: System.Security
  isExternal: false
  name: SecurityContextSource
  nameWithType: SecurityContextSource
  fullName: System.Security.SecurityContextSource
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
- uid: System.CrossAppDomainDelegate
  parent: System
  isExternal: false
  name: CrossAppDomainDelegate
  nameWithType: CrossAppDomainDelegate
  fullName: System.CrossAppDomainDelegate
- uid: System.AppDomain.DomainManager
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
- uid: System.AppDomainManager
  parent: System
  isExternal: false
  name: AppDomainManager
  nameWithType: AppDomainManager
  fullName: System.AppDomainManager
- uid: System.AppDomain.DomainUnload
  parent: System.AppDomain
  isExternal: false
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.AppDomain.DynamicDirectory
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
- uid: System.AppDomain.FirstChanceException
  parent: System.AppDomain
  isExternal: false
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
- uid: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<FirstChanceExceptionEventArgs>
  nameWithType: EventHandler<FirstChanceExceptionEventArgs>
  fullName: System.EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs
    name: FirstChanceExceptionEventArgs
    nameWithType: FirstChanceExceptionEventArgs
    fullName: FirstChanceExceptionEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.FriendlyName
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
- uid: System.Reflection.Assembly[]
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly[]
  spec.csharp:
  - uid: System.Reflection.Assembly
    name: Assembly
    nameWithType: Assembly
    fullName: Assembly[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.GetCurrentThreadId
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
- uid: System.AppDomain.GetData(System.String)
  parent: System.AppDomain
  isExternal: false
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
- uid: System.AppDomain.GetType
  parent: System.AppDomain
  isExternal: false
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.AppDomain.Id
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
- uid: System.Nullable{System.Boolean}
  parent: System
  isExternal: true
  name: Nullable<Boolean>
  nameWithType: Nullable<Boolean>
  fullName: System.Nullable<System.Boolean>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: Nullable<System.Boolean>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: Boolean
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.IsDefaultAppDomain
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
- uid: System.AppDomain.IsFinalizingForUnload
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
- uid: System.AppDomain.IsFullyTrusted
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
- uid: System.AppDomain.Load(System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
- uid: System.AppDomain.Load(System.String)
  parent: System.AppDomain
  isExternal: false
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
- uid: System.AppDomain.MonitoringIsEnabled
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.AppDomain.PermissionSet
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
- uid: System.AppDomain.ProcessExit
  parent: System.AppDomain
  isExternal: false
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
- uid: System.AppDomain.RelativeSearchPath
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
- uid: System.AppDomain.ResourceResolve
  parent: System.AppDomain
  isExternal: false
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
- uid: System.Security.Policy.PolicyLevel
  parent: System.Security.Policy
  isExternal: false
  name: PolicyLevel
  nameWithType: PolicyLevel
  fullName: System.Security.Policy.PolicyLevel
- uid: System.AppDomain.SetCachePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
- uid: System.AppDomain.SetData(System.String,System.Object)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
- uid: System.Security.IPermission
  parent: System.Security
  isExternal: false
  name: IPermission
  nameWithType: IPermission
  fullName: System.Security.IPermission
- uid: System.AppDomain.SetDynamicBase(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
- uid: System.Security.Principal.PrincipalPolicy
  parent: System.Security.Principal
  isExternal: false
  name: PrincipalPolicy
  nameWithType: PrincipalPolicy
  fullName: System.Security.Principal.PrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.AppDomain.SetupInformation
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.AppDomain.ToString
  parent: System.AppDomain
  isExternal: false
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
- uid: System.AppDomain.TypeResolve
  parent: System.AppDomain
  isExternal: false
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
- uid: System.AppDomain.UnhandledException
  parent: System.AppDomain
  isExternal: false
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
- uid: System.UnhandledExceptionEventHandler
  parent: System
  isExternal: false
  name: UnhandledExceptionEventHandler
  nameWithType: UnhandledExceptionEventHandler
  fullName: System.UnhandledExceptionEventHandler
- uid: System.AppDomain.Unload(System.AppDomain)
  parent: System.AppDomain
  isExternal: false
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
- uid: System.AppDomain.ActivationContext*
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
- uid: System.AppDomain.AppendPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath
  nameWithType: AppDomain.AppendPrivatePath
- uid: System.AppDomain.ApplicationIdentity*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy*
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy
  nameWithType: AppDomain.ApplyPolicy
- uid: System.AppDomain.BaseDirectory*
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath
  nameWithType: AppDomain.ClearPrivatePath
- uid: System.AppDomain.ClearShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath
  nameWithType: AppDomain.ClearShadowCopyPath
- uid: System.AppDomain.CreateComInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom
  nameWithType: AppDomain.CreateComInstanceFrom
- uid: System.AppDomain.CreateDomain*
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain
  nameWithType: AppDomain.CreateDomain
- uid: System.AppDomain.CreateInstance*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance
  nameWithType: AppDomain.CreateInstance
- uid: System.AppDomain.CreateInstanceAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap
  nameWithType: AppDomain.CreateInstanceAndUnwrap
- uid: System.AppDomain.CreateInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom
  nameWithType: AppDomain.CreateInstanceFrom
- uid: System.AppDomain.CreateInstanceFromAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap
- uid: System.AppDomain.CurrentDomain*
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly*
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly
  nameWithType: AppDomain.DefineDynamicAssembly
- uid: System.AppDomain.DoCallBack*
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack
  nameWithType: AppDomain.DoCallBack
- uid: System.AppDomain.DomainManager*
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
- uid: System.AppDomain.DynamicDirectory*
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence*
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly
  nameWithType: AppDomain.ExecuteAssembly
- uid: System.AppDomain.ExecuteAssemblyByName*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName
  nameWithType: AppDomain.ExecuteAssemblyByName
- uid: System.AppDomain.FriendlyName*
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies
  nameWithType: AppDomain.GetAssemblies
- uid: System.AppDomain.GetCurrentThreadId*
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId
  nameWithType: AppDomain.GetCurrentThreadId
- uid: System.AppDomain.GetData*
  parent: System.AppDomain
  isExternal: false
  name: GetData
  nameWithType: AppDomain.GetData
- uid: System.AppDomain.GetType*
  parent: System.AppDomain
  isExternal: false
  name: GetType
  nameWithType: AppDomain.GetType
- uid: System.AppDomain.Id*
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService*
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService
  nameWithType: AppDomain.InitializeLifetimeService
- uid: System.AppDomain.IsCompatibilitySwitchSet*
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet
  nameWithType: AppDomain.IsCompatibilitySwitchSet
- uid: System.AppDomain.IsDefaultAppDomain*
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain
  nameWithType: AppDomain.IsDefaultAppDomain
- uid: System.AppDomain.IsFinalizingForUnload*
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload
  nameWithType: AppDomain.IsFinalizingForUnload
- uid: System.AppDomain.IsFullyTrusted*
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous*
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
- uid: System.AppDomain.Load*
  parent: System.AppDomain
  isExternal: false
  name: Load
  nameWithType: AppDomain.Load
- uid: System.AppDomain.MonitoringIsEnabled*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
- uid: System.AppDomain.PermissionSet*
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
- uid: System.AppDomain.ReflectionOnlyGetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies
- uid: System.AppDomain.RelativeSearchPath*
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
- uid: System.AppDomain.SetAppDomainPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy
  nameWithType: AppDomain.SetAppDomainPolicy
- uid: System.AppDomain.SetCachePath*
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath
  nameWithType: AppDomain.SetCachePath
- uid: System.AppDomain.SetData*
  parent: System.AppDomain
  isExternal: false
  name: SetData
  nameWithType: AppDomain.SetData
- uid: System.AppDomain.SetDynamicBase*
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase
  nameWithType: AppDomain.SetDynamicBase
- uid: System.AppDomain.SetPrincipalPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy
  nameWithType: AppDomain.SetPrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles
  nameWithType: AppDomain.SetShadowCopyFiles
- uid: System.AppDomain.SetShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath
  nameWithType: AppDomain.SetShadowCopyPath
- uid: System.AppDomain.SetThreadPrincipal*
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal
  nameWithType: AppDomain.SetThreadPrincipal
- uid: System.AppDomain.SetupInformation*
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount
- uid: System.AppDomain.System#_AppDomain#Invoke*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke
  nameWithType: AppDomain.System._AppDomain.Invoke
- uid: System.AppDomain.ToString*
  parent: System.AppDomain
  isExternal: false
  name: ToString
  nameWithType: AppDomain.ToString
- uid: System.AppDomain.Unload*
  parent: System.AppDomain
  isExternal: false
  name: Unload
  nameWithType: AppDomain.Unload
