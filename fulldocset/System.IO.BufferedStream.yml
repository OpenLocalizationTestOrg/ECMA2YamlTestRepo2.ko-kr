### YamlMime:ManagedReference
items:
- uid: System.IO.BufferedStream
  id: BufferedStream
  children:
  - System.IO.BufferedStream.#ctor(System.IO.Stream)
  - System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  - System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.BufferedStream.CanRead
  - System.IO.BufferedStream.CanSeek
  - System.IO.BufferedStream.CanWrite
  - System.IO.BufferedStream.Dispose(System.Boolean)
  - System.IO.BufferedStream.EndRead(System.IAsyncResult)
  - System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  - System.IO.BufferedStream.Flush
  - System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.BufferedStream.Length
  - System.IO.BufferedStream.Position
  - System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.BufferedStream.ReadByte
  - System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.BufferedStream.SetLength(System.Int64)
  - System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.BufferedStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: BufferedStream
  nameWithType: BufferedStream
  fullName: System.IO.BufferedStream
  type: Class
  summary: "버퍼링 계층 읽고 다른 스트림에 대 한 쓰기 작업을 추가 합니다. 이 클래스는 상속 될 수 없습니다."
  remarks: "A buffer is a block of bytes in memory used to cache data, thereby reducing the number of calls to the operating system. Buffers improve read and write performance. A buffer can be used for either reading or writing, but never both simultaneously. The [Read(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True) and [Write(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True) methods of `BufferedStream` automatically maintain the buffer.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n `BufferedStream` can be composed around certain types of streams. It provides implementations for reading and writing bytes to an underlying data source or repository. Use <xref:System.IO.BinaryReader> and <xref:System.IO.BinaryWriter> for reading and writing other data types. `BufferedStream` is designed to prevent the buffer from slowing down input and output when the buffer is not needed. If you always read and write for sizes greater than the internal buffer size, then `BufferedStream` might not even allocate the internal buffer. `BufferedStream` also buffers reads and writes in a shared buffer. It is assumed that you will almost always be doing a series of reads or writes, but rarely alternate between the two of them."
  example:
  - "The following code examples show how to use the `BufferedStream` class over the `NetworkStream` class to increase the performance of certain I/O operations. Start the server on a remote computer before starting the client. Specify the remote computer name as a command-line argument when starting the client. Vary the `dataArraySize` and `streamBufferSize` constants to view their effect on performance.  \n  \n The first example shows the code that runs on the client, and the second example shows the code that runs on the server.  \n  \n **Example 1: Code that runs on the client**  \n  \n [!code-cs[System.IO.BufferedStream1#1](~/add/codesnippet/csharp/t-system.io.bufferedstream_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#1](~/add/codesnippet/cpp/t-system.io.bufferedstream_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#1](~/add/codesnippet/visualbasic/t-system.io.bufferedstream_1.vb)]  \n  \n **Example 2: Code that runs on the server**  \n  \n [!code-vb[System.IO.BufferedStream2#1](~/add/codesnippet/visualbasic/t-system.io.bufferedstream_2.vb)]\n [!code-cs[System.IO.BufferedStream2#1](~/add/codesnippet/csharp/t-system.io.bufferedstream_2.cs)]\n [!code-cpp[System.IO.BufferedStream2#1](~/add/codesnippet/cpp/t-system.io.bufferedstream_2.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class BufferedStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream)
  id: '#ctor(System.IO.Stream)'
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BufferedStream(Stream)
  nameWithType: BufferedStream.BufferedStream(Stream)
  fullName: System.IO.BufferedStream.BufferedStream(Stream)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.BufferedStream&quot;> </xref> 클래스 기본 버퍼 크기는 4096 바이트입니다."
  remarks: "공유 읽기/쓰기 버퍼에 처음으로 할당 되는 `BufferedStream` 이 생성자를 사용 하 여 개체 초기화 됩니다. 모든 읽기 및 쓰기 보다 크거나 같은 경우 공유 버퍼 사용 되지 않습니다 `bufferSize`합니다."
  syntax:
    content: public BufferedStream (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "현재 스트림입니다."
  overload: System.IO.BufferedStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  id: '#ctor(System.IO.Stream,System.Int32)'
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BufferedStream(Stream,Int32)
  nameWithType: BufferedStream.BufferedStream(Stream,Int32)
  fullName: System.IO.BufferedStream.BufferedStream(Stream,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.BufferedStream&quot;> </xref> 지정 된 버퍼 크기를 사용 합니다."
  remarks: "공유 읽기/쓰기 버퍼에 처음으로 할당 되는 `BufferedStream` 이 생성자를 사용 하 여 개체 초기화 됩니다. 모든 읽기 및 쓰기 보다 크거나 같은 경우 공유 버퍼 사용 되지 않습니다 `bufferSize`합니다."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#2](~/add/codesnippet/csharp/m-system.io.bufferedstre_2_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#2](~/add/codesnippet/cpp/m-system.io.bufferedstre_2_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#2](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_2_1.vb)]"
  syntax:
    content: public BufferedStream (System.IO.Stream stream, int bufferSize);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "현재 스트림입니다."
    - id: bufferSize
      type: System.Int32
      description: "버퍼 크기 (바이트)입니다."
  overload: System.IO.BufferedStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>가 음수입니다."
  platform:
  - net462
- uid: System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "비동기 읽기 작업을 시작합니다. (사용 하는 것이 좋습니다 <xref:System.IO.BufferedStream.ReadAsync*>대신 설명 섹션을 참조 합니다.)</xref:System.IO.BufferedStream.ReadAsync*>"
  remarks: ".NET Framework 4 및 이전 버전에서와 같은 메서드를 사용 해야 <xref:System.IO.Stream.BeginRead%2A>및 <xref:System.IO.Stream.EndRead%2A>비동기 파일 작업을 구현 합니다.</xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> 그러나 이러한 메서드는에서 계속 사용할 수는 [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] 레거시 코드를 지원 하기 위해 새로운 비동기 메서드 같은 <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, 및 <xref:System.IO.BufferedStream.FlushAsync%2A>, 비동기 파일 작업을 보다 쉽게 구현 도움말.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       <xref:System.IO.BufferedStream.EndWrite%2A>BeginRead 호출할 때마다 한 번만 호출 되어야 합니다.</xref:System.IO.BufferedStream.EndWrite%2A> 다른 읽기를 시작 하기 전에 읽기 프로세스를 종료 하지 못하면 교착 상태와 같이 원하지 않는 동작이 발생할 수 있습니다.      > [!NOTE] > 사용은 <xref:System.IO.BufferedStream.CanRead%2A>속성을 현재 인스턴스에 읽기를 지원 하는지를 확인 합니다.</xref:System.IO.BufferedStream.CanRead%2A>       <xref:System.IO.BufferedStream.EndRead%2A>이 호출 해야 <xref:System.IAsyncResult>읽은 바이트 수를 찾으려고 합니다.</xref:System.IAsyncResult></xref:System.IO.BufferedStream.EndRead%2A>"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "데이터를 읽어올 버퍼입니다."
    - id: offset
      type: System.Int32
      description: "바이트 오프셋 `buffer` 스트림에서 읽은 데이터를 쓰기 시작할입니다."
    - id: count
      type: System.Int32
      description: "읽을 바이트 수의 최대 수입니다."
    - id: callback
      type: System.AsyncCallback
      description: "읽기가 완료 되 면 호출 되는 선택적 비동기 콜백."
    - id: state
      type: System.Object
      description: "이 특정 비동기 읽기 요청을 다른 요청과 구별 하는 사용자 제공 개체입니다."
    return:
      type: System.IAsyncResult
      description: "보류 중일 수 있는 비동기 읽기를 나타내는 개체입니다."
  overload: System.IO.BufferedStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>또는 <code>count</code> 음수입니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "스트림의 끝을 지 나 비동기 읽기를 시도 합니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "버퍼 길이에서 <code> offset </code> 는 보다 작은 <code> count </code>합니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "현재 스트림이 읽기 작업을 지원 하지 않습니다."
  platform:
  - net462
- uid: System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "비동기 쓰기 작업을 시작합니다. (사용 하는 것이 좋습니다 <xref:System.IO.BufferedStream.WriteAsync*>대신 설명 섹션을 참조 합니다.)</xref:System.IO.BufferedStream.WriteAsync*>"
  remarks: ".NET Framework 4 및 이전 버전에서와 같은 메서드를 사용 해야 <xref:System.IO.Stream.BeginWrite%2A>및 <xref:System.IO.Stream.EndWrite%2A>비동기 파일 작업을 구현 합니다.</xref:System.IO.Stream.EndWrite%2A> </xref:System.IO.Stream.BeginWrite%2A> 그러나 이러한 메서드는에서 계속 사용할 수는 [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] 레거시 코드를 지원 하기 위해 새로운 비동기 메서드 같은 <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, 및 <xref:System.IO.BufferedStream.FlushAsync%2A>, 비동기 파일 작업을 보다 쉽게 구현 도움말.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       <xref:System.IO.BufferedStream.EndWrite%2A>정확히 한 번만 호출 해야 모든 <xref:System.IAsyncResult>BeginWrite에서.</xref:System.IAsyncResult></xref:System.IO.BufferedStream.EndWrite%2A> <xref:System.IO.BufferedStream.EndWrite%2A>I/O 작업이 완료 될 때까지 차단 됩니다.</xref:System.IO.BufferedStream.EndWrite%2A>"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "현재 스트림에 쓸 데이터를 포함 하는 버퍼입니다."
    - id: offset
      type: System.Int32
      description: "0부터 시작 하는 바이트 오프셋 `buffer` 를 현재 스트림에 바이트 복사를 시작 하는 합니다."
    - id: count
      type: System.Int32
      description: "쓸 바이트의 최대 수입니다."
    - id: callback
      type: System.AsyncCallback
      description: "비동기 쓰기 작업이 완료 될 때 호출 될 메서드."
    - id: state
      type: System.Object
      description: "다른 요청에서 특정 비동기 쓰기 요청을 구별 하는 사용자 제공 개체입니다."
    return:
      type: System.IAsyncResult
      description: "보류 중일 수 있는 비동기 쓰기를 참조 하는 개체입니다."
  overload: System.IO.BufferedStream.BeginWrite*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>buffer</code>길이에서 <code>offset</code> 는 보다 작은 <code>count</code>합니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>또는 <code>count</code> 음수입니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 쓰기를 지원 하지 않습니다."
  platform:
  - net462
- uid: System.IO.BufferedStream.CanRead
  id: CanRead
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanRead
  nameWithType: BufferedStream.CanRead
  fullName: System.IO.BufferedStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "현재 스트림이 읽기를 지원 하는지 여부를 나타내는 값을 가져옵니다."
  remarks: "클래스에서 파생 하는 경우 <xref:System.IO.Stream>읽기를 지원 하지 않습니다에 대 한 호출이 <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>, 및 `Peek` 방식의 <xref:System.IO.StreamReader>, <xref:System.IO.StringReader> <xref:System.IO.TextReader>에 <xref:System.NotSupportedException>.</xref:System.NotSupportedException> throw</xref:System.IO.TextReader> 및</xref:System.IO.StringReader> </xref:System.IO.StreamReader> </xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> </xref:System.IO.BufferedStream.ReadByte%2A> </xref:System.IO.BufferedStream.Read%2A> </xref:System.IO.Stream>       이 속성은 반환 된 스트림이 닫혀 있는지 `false`합니다."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#5](~/add/codesnippet/csharp/p-system.io.bufferedstre_2_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#5](~/add/codesnippet/cpp/p-system.io.bufferedstre_2_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#5](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_2_1.vb)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>스트림이 읽기를 지원 합니다. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 스트림이 닫혀 있거나 쓰기 전용 권한으로 열렸으면 경우."
  overload: System.IO.BufferedStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.CanSeek
  id: CanSeek
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
  fullName: System.IO.BufferedStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "현재 스트림이 검색을 지원 하는지 여부를 나타내는 값을 가져옵니다."
  remarks: "클래스에서 파생 하는 경우 <xref:System.IO.Stream>찾기를 지원 하지 않습니다에 대 한 호출이 <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>를 선언 하 고 <xref:System.IO.BufferedStream.Seek%2A>throw에 <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.BufferedStream.Seek%2A> </xref:System.IO.BufferedStream.Position%2A> </xref:System.IO.BufferedStream.SetLength%2A> </xref:System.IO.BufferedStream.Length%2A> </xref:System.IO.Stream>       이 속성은 반환 된 스트림이 닫혀 있는지 `false`합니다."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#3](~/add/codesnippet/csharp/p-system.io.bufferedstre_0_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#3](~/add/codesnippet/cpp/p-system.io.bufferedstre_0_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#3](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_0_1.vb)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>스트림이 검색을 지원 하면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 스트림이 닫혀 또는 스트림이 콘솔에 출력 또는 파이프와 같은 운영 체제 핸들에서 생성 된 경우."
  overload: System.IO.BufferedStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.CanWrite
  id: CanWrite
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
  fullName: System.IO.BufferedStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "현재 스트림이 쓰기를 지원 하는지 여부를 나타내는 값을 가져옵니다."
  remarks: "클래스에서 파생 하는 경우 <xref:System.IO.Stream>쓰기 호출을 지원 하지 않는 <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A> <xref:System.IO.BufferedStream.WriteByte%2A>에 <xref:System.NotSupportedException>.</xref:System.NotSupportedException> throw</xref:System.IO.BufferedStream.WriteByte%2A> 또는</xref:System.IO.BufferedStream.Write%2A> </xref:System.IO.BufferedStream.SetLength%2A> </xref:System.IO.Stream>       이 속성은 반환 된 스트림이 닫혀 있는지 `false`합니다."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#4](~/add/codesnippet/csharp/p-system.io.bufferedstre_1_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#4](~/add/codesnippet/cpp/p-system.io.bufferedstre_1_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#4](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_1_1.vb)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>스트림이 쓰기를 지원 합니다. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 스트림이 닫혀 있거나 읽기 전용 권한으로 열렸으면 경우."
  overload: System.IO.BufferedStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: BufferedStream.Dispose(Boolean)
  fullName: System.IO.BufferedStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "추가할 수 있습니다."
  overload: System.IO.BufferedStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: BufferedStream.EndRead(IAsyncResult)
  fullName: System.IO.BufferedStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "보류 중인 비동기 읽기 작업이 완료 되기를 기다립니다. (사용 하는 것이 좋습니다 <xref:System.IO.BufferedStream.ReadAsync*>대신 설명 섹션을 참조 합니다.)</xref:System.IO.BufferedStream.ReadAsync*>"
  remarks: ".NET Framework 4 및 이전 버전에서와 같은 메서드를 사용 해야 <xref:System.IO.Stream.BeginRead%2A>및 <xref:System.IO.Stream.EndRead%2A>비동기 파일 작업을 구현 합니다.</xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> 그러나 이러한 메서드는에서 계속 사용할 수는 [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] 레거시 코드를 지원 하기 위해 새로운 비동기 메서드 같은 <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, 및 <xref:System.IO.BufferedStream.FlushAsync%2A>, 비동기 파일 작업을 보다 쉽게 구현 도움말.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       이 EndRead를 호출 해야 <xref:System.IAsyncResult>읽은 바이트 수를 찾으려고 합니다.</xref:System.IAsyncResult>"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "기다리는 보류 중인 비동기 요청에 대 한 참조입니다."
    return:
      type: System.Int32
      description: "0 (영)과 요청한 바이트 수 사이의 스트림에서 읽은 바이트 수입니다. 스트림은 스트림의 끝 에서만 0만을 반환, 그렇지 않으면 최소한 1 바이트 있을 때까지 하며 차단 됩니다."
  overload: System.IO.BufferedStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "이 <xref:System.IAsyncResult>개체가 <xref:System.IO.BufferedStream.BeginRead*>이 클래스에서</xref:System.IO.BufferedStream.BeginRead*> 호출 하 여 만들어진 개체가 아닙니다</xref:System.IAsyncResult>"
  platform:
  - net462
- uid: System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: BufferedStream.EndWrite(IAsyncResult)
  fullName: System.IO.BufferedStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "I/O 작업이 완료 될 때까지 비동기 쓰기 작업 및 블록을 종료 합니다. (사용 하는 것이 좋습니다 <xref:System.IO.BufferedStream.WriteAsync*>대신 설명 섹션을 참조 합니다.)</xref:System.IO.BufferedStream.WriteAsync*>"
  remarks: ".NET Framework 4 및 이전 버전에서와 같은 메서드를 사용 해야 <xref:System.IO.Stream.BeginWrite%2A>및 <xref:System.IO.Stream.EndWrite%2A>비동기 파일 작업을 구현 합니다.</xref:System.IO.Stream.EndWrite%2A> </xref:System.IO.Stream.BeginWrite%2A> 그러나 이러한 메서드는에서 계속 사용할 수는 [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] 레거시 코드를 지원 하기 위해 새로운 비동기 메서드 같은 <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, 및 <xref:System.IO.BufferedStream.FlushAsync%2A>, 비동기 파일 작업을 보다 쉽게 구현 도움말.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       <xref:System.IO.BufferedStream.BeginRead%2A>.</xref:System.IO.BufferedStream.BeginRead%2A> 를 호출할 때마다 EndWrite는 한 번만 호출 해야 합니다. 시작 하기 전에 읽기 프로세스를 종료 하지 못하면 다른 읽기 작업에 교착 상태 또는 다른 원하지 않는 동작이 발생할 수 있습니다."
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "보류 중인 비동기 요청입니다."
  overload: System.IO.BufferedStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "이 <xref:System.IAsyncResult>개체가 <xref:System.IO.BufferedStream.BeginWrite*>이 클래스에서</xref:System.IO.BufferedStream.BeginWrite*> 호출 하 여 만들어진 개체가 아닙니다</xref:System.IAsyncResult>"
  platform:
  - net462
- uid: System.IO.BufferedStream.Flush
  id: Flush
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Flush()
  nameWithType: BufferedStream.Flush()
  fullName: System.IO.BufferedStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "이 스트림에 대 한 모든 버퍼를 지우고 버퍼링 된 모든 데이터가 내부 장치에 쓰여지도록 합니다."
  remarks: "명시적으로 호출 하지 않으면 스트림을 내부 인코더가 플러시되지 것입니다 `Flush` 나 <xref:System.IO.Stream.Close%2A>.</xref:System.IO.Stream.Close%2A>       사용 하는 경우는 <xref:System.IO.BufferedStream.%23ctor%2A>생성자를 만드는 동안 버퍼 크기를 지정 하는 `BufferedStream` 개체, 버퍼 크기에 도달 하면 플러시됩니다.</xref:System.IO.BufferedStream.%23ctor%2A> 예를 들어와 같은 코드 `BufferedStream bs = new BufferedStream(bs, 5)` 버퍼 크기에는 5 바이트에 도달할 때 내용을 플러시합니다.       모든 읽기 및 쓰기 메서드 `BufferedStream` 자동으로 버퍼를 유지 하기 위해 호출할 필요가 없습니다 `Flush` 읽기와 쓰기 간의 앞뒤로 전환 하는 경우."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#6](~/add/codesnippet/csharp/m-system.io.bufferedstre_0_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#6](~/add/codesnippet/cpp/m-system.io.bufferedstre_0_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#6](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_0_1.vb)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.BufferedStream.Flush*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 삭제 되었습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "데이터 소스 또는 리포지토리에 열려 있지 않습니다."
  platform:
  - net462
- uid: System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: BufferedStream.FlushAsync(CancellationToken)
  fullName: System.IO.BufferedStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "비동기적으로이 스트림에 대 한 모든 버퍼를 지우고 버퍼링 된 모든 데이터가 내부 장치에 쓰여지도록 하 고 취소 요청을 모니터링 합니다."
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "취소 요청을 모니터링할 토큰입니다."
    return:
      type: System.Threading.Tasks.Task
      description: "비동기 플러시 작업을 나타내는 작업입니다."
  overload: System.IO.BufferedStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 삭제 되었습니다."
  platform:
  - net462
- uid: System.IO.BufferedStream.Length
  id: Length
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Length
  nameWithType: BufferedStream.Length
  fullName: System.IO.BufferedStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "스트림 길이 바이트 단위로 가져옵니다."
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "바이트 스트림 길이입니다."
  overload: System.IO.BufferedStream.Length*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "내부 스트림이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 또는 종료 됨."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 찾기를 지원 하지 않습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 닫힌 후에 메서드가 호출 되었습니다."
  platform:
  - net462
- uid: System.IO.BufferedStream.Position
  id: Position
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Position
  nameWithType: BufferedStream.Position
  fullName: System.IO.BufferedStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "현재 스트림 내의 위치를 가져옵니다."
  remarks: "`get` 접근자 호출 <xref:System.IO.BufferedStream.Seek%2A>기본 스트림 내의 현재 위치를 가져오는 다음 버퍼 내의 현재 위치에 따라이 값을 조정 하 고.</xref:System.IO.BufferedStream.Seek%2A>       `set` 접근자 이전에 내부 스트림에 버퍼에 쓴 데이터를 복사한 다음 <xref:System.IO.BufferedStream.Seek%2A>.</xref:System.IO.BufferedStream.Seek%2A> 호출       스트림의 길이 초과 하는 위치에 검색을 지원 됩니다."
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "현재 스트림 내의 위치입니다."
  overload: System.IO.BufferedStream.Position*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "에 전달 된 값 <xref:System.IO.BufferedStream.Seek*>음수입니다.</xref:System.IO.BufferedStream.Seek*>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "닫히는 스트림과 같은 I/O 오류가 발생 합니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 찾기를 지원 하지 않습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 닫힌 후에 메서드가 호출 되었습니다."
  platform:
  - net462
- uid: System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "현재 버퍼링 된 스트림에서 배열에 바이트를 복사 합니다."
  remarks: "`Read` 스트림의 끝에 도달 하는 경우에 메서드가 0을 반환 합니다. 다른 모든 경우에 `Read` 항상 스트림에서 반환 하기 전에 적어도&1; 바이트를 읽습니다. 에 대 한 호출 시 스트림에서 데이터가 없는 경우 기본적으로 `Read`, `Read` 메서드 (자동으로 스트림의 끝에는 연결할) 0을 반환 합니다. 구현을 스트림의 끝에 도달 하지 하는 경우에 요청 된 것 보다 적은 바이트를 반환할 수 있습니다.       사용 하 여 <xref:System.IO.BinaryReader>기본 데이터 형식을 읽기 위한.</xref:System.IO.BinaryReader>"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#7](~/add/codesnippet/csharp/m-system.io.bufferedstre_3_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#7](~/add/codesnippet/cpp/m-system.io.bufferedstre_3_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#7](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_3_1.vb)]"
  syntax:
    content: public override int Read (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "버퍼를 바이트 복사 하려는입니다."
    - id: offset
      type: System.Int32
      description: "바이트 읽기를 시작할 버퍼의 바이트 오프셋입니다."
    - id: count
      type: System.Int32
      description: "읽을 바이트 수입니다."
    return:
      type: System.Int32
      description: "총 바이트 수가 읽힙니다 <code> array </code>합니다. 이 바이트 수를 현재 사용할 수 없는 또는 모든 데이터 스트림의 끝에 도달한 경우 0 수 읽을 수 있는 바이트 수가 요청 보다 작을 수 있습니다."
  overload: System.IO.BufferedStream.Read*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>또는 <code>count</code> 음수입니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "스트림이 열려 있지 않거나은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 읽기를 지원 하지 않습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 닫힌 후에 메서드가 호출 되었습니다."
  platform:
  - net462
- uid: System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "현재 스트림에서 바이트 시퀀스를 비동기적으로 읽고 읽은 바이트 수 만큼 스트림 내 위치를 이동 하 고 취소 요청을 모니터링 합니다."
  remarks: "인스턴스를 만들어 취소 토큰을 만들 수 있습니다는 <xref:System.Threading.CancellationTokenSource>클래스 및 전달 된 <xref:System.Threading.CancellationTokenSource.Token%2A>속성으로는 `cancellationToken` 매개 변수.</xref:System.Threading.CancellationTokenSource.Token%2A> </xref:System.Threading.CancellationTokenSource>"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "데이터를 쓸 버퍼입니다."
    - id: offset
      type: System.Int32
      description: "바이트 오프셋 `buffer` 데이터 스트림에서 쓰기를 시작할입니다."
    - id: count
      type: System.Int32
      description: "읽을 바이트 수의 최대 수입니다."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "취소 요청을 모니터링할 토큰입니다."
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "나타내는 비동기 읽기 작업입니다. 값은 <code> TResult </code> 바이트은 버퍼 안으로 읽어들인 총 수를 포함 하는 매개 변수입니다. 결과 값에는 현재 사용할 수 있는 바이트 수가 요청 된 수보다 작으면 하거나 스트림의 끝에 도달한 경우 0 (영) 수 바이트 수가 요청 된 수보다 작을 수 있습니다."
  overload: System.IO.BufferedStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>또는 <code>count</code> 음수입니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "총 <code> offset </code> 및 <code> count </code> 버퍼 길이 보다 큽니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 읽기를 지원 하지 않습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 삭제 되었습니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "스트림을 현재 이전 읽기 작업에서 사용 중입니다."
  platform:
  - net462
- uid: System.IO.BufferedStream.ReadByte
  id: ReadByte
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: BufferedStream.ReadByte()
  fullName: System.IO.BufferedStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "내부 스트림에서 바이트를 읽고로 캐스팅 된 바이트를 반환 합니다.는 <xref uid=&quot;langword_csharp_int&quot; name=&quot;int&quot; href=&quot;&quot;> </xref>, 하거나 스트림의 끝에서 읽는 경우-1을 반환 합니다."
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "로 캐스팅 된 바이트는 <xref uid=&quot;langword_csharp_int&quot; name=&quot;int&quot; href=&quot;&quot;> </xref>, 스트림의 끝에서 읽는 경우-1입니다."
  overload: System.IO.BufferedStream.ReadByte*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "닫히는 스트림과 같은 I/O 오류가 발생 합니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 읽기를 지원 하지 않습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 닫힌 후에 메서드가 호출 되었습니다."
  platform:
  - net462
- uid: System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: BufferedStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.BufferedStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "현재 버퍼링 된 스트림 내의 위치를 설정 합니다."
  remarks: "경우 `offset` 가 음수 이면 새 위치 앞에 올로 지정 된 위치 `origin` 에 지정 된 바이트 수로 `offset`합니다. 경우 `offset` 이 0 이면 새 위치에 지정 된 위치 `origin`합니다. 경우 `offset` 이 양수인 경우 새 위치에 지정 된 위치를 따를 것 `origin` 에 지정 된 바이트 수로 `offset`합니다.       경우는 <xref:System.IO.BufferedStream>개체에 대 한 기본 스트림에는 <xref:System.IO.StreamReader>개체 Seek 메서드를 호출 하면 더 이상 판독기의 내부 버퍼의 위치와 일치 하도록 스트림의 위치 발생할 수 없습니다.</xref:System.IO.StreamReader> </xref:System.IO.BufferedStream> 내부 버퍼를 다시 설정 하려면 호출는 <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName>메서드도 있습니다; 그러나이 인해 성능이 저하 메서드와 반드시 필요한 경우에 호출 해야 합니다.</xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName>       스트림의 길이 초과 하는 위치에 검색을 지원 됩니다."
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "변수에 상대적인 바이트 오프셋 `origin`합니다."
    - id: origin
      type: System.IO.SeekOrigin
      description: "형식의 값 <xref:System.IO.SeekOrigin>를 새 위치로 가져올 참조 지점을 나타내는.</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "현재 버퍼링 된 스트림 내의 새 위치입니다."
  overload: System.IO.BufferedStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "스트림이 열려 있지 않거나은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 찾기를 지원 하지 않습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 닫힌 후에 메서드가 호출 되었습니다."
  platform:
  - net462
- uid: System.IO.BufferedStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: BufferedStream.SetLength(Int64)
  fullName: System.IO.BufferedStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "버퍼링된 된 스트림에의 길이 설정 합니다."
  remarks: "버퍼는 내부 데이터 소스 또는 리포지토리에의 길이 설정 하기 전에 플러시됩니다. 지정된 된 값의 버퍼링된 된 스트림에 현재 길이 보다 작은 경우 버퍼링된 된 스트림에 잘립니다. 지정된 된 값의 버퍼링된 된 스트림에 현재 길이 보다 큰 경우에 버퍼링된 된 스트림에 확장 됩니다. 버퍼링된 된 스트림에 확장 되 면 이전 클라이언트 암호 및 새 길이 간에 버퍼링된 된 스트림에의 내용은 정의 되지 않습니다.       `SetLength`필요한 경우에 버퍼링된 된 쓰기를 플러시합니다.       스트림이 쓰기와 검색을 모두 지원 해야 `SetLength` 에서 실행 되도록 합니다."
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "현재 버퍼링 된 스트림에 바이트에서의 원하는 길이 나타내는 정수입니다."
  overload: System.IO.BufferedStream.SetLength*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>value</code>가 음수입니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "스트림이 열려 있지 않거나은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 쓰기 및 검색을 모두 지원 하지 않습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 닫힌 후에 메서드가 호출 되었습니다."
  platform:
  - net462
- uid: System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "버퍼링 된 스트림에 바이트를 복사 하 고 쓴 바이트 수 만큼 버퍼링 된 스트림에서 현재 위치를 앞으로 이동 합니다."
  remarks: ''
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#6](~/add/codesnippet/csharp/m-system.io.bufferedstre_1_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#6](~/add/codesnippet/cpp/m-system.io.bufferedstre_1_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#6](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_1_1.vb)]"
  syntax:
    content: public override void Write (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "복사할 바이트 배열 `count` 현재 버퍼링 된 스트림에 바이트입니다."
    - id: offset
      type: System.Int32
      description: "현재 버퍼링 된 스트림에 바이트를 복사 하기 시작할 버퍼의 오프셋입니다."
    - id: count
      type: System.Int32
      description: "현재 버퍼링 된 스트림에 쓸 바이트의 수입니다."
  overload: System.IO.BufferedStream.Write*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>또는 <code>count</code> 음수입니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "스트림이 닫혀 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 쓰기를 지원 하지 않습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 닫힌 후에 메서드가 호출 되었습니다."
  platform:
  - net462
- uid: System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "비동기적으로 현재 스트림에 바이트 시퀀스를 쓰고 쓰여진 바이트 수 만큼이 스트림 내의 현재 위치를 이동 하 고 취소 요청을 모니터링 합니다."
  remarks: "인스턴스를 만들어 취소 토큰을 만들 수 있습니다는 <xref:System.Threading.CancellationTokenSource>클래스 및 전달 된 <xref:System.Threading.CancellationTokenSource.Token%2A>속성으로는 `cancellationToken` 매개 변수.</xref:System.Threading.CancellationTokenSource.Token%2A> </xref:System.Threading.CancellationTokenSource>"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "데이터를 쓸 버퍼입니다."
    - id: offset
      type: System.Int32
      description: "0부터 시작 하는 바이트 오프셋 `buffer` 스트림에 바이트 복사를 시작 하는 합니다."
    - id: count
      type: System.Int32
      description: "쓸 바이트의 최대 수입니다."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "취소 요청을 모니터링할 토큰입니다."
    return:
      type: System.Threading.Tasks.Task
      description: "비동기 쓰기 작업을 나타내는 작업입니다."
  overload: System.IO.BufferedStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>또는 <code>count</code> 음수입니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "총 <code> offset </code> 및 <code> count </code> 버퍼 길이 보다 큽니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 쓰기를 지원 하지 않습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 삭제 되었습니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "스트림을 현재 이전 쓰기 작업에서 사용 중입니다."
  platform:
  - net462
- uid: System.IO.BufferedStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: BufferedStream.WriteByte(Byte)
  fullName: System.IO.BufferedStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "버퍼링 된 스트림에서 현재 위치에 바이트를 씁니다."
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "스트림에 쓸 바이트입니다."
  overload: System.IO.BufferedStream.WriteByte*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 쓰기를 지원 하지 않습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>value</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 닫힌 후에 메서드가 호출 되었습니다."
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream(Stream)
  nameWithType: BufferedStream.BufferedStream(Stream)
  fullName: System.IO.BufferedStream.BufferedStream(Stream)
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream(Stream,Int32)
  nameWithType: BufferedStream.BufferedStream(Stream,Int32)
  fullName: System.IO.BufferedStream.BufferedStream(Stream,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.BufferedStream.CanRead
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanRead
  nameWithType: BufferedStream.CanRead
  fullName: System.IO.BufferedStream.CanRead
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.BufferedStream.CanSeek
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
  fullName: System.IO.BufferedStream.CanSeek
- uid: System.IO.BufferedStream.CanWrite
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
  fullName: System.IO.BufferedStream.CanWrite
- uid: System.IO.BufferedStream.Dispose(System.Boolean)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: BufferedStream.Dispose(Boolean)
  fullName: System.IO.BufferedStream.Dispose(Boolean)
- uid: System.IO.BufferedStream.EndRead(System.IAsyncResult)
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: BufferedStream.EndRead(IAsyncResult)
  fullName: System.IO.BufferedStream.EndRead(IAsyncResult)
- uid: System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: BufferedStream.EndWrite(IAsyncResult)
  fullName: System.IO.BufferedStream.EndWrite(IAsyncResult)
- uid: System.IO.BufferedStream.Flush
  parent: System.IO.BufferedStream
  isExternal: false
  name: Flush()
  nameWithType: BufferedStream.Flush()
  fullName: System.IO.BufferedStream.Flush()
- uid: System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: BufferedStream.FlushAsync(CancellationToken)
  fullName: System.IO.BufferedStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.BufferedStream.Length
  parent: System.IO.BufferedStream
  isExternal: false
  name: Length
  nameWithType: BufferedStream.Length
  fullName: System.IO.BufferedStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.BufferedStream.Position
  parent: System.IO.BufferedStream
  isExternal: false
  name: Position
  nameWithType: BufferedStream.Position
  fullName: System.IO.BufferedStream.Position
- uid: System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Read(Byte[],Int32,Int32)
- uid: System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.BufferedStream.ReadByte
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadByte()
  nameWithType: BufferedStream.ReadByte()
  fullName: System.IO.BufferedStream.ReadByte()
- uid: System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: BufferedStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.BufferedStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.BufferedStream.SetLength(System.Int64)
  parent: System.IO.BufferedStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: BufferedStream.SetLength(Int64)
  fullName: System.IO.BufferedStream.SetLength(Int64)
- uid: System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Write(Byte[],Int32,Int32)
- uid: System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.BufferedStream.WriteByte(System.Byte)
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: BufferedStream.WriteByte(Byte)
  fullName: System.IO.BufferedStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.BufferedStream.#ctor*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream
  nameWithType: BufferedStream.BufferedStream
- uid: System.IO.BufferedStream.BeginRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginRead
  nameWithType: BufferedStream.BeginRead
- uid: System.IO.BufferedStream.BeginWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginWrite
  nameWithType: BufferedStream.BeginWrite
- uid: System.IO.BufferedStream.CanRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanRead
  nameWithType: BufferedStream.CanRead
- uid: System.IO.BufferedStream.CanSeek*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
- uid: System.IO.BufferedStream.CanWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
- uid: System.IO.BufferedStream.Dispose*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Dispose
  nameWithType: BufferedStream.Dispose
- uid: System.IO.BufferedStream.EndRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndRead
  nameWithType: BufferedStream.EndRead
- uid: System.IO.BufferedStream.EndWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndWrite
  nameWithType: BufferedStream.EndWrite
- uid: System.IO.BufferedStream.Flush*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Flush
  nameWithType: BufferedStream.Flush
- uid: System.IO.BufferedStream.FlushAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: FlushAsync
  nameWithType: BufferedStream.FlushAsync
- uid: System.IO.BufferedStream.Length*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Length
  nameWithType: BufferedStream.Length
- uid: System.IO.BufferedStream.Position*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Position
  nameWithType: BufferedStream.Position
- uid: System.IO.BufferedStream.Read*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Read
  nameWithType: BufferedStream.Read
- uid: System.IO.BufferedStream.ReadAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadAsync
  nameWithType: BufferedStream.ReadAsync
- uid: System.IO.BufferedStream.ReadByte*
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadByte
  nameWithType: BufferedStream.ReadByte
- uid: System.IO.BufferedStream.Seek*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Seek
  nameWithType: BufferedStream.Seek
- uid: System.IO.BufferedStream.SetLength*
  parent: System.IO.BufferedStream
  isExternal: false
  name: SetLength
  nameWithType: BufferedStream.SetLength
- uid: System.IO.BufferedStream.Write*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Write
  nameWithType: BufferedStream.Write
- uid: System.IO.BufferedStream.WriteAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteAsync
  nameWithType: BufferedStream.WriteAsync
- uid: System.IO.BufferedStream.WriteByte*
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteByte
  nameWithType: BufferedStream.WriteByte
