### YamlMime:ManagedReference
items:
- uid: System.IO.Log.LogStore
  id: LogStore
  children:
  - System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)
  - System.IO.Log.LogStore.Archivable
  - System.IO.Log.LogStore.BaseSequenceNumber
  - System.IO.Log.LogStore.CreateLogArchiveSnapshot
  - System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  - System.IO.Log.LogStore.Delete(System.String)
  - System.IO.Log.LogStore.Dispose
  - System.IO.Log.LogStore.Extents
  - System.IO.Log.LogStore.FreeBytes
  - System.IO.Log.LogStore.Handle
  - System.IO.Log.LogStore.LastSequenceNumber
  - System.IO.Log.LogStore.Length
  - System.IO.Log.LogStore.Policy
  - System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogStore.StreamCount
  langs:
  - csharp
  name: LogStore
  nameWithType: LogStore
  fullName: System.IO.Log.LogStore
  type: Class
  summary: "구조적 로그 저장소를 나타냅니다."
  remarks: "<xref:System.IO.Log.LogRecordSequence>클래스는 공통 로그 CLFS (File System) 로그 위에 레코드 시퀀스 인터페이스의 구현을 제공합니다</xref:System.IO.Log.LogRecordSequence> 직접 조작 하 고 CLFS 로그 파일을 관리 하기 위한 인터페이스를 제공 하는 LogStore 클래스와 함께 작동 합니다. 로그 저장소는 디스크 범위의 조합에 대해 추가 전용 저장소를 제공합니다. LogStore 클래스가이 저장소를 나타내며, 추가 및 컨테이너를 제거, 정책, 설정 및 아카이브 생성을 위한 메서드를 제공 합니다. 읽기 및 쓰기는 저장소;에 대 한 메서드를 제공 하지 않습니다. <xref:System.IO.Log.LogRecordSequence>클래스</xref:System.IO.Log.LogRecordSequence> 에서 이러한 메서드 제공       LogStore 클래스 간의 관계 및 <xref:System.IO.Log.LogRecordSequence>클래스는 디스크 파일 간의 관계와 유사 하며 <xref:System.IO.FileStream>개체.</xref:System.IO.FileStream> </xref:System.IO.Log.LogRecordSequence> 디스크 파일의 실제 저장소를 제공 하 고 길이 및 <xref:System.IO.FileStream>개체에서 읽고 쓰는.를 사용할 수 있는 파일에 대 한 뷰를 제공</xref:System.IO.FileStream> 하는 동안 마지막 액세스 시간과 같은 특성이 있으며 마찬가지로, LogStore 클래스는 정책 및 디스크 범위 컬렉션과 같은 특성 및 <xref:System.IO.Log.LogRecordSequence>클래스 데이터 읽기 및 쓰기 위한 레코드 기반 메커니즘을 제공 합니다.</xref:System.IO.Log.LogRecordSequence>       가 나타내는 파일 레코드 시퀀스와 달리는 <xref:System.IO.Log.FileRecordSequence>클래스 LogStore 인스턴스 데이터를 저장 하 여 나타내는 디스크 범위의 컬렉션에 <xref:System.IO.Log.LogExtent>인스턴스.</xref:System.IO.Log.LogExtent> </xref:System.IO.Log.FileRecordSequence> 지정 된 LogStore 인스턴스에서 익스텐트 사용 약관은 모두 균일 한 크기 및 공간에 추가 되 고 범위가 증가 LogStore 인스턴스에서 제거 합니다. 추가 하 고 로그 범위 제거를 사용 하 여는 <xref:System.IO.Log.LogExtentCollection.Add%2A>및 <xref:System.IO.Log.LogExtentCollection.Remove%2A>의 메서드는 <xref:System.IO.Log.LogExtentCollection>에서 반환할 수 있는 개체는 <xref:System.IO.Log.LogStore.Extents%2A>속성.</xref:System.IO.Log.LogStore.Extents%2A> </xref:System.IO.Log.LogExtentCollection> </xref:System.IO.Log.LogExtentCollection.Remove%2A> </xref:System.IO.Log.LogExtentCollection.Add%2A>       LogStore 인스턴스 정책이 연결 되어 있을 수 있습니다. 이러한 나타내는 <xref:System.IO.Log.LogPolicy>에서 반환 될 수 있는 인스턴스는 <xref:System.IO.Log.LogStore.Policy%2A>속성.</xref:System.IO.Log.LogStore.Policy%2A> </xref:System.IO.Log.LogPolicy> 정책에 따르면 로그는 같이 익스텐트와 최소 크기 지침의 최대 수를 늘리거나 줄이는 특정 조건에서 LogStore 하려고 시도 하는 규칙입니다. 또한 LogStore 인스턴스를 보관할 수 있는지 여부를 지정할 수 있습니다. 정책 로그 별로 설정 및 로그에 대 한 각 핸들이 닫히면 정책이 더 이상 존재 하는지 즉, 일시적입니다."
  example:
  - "The following example shows how to archive a LogStore to an XML document.  \n  \n [!code-vb[logarchievesnapshot#0](~/add/codesnippet/visualbasic/t-system.io.log.logstore_1.vb)]\n [!code-cs[logarchievesnapshot#0](~/add/codesnippet/csharp/t-system.io.log.logstore_1.cs)]"
  syntax:
    content: 'public sealed class LogStore : IDisposable'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(SafeFileHandle)
  nameWithType: LogStore.LogStore(SafeFileHandle)
  fullName: System.IO.Log.LogStore.LogStore(SafeFileHandle)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> 지정된 된 핸들에 대 한 클래스입니다."
  syntax:
    content: public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "로그에 대 한 파일 핸들 파일을 현재 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> 개체를 캡슐화 합니다."
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>handle</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "로그 핸들을 스레드 풀에 바인딩할 수 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 저장소에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode)
  nameWithType: LogStore.LogStore(String,FileMode)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> 클래스 지정 된 경로 및 모드를 사용 합니다."
  remarks: "된 지정 된 경로 모드로 로그 저장소를이 생성자를 사용 합니다. 저장소 읽기/쓰기 권한으로 열리고 읽기 권한을 공유 합니다.       `path` 매개 변수는 다음 구문을 사용 해야: `log:<physical log name>[::<log client name>]` 여기서 `<physical log name>` 로그 파일에는 올바른 경로가 및 `<log client name>` 고유한 클라이언트 식별자입니다. 로그 저장소는 실제 로그 저장소 또는 가상 로그 저장소 중 하나만 있어야 합니다. 로그 저장소를 만든 후에 물리적으로 구성 되었든, 남아 있으므로 한 수명 있습니다. 실제 로그 저장소는 실제 로그 이름만 지정 하 여 생성 됩니다. 가상 로그 저장소는 실제 로그 이름과 로그 클라이언트 이름을 모두 지정 하 여 생성 됩니다.       동일한 실제 로그 이름을 공유 하는 클라이언트는 동일한 범위 컬렉션과 정책을 공유 합니다."
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "열려는 로그 저장소의 기본 파일에 대 한 상대 또는 절대 경로입니다."
    - id: mode
      type: System.IO.FileMode
      description: "중 하나는 <xref href=&quot;System.IO.FileMode&quot;> </xref> 열거나 저장소를 만들 방법을 결정 하는 값입니다."
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>빈 문자열 (&quot;&quot;).       -또는- <code>path</code> 공백만 포함 합니다.       -또는- <code>path</code> 하나 이상의 잘못 된 문자가 포함 되어 있습니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>잘못 된 값을 포함합니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "파일을 찾을 수 없습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "로그 저장소를 열 때 I/O 오류가 발생 합니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 저장소에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>필요한 공통 로그 파일 시스템 (CLFS) 구성 요소가 설치 되어 있지 않으므로 사용할 수 없습니다. 플랫폼 또는 사용 하 여 사용할 수 있으면 CLFS 구성 요소를 설치는 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> 클래스를 대신 합니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode,FileAccess)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> 지정 된 경로, 모드 및 액세스를 사용 하 여 클래스입니다."
  remarks: "이 생성자를 사용 하 여 지정 된 경로, 모드 및 액세스 된 새 로그 저장소를 열려고 합니다. 저장소는 읽기 권한을 공유 열립니다.       `path` 매개 변수는 다음 구문을 사용 해야: `log:<physical log name>[::<log client name>]` 여기서 `<physical log name>` 로그 파일에는 올바른 경로가 및 `<log client name>` 고유한 클라이언트 식별자입니다. 로그 저장소는 실제 로그 저장소 또는 가상 로그 저장소 중 하나만 있어야 합니다. 로그 저장소를 만든 후에 물리적으로 구성 되었든, 남아 있으므로 한 수명 있습니다. 실제 로그 저장소는 실제 로그 이름만 지정 하 여 생성 됩니다. 가상 로그 저장소는 실제 로그 이름과 로그 클라이언트 이름을 모두 지정 하 여 생성 됩니다.       동일한 실제 로그 이름을 공유 하는 클라이언트는 동일한 범위 컬렉션과 정책을 공유 합니다."
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "열려는 로그 저장소의 기본 파일에 대 한 상대 또는 절대 경로입니다."
    - id: mode
      type: System.IO.FileMode
      description: "중 하나는 <xref href=&quot;System.IO.FileMode&quot;> </xref> 열거나 저장소를 만들 방법을 결정 하는 값입니다."
    - id: access
      type: System.IO.FileAccess
      description: "중 하나는 <xref href=&quot;System.IO.FileAccess&quot;> </xref> 하 여 파일에 액세스할 수 있는 방법을 결정 하는 값은 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>합니다."
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>빈 문자열 (&quot;&quot;).       -또는- <code>path</code> 공백만 포함 합니다.       -또는- <code>path</code> 하나 이상의 잘못 된 문자가 포함 되어 있습니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>잘못 된 값을 포함합니다.       -또는 <code>access</code> 값이 잘못 되었습니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "파일을 찾을 수 없습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "로그 저장소를 열 때 I/O 오류가 발생 합니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 저장소에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>필요한 공통 로그 파일 시스템 (CLFS) 구성 요소가 설치 되어 있지 않으므로 사용할 수 없습니다. 플랫폼 또는 사용 하 여 사용할 수 있으면 CLFS 구성 요소를 설치는 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> 클래스를 대신 합니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode,FileAccess,FileShare)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> 클래스입니다."
  remarks: "이 생성자는 새 <xref:System.IO.Log.LogStore>지정 된 경로, 모드 및 액세스를 사용 하 여 개체.</xref:System.IO.Log.LogStore> 지정 된 액세스 권한을 공유 저장소는 열립니다.       `path` 매개 변수는 다음 구문을 사용 해야: `log:<physical log name>[::<log client name>]` 여기서 `<physical log name>` 로그 파일에는 올바른 경로가 및 `<log client name>` 고유한 클라이언트 식별자입니다. 로그 저장소는 실제 로그 저장소 또는 가상 로그 저장소 중 하나만 있어야 합니다. 로그 저장소를 만든 후에 물리적으로 구성 되었든, 남아 있으므로 한 수명 있습니다. 실제 로그 저장소는 실제 로그 이름만 지정 하 여 생성 됩니다. 가상 로그 저장소는 실제 로그 이름과 로그 클라이언트 이름을 모두 지정 하 여 생성 됩니다.       동일한 실제 로그 이름을 공유 하는 클라이언트는 동일한 범위 컬렉션과 정책을 공유 합니다."
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "열려는 로그 저장소의 기본 파일에 대 한 상대 또는 절대 경로입니다."
    - id: mode
      type: System.IO.FileMode
      description: "중 하나는 <xref href=&quot;System.IO.FileMode&quot;> </xref> 열거나 저장소를 만들 방법을 결정 하는 값입니다."
    - id: access
      type: System.IO.FileAccess
      description: "중 하나는 <xref href=&quot;System.IO.FileAccess&quot;> </xref> 하 여 파일에 액세스할 수 있는 방법을 결정 하는 값은 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>합니다."
    - id: share
      type: System.IO.FileShare
      description: "중 하나는 <xref href=&quot;System.IO.FileShare&quot;> </xref> 로그 저장소가 프로세스 간에 공유 될 방법을 결정 하는 값입니다."
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>빈 문자열 (&quot;&quot;).       -또는- <code>path</code> 공백만 포함 합니다.       -또는- <code>path</code> 하나 이상의 잘못 된 문자가 포함 되어 있습니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>잘못 된 값을 포함합니다.       -또는 <code>access</code> 값이 잘못 되었습니다.       -또는- <code>share</code> 값이 잘못 되었습니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "파일을 찾을 수 없습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "로그 저장소를 열 때 I/O 오류가 발생 합니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 저장소에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>필요한 공통 로그 파일 시스템 (CLFS) 구성 요소가 설치 되어 있지 않으므로 사용할 수 없습니다. 플랫폼 또는 사용 하 여 사용할 수 있으면 CLFS 구성 요소를 설치는 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> 클래스를 대신 합니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> 클래스입니다."
  remarks: "이 생성자는 새 <xref:System.IO.Log.LogStore>지정 된 경로, 모드 및 액세스를 사용 하 여 개체.</xref:System.IO.Log.LogStore> 지정 된 액세스 권한을 공유 저장소는 열립니다. `path` 매개 변수는 다음 구문을 따라야: `log:<physical log name>[::<log client name>]` 여기서 `<physical log name>` 로그 파일에는 올바른 경로가 및 `<log client name>` 고유한 클라이언트 식별자입니다. 로그 저장소는 실제 로그 저장소 또는 가상 로그 저장소 중 하나만 있어야 합니다. 로그 저장소를 만든 후에 물리적으로 구성 되었든, 남아 있으므로 한 수명 있습니다. 실제 로그 저장소는 실제 로그 이름만 지정 하 여 생성 됩니다. 가상 로그 저장소는 실제 로그 이름과 로그 클라이언트 이름을 모두 지정 하 여 생성 됩니다.       동일한 실제 로그 이름을 공유 하는 클라이언트는 동일한 범위 컬렉션과 정책을 공유 합니다."
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "열려는 로그 저장소의 기본 파일에 대 한 상대 또는 절대 경로입니다."
    - id: mode
      type: System.IO.FileMode
      description: "중 하나는 <xref href=&quot;System.IO.FileMode&quot;> </xref> 열거나 저장소를 만들 방법을 결정 하는 값입니다."
    - id: access
      type: System.IO.FileAccess
      description: "중 하나는 <xref href=&quot;System.IO.FileAccess&quot;> </xref> 하 여 파일에 액세스할 수 있는 방법을 결정 하는 값은 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>합니다."
    - id: share
      type: System.IO.FileShare
      description: "중 하나는 <xref href=&quot;System.IO.FileShare&quot;> </xref> 로그 저장소가 프로세스 간에 공유 될 방법을 결정 하는 값입니다."
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "중 하나는 <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> 저장소를 만들어야 하는 경우 새로 만든된 저장소에 설정할 보안을 지정 하는 값입니다."
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "로 지정 된 로그 저장소 파일 이름이 <code> path </code> 올바르지 않습니다.       -또는- <code> Mode </code> 은 <xref uid=&quot;langword_csharp_CreateNew&quot; name=&quot;CreateNew&quot; href=&quot;&quot;> </xref>, 쓰기 권한 없이 사용할 수 없습니다.       -또는- <code> Mode </code> 은 <xref uid=&quot;langword_csharp_OpenOrCreate&quot; name=&quot;OpenOrCreate&quot; href=&quot;&quot;> </xref>, 쓰기 권한 없이 사용할 수 없습니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>잘못 된 값을 포함합니다.       -또는 <code>access</code> 값이 잘못 되었습니다.       -또는- <code>share</code> 값이 잘못 되었습니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "파일을 찾을 수 없습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "로그 저장소를 열 때 I/O 오류가 발생 합니다.       지정한 파일 <code> path </code> 액세스할 수 없습니다 사용 중이기 때문에 다른 프로세스에서 합니다.       -또는-지정 된 파일이 <code> path </code> 파일 또는 디렉터리가 이미 있기 때문에 만들 수 없습니다.       -또는-로그 핸들을 스레드 풀에 바인딩할 수 없습니다.       -또는-지정 된 로그 파일 형식이 나 버전이 잘못 되었습니다."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>필요한 공통 로그 파일 시스템 (CLFS) 구성 요소가 설치 되어 있지 않으므로 사용할 수 없습니다. 플랫폼 또는 사용 하 여 사용할 수 있으면 CLFS 구성 요소를 설치는 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> 클래스를 대신 합니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 저장소에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Archivable
  id: Archivable
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Archivable
  nameWithType: LogStore.Archivable
  fullName: System.IO.Log.LogStore.Archivable
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "나타내는 값을 가져옵니다 여부이 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> 인스턴스를 보관할 수 있습니다."
  remarks: "경우는 <xref:System.IO.Log.LogStore>를 보관할 수 없는,에 대 한 호출이 <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A>및 <xref:System.IO.Log.LogStore.SetArchiveTail%2A>메서드는 <xref:System.NotSupportedException>throw 됩니다.</xref:System.NotSupportedException> </xref:System.IO.Log.LogStore.SetArchiveTail%2A> </xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> </xref:System.IO.Log.LogStore>"
  syntax:
    content: public bool Archivable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>이 경우 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> 인스턴스 수 보관 된 없으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.IO.Log.LogStore.Archivable*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 속성에 액세스 합니다."
  platform:
  - net462
- uid: System.IO.Log.LogStore.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: LogStore.BaseSequenceNumber
  fullName: System.IO.Log.LogStore.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "이 유효한 레코드에 해당 하는 가장 낮은 시퀀스 번호를 가져옵니다 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> 인스턴스."
  remarks: "유효한 시퀀스 번호는 보다 큰가 BaseSequenceNumber 같고 <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.</xref:System.IO.Log.LogStore.LastSequenceNumber%2A> 보다 작음"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "이 유효한 레코드에 해당 하는 가장 낮은 시퀀스 번호 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> 인스턴스."
  overload: System.IO.Log.LogStore.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 속성에 액세스 합니다."
  platform:
  - net462
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot
  id: CreateLogArchiveSnapshot
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: CreateLogArchiveSnapshot()
  nameWithType: LogStore.CreateLogArchiveSnapshot()
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "백업을 만들기 위한 로그 저장소 상태의 스냅숏을 만듭니다."
  remarks: ''
  example:
  - "The following example shows how to archive a <xref:System.IO.Log.LogStore> to an XML document.  \n  \n [!code-vb[logarchievesnapshot#0](~/add/codesnippet/visualbasic/m-system.io.log.logstore_1_1.vb)]\n [!code-cs[logarchievesnapshot#0](~/add/codesnippet/csharp/m-system.io.log.logstore_1_1.cs)]"
  syntax:
    content: public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();
    parameters: []
    return:
      type: System.IO.Log.LogArchiveSnapshot
      description: "A <xref href=&quot;System.IO.Log.LogArchiveSnapshot&quot;> </xref> 아카이브를 만드는 데 필요한 상태를 포함 하는 개체입니다."
  overload: System.IO.Log.LogStore.CreateLogArchiveSnapshot*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "로그 저장소를 보관할 수 있습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "아카이브 스냅숏을 만들 때 I/O 오류가 발생 합니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "인수가 올바르지 않습니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "잘못 된 작업을 실행 합니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 저장소에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  id: CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  nameWithType: LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "백업을 만들기 위한 지정 된 시퀀스 번호 간의 로그 저장소 상태의 스냅숏을 만듭니다."
  remarks: "이 메서드에서 반환 된 아카이브 스냅숏은 기준 시퀀스 번호나 아카이브 시퀀스 번호 중 하나에서 정보를 포함에서 더 낮은, 마지막 시퀀스 번호입니다. 보관 파일에만 마지막 점을 포함 하지 않고 최대 레코드에 의미 있는 마지막 시퀀스 번호 포함 되지 않습니다. 또한이 메서드를 사용 하면 시작 SequenceNumber가 BaseSequenceNumber 일관 되도록 보관 하려면에서 같음 이어야 합니다."
  syntax:
    content: public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);
    parameters:
    - id: first
      type: System.IO.Log.SequenceNumber
      description: "시작 시퀀스 번호 범위에 보관 합니다."
    - id: last
      type: System.IO.Log.SequenceNumber
      description: "끝 시퀀스 번호 범위에 보관 합니다."
    return:
      type: System.IO.Log.LogArchiveSnapshot
      description: "A <xref href=&quot;System.IO.Log.LogArchiveSnapshot&quot;> </xref> 아카이브를 만드는 데 필요한 상태를 포함 하는 개체입니다."
  overload: System.IO.Log.LogStore.CreateLogArchiveSnapshot*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>first</code>또는 <code>last</code> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>first</code>보다 큰 <code>last</code>합니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "잘못 된 작업을 실행 합니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "아카이브 스냅숏을 만들 때 I/O 오류가 발생 합니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "로그 저장소를 보관할 수 있습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 저장소에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Delete(System.String)
  id: Delete(System.String)
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Delete(String)
  nameWithType: LogStore.Delete(String)
  fullName: System.IO.Log.LogStore.Delete(String)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "로그 저장소를 제거합니다."
  syntax:
    content: public static void Delete (string path);
    parameters:
    - id: path
      type: System.String
      description: "제거할 로그 저장소의 기본 파일에 대 한 상대 또는 절대 경로입니다."
  overload: System.IO.Log.LogStore.Delete*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>빈 문자열 (&quot;&quot;).       -또는- <code>path</code> 공백만 포함 합니다.       -또는- <code>path</code> 하나 이상의 잘못 된 문자가 포함 되어 있습니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "파일을 찾을 수 없습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "로그 저장소를 열 때 I/O 오류가 발생 합니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 저장소에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Dispose
  id: Dispose
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Dispose()
  nameWithType: LogStore.Dispose()
  fullName: System.IO.Log.LogStore.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "사용 하는 모든 리소스를 해제는 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>합니다."
  remarks: "<xref:System.IO.Log.LogStore>.</xref:System.IO.Log.LogStore> 를 사용 하 여 완료 되 면 Dispose를 호출 합니다. Dispose 메서드는 <xref:System.IO.Log.LogStore>불안정 한 상태가.</xref:System.IO.Log.LogStore> Dispose를 호출한 후에 대 한 모든 참조를 해제 해야는 <xref:System.IO.Log.LogStore>가비지 수집기는 메모리를 회수할 수 있도록 하는 <xref:System.IO.Log.LogStore>차지한.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogStore>      > [!NOTE] > <xref:System.IO.Log.LogStore>.</xref:System.IO.Log.LogStore> 에 대 한 마지막 참조를 해제 하기 전에 항상 호출 삭제 사용 중인 리소스가 가비지 수집기 호출할 때까지 해제 되지 것입니다 그렇지 않은 경우는 <xref:System.IO.Log.LogStore>개체의 `Finalize` 메서드.</xref:System.IO.Log.LogStore>"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.LogStore.Dispose*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Extents
  id: Extents
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Extents
  nameWithType: LogStore.Extents
  fullName: System.IO.Log.LogStore.Extents
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "이 로그 저장소에 대 한 데이터를 포함 하는 로그 범위의 컬렉션을 가져옵니다."
  remarks: "A <xref:System.IO.Log.LogStore>인스턴스가 나타내는 디스크 범위의 컬렉션에 데이터를 저장 <xref:System.IO.Log.LogExtent>인스턴스.</xref:System.IO.Log.LogExtent> </xref:System.IO.Log.LogStore> 에 있는 범위는 주어진 <xref:System.IO.Log.LogStore>인스턴스 사용 약관은 모두 균일 한 크기 및 공간에 추가 되 고에서 제거는 <xref:System.IO.Log.LogStore>범위가 증가 인스턴스.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogStore> 추가 하 고 로그 범위 제거를 사용 하 여는 <xref:System.IO.Log.LogExtentCollection.Add%2A>및<xref:System.IO.Log.LogExtentCollection.Remove%2A> 의 메서드는 <xref:System.IO.Log.LogExtentCollection>이 속성에서 반환 되는 개체입니다.</xref:System.IO.Log.LogExtentCollection> </xref:System.IO.Log.LogExtentCollection.Remove%2A> </xref:System.IO.Log.LogExtentCollection.Add%2A>"
  syntax:
    content: public System.IO.Log.LogExtentCollection Extents { get; }
    return:
      type: System.IO.Log.LogExtentCollection
      description: "A <xref href=&quot;System.IO.Log.LogExtentCollection&quot;> </xref> 이 로그 저장소에 대 한 데이터를 캡슐화 하는 로그 범위의 컬렉션을 포함 하는 인스턴스."
  overload: System.IO.Log.LogStore.Extents*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.FreeBytes
  id: FreeBytes
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: FreeBytes
  nameWithType: LogStore.FreeBytes
  fullName: System.IO.Log.LogStore.FreeBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "로그 저장소의 사용 가능한 바이트의 수를 가져옵니다."
  syntax:
    content: public long FreeBytes { get; }
    return:
      type: System.Int64
      description: "로그 저장소의 사용 가능한 바이트의 수입니다."
  overload: System.IO.Log.LogStore.FreeBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 속성에 액세스 합니다."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Handle
  id: Handle
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Handle
  nameWithType: LogStore.Handle
  fullName: System.IO.Log.LogStore.Handle
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "하는 로그 파일에 대 한 운영 체제 파일 핸들을 가져옵니다. 현재 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> 인스턴스 캡슐화 합니다."
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "운영 체제 파일 핸들에 대 한 로그 파일을 현재 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> 인스턴스 캡슐화 합니다."
  overload: System.IO.Log.LogStore.Handle*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: LogStore.LastSequenceNumber
  fullName: System.IO.Log.LogStore.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "파생된 클래스에서 재정의 되 면 로그 저장소에 추가할 다음 레코드의 시퀀스 번호를 가져옵니다."
  remarks: "유효한 시퀀스 번호 보다 크거나 같은 경우는 <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>같고 LastSequenceNumber 보다.</xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "로그 저장소에 추가할 다음 레코드의 시퀀스 번호입니다."
  overload: System.IO.Log.LogStore.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 속성에 액세스 합니다."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Length
  id: Length
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Length
  nameWithType: LogStore.Length
  fullName: System.IO.Log.LogStore.Length
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "바이트 단위로 로그 저장소의 크기를 가져옵니다."
  remarks: "로그 저장소의 크기는 로그 범위의 크기의 합입니다."
  syntax:
    content: public long Length { get; }
    return:
      type: System.Int64
      description: "바이트 단위로 로그 저장소의 크기입니다."
  overload: System.IO.Log.LogStore.Length*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 속성에 액세스 합니다."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Policy
  id: Policy
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Policy
  nameWithType: LogStore.Policy
  fullName: System.IO.Log.LogStore.Policy
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "이 로그 저장소와 연결 된 정책을 가져옵니다."
  remarks: "<xref:System.IO.Log.LogPolicy>이 <xref:System.IO.Log.LogStore>.</xref:System.IO.Log.LogStore> 와 관련 된 검사 하 고 로그 정책 조작이 속성에서 반환 된 인스턴스</xref:System.IO.Log.LogPolicy> 를 사용할 수 있습니다."
  syntax:
    content: public System.IO.Log.LogPolicy Policy { get; }
    return:
      type: System.IO.Log.LogPolicy
      description: "A <xref href=&quot;System.IO.Log.LogPolicy&quot;> </xref> 인스턴스는이 로그 저장소와 연결 된 정책을 나타냅니다."
  overload: System.IO.Log.LogStore.Policy*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)
  id: SetArchiveTail(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: SetArchiveTail(SequenceNumber)
  nameWithType: LogStore.SetArchiveTail(SequenceNumber)
  fullName: System.IO.Log.LogStore.SetArchiveTail(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "아카이브 테일의 시퀀스 번호를 설정합니다."
  remarks: "기준 시퀀스 번호와 아카이브 테일 중 더 작은 숫자는 비상 로그를 결정합니다."
  example:
  - "The following example shows how to archive a <xref:System.IO.Log.LogStore> to an XML document.  \n  \n [!code-vb[logarchievesnapshot#0](~/add/codesnippet/visualbasic/m-system.io.log.logstore_0_1.vb)]\n [!code-cs[logarchievesnapshot#0](~/add/codesnippet/csharp/m-system.io.log.logstore_0_1.cs)]"
  syntax:
    content: public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);
    parameters:
    - id: archiveTail
      type: System.IO.Log.SequenceNumber
      description: "아카이브 테일의 시퀀스 번호입니다."
  overload: System.IO.Log.LogStore.SetArchiveTail*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>archiveTail</code>이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이의 않습니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>archiveTail</code>이 시퀀스에 대해 올바르지 않습니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "잘못 된 작업을 실행 합니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "아카이브 스냅숏을 만들 때 I/O 오류가 발생 합니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "로그 저장소를 보관할 수 있습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 저장소에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogStore.StreamCount
  id: StreamCount
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: StreamCount
  nameWithType: LogStore.StreamCount
  fullName: System.IO.Log.LogStore.StreamCount
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "이 로그 저장소의 로그 스트림 수를 가져옵니다."
  syntax:
    content: public int StreamCount { get; }
    return:
      type: System.Int32
      description: "이 로그 저장소의 로그 스트림 수입니다."
  overload: System.IO.Log.LogStore.StreamCount*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(SafeFileHandle)
  nameWithType: LogStore.LogStore(SafeFileHandle)
  fullName: System.IO.Log.LogStore.LogStore(SafeFileHandle)
- uid: Microsoft.Win32.SafeHandles.SafeFileHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeFileHandle
  nameWithType: SafeFileHandle
  fullName: Microsoft.Win32.SafeHandles.SafeFileHandle
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode)
  nameWithType: LogStore.LogStore(String,FileMode)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode,FileAccess)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode,FileAccess,FileShare)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.Log.LogStore.Archivable
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Archivable
  nameWithType: LogStore.Archivable
  fullName: System.IO.Log.LogStore.Archivable
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.LogStore.BaseSequenceNumber
  parent: System.IO.Log.LogStore
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogStore.BaseSequenceNumber
  fullName: System.IO.Log.LogStore.BaseSequenceNumber
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot
  parent: System.IO.Log.LogStore
  isExternal: false
  name: CreateLogArchiveSnapshot()
  nameWithType: LogStore.CreateLogArchiveSnapshot()
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot()
- uid: System.IO.Log.LogArchiveSnapshot
  parent: System.IO.Log
  isExternal: false
  name: LogArchiveSnapshot
  nameWithType: LogArchiveSnapshot
  fullName: System.IO.Log.LogArchiveSnapshot
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  nameWithType: LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
- uid: System.IO.Log.LogStore.Delete(System.String)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Delete(String)
  nameWithType: LogStore.Delete(String)
  fullName: System.IO.Log.LogStore.Delete(String)
- uid: System.IO.Log.LogStore.Dispose
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Dispose()
  nameWithType: LogStore.Dispose()
  fullName: System.IO.Log.LogStore.Dispose()
- uid: System.IO.Log.LogStore.Extents
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Extents
  nameWithType: LogStore.Extents
  fullName: System.IO.Log.LogStore.Extents
- uid: System.IO.Log.LogExtentCollection
  parent: System.IO.Log
  isExternal: false
  name: LogExtentCollection
  nameWithType: LogExtentCollection
  fullName: System.IO.Log.LogExtentCollection
- uid: System.IO.Log.LogStore.FreeBytes
  parent: System.IO.Log.LogStore
  isExternal: false
  name: FreeBytes
  nameWithType: LogStore.FreeBytes
  fullName: System.IO.Log.LogStore.FreeBytes
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.LogStore.Handle
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Handle
  nameWithType: LogStore.Handle
  fullName: System.IO.Log.LogStore.Handle
- uid: System.IO.Log.LogStore.LastSequenceNumber
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogStore.LastSequenceNumber
  fullName: System.IO.Log.LogStore.LastSequenceNumber
- uid: System.IO.Log.LogStore.Length
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Length
  nameWithType: LogStore.Length
  fullName: System.IO.Log.LogStore.Length
- uid: System.IO.Log.LogStore.Policy
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Policy
  nameWithType: LogStore.Policy
  fullName: System.IO.Log.LogStore.Policy
- uid: System.IO.Log.LogPolicy
  parent: System.IO.Log
  isExternal: false
  name: LogPolicy
  nameWithType: LogPolicy
  fullName: System.IO.Log.LogPolicy
- uid: System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: SetArchiveTail(SequenceNumber)
  nameWithType: LogStore.SetArchiveTail(SequenceNumber)
  fullName: System.IO.Log.LogStore.SetArchiveTail(SequenceNumber)
- uid: System.IO.Log.LogStore.StreamCount
  parent: System.IO.Log.LogStore
  isExternal: false
  name: StreamCount
  nameWithType: LogStore.StreamCount
  fullName: System.IO.Log.LogStore.StreamCount
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.LogStore.#ctor*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore
  nameWithType: LogStore.LogStore
- uid: System.IO.Log.LogStore.Archivable*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Archivable
  nameWithType: LogStore.Archivable
- uid: System.IO.Log.LogStore.BaseSequenceNumber*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogStore.BaseSequenceNumber
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: CreateLogArchiveSnapshot
  nameWithType: LogStore.CreateLogArchiveSnapshot
- uid: System.IO.Log.LogStore.Delete*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Delete
  nameWithType: LogStore.Delete
- uid: System.IO.Log.LogStore.Dispose*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Dispose
  nameWithType: LogStore.Dispose
- uid: System.IO.Log.LogStore.Extents*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Extents
  nameWithType: LogStore.Extents
- uid: System.IO.Log.LogStore.FreeBytes*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: FreeBytes
  nameWithType: LogStore.FreeBytes
- uid: System.IO.Log.LogStore.Handle*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Handle
  nameWithType: LogStore.Handle
- uid: System.IO.Log.LogStore.LastSequenceNumber*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogStore.LastSequenceNumber
- uid: System.IO.Log.LogStore.Length*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Length
  nameWithType: LogStore.Length
- uid: System.IO.Log.LogStore.Policy*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Policy
  nameWithType: LogStore.Policy
- uid: System.IO.Log.LogStore.SetArchiveTail*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: SetArchiveTail
  nameWithType: LogStore.SetArchiveTail
- uid: System.IO.Log.LogStore.StreamCount*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: StreamCount
  nameWithType: LogStore.StreamCount
