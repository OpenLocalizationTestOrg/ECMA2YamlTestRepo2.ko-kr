### YamlMime:ManagedReference
items:
- uid: System.Windows.RoutedEventArgs
  id: RoutedEventArgs
  children:
  - System.Windows.RoutedEventArgs.#ctor
  - System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)
  - System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)
  - System.Windows.RoutedEventArgs.Handled
  - System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)
  - System.Windows.RoutedEventArgs.OnSetSource(System.Object)
  - System.Windows.RoutedEventArgs.OriginalSource
  - System.Windows.RoutedEventArgs.RoutedEvent
  - System.Windows.RoutedEventArgs.Source
  langs:
  - csharp
  name: RoutedEventArgs
  nameWithType: RoutedEventArgs
  fullName: System.Windows.RoutedEventArgs
  type: Class
  summary: "라우트된 이벤트와 연결 된 상태 정보 및 이벤트 데이터를 포함 합니다."
  remarks: "다른 RoutedEventArgs 단일 <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>.</xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> 함께 사용할 수 있습니다. 이 클래스에 대 한 이벤트 데이터를 패키지 하는 한 <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, 추가 이벤트 상태 정보를 제공 하 고 이벤트 시스템에 의해 라우트된 이벤트와 연결 된 처리기를 호출 하는 데 사용 됩니다.</xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>"
  syntax:
    content: 'public class RoutedEventArgs : EventArgs'
  inheritance:
  - System.EventArgs
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.RoutedEventArgs.#ctor
  id: '#ctor'
  parent: System.Windows.RoutedEventArgs
  langs:
  - csharp
  name: RoutedEventArgs()
  nameWithType: RoutedEventArgs.RoutedEventArgs()
  fullName: System.Windows.RoutedEventArgs.RoutedEventArgs()
  type: Constructor
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref> 클래스입니다."
  remarks: "이 매개 변수가 없는 생성자, 새 모든 공용 속성을 사용 하는 경우 <xref:System.Windows.RoutedEventArgs>인스턴스는 다음과 같은 기본값 가정:- <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>기본값으로 `null`.</xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> </xref:System.Windows.RoutedEventArgs>      - <xref:System.Windows.RoutedEventArgs.Handled%2A>기본값으로 `false` - <xref:System.Windows.RoutedEventArgs.Source%2A>기본값으로 `null`.</xref:System.Windows.RoutedEventArgs.Source%2A> </xref:System.Windows.RoutedEventArgs.Handled%2A>      - <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>기본값으로 `null`.</xref:System.Windows.RoutedEventArgs.OriginalSource%2A>       값이 null <xref:System.Windows.RoutedEventArgs.Source%2A>및 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>만 된다는 의미는 <xref:System.Windows.RoutedEventArgs>데이터에서는 소스를 지정 하지 않습니다.</xref:System.Windows.RoutedEventArgs> </xref:System.Windows.RoutedEventArgs.OriginalSource%2A> </xref:System.Windows.RoutedEventArgs.Source%2A> 에 대 한 호출에서이 인스턴스를 사용 하는 경우 <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A>및 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>하 이벤트를 발생 하 고 라우팅을 통해 수신기로 전달 되는 요소에 따라 값은 채워집니다.</xref:System.Windows.RoutedEventArgs.OriginalSource%2A> </xref:System.Windows.RoutedEventArgs.Source%2A> </xref:System.Windows.UIElement.RaiseEvent%2A>"
  syntax:
    content: public RoutedEventArgs ();
    parameters: []
  overload: System.Windows.RoutedEventArgs.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)
  id: '#ctor(System.Windows.RoutedEvent)'
  parent: System.Windows.RoutedEventArgs
  langs:
  - csharp
  name: RoutedEventArgs(RoutedEvent)
  nameWithType: RoutedEventArgs.RoutedEventArgs(RoutedEvent)
  fullName: System.Windows.RoutedEventArgs.RoutedEventArgs(RoutedEvent)
  type: Constructor
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref> 클래스, 제공 된 라우트된 이벤트 식별자를 사용 합니다."
  remarks: "이 오버 로드 된 생성자를 사용할 때는 새 속성을 지정 하지 않으면 <xref:System.Windows.RoutedEventArgs>인스턴스는 다음과 같은 기본값 가정:- <xref:System.Windows.RoutedEventArgs.Handled%2A>기본값으로 `false` - <xref:System.Windows.RoutedEventArgs.Source%2A>기본값으로 `null`.</xref:System.Windows.RoutedEventArgs.Source%2A> </xref:System.Windows.RoutedEventArgs.Handled%2A> </xref:System.Windows.RoutedEventArgs>      - <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>기본값으로 `null`.</xref:System.Windows.RoutedEventArgs.OriginalSource%2A>       값이 null <xref:System.Windows.RoutedEventArgs.Source%2A>및 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>만이 구성이 <xref:System.Windows.RoutedEventArgs>원본을 지정 하려고 하지 않으므로.</xref:System.Windows.RoutedEventArgs> </xref:System.Windows.RoutedEventArgs.OriginalSource%2A> </xref:System.Windows.RoutedEventArgs.Source%2A> 에 대 한 호출에서이 인스턴스를 사용 하는 경우 <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A>및 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>하 이벤트를 발생 하 고 라우팅을 통해 수신기로 전달 되는 요소에 따라 값은 채워집니다.</xref:System.Windows.RoutedEventArgs.OriginalSource%2A> </xref:System.Windows.RoutedEventArgs.Source%2A> </xref:System.Windows.UIElement.RaiseEvent%2A>"
  example:
  - "The following example constructs a new <xref:System.Windows.RoutedEventArgs> for use in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>.  \n  \n [!code-cs[RoutedEventCustom#RaiseEvent](~/add/codesnippet/csharp/RoutedEventCustom/SDKSampleLibrary/class1.cs#raiseevent)]\n [!code-vb[RoutedEventCustom#RaiseEvent](~/add/codesnippet/visualbasic/SDKSampleLibrary/Class1.vb#raiseevent)]"
  syntax:
    content: public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);
    parameters:
    - id: routedEvent
      type: System.Windows.RoutedEvent
      description: "이 인스턴스에 대 한 라우트된 이벤트 식별자는 <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref> 클래스입니다."
  overload: System.Windows.RoutedEventArgs.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)
  id: '#ctor(System.Windows.RoutedEvent,System.Object)'
  parent: System.Windows.RoutedEventArgs
  langs:
  - csharp
  name: RoutedEventArgs(RoutedEvent,Object)
  nameWithType: RoutedEventArgs.RoutedEventArgs(RoutedEvent,Object)
  fullName: System.Windows.RoutedEventArgs.RoutedEventArgs(RoutedEvent,Object)
  type: Constructor
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref> 클래스를 제공 된 라우트된 이벤트 식별자를 사용 하는 이벤트에 대 한 다른 소스를 선언할 수 있는 기회를 제공 합니다."
  remarks: "이 오버 로드 된 생성자를 사용할 때는 새 속성을 지정 하지 않으면 <xref:System.Windows.RoutedEventArgs>인스턴스는 다음과 같은 기본값 가정:- <xref:System.Windows.RoutedEventArgs.Handled%2A>기본값으로 `false` - <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>기본값으로 `null`.</xref:System.Windows.RoutedEventArgs.OriginalSource%2A> </xref:System.Windows.RoutedEventArgs.Handled%2A> </xref:System.Windows.RoutedEventArgs>       값이 null <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>이벤트를 발생 하는 라우팅 전달 하는 요소에 따라 채워진 있지만 읽을 `null` 호출 이전.</xref:System.Windows.RoutedEventArgs.OriginalSource%2A>       전달 하는 경우이 서명을 사용 하 여 <xref:System.Windows.RoutedEventArgs>와 같은 가상 메서드를 <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>호출에 인수가 사용 되는 위치, <xref:System.Windows.UIElement.RaiseEvent%2A>내부적으로.</xref:System.Windows.UIElement.RaiseEvent%2A> </xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A> </xref:System.Windows.RoutedEventArgs>"
  syntax:
    content: public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);
    parameters:
    - id: routedEvent
      type: System.Windows.RoutedEvent
      description: "이 인스턴스에 대 한 라우트된 이벤트 식별자는 <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref> 클래스입니다."
    - id: source
      type: System.Object
      description: "이벤트를 처리 하는 경우 보고 되는 대체 원본입니다. 이 미리 채웁니다는 <xref:System.Windows.RoutedEventArgs.Source*>속성.</xref:System.Windows.RoutedEventArgs.Source*>"
  overload: System.Windows.RoutedEventArgs.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.RoutedEventArgs.Handled
  id: Handled
  parent: System.Windows.RoutedEventArgs
  langs:
  - csharp
  name: Handled
  nameWithType: RoutedEventArgs.Handled
  fullName: System.Windows.RoutedEventArgs.Handled
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "경로 따라 이동할 때 라우트된 이벤트에 대 한 처리 이벤트의 현재 상태를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "이벤트를 처리 하는 이벤트 경로 따라 수신기 라우트된 이벤트의 표시 유형을 제한 됩니다. 이벤트는 경로의 나머지 부분을 계속 이동지 않습니다와 특히만 처리기를 추가 하지만 `HandledEventsToo` `true` 에 <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>메서드 호출에 대 한 응답에서 호출 됩니다.</xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 기본 인스턴스 수신기에 대 한 처리기 (로 표현 되는 같은 [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]) 호출 되지 것입니다. 일반적인 시나리오는 아닙니다 처리 표시 된 이벤트를 처리 합니다.       제어 작성자는 정의 사용자 고유의 이벤트를 결정 하 클래스에서 이벤트 처리에 대 한 수준에 영향을 줍니다 컨트롤의 사용자와 파생 된 컨트롤의 모든 사용자 및 잠재적으로 컨트롤에 포함 되어 있거나 다른 요소 또는 컨트롤을 포함 하는 합니다. 자세한 내용은 참조 [표시 라우트된 이벤트로 클래스를 처리 하 고,](~/add/includes/ajax-current-ext-md.md)합니다.       매우 드문 경우가 이벤트를 처리 하기에 적합 Handled 표시 되어 `true`, Handled를 변경 하 여 이벤트의 인수를 수정 하 고 `false`합니다. 이의 키 처리 같은 컨트롤의 입력된 이벤트의 특정 영역에 필요할 수 있습니다 <xref:System.Windows.UIElement.KeyDown>와 <xref:System.Windows.UIElement.TextInput>는 낮은 수준과 및 높은 수준의 입력된 이벤트 처리를 위해 경쟁 하 고, 각각 서로 다른 라우팅 전략을 사용 하려고 합니다.</xref:System.Windows.UIElement.TextInput> </xref:System.Windows.UIElement.KeyDown>"
  example:
  - "The following example implements an event handler that marks the event handled.  \n  \n [!code-vb[ClassHandling#OnStarClassHandler](~/add/codesnippet/visualbasic/ClassHandling.sdksamplelibrary/class1.vb#onstarclasshandler)]\n [!code-cs[ClassHandling#OnStarClassHandler](~/add/codesnippet/csharp/ClassHandling/SDKSampleLibrary/class1.cs#onstarclasshandler)]"
  syntax:
    content: public bool Handled { get; set; }
    return:
      type: System.Boolean
      description: "로 설정 하 고,<xref uid=&quot;langword_csharp_ true&quot; name=&quot; true&quot; href=&quot;&quot;> </xref> 이벤트가 처리 되지 않으면 표시할 경우 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 이 값을 읽는 경우<xref uid=&quot;langword_csharp_ true&quot; name=&quot; true&quot; href=&quot;&quot;> </xref> 클래스 처리기 또는 경로의 일부 인스턴스 처리기가 이미 표시 나타냅니다이 이벤트를 처리 합니다. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>이러한 처리기 이벤트를 처리 표시 않았음을 나타냅니다.       기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.RoutedEventArgs.Handled*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)
  id: InvokeEventHandler(System.Delegate,System.Object)
  parent: System.Windows.RoutedEventArgs
  langs:
  - csharp
  name: InvokeEventHandler(Delegate,Object)
  nameWithType: RoutedEventArgs.InvokeEventHandler(Delegate,Object)
  fullName: System.Windows.RoutedEventArgs.InvokeEventHandler(Delegate,Object)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "파생된 클래스에서 재정의 되 면 기본 구현을 통해 효율성을 높일 수 있는 형식별 방법으로 이벤트 처리기를 호출 하는 방법을 제공 합니다."
  remarks: "리플렉션을 처리기가 있지 않은 문자 그대로 모든 경우에 적절 한 처리기를 통합 하는 기본 구현을 <xref:System.Windows.RoutedEventHandler>, 성능은 저하 없고이 리플렉션 단계.</xref:System.Windows.RoutedEventHandler> 호출 가능 더 효율적으로 리플렉션을 사용 하지 않고도 합니다. 이 메서드를 재정의 하는 모든 라우트된 이벤트 인수 클래스에 대해 사용 가능 하면 시나리오입니다. 구현은 구현 이미를 형식이 안전한 처리기를 호출 해야 하기 때문에이 메서드에 대 한 기본을 호출 하지 않습니다."
  example:
  - "The following is pseudocode that illustrates a basic pattern that can be used for implementation. Here, `MyRoutedEventHandler` is a subclass of <xref:System.Windows.RoutedEventHandler>.  \n  \n [!code-cs[CorePseudocode#RoutedEventArgs](~/add/codesnippet/csharp/CorePseudocode/corepseudocode.cs#routedeventargs)]\n [!code-vb[CorePseudocode#RoutedEventArgs](~/add/codesnippet/visualbasic/corepseudocode/corepseudocode.vb#routedeventargs)]"
  syntax:
    content: protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);
    parameters:
    - id: genericHandler
      type: System.Delegate
      description: "제네릭 처리기 / 대리자 구현을 호출 합니다."
    - id: genericTarget
      type: System.Object
      description: "제공된 된 처리기를 호출 해야 하는 대상입니다."
  overload: System.Windows.RoutedEventArgs.InvokeEventHandler*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.RoutedEventArgs.OnSetSource(System.Object)
  id: OnSetSource(System.Object)
  parent: System.Windows.RoutedEventArgs
  langs:
  - csharp
  name: OnSetSource(Object)
  nameWithType: RoutedEventArgs.OnSetSource(Object)
  fullName: System.Windows.RoutedEventArgs.OnSetSource(Object)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "파생된 클래스에서 재정의 되 면 알림 콜백 항목이 제공 될 때마다 값은 <xref:System.Windows.RoutedEventArgs.Source*>속성이 인스턴스 변경.</xref:System.Windows.RoutedEventArgs.Source*>"
  syntax:
    content: protected virtual void OnSetSource (object source);
    parameters:
    - id: source
      type: System.Object
      description: "새 값 <xref:System.Windows.RoutedEventArgs.Source*>로 설정 되어 있습니다.</xref:System.Windows.RoutedEventArgs.Source*>"
  overload: System.Windows.RoutedEventArgs.OnSetSource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.RoutedEventArgs.OriginalSource
  id: OriginalSource
  parent: System.Windows.RoutedEventArgs
  langs:
  - csharp
  name: OriginalSource
  nameWithType: RoutedEventArgs.OriginalSource
  fullName: System.Windows.RoutedEventArgs.OriginalSource
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "가져옵니다 원본 보고 소스 순수 적중 테스트를 모든 가능한 <xref:System.Windows.RoutedEventArgs.Source*>부모 클래스에서 조정</xref:System.Windows.RoutedEventArgs.Source*> 하기 전에 따른"
  remarks: "이 속성을 한 번만 클래스 하기 전에 이벤트 처리기 또는 모든 인스턴스 호출 되 고이 지점 이후의 조정 되지 않습니다 해당 값을 가져옵니다. 원본 소스 정보는 이벤트 데이터에서 보고 하는 것 처럼 클래스 처리기 또는 클래스 구현에 읽기 전용입니다.       컨트롤에 대 한 콘텐츠 모델 내 콘텐츠 요소를 포함 하는 일반적인 경우는 소스를 조정할 수 있습니다 (예를 들어, 목록 항목의 내용으로 목록 항목 요소에서 보고는 <xref:System.Windows.RoutedEventArgs.Source%2A>목록 항목 내에서 실제 요소는 OriginalSource 됩니다.</xref:System.Windows.RoutedEventArgs.Source%2A>       다양 한 요소 및 정적 콘텐츠 모델에서 원본 조정 클래스에 따라 달라 집니다. 이벤트 소스를 조정 하는 각 클래스 소스를 대부분의 입력된 시나리오를 클래스를 마우스 <xref:System.Windows.RoutedEventArgs.Source%2A>.</xref:System.Windows.RoutedEventArgs.Source%2A> 해당 소스를 설정 하는 다음 시나리오에 대 한 보고 하는 가장 유용한 예측 하 하려고 합니다. 이 원본의 이벤트의 처리와 관련 된 하나가 아닌 경우를 더 적합 한 다른 소스를 보고 하는 경우 대신 OriginalSource를 확인해 보십시오. 입력된 이벤트에 대 한 자세한 내용은 참조 하십시오. [입력 개요](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public object OriginalSource { get; }
    return:
      type: System.Object
      description: "앞에 있는 원본 보고 소스로, <xref:System.Windows.RoutedEventArgs.Source*>합성 요소 트리를 평면화 하기 위한 것 클래스 처리에의 한 조정 합니다.</xref:System.Windows.RoutedEventArgs.Source*>"
  overload: System.Windows.RoutedEventArgs.OriginalSource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.RoutedEventArgs.RoutedEvent
  id: RoutedEvent
  parent: System.Windows.RoutedEventArgs
  langs:
  - csharp
  name: RoutedEvent
  nameWithType: RoutedEventArgs.RoutedEvent
  fullName: System.Windows.RoutedEventArgs.RoutedEvent
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "이 연결 된 RoutedEvent을 가져오거나 설정 합니다. <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref> 인스턴스."
  remarks: "이 값을 설정할 수 없습니다는 <xref:System.Windows.RoutedEventArgs>있는 이미 라우팅된 (예를 들어, 구입한 경우 처리기를 통해 인수).</xref:System.Windows.RoutedEventArgs> 이렇게 하면 예외가 발생 합니다. 이벤트의 호출을 생성 하는 아직 사용 하지 않은 인스턴스만 설정할 수 있습니다.       RoutedEvent 값 일 수 없습니다 `null` 언제 든 지 합니다."
  example:
  - "The following example creates new routed event data with an initial constructor and then sets the RoutedEvent property as a subsequent operation. You must have RoutedEvent set prior to raising the routed event.  \n  \n [!code-cs[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/add/codesnippet/csharp/ColorPicker/ColorPicker.cs#routedeventargsroutedevent)]\n [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/add/codesnippet/visualbasic/colorpicker/colorpicker.vb#routedeventargsroutedevent)]"
  syntax:
    content: public System.Windows.RoutedEvent RoutedEvent { get; set; }
    return:
      type: System.Windows.RoutedEvent
      description: "호출 된 이벤트에 대 한 식별자입니다."
  overload: System.Windows.RoutedEventArgs.RoutedEvent*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이벤트가 라우트되는 동안 RoutedEvent 값을 변경 하려고 했습니다."
  platform:
  - net462
- uid: System.Windows.RoutedEventArgs.Source
  id: Source
  parent: System.Windows.RoutedEventArgs
  langs:
  - csharp
  name: Source
  nameWithType: RoutedEventArgs.Source
  fullName: System.Windows.RoutedEventArgs.Source
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "이벤트를 발생 시킨 개체에 대 한 참조를 가져오거나 설정 합니다."
  remarks: "모든 버블링 라우트된 이벤트를 발생 시킨 요소 경로 이동한 실제로 및 라우트된 이벤트를 발생 시킨 요소 아직 터널 되지가 모든 터널링에 대 한 Source 값이 달라 집니다의 값 보다는 `sender` 이벤트 인수 클래스의 매개 변수입니다. 이 두 요소 중 이벤트와 관련 된 지정 된 임의의 처리기에서 가장 중요 (원본, 발생 하는 요소 또는 `sender`, 현재이 처리 하는 요소) 처리기의 주소를 지정 하는 응용 프로그램 논리에 따라 달라 집니다.       이 속성은 일반적으로 경우에 수행 재정의 하거나 구현 다른 [!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)] 때 처럼 이벤트 소스를 조정 하는 클래스는 이벤트를 처리 합니다. 인스턴스 처리기에서 명백한 이벤트 소스를 다시 설정 하면 권장 되지 않습니다, 특히 처리 처리기 이벤트를 표시 하지 않는 경우.       다른 이벤트 소스를 보고 하기 위해 원본 다시 설정 해도 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>첫 번째 소스로 시작에 의해 발생 하는 보고서는 계속 <xref:System.Windows.UIElement.RaiseEvent%2A>호출.</xref:System.Windows.UIElement.RaiseEvent%2A> </xref:System.Windows.RoutedEventArgs.OriginalSource%2A>"
  syntax:
    content: public object Source { get; set; }
    return:
      type: System.Object
      description: "이벤트를 발생 시킨 개체입니다."
  overload: System.Windows.RoutedEventArgs.Source*
  exceptions: []
  platform:
  - net462
references:
- uid: System.EventArgs
  isExternal: false
  name: System.EventArgs
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.RoutedEventArgs.#ctor
  parent: System.Windows.RoutedEventArgs
  isExternal: false
  name: RoutedEventArgs()
  nameWithType: RoutedEventArgs.RoutedEventArgs()
  fullName: System.Windows.RoutedEventArgs.RoutedEventArgs()
- uid: System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)
  parent: System.Windows.RoutedEventArgs
  isExternal: false
  name: RoutedEventArgs(RoutedEvent)
  nameWithType: RoutedEventArgs.RoutedEventArgs(RoutedEvent)
  fullName: System.Windows.RoutedEventArgs.RoutedEventArgs(RoutedEvent)
- uid: System.Windows.RoutedEvent
  parent: System.Windows
  isExternal: false
  name: RoutedEvent
  nameWithType: RoutedEvent
  fullName: System.Windows.RoutedEvent
- uid: System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)
  parent: System.Windows.RoutedEventArgs
  isExternal: false
  name: RoutedEventArgs(RoutedEvent,Object)
  nameWithType: RoutedEventArgs.RoutedEventArgs(RoutedEvent,Object)
  fullName: System.Windows.RoutedEventArgs.RoutedEventArgs(RoutedEvent,Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.RoutedEventArgs.Handled
  parent: System.Windows.RoutedEventArgs
  isExternal: false
  name: Handled
  nameWithType: RoutedEventArgs.Handled
  fullName: System.Windows.RoutedEventArgs.Handled
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)
  parent: System.Windows.RoutedEventArgs
  isExternal: false
  name: InvokeEventHandler(Delegate,Object)
  nameWithType: RoutedEventArgs.InvokeEventHandler(Delegate,Object)
  fullName: System.Windows.RoutedEventArgs.InvokeEventHandler(Delegate,Object)
- uid: System.Delegate
  parent: System
  isExternal: true
  name: Delegate
  nameWithType: Delegate
  fullName: System.Delegate
- uid: System.Windows.RoutedEventArgs.OnSetSource(System.Object)
  parent: System.Windows.RoutedEventArgs
  isExternal: false
  name: OnSetSource(Object)
  nameWithType: RoutedEventArgs.OnSetSource(Object)
  fullName: System.Windows.RoutedEventArgs.OnSetSource(Object)
- uid: System.Windows.RoutedEventArgs.OriginalSource
  parent: System.Windows.RoutedEventArgs
  isExternal: false
  name: OriginalSource
  nameWithType: RoutedEventArgs.OriginalSource
  fullName: System.Windows.RoutedEventArgs.OriginalSource
- uid: System.Windows.RoutedEventArgs.RoutedEvent
  parent: System.Windows.RoutedEventArgs
  isExternal: false
  name: RoutedEvent
  nameWithType: RoutedEventArgs.RoutedEvent
  fullName: System.Windows.RoutedEventArgs.RoutedEvent
- uid: System.Windows.RoutedEventArgs.Source
  parent: System.Windows.RoutedEventArgs
  isExternal: false
  name: Source
  nameWithType: RoutedEventArgs.Source
  fullName: System.Windows.RoutedEventArgs.Source
- uid: System.Windows.RoutedEventArgs.#ctor*
  parent: System.Windows.RoutedEventArgs
  isExternal: false
  name: RoutedEventArgs
  nameWithType: RoutedEventArgs.RoutedEventArgs
- uid: System.Windows.RoutedEventArgs.Handled*
  parent: System.Windows.RoutedEventArgs
  isExternal: false
  name: Handled
  nameWithType: RoutedEventArgs.Handled
- uid: System.Windows.RoutedEventArgs.InvokeEventHandler*
  parent: System.Windows.RoutedEventArgs
  isExternal: false
  name: InvokeEventHandler
  nameWithType: RoutedEventArgs.InvokeEventHandler
- uid: System.Windows.RoutedEventArgs.OnSetSource*
  parent: System.Windows.RoutedEventArgs
  isExternal: false
  name: OnSetSource
  nameWithType: RoutedEventArgs.OnSetSource
- uid: System.Windows.RoutedEventArgs.OriginalSource*
  parent: System.Windows.RoutedEventArgs
  isExternal: false
  name: OriginalSource
  nameWithType: RoutedEventArgs.OriginalSource
- uid: System.Windows.RoutedEventArgs.RoutedEvent*
  parent: System.Windows.RoutedEventArgs
  isExternal: false
  name: RoutedEvent
  nameWithType: RoutedEventArgs.RoutedEvent
- uid: System.Windows.RoutedEventArgs.Source*
  parent: System.Windows.RoutedEventArgs
  isExternal: false
  name: Source
  nameWithType: RoutedEventArgs.Source
