### YamlMime:ManagedReference
items:
- uid: System.Windows.Input.CanExecuteRoutedEventHandler
  id: CanExecuteRoutedEventHandler
  langs:
  - csharp
  name: CanExecuteRoutedEventHandler
  nameWithType: CanExecuteRoutedEventHandler
  fullName: System.Windows.Input.CanExecuteRoutedEventHandler
  type: Delegate
  summary: "처리 하는 메서드를 나타냅니다는 <xref href=&quot;System.Windows.Input.CommandBinding.CanExecute&quot;> </xref> 이벤트입니다."
  remarks: "CanExecuteRoutedEventHandler 이벤트 소스와 연결 된 명령 명령 대상에서 실행할 수 인지 여부를 확인 합니다. 명령에는 대상을 지정 하는 명령 소스가 경우 대상 정보를 통해 얻을 수 있습니다 `sender`합니다. 경우는 <xref:System.Windows.Input.ICommandSource.CommandTarget%2A>키보드 포커스가 있는 요소는 대상 이며 통해 얻을 수 있습니다 설정 되어 있지 않은 `sender`.</xref:System.Windows.Input.ICommandSource.CommandTarget%2A>  대상에 대해 명령을 실행할 수 있는지 확인 하면 <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A?displayProperty=fullName>속성 설정 해야 `true`, 그렇지 않으면로 설정 `false`.</xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A?displayProperty=fullName>       명령, 소스 및 대상 확인 하기 위해 이벤트 데이터에 의존 하 고 필요가 없습니다. 훨씬 어렵습니다 명령 구조에 연결 되는 이벤트 경로에 동일한 명령을 실행 하려면 명령 라우팅에 광범위 하 게 사용 하는 경우이 알려진된 가능한 명령 호출 처리기의 사용을 제한할 수 있습니다."
  example:
  - "The following example shows a CanExecuteRoutedEventHandler that sets <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A> to `true`.  \n  \n [!code-cs[commandwithhandler#CommandHandlerCanExecuteHandler](~/add/codesnippet/csharp/commandWithHandler/Window1.xaml.cs#commandhandlercanexecutehandler)]\n [!code-vb[commandwithhandler#CommandHandlerCanExecuteHandler](~/add/codesnippet/visualbasic/commandWithHandler/Window1.xaml.vb#commandhandlercanexecutehandler)]"
  syntax:
    content: public delegate void CanExecuteRoutedEventHandler(object sender, CanExecuteRoutedEventArgs e);
  inheritance:
  - System.Delegate
  platform:
  - net462
references:
- uid: System.Delegate
  isExternal: false
  name: System.Delegate
