### YamlMime:ManagedReference
items:
- uid: System.Collections.Queue
  id: Queue
  children:
  - System.Collections.Queue.#ctor
  - System.Collections.Queue.#ctor(System.Collections.ICollection)
  - System.Collections.Queue.#ctor(System.Int32)
  - System.Collections.Queue.#ctor(System.Int32,System.Single)
  - System.Collections.Queue.Clear
  - System.Collections.Queue.Clone
  - System.Collections.Queue.Contains(System.Object)
  - System.Collections.Queue.CopyTo(System.Array,System.Int32)
  - System.Collections.Queue.Count
  - System.Collections.Queue.Dequeue
  - System.Collections.Queue.Enqueue(System.Object)
  - System.Collections.Queue.GetEnumerator
  - System.Collections.Queue.IsSynchronized
  - System.Collections.Queue.Peek
  - System.Collections.Queue.Synchronized(System.Collections.Queue)
  - System.Collections.Queue.SyncRoot
  - System.Collections.Queue.ToArray
  - System.Collections.Queue.TrimToSize
  langs:
  - csharp
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
  type: Class
  summary: "개체의 선입 선출 컬렉션을 나타냅니다."
  remarks: "이 클래스는 순환 배열로 큐를 구현합니다. 큐에 저장 된 개체는 한쪽 끝에 삽입 되 고 다른에서 제거 합니다.       큐 및 스택은 유용 정보에 대 한 임시 저장소를 사용 해야 하는 경우 즉 때 하려는 경우도 요소 값을 검색 한 후 취소 합니다. 에 컬렉션에 저장 된 동일한 순서로 정보에에서 액세스 해야 하는 경우 큐를 사용 합니다. 사용 하 여 <xref:System.Collections.Stack>반대 순서로 정보에 액세스 해야 합니다.</xref:System.Collections.Stack> 사용 하 여 <xref:System.Collections.Concurrent.ConcurrentQueue%601>또는 <xref:System.Collections.Concurrent.ConcurrentStack%601>경우 동시에 여러 스레드에서 컬렉션에 액세스 해야 합니다.</xref:System.Collections.Concurrent.ConcurrentStack%601> </xref:System.Collections.Concurrent.ConcurrentQueue%601>       큐와 요소에 세 가지 주요 작업을 수행할 수 있습니다.- <xref:System.Collections.Queue.Enqueue%2A>큐의 끝에 요소를 추가 합니다.</xref:System.Collections.Queue.Enqueue%2A>      - <xref:System.Collections.Queue.Dequeue%2A>큐의 시작 부분부터 가장 오래 된 요소를 제거 합니다.</xref:System.Collections.Queue.Dequeue%2A>      - <xref:System.Collections.Queue.Peek%2A>큐의 시작 부분에 없지만 큐에서 제거 되지 않고 가장 오래 된 요소를 반환 합니다.</xref:System.Collections.Queue.Peek%2A>       큐의 용량은는 큐에 저장할 수 있는 요소의 수입니다. 요소는 큐에 추가 되 면 자동으로 용량 증가 하면 재할당을 통해 필요에 따라 합니다.  <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> 를 호출 하 여 용량을 줄일 수 있습니다.       증가 비율은 현재 용량이 더 큰 용량이 필요할 때 기준이 곱한 숫자입니다.  증가 비율은 큐 생성 될 때 결정 됩니다. 기본 증가 비율은 2.0입니다. 큐의 용량 증가 비율에 관계 없이&4;의 최소 이상 증가 합니다. 예를 들어 큐 증가 비율 1.0 항상 늘어납니다 용량에 네 개의 큰 용량이 필요할 때.       큐에 받아들일지 `null` 을 유효한 값으로 중복 요소를 허용 합니다.       이 컬렉션의 제네릭 버전은를 참조 하세요.<xref:System.Collections.Generic.Queue%601?displayProperty=fullName></xref:System.Collections.Generic.Queue%601?displayProperty=fullName>"
  example:
  - "The following example shows how to create and add values to a Queue and how to print out its values.  \n  \n [!code-cs[Classic Queue Example#1](~/add/codesnippet/csharp/t-system.collections.queue_1.cs)]\n [!code-cpp[Classic Queue Example#1](~/add/codesnippet/cpp/t-system.collections.queue_1.cpp)]\n [!code-vb[Classic Queue Example#1](~/add/codesnippet/visualbasic/t-system.collections.queue_1.vb)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Queue/QueueDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Queue : ICloneable, System.Collections.ICollection
  inheritance:
  - System.Object
  implements:
  - System.Collections.ICollection
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor
  id: '#ctor'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Collections.Queue&quot;> </xref> 클래스는 비어 있는 기본 초기 용량을 갖고 있고 기본 증가 비율을 사용 하 여 합니다."
  remarks: "용량은 <xref:System.Collections.Queue>요소의 수가 고 <xref:System.Collections.Queue>보유할 수 있습니다.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  요소에 추가 되는 <xref:System.Collections.Queue>, 용량 자동으로 증가 하면 재할당을 통해 필요에 따라.</xref:System.Collections.Queue>  <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> 를 호출 하 여 용량을 줄일 수 있습니다.       증가 비율은 현재 용량이 더 큰 용량이 필요할 때 기준이 곱한 숫자입니다.  증가 비율은 결정 됩니다 때는 <xref:System.Collections.Queue>생성 됩니다.</xref:System.Collections.Queue>       이 생성자는 o (1) 연산입니다."
  syntax:
    content: public Queue ();
    parameters: []
  overload: System.Collections.Queue.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Collections.Queue&quot;> </xref> 복사 된 요소 수와 같은 초기 용량을 가지와 기본 증가 비율을 사용 하 여 지정된 된 컬렉션에서 복사한 요소가 들어 클래스입니다."
  remarks: "용량은 <xref:System.Collections.Queue>요소의 수가 고 <xref:System.Collections.Queue>보유할 수 있습니다.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  요소에 추가 되는 <xref:System.Collections.Queue>, 용량 자동으로 증가 하면 재할당을 통해 필요에 따라.</xref:System.Collections.Queue>  <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> 를 호출 하 여 용량을 줄일 수 있습니다.       증가 비율은 현재 용량이 더 큰 용량이 필요할 때 기준이 곱한 숫자입니다.  증가 비율은 결정 됩니다 때는 <xref:System.Collections.Queue>생성 됩니다.</xref:System.Collections.Queue>       요소는 <xref:System.Collections.Queue>순서는 <xref:System.Collections.IEnumerator> <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.IEnumerator> 가 읽을</xref:System.Collections.Queue> 에 복사 됩니다.       이 생성자는는 O (`n`) 작업, 여기서 `n` 에 있는 요소의 수는 `col`합니다."
  syntax:
    content: public Queue (System.Collections.ICollection col);
    parameters:
    - id: col
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>요소를 복사할 원본.</xref:System.Collections.ICollection>"
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>col</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Collections.Queue&quot;> </xref> 클래스는 비어 있는 지정 된 초기 용량을 갖고 있고 기본 증가 비율을 사용 하 여 합니다."
  remarks: "용량은 <xref:System.Collections.Queue>요소의 수가 고 <xref:System.Collections.Queue>보유할 수 있습니다.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  요소에 추가 되는 <xref:System.Collections.Queue>, 용량 자동으로 증가 하면 재할당을 통해 필요에 따라.</xref:System.Collections.Queue>  <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> 를 호출 하 여 용량을 줄일 수 있습니다.       증가 비율은 현재 용량이 더 큰 용량이 필요할 때 기준이 곱한 숫자입니다.  증가 비율은 결정 됩니다 때는 <xref:System.Collections.Queue>생성 됩니다.</xref:System.Collections.Queue>       컬렉션의 크기를 예상할 수 있는 경우 초기 용량을 지정 하지 않아도 크기 조정 작업 <xref:System.Collections.Queue>.</xref:System.Collections.Queue> 에 요소를 추가 하는 동안 여러 번 수행       이 생성자는는 O (`n`) 작업, 여기서 `n` 은 `capacity`합니다."
  syntax:
    content: public Queue (int capacity);
    parameters:
    - id: capacity
      type: System.Int32
      description: "초기 요소 수는는 <xref href=&quot;System.Collections.Queue&quot;> </xref> 포함 될 수 있습니다."
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>가&0; 보다 작습니다."
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  id: '#ctor(System.Int32,System.Single)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Collections.Queue&quot;> </xref> 클래스는 비어 있는 지정 된 초기 용량을 갖고 및 지정한 증가 비율을 사용 하 여 합니다."
  remarks: "용량은 <xref:System.Collections.Queue>요소의 수가 고 <xref:System.Collections.Queue>보유할 수 있습니다.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  요소에 추가 되는 <xref:System.Collections.Queue>, 용량 자동으로 증가 하면 재할당을 통해 필요에 따라.</xref:System.Collections.Queue>  <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> 를 호출 하 여 용량을 줄일 수 있습니다.       증가 비율은 현재 용량이 더 큰 용량이 필요할 때 기준이 곱한 숫자입니다.  증가 비율은 결정 됩니다 때는 <xref:System.Collections.Queue>생성 됩니다.</xref:System.Collections.Queue> 용량에서 <xref:System.Collections.Queue>증가 비율에 관계 없이 최소 값은 증가 합니다. 1.0 증가 비율을 주지 않는 것은 <xref:System.Collections.Queue>의 크기가 증가 합니다.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       컬렉션의 크기를 예상할 수 있는 경우 초기 용량을 지정 하지 않아도 크기 조정 작업 <xref:System.Collections.Queue>.</xref:System.Collections.Queue> 에 요소를 추가 하는 동안 여러 번 수행       이 생성자는는 O (`n`) 작업, 여기서 `n` 은 `capacity`합니다."
  syntax:
    content: public Queue (int capacity, float growFactor);
    parameters:
    - id: capacity
      type: System.Int32
      description: "초기 요소 수는는 <xref href=&quot;System.Collections.Queue&quot;> </xref> 포함 될 수 있습니다."
    - id: growFactor
      type: System.Single
      description: "인수입니다 용량의 <xref href=&quot;System.Collections.Queue&quot;> </xref> 확장 됩니다."
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>가&0; 보다 작습니다.       -또는- <code>growFactor</code> 가 1.0 보다 작은 10.0 보다 큽니다."
  platform:
  - net462
- uid: System.Collections.Queue.Clear
  id: Clear
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "개체를 모두 제거 된 <xref href=&quot;System.Collections.Queue&quot;> </xref>합니다."
  remarks: "<xref:System.Collections.Queue.Count%2A>가&0;으로 설정 하 고 컬렉션의 요소에 다른 개체에 대 한 참조도 해제 됩니다.</xref:System.Collections.Queue.Count%2A>       용량 변경 되지 않습니다. <xref:System.Collections.Queue> <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> 호출,</xref:System.Collections.Queue> 용량을 다시 설정 하려면 빈 트리밍 <xref:System.Collections.Queue>의 용량 설정는 <xref:System.Collections.Queue>기본 용량을.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.que_6_1.cpp)]\n [!code-cs[Classic Queue.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.que_6_1.cs)]\n [!code-vb[Classic Queue.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_6_1.vb)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Queue.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Clone
  id: Clone
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "단순 복사본을 만듭니다는 <xref href=&quot;System.Collections.Queue&quot;> </xref>합니다."
  remarks: "컬렉션의 단순 복사본은 참조 형식 또는 값 형식 참조에서 참조 하는 개체를 복사 하지 않습니다 여부는 컬렉션의 요소에만 복사 합니다. 새 컬렉션에 대 한 참조는 원본 컬렉션에 대 한 참조를 가리키는 동일한 개체를 가리킵니다.       반면, 요소를 복사 하는 컬렉션의 전체 복사본 및 뿐만 아니라 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목입니다.       이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "단순 복사는 <xref href=&quot;System.Collections.Queue&quot;> </xref>합니다."
  overload: System.Collections.Queue.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "에 요소가 있는지 여부를 결정은 <xref href=&quot;System.Collections.Queue&quot;> </xref>합니다."
  remarks: "이 메서드는 <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> 를 호출 하 여 같은지를 확인 합니다.       이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>       컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 <xref:System.Object.Equals%2A>및 <xref:System.IComparable.CompareTo%2A>에 대 한 메서드 `obj` 확인 하려면 여부 `item` 존재 합니다.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> .NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <xref:System.Object.Equals%2A>및 <xref:System.IComparable.CompareTo%2A>의 메서드는 `obj` 컬렉션의 개체에 대 한 매개 변수.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  syntax:
    content: public virtual bool Contains (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "<xref:System.Object>에서 찾으려고는 <xref href=&quot;System.Collections.Queue&quot;> </xref>.</xref:System.Object> 값일 수 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>if <code>obj</code> is found in the <xref href=&quot;System.Collections.Queue&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Queue.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "복사본의 <xref href=&quot;System.Collections.Queue&quot;> </xref> 요소를 사용 하는 기존&1; 차원 <xref:System.Array>지정한 배열 인덱스부터 시작 합니다.</xref:System.Array>"
  remarks: "<xref:System.Array>열거자 <xref:System.Collections.Queue>.</xref:System.Collections.Queue> 을 반복 하는 같은 순서로</xref:System.Array> 요소가 복사 되       이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_4_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_4_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_4_1.vb)]"
  syntax:
    content: public virtual void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "1 차원 <xref:System.Array>에서 복사한 요소의 대상인 <xref href=&quot;System.Collections.Queue&quot;> </xref>.</xref:System.Array> <xref:System.Array>0부터 시작 하는 인덱스가 있어야 합니다.</xref:System.Array>"
    - id: index
      type: System.Int32
      description: "인덱스는&0;부터 시작 `array` 복사가 시작 되는 합니다."
  overload: System.Collections.Queue.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>가&0; 보다 작습니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>가 다차원 배열인 경우       -또는-소스에 있는 요소의 수 <xref href=&quot;System.Collections.Queue&quot;> </xref> 에서 사용 가능한 공간 보다 큰 <code>index</code> 대상의 끝에 <code>array</code>합니다."
  - type: System.ArrayTypeMismatchException
    commentId: T:System.ArrayTypeMismatchException
    description: "소스의 형식을 <xref href=&quot;System.Collections.Queue&quot;> </xref> 대상의 형식으로 자동 캐스팅할 수 없는 <code> array </code>합니다."
  platform:
  - net462
- uid: System.Collections.Queue.Count
  id: Count
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "에 포함 된 요소의 수를 가져옵니다는 <xref href=&quot;System.Collections.Queue&quot;> </xref>합니다."
  remarks: "용량을 <xref:System.Collections.Queue>요소의 수가 하는 <xref:System.Collections.Queue>저장할 수 있습니다.</xref:System.Collections.Queue> </xref:System.Collections.Queue> Count가 실제로 있는 <xref:System.Collections.Queue>.</xref:System.Collections.Queue> 에 있는 요소 수       용량을 <xref:System.Collections.Queue>개수 보다 크거나 같은 경우는 항상.</xref:System.Collections.Queue> Count는 용량을 초과 하면 요소를 추가 하는 동안 용량 자동으로 이전 요소를 복사 하 고 새 요소를 추가 하기 전에 내부 배열을 다시 할당 하 여 증가 합니다. 새 용량 증가 비율을은 현재 용량을 곱하여 결정 됩니다 때 결정는 <xref:System.Collections.Queue>생성 됩니다.</xref:System.Collections.Queue> 용량에서 <xref:System.Collections.Queue>증가 비율에 관계 없이 최소 값은 증가 합니다. 1.0 증가 비율을 주지 않는 것은 <xref:System.Collections.Queue>의 크기가 증가 합니다.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> 를 호출 하 여 용량을 줄일 수 있습니다.       이 속성의 값을 검색 하는 것은 o (1) 작업입니다."
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "에 포함 된 요소의 수는 <xref href=&quot;System.Collections.Queue&quot;> </xref>합니다."
  overload: System.Collections.Queue.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Dequeue
  id: Dequeue
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "제거 하 고 맨 앞에 개체를 반환 합니다.는 <xref href=&quot;System.Collections.Queue&quot;> </xref>합니다."
  remarks: "이 메서드는 <xref:System.Collections.Queue.Peek%2A>메서드를 <xref:System.Collections.Queue.Peek%2A> <xref:System.Collections.Queue>.</xref:System.Collections.Queue> 를 수정 하지 않은</xref:System.Collections.Queue.Peek%2A> 채</xref:System.Collections.Queue.Peek%2A>       `null`에 추가할 수는 <xref:System.Collections.Queue>값으로.</xref:System.Collections.Queue> 끝과 null 값을 구분 하기 위해는 <xref:System.Collections.Queue>, 확인 된 <xref:System.Collections.Queue.Count%2A>속성 또는 catch는 <xref:System.InvalidOperationException>때 throw 되는 <xref:System.Collections.Queue>비어.</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       이 메서드는 o (1) 작업."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_0_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_0_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_0_1.cpp)]"
  syntax:
    content: public virtual object Dequeue ();
    parameters: []
    return:
      type: System.Object
      description: "시작 부분에서 제거 된 개체는 <xref href=&quot;System.Collections.Queue&quot;> </xref>합니다."
  overload: System.Collections.Queue.Dequeue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Collections.Queue&quot;> </xref> 비어 있습니다."
  platform:
  - net462
- uid: System.Collections.Queue.Enqueue(System.Object)
  id: Enqueue(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "개체의 끝에 추가 된 <xref href=&quot;System.Collections.Queue&quot;> </xref>합니다."
  remarks: "용량은 <xref:System.Collections.Queue>요소의 수가 고 <xref:System.Collections.Queue>보유할 수 있습니다.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  요소에 추가 되는 <xref:System.Collections.Queue>, 용량 자동으로 증가 하면 재할당을 통해 필요에 따라.</xref:System.Collections.Queue>  <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> 를 호출 하 여 용량을 줄일 수 있습니다.       증가 비율은 현재 용량이 더 큰 용량이 필요할 때 기준이 곱한 숫자입니다.  증가 비율은 결정 됩니다 때는 <xref:System.Collections.Queue>생성 됩니다.</xref:System.Collections.Queue> 용량에서 <xref:System.Collections.Queue>증가 비율에 관계 없이 최소 값은 증가 합니다. 1.0 증가 비율을 주지 않는 것은 <xref:System.Collections.Queue>의 크기가 증가 합니다.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       경우 <xref:System.Collections.Queue.Count%2A>작으면이 메서드는 o (1) 작업 내부 배열의 용량 보다.</xref:System.Collections.Queue.Count%2A> 내부 배열을 재할당 하 여 새 요소로 적용 하는 경우이 메서드는 O는 됩니다 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_5_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_5_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_5_1.cpp)]"
  syntax:
    content: public virtual void Enqueue (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "에 추가할 개체는 <xref href=&quot;System.Collections.Queue&quot;> </xref>합니다. 값일 수 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Collections.Queue.Enqueue*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Queue
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "반복 하는 열거자를 반환 된 <xref href=&quot;System.Collections.Queue&quot;> </xref>합니다."
  remarks: "`foreach` C# 언어의 (`for each` Visual basic에서)은 열거자의 복잡성을 숨깁니다.  따라서 사용 하 여 `foreach` 열거자를 직접 조작 하는 대신이 좋습니다.       열거자는 컬렉션의에서 데이터를 읽는 데 사용할 수 있지만 기본 컬렉션을 수정 하는 사용할 수 없습니다.       처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치 됩니다. <xref:System.Collections.IEnumerator.Reset%2A>또한이 위치로 복원 열거자를 가져옵니다.</xref:System.Collections.IEnumerator.Reset%2A>  이 위치에서 <xref:System.Collections.IEnumerator.Current%2A>정의 되지 않습니다.</xref:System.Collections.IEnumerator.Current%2A> 따라서 <xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> 의 값을 읽기 전에 컬렉션의 첫 번째 요소로 열거자를</xref:System.Collections.IEnumerator.MoveNext%2A> 호출 해야 합니다.       <xref:System.Collections.IEnumerator.Current%2A>될 때까지 동일한 개체를 반환 <xref:System.Collections.IEnumerator.MoveNext%2A>또는 <xref:System.Collections.IEnumerator.Reset%2A>호출 됩니다.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>설정 <xref:System.Collections.IEnumerator.Current%2A>를 다음 요소로.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       경우 <xref:System.Collections.IEnumerator.MoveNext%2A>전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <xref:System.Collections.IEnumerator.MoveNext%2A>반환 `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 열거자가 있는 경우이 위치에 대 한 후속 호출에서 <xref:System.Collections.IEnumerator.MoveNext%2A>반환할 수도 `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A>반환 `false`, <xref:System.Collections.IEnumerator.Current%2A>정의 되지 않습니다.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Current%2A>다시, 컬렉션의 첫 번째 요소를 호출할 수 있습니다 <xref:System.Collections.IEnumerator.Reset%2A>그 뒤 <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A> 설정 하려면       열거자는 컬렉션이 변경 되지으로 유효한 상태를 유지 합니다. 컬렉션 변경 되 면 추가, 수정 또는 요소를 삭제와 같은 열거자는 무효화 하 고 해당 동작은 정의 되지 않습니다.       열거자는 컬렉션에 배타적으로 액세스가 없습니다. 따라서 컬렉션을 열거 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다.  을 열거 하는 동안 스레드로부터 안전을 보장 하려면 전체 열거 동안 컬렉션을 잠글 수 있습니다.  컬렉션에 여러 스레드에서 읽기 및 쓰기에 대 한 액세스를 허용 하려면 사용자 지정 동기화를 구현 해야 합니다.       이 메서드는 o (1) 작업."
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Queue&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Queue.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Queue
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "에 대 한 액세스 여부를 나타내는 값을 가져옵니다는 <xref href=&quot;System.Collections.Queue&quot;> </xref> 이 동기화 되었으면 (스레드로부터 안전 하 게 보호)."
  remarks: "스레드로부터 안전을 보장 하려면는 <xref:System.Collections.Queue>에서 반환 되는 래퍼를 통해 모든 작업을 완료 해야 합니다는 <xref:System.Collections.Queue.Synchronized%2A>메서드.</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue>       컬렉션을 열거 본질적으로 스레드로부터 안전한 프로시저가 아닙니다. 컬렉션이 동기화 되어 있을 때 다른 스레드에서 수 수정할 열거자에서 예외가 발생 하는 컬렉션입니다. 열거 동안 스레드 보안을 보장 하려면 전체 열거 동안 컬렉션을 잠글 하거나 다른 스레드에서 변경 된 내용으로 인해 발생 한 예외를 catch 합니다."
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_0_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_0_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_0_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized, and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.que_0_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.que_0_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.que_0_2.vb)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우에 대 한 액세스는 <xref href=&quot;System.Collections.Queue&quot;> </xref> 은 동기화 (스레드로부터 안전함); 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Collections.Queue.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Peek
  id: Peek
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "시작 부분에서 개체를 반환 된 <xref href=&quot;System.Collections.Queue&quot;> </xref> 제거 하지 않고 있습니다."
  remarks: "이 메서드는 유사 <xref:System.Collections.Queue.Dequeue%2A>메서드이지만 Peek <xref:System.Collections.Queue>.</xref:System.Collections.Queue> 수정 하지 않습니다</xref:System.Collections.Queue.Dequeue%2A>       `null`에 추가할 수는 <xref:System.Collections.Queue>값으로.</xref:System.Collections.Queue> 끝과 null 값을 구분 하기 위해는 <xref:System.Collections.Queue>, 확인 된 <xref:System.Collections.Queue.Count%2A>속성 또는 catch는 <xref:System.InvalidOperationException>때 throw 되는 <xref:System.Collections.Queue>비어.</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       이 메서드는 o (1) 작업."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_1_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_1_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_1_1.cpp)]"
  syntax:
    content: public virtual object Peek ();
    parameters: []
    return:
      type: System.Object
      description: "시작 부분에 있는 개체는 <xref href=&quot;System.Collections.Queue&quot;> </xref>합니다."
  overload: System.Collections.Queue.Peek*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Collections.Queue&quot;> </xref> 비어 있습니다."
  platform:
  - net462
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  id: Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새 반환 <xref href=&quot;System.Collections.Queue&quot;> </xref> 원본 큐를 래핑하고 스레드로부터 안전 합니다."
  remarks: "이 메서드에 의해 반환 되는 래퍼를 스레드로부터 안전한 방식으로 수행 되는 작업을 수행 하기 전에 큐를 잠급니다.       스레드로부터 안전을 보장 하려면는 <xref:System.Collections.Queue>만이 래퍼를 통해 모든 작업을 완료 해야 합니다.</xref:System.Collections.Queue>       컬렉션을 열거 본질적으로 스레드로부터 안전한 프로시저가 아닙니다. 컬렉션이 동기화 되어 있을 때 다른 스레드에서 수 수정할 열거자에서 예외가 발생 하는 컬렉션입니다. 열거 동안 스레드 보안을 보장 하려면 전체 열거 동안 컬렉션을 잠글 하거나 다른 스레드에서 변경 된 내용으로 인해 발생 한 예외를 catch 합니다."
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. This method is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/m-system.collections.que_3_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/m-system.collections.que_3_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/m-system.collections.que_3_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.que_3_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.que_3_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_3_2.vb)]"
  syntax:
    content: public static System.Collections.Queue Synchronized (System.Collections.Queue queue);
    parameters:
    - id: queue
      type: System.Collections.Queue
      description: "<xref href=&quot;System.Collections.Queue&quot;> </xref> 동기화 합니다."
    return:
      type: System.Collections.Queue
      description: "A <xref href=&quot;System.Collections.Queue&quot;> </xref> 래퍼를 동기화 (스레드로부터 안전함)."
  overload: System.Collections.Queue.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>queue</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.SyncRoot
  id: SyncRoot
  parent: System.Collections.Queue
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "에 대 한 액세스를 동기화 하는 데 사용할 수 있는 개체를 가져옵니다는 <xref href=&quot;System.Collections.Queue&quot;> </xref>합니다."
  remarks: "동기화 된 버전을 만들려면는 <xref:System.Collections.Queue>를 사용 하 여는 <xref:System.Collections.Queue.Synchronized%2A>메서드.</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue> 하지만 파생된 클래스의 동기화 된 버전을 제공할 수 있습니다는 <xref:System.Collections.Queue>SyncRoot 속성을 사용 하 여.</xref:System.Collections.Queue> 동기화 하는 코드의 SyncRoot에 대 한 작업을 수행 해야는 <xref:System.Collections.Queue>, <xref:System.Collections.Queue>.</xref:System.Collections.Queue> 으로 만들어지므로</xref:System.Collections.Queue> 이렇게 하면 다른 개체에서 파생 된 컬렉션의 적절 한 작업입니다. 특히, 동시에 수정할 수 있는 다른 스레드와 적절 한 동기화를 유지 관리는 <xref:System.Collections.Queue>개체입니다.</xref:System.Collections.Queue>       컬렉션을 열거 본질적으로 스레드로부터 안전한 프로시저가 아닙니다. 컬렉션이 동기화 되어 있을 때 다른 스레드에서 수 수정할 열거자에서 예외가 발생 하는 컬렉션입니다. 열거 동안 스레드 보안을 보장 하려면 전체 열거 동안 컬렉션을 잠글 하거나 다른 스레드에서 변경 된 내용으로 인해 발생 한 예외를 catch 합니다."
  example:
  - "The following code example shows how to lock the collection using the SyncRoot during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_1_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_1_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_1_1.vb)]"
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "에 대 한 액세스를 동기화 하는 데 사용할 수 있는 개체는 <xref href=&quot;System.Collections.Queue&quot;> </xref>합니다."
  overload: System.Collections.Queue.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.ToArray
  id: ToArray
  parent: System.Collections.Queue
  langs:
  - csharp
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "복사본의 <xref href=&quot;System.Collections.Queue&quot;> </xref> 요소를 새 배열입니다."
  remarks: "<xref:System.Collections.Queue>수정 되지 않습니다.</xref:System.Collections.Queue> 새 배열의 요소 순서의 시작 부분에서 요소의 순서와 같습니다는 <xref:System.Collections.Queue>끝.</xref:System.Collections.Queue>       이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_2_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_2_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_2_1.vb)]"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "새 배열에서 복사 된 요소를 포함 하는 <xref href=&quot;System.Collections.Queue&quot;> </xref>합니다."
  overload: System.Collections.Queue.ToArray*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.TrimToSize
  id: TrimToSize
  parent: System.Collections.Queue
  langs:
  - csharp
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "용량을 실제로 수의 요소는 <xref href=&quot;System.Collections.Queue&quot;> </xref>합니다."
  remarks: "새 요소가 더 이상 큐에 추가 될 경우 큐의 메모리 오버 헤드를 최소화할이 메서드를 사용할 수 있습니다.       다시 설정 하는 <xref:System.Collections.Queue>를 초기 상태로 호출는 <xref:System.Collections.Queue.Clear%2A>메서드 TrimToSize를 호출 하기 전에.</xref:System.Collections.Queue.Clear%2A> </xref:System.Collections.Queue> 빈 트리밍 <xref:System.Collections.Queue>의 용량 설정는 <xref:System.Collections.Queue>기본 용량을.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual void TrimToSize ();
    parameters: []
  overload: System.Collections.Queue.TrimToSize*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.Queue&quot;> </xref> 읽기 전용입니다."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArrayTypeMismatchException
  isExternal: true
  name: System.ArrayTypeMismatchException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Collections.Queue.#ctor
  parent: System.Collections.Queue
  isExternal: false
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Queue.#ctor(System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Collections.Queue.Clear
  parent: System.Collections.Queue
  isExternal: false
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
- uid: System.Collections.Queue.Clone
  parent: System.Collections.Queue
  isExternal: false
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
- uid: System.Collections.Queue.Contains(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Queue.Count
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
- uid: System.Collections.Queue.Dequeue
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
- uid: System.Collections.Queue.Enqueue(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
- uid: System.Collections.Queue.GetEnumerator
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Queue.IsSynchronized
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
- uid: System.Collections.Queue.Peek
  parent: System.Collections.Queue
  isExternal: false
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
- uid: System.Collections.Queue
  parent: System.Collections
  isExternal: false
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
- uid: System.Collections.Queue.SyncRoot
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
- uid: System.Collections.Queue.ToArray
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.Queue.TrimToSize
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
- uid: System.Collections.Queue.#ctor*
  parent: System.Collections.Queue
  isExternal: false
  name: Queue
  nameWithType: Queue.Queue
- uid: System.Collections.Queue.Clear*
  parent: System.Collections.Queue
  isExternal: false
  name: Clear
  nameWithType: Queue.Clear
- uid: System.Collections.Queue.Clone*
  parent: System.Collections.Queue
  isExternal: false
  name: Clone
  nameWithType: Queue.Clone
- uid: System.Collections.Queue.Contains*
  parent: System.Collections.Queue
  isExternal: false
  name: Contains
  nameWithType: Queue.Contains
- uid: System.Collections.Queue.CopyTo*
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo
  nameWithType: Queue.CopyTo
- uid: System.Collections.Queue.Count*
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
- uid: System.Collections.Queue.Dequeue*
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue
  nameWithType: Queue.Dequeue
- uid: System.Collections.Queue.Enqueue*
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue
  nameWithType: Queue.Enqueue
- uid: System.Collections.Queue.GetEnumerator*
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator
  nameWithType: Queue.GetEnumerator
- uid: System.Collections.Queue.IsSynchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
- uid: System.Collections.Queue.Peek*
  parent: System.Collections.Queue
  isExternal: false
  name: Peek
  nameWithType: Queue.Peek
- uid: System.Collections.Queue.Synchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized
  nameWithType: Queue.Synchronized
- uid: System.Collections.Queue.SyncRoot*
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
- uid: System.Collections.Queue.ToArray*
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray
  nameWithType: Queue.ToArray
- uid: System.Collections.Queue.TrimToSize*
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize
  nameWithType: Queue.TrimToSize
