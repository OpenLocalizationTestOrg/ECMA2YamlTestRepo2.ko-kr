### YamlMime:ManagedReference
items:
- uid: System.Security.RightsManagement.CryptoProvider
  id: CryptoProvider
  children:
  - System.Security.RightsManagement.CryptoProvider.BlockSize
  - System.Security.RightsManagement.CryptoProvider.BoundGrants
  - System.Security.RightsManagement.CryptoProvider.CanDecrypt
  - System.Security.RightsManagement.CryptoProvider.CanEncrypt
  - System.Security.RightsManagement.CryptoProvider.CanMergeBlocks
  - System.Security.RightsManagement.CryptoProvider.Decrypt(System.Byte[])
  - System.Security.RightsManagement.CryptoProvider.Dispose
  - System.Security.RightsManagement.CryptoProvider.Dispose(System.Boolean)
  - System.Security.RightsManagement.CryptoProvider.Encrypt(System.Byte[])
  - System.Security.RightsManagement.CryptoProvider.Finalize
  langs:
  - csharp
  name: CryptoProvider
  nameWithType: CryptoProvider
  fullName: System.Security.RightsManagement.CryptoProvider
  type: Class
  summary: "디지털 권한 관리 서비스를 암호화 및 해독할 보호 된 콘텐츠를 제공 합니다."
  remarks: "CryptoProvider는 <xref:System.Security.RightsManagement.UseLicense.Bind%2A>메서드는 권한 관리 <xref:System.Security.RightsManagement.UseLicense> <xref:System.Security.RightsManagement.SecureEnvironment>.</xref:System.Security.RightsManagement.SecureEnvironment> 에</xref:System.Security.RightsManagement.UseLicense> 바인딩할 때</xref:System.Security.RightsManagement.UseLicense.Bind%2A> 결과로 만들어집니다.       다른와 마찬가지로 <xref:System.Security.RightsManagement>형식의 CryptoProvider이 완전 신뢰 응용 프로그램에서 사용할 수만 있습니다.</xref:System.Security.RightsManagement>"
  example:
  - "The following example shows how to use the CryptoProvider class to create an <xref:System.IO.Packaging.EncryptedPackageEnvelope>.  \n  \n [!code-vb[RightsManagedPackagePublish#RmPkgPubEncrypt](~/add/codesnippet/visualbasic/rmpackagepublish/window1.xaml.vb#rmpkgpubencrypt)]\n [!code-cs[RightsManagedPackagePublish#RmPkgPubEncrypt](~/add/codesnippet/csharp/RmPackagePublish/Window1.xaml.cs#rmpkgpubencrypt)]"
  syntax:
    content: >-
      [System.Security.SecurityCritical(System.Security.SecurityCriticalScope.Everything)]

      public class CryptoProvider : IDisposable
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Security.RightsManagement.CryptoProvider.BlockSize
  id: BlockSize
  parent: System.Security.RightsManagement.CryptoProvider
  langs:
  - csharp
  name: BlockSize
  nameWithType: CryptoProvider.BlockSize
  fullName: System.Security.RightsManagement.CryptoProvider.BlockSize
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Security.RightsManagement
  summary: "암호화 블록 크기를 바이트 단위로 가져옵니다."
  remarks: "`clearText` 및 `cipherText` 에 전달 된 버퍼 <xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A>및 <xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A>n 여야 합니다 * BlockSize 바이트 길이가 여기서 &quot; n &quot;은 1 보다 크거나 정수입니다.</xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A> </xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A>       경우 <xref:System.Security.RightsManagement.CryptoProvider.CanMergeBlocks%2A>은 `false`, <xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A> <xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A>.</xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A> 에 전달 된 버퍼와 같은 길이 여야</xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A> 에 전달 된 버퍼</xref:System.Security.RightsManagement.CryptoProvider.CanMergeBlocks%2A>       경우 <xref:System.Security.RightsManagement.CryptoProvider.CanMergeBlocks%2A>은 `true`에 전달 된 버퍼 <xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A>에 전달 된 버퍼에서 다른 길이가 수 <xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A>(모든 버퍼 크기 여전히 있어야 길이 블록 크기를 바이트의 배수).</xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A> </xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A> </xref:System.Security.RightsManagement.CryptoProvider.CanMergeBlocks%2A>       1의 블록 크기는 암호화 스트림 암호; 임을 나타냅니다. 2 이상의 블록 크기는 블록 암호화를 나타냅니다."
  example:
  - "The following example shows how to use the BlockSize property in converting clear-text data to encrypted-text data.  \n  \n [!code-vb[RightsManagedContentPublish#RmContPubEncrypt](~/add/codesnippet/visualbasic/rmcontentpublish/window1.xaml.vb#rmcontpubencrypt)]\n [!code-cs[RightsManagedContentPublish#RmContPubEncrypt](~/add/codesnippet/csharp/RmContentPublish/Window1.xaml.cs#rmcontpubencrypt)]"
  syntax:
    content: public int BlockSize { get; }
    return:
      type: System.Int32
      description: "암호 블록 크기 (바이트)에서입니다.  에 대 한 기본 블록 크기 [!INCLUDE[TLA#tla_aes](~/add/includes/tlasharptla-aes-md.md)] 8입니다."
  overload: System.Security.RightsManagement.CryptoProvider.BlockSize*
  exceptions: []
  platform:
  - net462
- uid: System.Security.RightsManagement.CryptoProvider.BoundGrants
  id: BoundGrants
  parent: System.Security.RightsManagement.CryptoProvider
  langs:
  - csharp
  name: BoundGrants
  nameWithType: CryptoProvider.BoundGrants
  fullName: System.Security.RightsManagement.CryptoProvider.BoundGrants
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Security.RightsManagement
  summary: "확인에 통과 하 고 사용자에 게 부여 하는 권한을 나열 하는 컬렉션을 가져옵니다."
  remarks: ''
  example:
  - "The following example shows how to use the BoundGrants property to obtain a list rights granted through a <xref:System.Security.RightsManagement.UseLicense>.  \n  \n [!code-vb[RightsManagedContentViewer#RmContViewUseLicense](~/add/codesnippet/visualbasic/rmcontentviewer/window1.xaml.vb#rmcontviewuselicense)]\n [!code-cs[RightsManagedContentViewer#RmContViewUseLicense](~/add/codesnippet/csharp/RmContentViewer/Window1.xaml.cs#rmcontviewuselicense)]"
  syntax:
    content: public System.Collections.ObjectModel.ReadOnlyCollection<System.Security.RightsManagement.ContentGrant> BoundGrants { get; }
    return:
      type: System.Collections.ObjectModel.ReadOnlyCollection{System.Security.RightsManagement.ContentGrant}
      description: "확인 및를 전달 하는 권한을 열거 하는 컬렉션은 사용자에 게 부여 됩니다."
  overload: System.Security.RightsManagement.CryptoProvider.BoundGrants*
  exceptions: []
  platform:
  - net462
- uid: System.Security.RightsManagement.CryptoProvider.CanDecrypt
  id: CanDecrypt
  parent: System.Security.RightsManagement.CryptoProvider
  langs:
  - csharp
  name: CanDecrypt
  nameWithType: CryptoProvider.CanDecrypt
  fullName: System.Security.RightsManagement.CryptoProvider.CanDecrypt
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Security.RightsManagement
  summary: "사용자에 게 암호 해독 권한이 있는지 여부를 나타내는 값을 가져옵니다."
  remarks: "CanDecrypt 반환 **true** 경우는 <xref:System.Security.RightsManagement.UseLicense>이 바인딩된 <xref:System.Security.RightsManagement.CryptoProvider>보기, 편집, 인쇄 또는 소유자와 같은 읽기 액세스 권한을 사용자에 게 부여 합니다.</xref:System.Security.RightsManagement.CryptoProvider> </xref:System.Security.RightsManagement.UseLicense>"
  example:
  - "The following example shows how to use the CanDecrypt property to determine if decryption is allowed.  \n  \n [!code-vb[RightsManagedContentViewer#RmContViewUseLicense](~/add/codesnippet/visualbasic/rmcontentviewer/window1.xaml.vb#rmcontviewuselicense)]\n [!code-cs[RightsManagedContentViewer#RmContViewUseLicense](~/add/codesnippet/csharp/RmContentViewer/Window1.xaml.cs#rmcontviewuselicense)]"
  syntax:
    content: public bool CanDecrypt { get; }
    return:
      type: System.Boolean
      description: '**true** 경우는 <xref href=&quot;System.Security.RightsManagement.UseLicense&quot;> </xref> 해독; 사용자 권한을 부여, **false**합니다.'
  overload: System.Security.RightsManagement.CryptoProvider.CanDecrypt*
  exceptions: []
  platform:
  - net462
- uid: System.Security.RightsManagement.CryptoProvider.CanEncrypt
  id: CanEncrypt
  parent: System.Security.RightsManagement.CryptoProvider
  langs:
  - csharp
  name: CanEncrypt
  nameWithType: CryptoProvider.CanEncrypt
  fullName: System.Security.RightsManagement.CryptoProvider.CanEncrypt
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Security.RightsManagement
  summary: "사용자에 게 암호화 권한이 있는지 여부를 나타내는 값을 가져옵니다."
  remarks: "<xref:System.Security.RightsManagement.CryptoProvider.CanDecrypt%2A>반환 **true** 경우는 <xref:System.Security.RightsManagement.UseLicense>이 바인딩된 <xref:System.Security.RightsManagement.CryptoProvider>편집 또는 소유자와 같은 쓰기 액세스 권한을 사용자에 게 부여 합니다.</xref:System.Security.RightsManagement.CryptoProvider> </xref:System.Security.RightsManagement.UseLicense></xref:System.Security.RightsManagement.CryptoProvider.CanDecrypt%2A>"
  syntax:
    content: public bool CanEncrypt { get; }
    return:
      type: System.Boolean
      description: '**true** 경우는 <xref href=&quot;System.Security.RightsManagement.UseLicense&quot;> </xref> 암호화;에 대 한 사용자 권한을 부여, **false**합니다.'
  overload: System.Security.RightsManagement.CryptoProvider.CanEncrypt*
  exceptions: []
  platform:
  - net462
- uid: System.Security.RightsManagement.CryptoProvider.CanMergeBlocks
  id: CanMergeBlocks
  parent: System.Security.RightsManagement.CryptoProvider
  langs:
  - csharp
  name: CanMergeBlocks
  nameWithType: CryptoProvider.CanMergeBlocks
  fullName: System.Security.RightsManagement.CryptoProvider.CanMergeBlocks
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Security.RightsManagement
  summary: "나타내는 값을 가져옵니다 여부 <> </> *> 및 <> </> *> 다른 버퍼에에서 블록 크기 길이 사용할 수 있습니다."
  remarks: "`clearText` 및 `cipherText` 에 전달 된 버퍼 <xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A>및 <xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A>n 해야* <xref:System.Security.RightsManagement.CryptoProvider.BlockSize%2A> 바이트 길이가 여기서 &quot; n &quot;은 1 보다 크거나 정수입니다.</xref:System.Security.RightsManagement.CryptoProvider.BlockSize%2A> </xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A> </xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A>       CanMergeBlocks 이면 * *false**, <xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A> <xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A>.</xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A> 에 전달 된 버퍼와 같은 길이 여야</xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A> 에 전달 된 버퍼       CanMergeBlocks 이면 * *true**에 전달 된 버퍼 <xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A>에 전달 된 버퍼에서 길이가 다를 수 있습니다 <xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A>(모든 버퍼 크기의 배수 여야 여전히 <xref:System.Security.RightsManagement.CryptoProvider.BlockSize%2A>의 길이 바이트).</xref:System.Security.RightsManagement.CryptoProvider.BlockSize%2A> </xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A> </xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A>"
  syntax:
    content: public bool CanMergeBlocks { get; }
    return:
      type: System.Boolean
      description: '**true** 버퍼에 전달 하는 경우 <> </> *>에 전달 된 버퍼에서 길이가 다를 수 있습니다 <> </> *> 고, 그렇지 않으면, **false** 버퍼에 전달 하는 경우 <> </> *> 및 <> </> *> 동일한 길이 해당 해야 합니다.  에 대 한 [!INCLUDE[TLA#tla_aes](~/add/includes/tlasharptla-aes-md.md)] 기본값은 **true**합니다.'
  overload: System.Security.RightsManagement.CryptoProvider.CanMergeBlocks*
  exceptions: []
  platform:
  - net462
- uid: System.Security.RightsManagement.CryptoProvider.Decrypt(System.Byte[])
  id: Decrypt(System.Byte[])
  parent: System.Security.RightsManagement.CryptoProvider
  langs:
  - csharp
  name: Decrypt(Byte[])
  nameWithType: CryptoProvider.Decrypt(Byte[])
  fullName: System.Security.RightsManagement.CryptoProvider.Decrypt(Byte[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Security.RightsManagement
  summary: "텍스트를 일반 텍스트로 암호화를 해독 합니다."
  remarks: ''
  example:
  - "The following example shows how to use the Decrypt method to convert encrypted data to unencrypted data.  \n  \n [!code-vb[RightsManagedContentViewer#RmContViewDecrypt](~/add/codesnippet/visualbasic/rmcontentviewer/window1.xaml.vb#rmcontviewdecrypt)]\n [!code-cs[RightsManagedContentViewer#RmContViewDecrypt](~/add/codesnippet/csharp/RmContentViewer/Window1.xaml.cs#rmcontviewdecrypt)]"
  syntax:
    content: public byte[] Decrypt (byte[] cryptoText);
    parameters:
    - id: cryptoText
      type: System.Byte[]
      description: "해독할 암호화 텍스트입니다."
    return:
      type: System.Byte[]
      description: "암호 해독 된 일반 텍스트 <code> cryptoText </code>합니다."
  overload: System.Security.RightsManagement.CryptoProvider.Decrypt*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>cipherText</code>null입니다."
  - type: System.Security.RightsManagement.RightsManagementException
    commentId: T:System.Security.RightsManagement.RightsManagementException
    description: "암호 해독 권한이 허가 되지 않았습니다."
  platform:
  - net462
- uid: System.Security.RightsManagement.CryptoProvider.Dispose
  id: Dispose
  parent: System.Security.RightsManagement.CryptoProvider
  langs:
  - csharp
  name: Dispose()
  nameWithType: CryptoProvider.Dispose()
  fullName: System.Security.RightsManagement.CryptoProvider.Dispose()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Security.RightsManagement
  summary: "사용 하는 모든 리소스를 해제는 <xref href=&quot;System.Security.RightsManagement.CryptoProvider&quot;> </xref>합니다."
  remarks: "Dispose 수행 <xref:System.Security.RightsManagement.CryptoProvider.Dispose%2A>(~ / add/includes/ajax-current-ext-md.md).</xref:System.Security.RightsManagement.CryptoProvider.Dispose%2A>       <xref:System.Security.RightsManagement.CryptoProvider>.</xref:System.Security.RightsManagement.CryptoProvider> 를 사용 하 여 작업을 마쳤으면 Dispose를 호출 합니다. Dispose 메서드는 <xref:System.Security.RightsManagement.CryptoProvider>불안정 한 상태가.</xref:System.Security.RightsManagement.CryptoProvider> Dispose를 호출한 후에 대 한 모든 참조를 해제 해야는 <xref:System.Security.RightsManagement.CryptoProvider>가비지 수집기는 메모리를 회수할 수 있도록 하는 <xref:System.Security.RightsManagement.CryptoProvider>차지한.</xref:System.Security.RightsManagement.CryptoProvider> </xref:System.Security.RightsManagement.CryptoProvider> 자세한 내용은 참조 [관리 되지 않는 리소스 정리](~/add/includes/ajax-current-ext-md.md) 및 [Dispose 메서드를 구현](~/add/includes/ajax-current-ext-md.md)합니다.      > [!NOTE] > <xref:System.Security.RightsManagement.CryptoProvider>.</xref:System.Security.RightsManagement.CryptoProvider> 에 대 한 마지막 참조를 해제 하기 전에 항상 호출 삭제 사용 중인 리소스가 가비지 수집기 호출할 때까지 해제 되지 것입니다 그렇지 않은 경우는 <xref:System.Security.RightsManagement.CryptoProvider>개체의 `Finalize` 메서드.</xref:System.Security.RightsManagement.CryptoProvider>"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.Security.RightsManagement.CryptoProvider.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Security.RightsManagement.CryptoProvider.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Security.RightsManagement.CryptoProvider
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: CryptoProvider.Dispose(Boolean)
  fullName: System.Security.RightsManagement.CryptoProvider.Dispose(Boolean)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Security.RightsManagement
  summary: "사용 하는 관리 되지 않는 리소스를 해제는 <xref href=&quot;System.Security.RightsManagement.CryptoProvider&quot;> </xref> 관리 되는 리소스를 선택적으로 해제 합니다."
  remarks: "이 메서드는 public `Dispose()`메서드 및 <xref:System.Object.Finalize%2A>메서드.</xref:System.Object.Finalize%2A> `Dispose()`보호 된 호출 `Dispose(Boolean)` 메서드는 `disposing` 매개 변수 설정 `true`합니다. <xref:System.Object.Finalize%2A>호출 `Dispose` 와 `disposing` 로 설정 `false`합니다.</xref:System.Object.Finalize%2A>       경우는 `disposing` 매개 변수가 true 이면이 메서드는 관리 개체가 보유 하는 모든 리소스를 해제 합니다.이 <xref:System.Security.RightsManagement.CryptoProvider>참조.</xref:System.Security.RightsManagement.CryptoProvider> 이 메서드 호출에서 `Dispose()` 각 참조 된 개체의 메서드."
  syntax:
    content: protected virtual void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>관리 되는 관리 되지 않는 리소스만 해제 하려면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 만 관리 되지 않는 리소스를 해제 합니다."
  overload: System.Security.RightsManagement.CryptoProvider.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Security.RightsManagement.CryptoProvider.Encrypt(System.Byte[])
  id: Encrypt(System.Byte[])
  parent: System.Security.RightsManagement.CryptoProvider
  langs:
  - csharp
  name: Encrypt(Byte[])
  nameWithType: CryptoProvider.Encrypt(Byte[])
  fullName: System.Security.RightsManagement.CryptoProvider.Encrypt(Byte[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Security.RightsManagement
  summary: "일반 텍스트를 암호화 텍스트로 암호화 합니다."
  remarks: "바이트 길이 `clearText` 버퍼는 암호의 배수 여야 하며 <xref:System.Security.RightsManagement.CryptoProvider.BlockSize%2A>속성.</xref:System.Security.RightsManagement.CryptoProvider.BlockSize%2A>       디지털 권한 관리 시스템 사용 하 여 [!INCLUDE[TLA#tla_aes](~/add/includes/tlasharptla-aes-md.md)] 블록 암호화 합니다.  와 [!INCLUDE[TLA2#tla_aes](~/add/includes/tla2sharptla-aes-md.md)], 동일한 암호화 텍스트 결과 생성 되는 두 개의 블록의 동일한 일반 텍스트가 블록 독립적으로 암호화 됩니다.  독립적인 블록 암호화에서 잠재적인 암호 해독 위협을 최소화 하기 위해 응용 프로그램에는 동일한 일반 텍스트 블록이 암호화 되지 않게 압축 등의 콘텐츠를 수정 하는 방법을 사용 합니다."
  example:
  - "The following example shows how to use the Encrypt method to convert clear-text data to encrypted-text data.  \n  \n [!code-vb[RightsManagedContentPublish#RmContPubEncrypt](~/add/codesnippet/visualbasic/rmcontentpublish/window1.xaml.vb#rmcontpubencrypt)]\n [!code-cs[RightsManagedContentPublish#RmContPubEncrypt](~/add/codesnippet/csharp/RmContentPublish/Window1.xaml.cs#rmcontpubencrypt)]"
  syntax:
    content: public byte[] Encrypt (byte[] clearText);
    parameters:
    - id: clearText
      type: System.Byte[]
      description: "일반 텍스트 콘텐츠를 암호화 합니다."
    return:
      type: System.Byte[]
      description: "암호화 된 암호 텍스트는 주어진 <code> clearText </code>합니다."
  overload: System.Security.RightsManagement.CryptoProvider.Encrypt*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>clearText</code>null입니다."
  - type: System.Security.RightsManagement.RightsManagementException
    commentId: T:System.Security.RightsManagement.RightsManagementException
    description: "암호화 허용 되지 않습니다."
  platform:
  - net462
- uid: System.Security.RightsManagement.CryptoProvider.Finalize
  id: Finalize
  parent: System.Security.RightsManagement.CryptoProvider
  langs:
  - csharp
  name: Finalize()
  nameWithType: CryptoProvider.Finalize()
  fullName: System.Security.RightsManagement.CryptoProvider.Finalize()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Security.RightsManagement
  summary: "리소스를 해제 하 고 인스턴스가 가비지 수집에 의해 회수 되기 전에 내부 정리를 수행 합니다."
  remarks: "마무리 수행 <xref:System.Security.RightsManagement.CryptoProvider.Dispose%2A>(~ / add/includes/ajax-current-ext-md.md).</xref:System.Security.RightsManagement.CryptoProvider.Dispose%2A>       이 메서드를 재정의 <xref:System.Object.Finalize%2A>.</xref:System.Object.Finalize%2A> 응용 프로그램 코드,이 메서드를 호출 하지 않아야 개체의 `Finalize` 메서드를 호출 하 여 가비지 수집기의 종료를 사용 하지 않도록 설정 된 경우가 아니면 자동으로 가비지 수집 중 호출 됩니다는 <xref:System.GC.SuppressFinalize%2A>메서드.</xref:System.GC.SuppressFinalize%2A>       자세한 내용은 참조 [Finalize 메서드 및 소멸자](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70), [관리 되지 않는 리소스 정리](~/add/includes/ajax-current-ext-md.md), 및 [Finalize 메서드를 재정의](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)합니다."
  syntax:
    content: ~CryptoProvider ();
    parameters: []
  overload: System.Security.RightsManagement.CryptoProvider.Finalize*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Security.RightsManagement.RightsManagementException
  parent: System.Security.RightsManagement
  isExternal: false
  name: RightsManagementException
  nameWithType: RightsManagementException
  fullName: System.Security.RightsManagement.RightsManagementException
- uid: System.Security.RightsManagement.CryptoProvider.BlockSize
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: BlockSize
  nameWithType: CryptoProvider.BlockSize
  fullName: System.Security.RightsManagement.CryptoProvider.BlockSize
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Security.RightsManagement.CryptoProvider.BoundGrants
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: BoundGrants
  nameWithType: CryptoProvider.BoundGrants
  fullName: System.Security.RightsManagement.CryptoProvider.BoundGrants
- uid: System.Collections.ObjectModel.ReadOnlyCollection{System.Security.RightsManagement.ContentGrant}
  parent: System.Collections.ObjectModel
  isExternal: true
  name: ReadOnlyCollection<ContentGrant>
  nameWithType: ReadOnlyCollection<ContentGrant>
  fullName: System.Collections.ObjectModel.ReadOnlyCollection<System.Security.RightsManagement.ContentGrant>
  spec.csharp:
  - uid: System.Collections.ObjectModel.ReadOnlyCollection`1
    name: ReadOnlyCollection
    nameWithType: ReadOnlyCollection
    fullName: ReadOnlyCollection<System.Security.RightsManagement.ContentGrant>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Security.RightsManagement.ContentGrant
    name: ContentGrant
    nameWithType: ContentGrant
    fullName: ContentGrant
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Security.RightsManagement.CryptoProvider.CanDecrypt
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: CanDecrypt
  nameWithType: CryptoProvider.CanDecrypt
  fullName: System.Security.RightsManagement.CryptoProvider.CanDecrypt
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.RightsManagement.CryptoProvider.CanEncrypt
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: CanEncrypt
  nameWithType: CryptoProvider.CanEncrypt
  fullName: System.Security.RightsManagement.CryptoProvider.CanEncrypt
- uid: System.Security.RightsManagement.CryptoProvider.CanMergeBlocks
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: CanMergeBlocks
  nameWithType: CryptoProvider.CanMergeBlocks
  fullName: System.Security.RightsManagement.CryptoProvider.CanMergeBlocks
- uid: System.Security.RightsManagement.CryptoProvider.Decrypt(System.Byte[])
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: Decrypt(Byte[])
  nameWithType: CryptoProvider.Decrypt(Byte[])
  fullName: System.Security.RightsManagement.CryptoProvider.Decrypt(Byte[])
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Security.RightsManagement.CryptoProvider.Dispose
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: Dispose()
  nameWithType: CryptoProvider.Dispose()
  fullName: System.Security.RightsManagement.CryptoProvider.Dispose()
- uid: System.Security.RightsManagement.CryptoProvider.Dispose(System.Boolean)
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: CryptoProvider.Dispose(Boolean)
  fullName: System.Security.RightsManagement.CryptoProvider.Dispose(Boolean)
- uid: System.Security.RightsManagement.CryptoProvider.Encrypt(System.Byte[])
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: Encrypt(Byte[])
  nameWithType: CryptoProvider.Encrypt(Byte[])
  fullName: System.Security.RightsManagement.CryptoProvider.Encrypt(Byte[])
- uid: System.Security.RightsManagement.CryptoProvider.Finalize
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: Finalize()
  nameWithType: CryptoProvider.Finalize()
  fullName: System.Security.RightsManagement.CryptoProvider.Finalize()
- uid: System.Security.RightsManagement.CryptoProvider.BlockSize*
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: BlockSize
  nameWithType: CryptoProvider.BlockSize
- uid: System.Security.RightsManagement.CryptoProvider.BoundGrants*
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: BoundGrants
  nameWithType: CryptoProvider.BoundGrants
- uid: System.Security.RightsManagement.CryptoProvider.CanDecrypt*
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: CanDecrypt
  nameWithType: CryptoProvider.CanDecrypt
- uid: System.Security.RightsManagement.CryptoProvider.CanEncrypt*
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: CanEncrypt
  nameWithType: CryptoProvider.CanEncrypt
- uid: System.Security.RightsManagement.CryptoProvider.CanMergeBlocks*
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: CanMergeBlocks
  nameWithType: CryptoProvider.CanMergeBlocks
- uid: System.Security.RightsManagement.CryptoProvider.Decrypt*
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: Decrypt
  nameWithType: CryptoProvider.Decrypt
- uid: System.Security.RightsManagement.CryptoProvider.Dispose*
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: Dispose
  nameWithType: CryptoProvider.Dispose
- uid: System.Security.RightsManagement.CryptoProvider.Encrypt*
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: Encrypt
  nameWithType: CryptoProvider.Encrypt
- uid: System.Security.RightsManagement.CryptoProvider.Finalize*
  parent: System.Security.RightsManagement.CryptoProvider
  isExternal: false
  name: Finalize
  nameWithType: CryptoProvider.Finalize
