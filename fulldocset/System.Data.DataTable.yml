### YamlMime:ManagedReference
items:
- uid: System.Data.DataTable
  id: DataTable
  children:
  - System.Data.DataTable.#ctor
  - System.Data.DataTable.#ctor(System.String)
  - System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataTable.#ctor(System.String,System.String)
  - System.Data.DataTable.AcceptChanges
  - System.Data.DataTable.BeginInit
  - System.Data.DataTable.BeginLoadData
  - System.Data.DataTable.CaseSensitive
  - System.Data.DataTable.ChildRelations
  - System.Data.DataTable.Clear
  - System.Data.DataTable.Clone
  - System.Data.DataTable.ColumnChanged
  - System.Data.DataTable.ColumnChanging
  - System.Data.DataTable.Columns
  - System.Data.DataTable.Compute(System.String,System.String)
  - System.Data.DataTable.Constraints
  - System.Data.DataTable.Copy
  - System.Data.DataTable.CreateDataReader
  - System.Data.DataTable.CreateInstance
  - System.Data.DataTable.DataSet
  - System.Data.DataTable.DefaultView
  - System.Data.DataTable.DisplayExpression
  - System.Data.DataTable.EndInit
  - System.Data.DataTable.EndLoadData
  - System.Data.DataTable.ExtendedProperties
  - System.Data.DataTable.fInitInProgress
  - System.Data.DataTable.GetChanges
  - System.Data.DataTable.GetChanges(System.Data.DataRowState)
  - System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)
  - System.Data.DataTable.GetErrors
  - System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataTable.GetRowType
  - System.Data.DataTable.GetSchema
  - System.Data.DataTable.HasErrors
  - System.Data.DataTable.ImportRow(System.Data.DataRow)
  - System.Data.DataTable.Initialized
  - System.Data.DataTable.IsInitialized
  - System.Data.DataTable.Load(System.Data.IDataReader)
  - System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)
  - System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)
  - System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)
  - System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)
  - System.Data.DataTable.Locale
  - System.Data.DataTable.Merge(System.Data.DataTable)
  - System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)
  - System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  - System.Data.DataTable.MinimumCapacity
  - System.Data.DataTable.Namespace
  - System.Data.DataTable.NewRow
  - System.Data.DataTable.NewRowArray(System.Int32)
  - System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)
  - System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)
  - System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)
  - System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  - System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)
  - System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)
  - System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)
  - System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)
  - System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)
  - System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)
  - System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)
  - System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)
  - System.Data.DataTable.ParentRelations
  - System.Data.DataTable.Prefix
  - System.Data.DataTable.PrimaryKey
  - System.Data.DataTable.ReadXml(System.IO.Stream)
  - System.Data.DataTable.ReadXml(System.IO.TextReader)
  - System.Data.DataTable.ReadXml(System.String)
  - System.Data.DataTable.ReadXml(System.Xml.XmlReader)
  - System.Data.DataTable.ReadXmlSchema(System.IO.Stream)
  - System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)
  - System.Data.DataTable.ReadXmlSchema(System.String)
  - System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)
  - System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)
  - System.Data.DataTable.RejectChanges
  - System.Data.DataTable.RemotingFormat
  - System.Data.DataTable.Reset
  - System.Data.DataTable.RowChanged
  - System.Data.DataTable.RowChanging
  - System.Data.DataTable.RowDeleted
  - System.Data.DataTable.RowDeleting
  - System.Data.DataTable.Rows
  - System.Data.DataTable.Select
  - System.Data.DataTable.Select(System.String)
  - System.Data.DataTable.Select(System.String,System.String)
  - System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)
  - System.Data.DataTable.Site
  - System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection
  - System.Data.DataTable.System#ComponentModel#IListSource#GetList
  - System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema
  - System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  - System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  - System.Data.DataTable.TableCleared
  - System.Data.DataTable.TableClearing
  - System.Data.DataTable.TableName
  - System.Data.DataTable.TableNewRow
  - System.Data.DataTable.ToString
  - System.Data.DataTable.WriteXml(System.IO.Stream)
  - System.Data.DataTable.WriteXml(System.IO.TextWriter)
  - System.Data.DataTable.WriteXml(System.String)
  - System.Data.DataTable.WriteXml(System.Xml.XmlWriter)
  - System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)
  - System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  - System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)
  - System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  - System.Data.DataTable.WriteXml(System.String,System.Boolean)
  - System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)
  - System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)
  - System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  - System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)
  - System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)
  - System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)
  - System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)
  - System.Data.DataTable.WriteXmlSchema(System.IO.Stream)
  - System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)
  - System.Data.DataTable.WriteXmlSchema(System.String)
  - System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)
  - System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)
  - System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)
  - System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)
  - System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)
  langs:
  - csharp
  name: DataTable
  nameWithType: DataTable
  fullName: System.Data.DataTable
  type: Class
  summary: "메모리 내 데이터의 한 테이블을 나타냅니다."
  remarks: "DataTable은 ADO.NET 라이브러리는 중앙 개체입니다. DataTable을 사용 하는 다른 개체를 포함 <xref:System.Data.DataSet>하 고 있는 <xref:System.Data.DataView>.</xref:System.Data.DataView> </xref:System.Data.DataSet>       DataTable 개체에 액세스할 때 조건에 따라 대/소문자 구분 되는지 note 합니다. 예를 들어 하나의 DataTable &quot;mydatatable&quot; 라고 하는 경우 &quot;Mydatatable&quot; 라는 다른 테이블 중 하나를 검색 하는 데 사용 하는 문자열은 대/소문자 구분로 간주 됩니다. 그러나 &quot;mydatatable&quot; 있으며 &quot;Mydatatable&quot; 하지 않는 경우 검색 문자열 소문자 간주 됩니다. A <xref:System.Data.DataSet>동일한 두 개의 DataTable 개체를 포함할 수 <xref:System.Data.DataTable.TableName%2A>속성 값은 다른 <xref:System.Data.DataTable.Namespace%2A>속성 값.</xref:System.Data.DataTable.Namespace%2A> </xref:System.Data.DataTable.TableName%2A> </xref:System.Data.DataSet> DataTable 개체를 사용 하는 방법에 대 한 자세한 내용은 참조 [DataTable 만들기](~/add/includes/ajax-current-ext-md.md)합니다.       추가 하 여 해당 스키마를 먼저 정의 해야 DataTable을 프로그래밍 방식으로 만들려는 경우 <xref:System.Data.DataColumn>개체는 <xref:System.Data.DataColumnCollection>(통해 액세스는 <xref:System.Data.DataTable.Columns%2A>속성).</xref:System.Data.DataTable.Columns%2A> </xref:System.Data.DataColumnCollection> </xref:System.Data.DataColumn> 추가 하는 방법에 대 한 자세한 내용은 <xref:System.Data.DataColumn>개체 참조 [DataTable에 열 추가](~/add/includes/ajax-current-ext-md.md).</xref:System.Data.DataColumn>       DataTable에 행을 추가 하려면 먼저 사용 해야는 <xref:System.Data.DataTable.NewRow%2A>새 반환 하는 메서드 <xref:System.Data.DataRow>개체입니다.</xref:System.Data.DataRow> </xref:System.Data.DataTable.NewRow%2A> <xref:System.Data.DataTable.NewRow%2A>테이블의 <xref:System.Data.DataColumnCollection>.</xref:System.Data.DataColumnCollection> 에 의해 정의 된 대로 메서드는 데이터 테이블의 스키마와 함께 행을 반환</xref:System.Data.DataTable.NewRow%2A> DataTable을 저장할 수 있는 행의 최대는 16777216 합니다. 자세한 내용은 참조 [DataTable에 데이터 추가](~/add/includes/ajax-current-ext-md.md)합니다.       DataTable에는 또한 컬렉션을 포함 <xref:System.Data.Constraint>데이터의 무결성을 보장 하는 데 사용할 수 있습니다.</xref:System.Data.Constraint> 자세한 내용은 참조 [DataTable 제약 조건](~/add/includes/ajax-current-ext-md.md)합니다.       테이블에 변경 내용이 시기를 결정 하는 데 사용할 수 있는 많은 DataTable 이벤트가 있습니다. 여기에 <xref:System.Data.DataTable.RowChanged>, <xref:System.Data.DataTable.RowChanging>, <xref:System.Data.DataTable.RowDeleting>, 및 <xref:System.Data.DataTable.RowDeleted>.</xref:System.Data.DataTable.RowDeleted> </xref:System.Data.DataTable.RowDeleting> </xref:System.Data.DataTable.RowChanging> </xref:System.Data.DataTable.RowChanged> DataTable에 사용할 수 있는 이벤트에 대 한 자세한 내용은 참조 [DataTable 이벤트 처리](~/add/includes/ajax-current-ext-md.md)합니다.       DataTable의 인스턴스를 만들 때 읽기/쓰기 속성 중 일부를 초기 값으로 설정 됩니다. 이러한 값의 목록에 대 한 참조는 <xref:System.Data.DataTable.%23ctor%2A?displayProperty=fullName>생성자 항목.</xref:System.Data.DataTable.%23ctor%2A?displayProperty=fullName>      > [!NOTE] >는 <xref:System.Data.DataSet>DataTable 개체에서 상속 <xref:System.ComponentModel.MarshalByValueComponent>, 및 지원에서 <xref:System.Runtime.Serialization.ISerializable>.NET Framework remoting에 대 한 인터페이스입니다.</xref:System.Runtime.Serialization.ISerializable> </xref:System.ComponentModel.MarshalByValueComponent> </xref:System.Data.DataSet> 이들은.NET Framework remoting에 사용할 수 있는 유일한 ADO.NET 개체입니다."
  example:
  - "The following example creates two DataTable objects and one <xref:System.Data.DataRelation> object, and adds the new objects to a <xref:System.Data.DataSet>. The tables are then displayed in a <xref:System.Windows.Forms.DataGridView> control.  \n  \n [!code-vb[Classic WebData DataTable Example#1](~/add/codesnippet/visualbasic/t-system.data.datatable_1.vb)]\n [!code-cs[Classic WebData DataTable Example#1](~/add/codesnippet/csharp/t-system.data.datatable_1.cs)]  \n  \n This sample demonstrates how to create a DataTable manually with specific schema definitions:  \n  \n-   Create multiple DataTables and define the initial columns.  \n  \n-   Create the table constraints.  \n  \n-   Insert the values and display the tables.  \n  \n-   Create the expression columns and display the tables.  \n  \n C# and Visual Basic projects with this code sample can be found on [Developer Code Samples](http://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914).  \n  \n [!code-cs[Classic WebData DataTable Example2#1](~/add/codesnippet/csharp/t-system.data.datatable_2.cs)]\n [!code-vb[Classic WebData DataTable Example2#1](~/add/codesnippet/visualbasic/t-system.data.datatable_2.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("RowChanging")]

      [System.ComponentModel.DefaultProperty("TableName")]

      [System.ComponentModel.DesignTimeVisible(false)]

      [System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.ComponentModel.ToolboxItem(false)]

      [System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")]

      public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable
  inheritance:
  - System.Object
  - System.ComponentModel.MarshalByValueComponent
  implements:
  - System.ComponentModel.IListSource
  - System.ComponentModel.ISupportInitializeNotification
  - System.Runtime.Serialization.ISerializable
  - System.Xml.Serialization.IXmlSerializable
  inheritedMembers:
  - System.ComponentModel.MarshalByValueComponent.Container
  - System.ComponentModel.MarshalByValueComponent.DesignMode
  - System.ComponentModel.MarshalByValueComponent.Dispose
  - System.ComponentModel.MarshalByValueComponent.Dispose(System.Boolean)
  - System.ComponentModel.MarshalByValueComponent.Disposed
  - System.ComponentModel.MarshalByValueComponent.Events
  - System.ComponentModel.MarshalByValueComponent.GetService(System.Type)
  platform:
  - net462
- uid: System.Data.DataTable.#ctor
  id: '#ctor'
  parent: System.Data.DataTable
  langs:
  - csharp
  name: DataTable()
  nameWithType: DataTable.DataTable()
  fullName: System.Data.DataTable.DataTable()
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 인수가 없는 클래스입니다."
  remarks: "모든 속성에 대 한 초기 값을 설정 하는 생성자는 <xref:System.Data.DataTable>개체입니다.</xref:System.Data.DataTable> 다음 표에서 속성 및 기본값을 보여 줍니다. 인스턴스가 <xref:System.Data.DataTable>만들어지면 다음 읽기/쓰기 속성은 초기 값으로 설정 됩니다.</xref:System.Data.DataTable>      | 속성 | 기본 값 |   |--------------|-------------------|   | **CaseSensitive**| 부모와 동일한 <xref:System.Data.DataSet>하나에 속하게 하는 경우.</xref:System.Data.DataSet> 그렇지 않으면 `false`. |   | **DisplayExpression**| 빈 문자열 (&quot;&quot;) |   | **Locale**| <xref:System.Data.DataSet>부모와 동일한 개체의 <xref:System.Globalization.CultureInfo>( <xref:System.Data.DataSet.Locale%2A>속성으로 반환 됨); 기본값은 현재 시스템 <xref:System.Globalization.CultureInfo>부모가 없으면. |   | **Minimumcapacity는**|&50; 개 행입니다. |       속성에 대 한 별도 호출을 통해 이러한 속성에 대 한 값을 변경할 수 있습니다.</xref:System.Globalization.CultureInfo> </xref:System.Data.DataSet.Locale%2A> </xref:System.Globalization.CultureInfo> </xref:System.Data.DataSet>"
  example:
  - "The following example creates a new <xref:System.Data.DataTable> with <xref:System.Data.DataColumn> and <xref:System.Data.DataRow>, and displays it in a <xref:System.Windows.Forms.DataGridView> control.  \n  \n [!code-vb[Classic WebData DataTable.DataTable Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._0_1.vb)]\n [!code-cs[Classic WebData DataTable.DataTable Example#1](~/add/codesnippet/csharp/m-system.data.datatable._0_1.cs)]"
  syntax:
    content: public DataTable ();
    parameters: []
  overload: System.Data.DataTable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Data.DataTable
  langs:
  - csharp
  name: DataTable(String)
  nameWithType: DataTable.DataTable(String)
  fullName: System.Data.DataTable.DataTable(String)
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 지정한 테이블 이름 사용 합니다."
  remarks: ''
  example:
  - "The following example creates a <xref:System.Data.DataTable> and displays it in a <xref:System.Windows.Forms.DataGridView> control.  \n  \n [!code-cs[Classic WebData DataTable.DataTable1 Example#1](~/add/codesnippet/csharp/m-system.data.datatable._21_1.cs)]\n [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._21_1.vb)]"
  syntax:
    content: public DataTable (string tableName);
    parameters:
    - id: tableName
      type: System.String
      description: "테이블에 대 한 이름입니다. 경우 `tableName` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 또는 빈 문자열인 경우에 추가 될 때 기본 이름이 지정 되는 <xref href=&quot;System.Data.DataTableCollection&quot;> </xref>합니다."
  overload: System.Data.DataTable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: '#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)'
  parent: System.Data.DataTable
  langs:
  - csharp
  name: DataTable(SerializationInfo,StreamingContext)
  nameWithType: DataTable.DataTable(SerializationInfo,StreamingContext)
  fullName: System.Data.DataTable.DataTable(SerializationInfo,StreamingContext)
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 클래스와 <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> 및 <xref:System.Runtime.Serialization.StreamingContext>.</xref:System.Runtime.Serialization.StreamingContext>"
  remarks: "이 구현은 하는 <xref:System.Data.DataTable>생성자가 <xref:System.Runtime.Serialization.ISerializable>.</xref:System.Runtime.Serialization.ISerializable> 필요</xref:System.Data.DataTable>"
  syntax:
    content: protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "Serialize 하거나 개체를 역직렬화 하는 데 필요한 데이터입니다."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "원본 및 대상 지정 된 직렬화 된 스트림의 합니다."
  overload: System.Data.DataTable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Data.DataTable
  langs:
  - csharp
  name: DataTable(String,String)
  nameWithType: DataTable.DataTable(String,String)
  fullName: System.Data.DataTable.DataTable(String,String)
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 클래스 지정한 테이블 이름 및 네임 스페이스를 사용 합니다."
  syntax:
    content: public DataTable (string tableName, string tableNamespace);
    parameters:
    - id: tableName
      type: System.String
      description: "테이블에 대 한 이름입니다. 경우 `tableName` 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 또는 빈 문자열인 경우에 추가 될 때 기본 이름이 지정 되는 <xref href=&quot;System.Data.DataTableCollection&quot;> </xref>합니다."
    - id: tableNamespace
      type: System.String
      description: "에 저장 된 데이터의 XML 표현에 대 한 네임 스페이스는 <xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataTable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.AcceptChanges
  id: AcceptChanges
  parent: System.Data.DataTable
  langs:
  - csharp
  name: AcceptChanges()
  nameWithType: DataTable.AcceptChanges()
  fullName: System.Data.DataTable.AcceptChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "마지막으로 AcceptChanges가 호출 된 이후이 테이블에 대 한 모든 변경 내용을 커밋합니다."
  remarks: "AcceptChanges 호출 될 때 모든 <xref:System.Data.DataRow>아직 편집 모드에에서는 개체의 편집을 성공적으로 종료 합니다.</xref:System.Data.DataRow> <xref:System.Data.DataRowState>설치 경로도 변경: 모든 `Added` 및 `Modified` 될 행 `Unchanged`, 및 `Deleted` 행이 제거 됩니다.</xref:System.Data.DataRowState>       일반적으로 AcceptChanges 메서드가 호출 되는 <xref:System.Data.DataTable>후 업데이트 하 려 하면는 <xref:System.Data.DataSet>를 사용 하 여는 <xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=fullName>메서드.</xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=fullName> </xref:System.Data.DataSet> </xref:System.Data.DataTable>"
  example:
  - "The following example tests each table for errors. If the table's errors can be reconciled (by passing it to an undefined function), AcceptChanges is called; otherwise, <xref:System.Data.DataTable.RejectChanges%2A> is called.  \n  \n [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._22_1.vb)]\n [!code-cs[Classic WebData DataTable.AcceptChanges Example#1](~/add/codesnippet/csharp/m-system.data.datatable._22_1.cs)]"
  syntax:
    content: public void AcceptChanges ();
    parameters: []
  overload: System.Data.DataTable.AcceptChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.BeginInit
  id: BeginInit
  parent: System.Data.DataTable
  langs:
  - csharp
  name: BeginInit()
  nameWithType: DataTable.BeginInit()
  fullName: System.Data.DataTable.BeginInit()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "초기화를 시작는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 폼에 사용 되거나 다른 구성 요소에서 사용 하 합니다. 초기화는 런타임에 발생 합니다."
  remarks: "Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소 초기화를 시작 합니다. <xref:System.Data.DataTable.EndInit%2A>메서드 초기화를 끝냅니다.</xref:System.Data.DataTable.EndInit%2A> BeginInit를 사용 하 여 및 <xref:System.Data.DataTable.EndInit%2A>메서드는 컨트롤이 완전히 초기화 되기 전에 사용 되지 않습니다.</xref:System.Data.DataTable.EndInit%2A>"
  syntax:
    content: public virtual void BeginInit ();
    parameters: []
  overload: System.Data.DataTable.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.BeginLoadData
  id: BeginLoadData
  parent: System.Data.DataTable
  langs:
  - csharp
  name: BeginLoadData()
  nameWithType: DataTable.BeginLoadData()
  fullName: System.Data.DataTable.BeginLoadData()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "데이터를 로드 하는 동안 알림, 인덱스 유지 관리 및 제약 조건 해제 합니다."
  remarks: "BeginLoadData <xref:System.Data.DataTable.LoadDataRow%2A>및 <xref:System.Data.DataTable.EndLoadData%2A>.</xref:System.Data.DataTable.EndLoadData%2A> </xref:System.Data.DataTable.LoadDataRow%2A> 와 함께에서 사용 하 여"
  syntax:
    content: public void BeginLoadData ();
    parameters: []
  overload: System.Data.DataTable.BeginLoadData*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.CaseSensitive
  id: CaseSensitive
  parent: System.Data.DataTable
  langs:
  - csharp
  name: CaseSensitive
  nameWithType: DataTable.CaseSensitive
  fullName: System.Data.DataTable.CaseSensitive
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "테이블 내에서 문자열 비교는 대/소문자 구분 여부를 나타냅니다."
  remarks: "CaseSensitive 속성 정렬, 검색 및 필터링에 대 한 문자열 비교를 영향을 줍니다."
  example:
  - "The following example calls the <xref:System.Data.DataTable.Select%2A> method twice on a <xref:System.Data.DataTable>. The first time, the CaseSensitive property is set to `false`, the second, to `true`.  \n  \n [!code-cs[Classic WebData DataTable.CaseSensitive Example#1](~/add/codesnippet/csharp/p-system.data.datatable._0_1.cs)]\n [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._0_1.vb)]"
  syntax:
    content: public bool CaseSensitive { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>비교는 대/소문자 구분; 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 parent로 설정 된 <xref href=&quot;System.Data.DataSet&quot;> </xref> 개체의 <xref:System.Data.DataSet.CaseSensitive*>속성을 또는 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 경우는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 와 독립적으로 만들어진는 <xref href=&quot;System.Data.DataSet&quot;> </xref>.</xref:System.Data.DataSet.CaseSensitive*>"
  overload: System.Data.DataTable.CaseSensitive*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ChildRelations
  id: ChildRelations
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ChildRelations
  nameWithType: DataTable.ChildRelations
  fullName: System.Data.DataTable.ChildRelations
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 대 한 자식 관계의 컬렉션을 가져옵니다 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  remarks: 'A <xref:System.Data.DataRelation>두 테이블 간의 관계를 정의 합니다.</xref:System.Data.DataRelation> 일반적으로 두 테이블은 동일한 데이터를 포함 하는 단일 필드를 통해 연결 됩니다. 예를 들어 주소 데이터를 포함 하는 테이블에는 국가/지역을 나타내는 코드를 포함 하는 단일 필드가 있을 수 있습니다. 국가/지역 데이터를 포함 하는 두 번째 테이블에서 국가/지역을 식별 하는 코드를 포함 하는 단일 필드 있으며이 코드가 첫 번째 테이블의 해당 필드에 삽입 됩니다. A <xref:System.Data.DataRelation>, 그런 다음 최소한 다음&4; 가지 정보를 포함: (1) 첫 번째 테이블의 이름, 첫 번째 테이블의 열 이름 (2), (3) 두 번째 테이블의 이름 및 (4) 두 번째 테이블의 열 이름입니다.</xref:System.Data.DataRelation>'
  example:
  - "The following example uses the ChildRelations property to return each child <xref:System.Data.DataRelation> in a <xref:System.Data.DataTable>. Each relation is then used as an argument in the <xref:System.Data.DataRow.GetChildRows%2A> method of the <xref:System.Data.DataRow> to return an array of rows. The value of each column in the row is then printed.  \n  \n [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._13_1.vb)]\n [!code-cs[Classic WebData DataTable.ChildRelations Example#1](~/add/codesnippet/csharp/p-system.data.datatable._13_1.cs)]"
  syntax:
    content: public System.Data.DataRelationCollection ChildRelations { get; }
    return:
      type: System.Data.DataRelationCollection
      description: "A <xref href=&quot;System.Data.DataRelationCollection&quot;> </xref> 테이블에 대 한 자식 관계를 포함 하 합니다. 없는 경우에 빈 컬렉션이 반환 됩니다 <xref href=&quot;System.Data.DataRelation&quot;> </xref> 개체가 존재 합니다."
  overload: System.Data.DataTable.ChildRelations*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Clear
  id: Clear
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Clear()
  nameWithType: DataTable.Clear()
  fullName: System.Data.DataTable.Clear()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "지웁니다는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 의 모든 데이터입니다."
  remarks: "모든 테이블의 모든 행이 제거 됩니다. 테이블에 자식 관계가 적용된 해야 하는 자식 행이 분리 될 경우 예외가 생성 됩니다.       경우 <xref:System.Data.DataSet>에 <xref:System.Xml.XmlDataDocument>, 호출 <xref:System.Data.DataSet.Clear%2A?displayProperty=fullName>하거나 선택 취소 <xref:System.NotSupportedException>.</xref:System.NotSupportedException> 를 발생 시킵니다.</xref:System.Data.DataSet.Clear%2A?displayProperty=fullName> </xref:System.Xml.XmlDataDocument> 바인딩된</xref:System.Data.DataSet> 이러한 상황을 방지 하려면 한 번에 하나씩 행을 제거, 각 테이블을 이동 합니다. 사용 하는 경우 <xref:System.Data.DataTable.NewRow%2A>새 행을 만들려면는 행을 처리 해야 지우기 호출 하기 전에.</xref:System.Data.DataTable.NewRow%2A>"
  example:
  - "The following example clears the table of all data.  \n  \n [!code-cs[Classic WebData DataTable.Clear Example#1](~/add/codesnippet/csharp/m-system.data.datatable._20_1.cs)]\n [!code-vb[Classic WebData DataTable.Clear Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._20_1.vb)]"
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.Data.DataTable.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Clone
  id: Clone
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Clone()
  nameWithType: DataTable.Clone()
  fullName: System.Data.DataTable.Clone()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "구조를 복제 하는 <xref href=&quot;System.Data.DataTable&quot;> </xref>, 모든 포함 하 여 <xref href=&quot;System.Data.DataTable&quot;> </xref> 스키마 및 제약 조건입니다."
  remarks: "이러한 클래스를 파생 된 경우 동일한 파생된 클래스가 복제가 됩니다.       복제 대상을 새 <xref:System.Data.DataTable>원본과 같은 구조와 <xref:System.Data.DataTable>, 하지만 모든 데이터를 복사 하지 않습니다 (새 <xref:System.Data.DataTable>포함 되지 것입니다 `DataRows`).</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataTable> 에는 새 <xref:System.Data.DataTable> <xref:System.Data.DataTable.Copy%2A>.</xref:System.Data.DataTable.Copy%2A> 를 사용 하 여</xref:System.Data.DataTable> 구조와 데이터를 복사 하려면"
  example:
  - "The following sample demonstrates how to update the structure and constraints of the destination table after you execute DataTable.Clone. The ClonedDataTable class will return a destination table and includes all the updating events. After the clone, structure changes in the source table won’t be reflected in the destination table. Specifically, this sample will:  \n  \n-   Update the changes of the columns in source table.  \n  \n-   Update the changes of the UniqueConstraint in source table.  \n  \n-   Update the changes of the ForeignKeyConstraint in source table.  \n  \n C# and Visual Basic projects with this code sample can be found on [Developer Code Samples](http://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable).  \n  \n```  \nusing System;  \nusing System.Linq;  \nusing System.Data;  \nusing System.ComponentModel;  \n  \nclass Program {  \n   static void Main(string[] args) {  \n      DataTable courses = NewCourseDataTable();  \n      Console.WriteLine(\"This is the source table:\");  \n      WriteDataTable(courses);  \n  \n      ClonedDataTable clonedResult = new ClonedDataTable(courses);  \n      DataTable clonedCourses = clonedResult.DestinationTable;  \n      Console.WriteLine(\"This is the destination table:\");  \n      WriteDataTable(clonedCourses);  \n  \n      // Add the events of updating column collection into the source table.  \n      clonedResult.UpdateAddedColumn();  \n      clonedResult.UpdateDeletedColumn();  \n      // Add a DataColumn in source table.  \n      DataColumn columnCreidts = new DataColumn(\"Credits\", typeof(Int32));  \n      courses.Columns.Add(columnCreidts);  \n      Console.WriteLine(\"After add a column in source table, it's the result in the destination:\");  \n      WriteDataTable(clonedCourses);  \n  \n      // Add the event of updating UniqueConstraint into the source table.  \n      clonedResult.UpdateUniqueConstraint();  \n  \n      // Add the unique constraint in source table.  \n      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns[\"CourseId\"]);  \n      courses.Constraints.Add(uniqueConstraint);  \n  \n      Console.WriteLine(@\"If we add the unique constraint in source table and then insert the duplicate   \nrows into the destination table, we will get the following error:\");  \n      InsertDuplicateData(clonedCourses);  \n      Console.WriteLine();  \n  \n      // Add the event of updating ForeignKeyConstraint into the source table.  \n      clonedResult.UpdateForeignKeyConstraint();  \n  \n      // Add the ForeignKeyConstraint into the source table.  \n      DataTable deparments = NewDeparmentDataTable();  \n      DataSet dataset = new DataSet();  \n  \n      dataset.Tables.Add(courses);  \n      dataset.Tables.Add(clonedCourses);  \n      dataset.Tables.Add(deparments);  \n  \n      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns[\"DepartmentId\"], courses.Columns[\"DepartmentId\"]);  \n      courses.Constraints.Add(foreignKey);  \n  \n      Console.WriteLine(@\"If we add the foreign key constraint in source table and then insert a row   \nwithout the parent  into the destination table, we will get the following error:\");  \n      InsertNoParentRow(clonedCourses);  \n      Console.WriteLine();  \n  \n      Console.WriteLine(\"Please press any key to exit...\");  \n      Console.ReadKey();  \n   }  \n  \n   static private DataTable NewCourseDataTable() {  \n      DataTable newTable = new DataTable();  \n  \n      DataColumn[] columns ={   \n                                      new DataColumn(\"CourseId\", typeof(String)),  \n                                      new DataColumn(\"CourseName\",typeof(String)),                                        \n                                      new DataColumn(\"DepartmentId\", typeof(Int32))  \n                                  };  \n  \n      newTable.Columns.AddRange(columns);  \n  \n      newTable.Rows.Add(\"C1045\", \"Calculus\", 7);  \n      newTable.Rows.Add(\"C1061\", \"Physics\", 1);  \n      newTable.Rows.Add(\"C2021\", \"Composition\", 2);  \n      newTable.Rows.Add(\"C2042\", \"Literature\", 2);  \n  \n      return newTable;  \n   }  \n  \n   static private DataTable NewDeparmentDataTable() {  \n      DataTable newTable = new DataTable();  \n  \n      DataColumn[] columns ={   \n                                      new DataColumn(\"DepartmentId\", typeof(Int32)),  \n                                      new DataColumn(\"Name\",typeof(String)),  \n                                  };  \n  \n      newTable.Columns.AddRange(columns);  \n  \n      newTable.Rows.Add(1, \"Engineering\");  \n      newTable.Rows.Add(2, \"English\");  \n      newTable.Rows.Add(4, \"Economics\");  \n      newTable.Rows.Add(7, \"Mathematics\");  \n  \n      return newTable;  \n   }  \n  \n   static private void WriteDataTable(DataTable table) {  \n      if (table == null)  \n         return;  \n  \n      foreach (DataColumn column in table.Columns) {  \n         Console.Write(\"{0,-15}\", column.ColumnName);  \n      }  \n      Console.WriteLine();  \n  \n      foreach (DataRow row in table.Rows) {  \n         for (int i = 0; i < table.Columns.Count; i++)  \n            Console.Write(\"{0,-15}\", row[i].ToString());  \n         Console.WriteLine();  \n      }  \n  \n      Console.WriteLine();  \n   }  \n  \n   static private void InsertDuplicateData(DataTable table) {  \n      try {  \n         table.Rows.Add(\"C1045\", \"Calculus\", 7);  \n         table.Rows.Add(\"C1045\", \"Calculus\", 7);  \n      } catch (Exception e) {  \n         Console.WriteLine(\"\\\"\" + e.Message + \"\\\"\");  \n      }  \n   }  \n  \n   private static void InsertNoParentRow(DataTable table) {  \n      try {  \n         table.Rows.Add(\"C1061\", \"Physics\", 11);  \n      } catch (Exception e) {  \n         Console.WriteLine(\"\\\"\" + e.Message + \"\\\"\");  \n      }  \n   }  \n}  \n  \npublic class ClonedDataTable {  \n   private DataTable sourceTable;  \n   private DataTable destinationTable;  \n  \n   public ClonedDataTable(DataTable source) {  \n      sourceTable = source;  \n      // set the cloned result  \n      destinationTable = sourceTable.Clone();  \n   }  \n  \n   public void UpdateAddedColumn() {  \n      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  \n   }  \n  \n   public void UpdateDeletedColumn() {  \n      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  \n   }  \n  \n   public void UpdateUniqueConstraint() {  \n      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  \n   }  \n  \n   public void UpdateForeignKeyConstraint() {  \n      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  \n   }  \n  \n   // After the source table adds a column, the method will add the same column in the destination table.  \n   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  \n      if (e.Action == CollectionChangeAction.Add) {  \n         DataColumn column = e.Element as DataColumn;  \n  \n         if (column != null) {  \n            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  \n  \n            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  \n               destinationTable.Columns.Add(newColumn);  \n         }  \n      }  \n   }  \n  \n   // After the source table deletes a column, the method will delete the same column in the destination table.  \n   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  \n      if (e.Action == CollectionChangeAction.Remove) {  \n         DataColumn column = e.Element as DataColumn;  \n  \n         if (column != null)  \n            if (destinationTable.Columns.Contains(column.ColumnName))  \n               destinationTable.Columns.Remove(column.ColumnName);  \n      }  \n   }  \n  \n   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        \n   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  \n      UniqueConstraint constraint = e.Element as UniqueConstraint;  \n  \n      if (constraint == null)  \n         return;  \n  \n      String constraintName = constraint.ConstraintName;  \n  \n      if (e.Action == CollectionChangeAction.Add) {  \n         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  \n         Boolean isPrimaryKey = constraint.IsPrimaryKey;  \n  \n         // Get the columns used in new constraint from the destiantion table.  \n         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  \n            String columnName = constraint.Columns[i].ColumnName;  \n  \n            if (destinationTable.Columns.Contains(columnName))  \n               columns[i] = destinationTable.Columns[columnName];  \n            else  \n               return;  \n         }  \n  \n         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  \n  \n         if (!destinationTable.Constraints.Contains(constraintName))  \n            destinationTable.Constraints.Add(newConstraint);  \n  \n      } else if (e.Action == CollectionChangeAction.Remove)  \n         if (destinationTable.Constraints.Contains(constraintName))  \n            destinationTable.Constraints.Remove(constraintName);  \n   }  \n  \n   // After the source table changes the ForeignKeyConstraint, this method changes    \n   // the same ForeignKeyConstraint in the destination table.  \n   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  \n      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  \n  \n      if (constraint == null)  \n         return;  \n  \n      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  \n      if (sourceTable.DataSet != destinationTable.DataSet)  \n         return;  \n  \n      String constraintName = constraint.ConstraintName;  \n  \n      if (e.Action == CollectionChangeAction.Add) {  \n         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  \n         DataColumn[] parentColumns = constraint.RelatedColumns;  \n  \n         // Get the columns used in new constraint from the destination table.  \n         for (int i = 0; i < constraint.Columns.Count(); i++) {  \n            String columnName = constraint.Columns[i].ColumnName;  \n  \n            if (destinationTable.Columns.Contains(columnName))  \n               columns[i] = destinationTable.Columns[columnName];  \n            else  \n               return;  \n         }  \n  \n         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  \n         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  \n         newConstraint.DeleteRule = constraint.DeleteRule;  \n         newConstraint.UpdateRule = constraint.UpdateRule;  \n  \n         if (!destinationTable.Constraints.Contains(constraintName))  \n            destinationTable.Constraints.Add(newConstraint);  \n      } else if (e.Action == CollectionChangeAction.Remove)  \n         if (destinationTable.Constraints.Contains(constraintName))  \n            destinationTable.Constraints.Remove(constraintName);  \n   }  \n  \n   // return the destination table.  \n   public DataTable DestinationTable {  \n      get { return destinationTable; }  \n   }  \n}  \n```  \n  \n This sample shows how to modify data in a DataTable and update the data source.  \n  \n First, create a database:  \n  \n```  \nUSE [master]  \nGO  \n  \nCREATE DATABASE [MySchool]   \n  \nGO  \n  \nUSE [MySchool]  \nGO  \n  \nSET ANSI_NULLS ON  \nGO  \nSET QUOTED_IDENTIFIER ON  \nGO  \nCREATE TABLE [dbo].[Course](~/add/includes/ajax-current-ext-md.md [nvarchar](10) NOT NULL,  \n[Year] [smallint] NOT NULL,  \n[Title] [nvarchar](100) NOT NULL,  \n[Credits] [int] NOT NULL,  \n[DepartmentID] [int] NOT NULL,  \n CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   \n(  \n[CourseID] ASC,  \n[Year] ASC  \n)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  \n  \nGO  \n  \nSET ANSI_NULLS ON  \nGO  \nSET QUOTED_IDENTIFIER ON  \nGO  \nCREATE TABLE [dbo].[Department](~/add/includes/ajax-current-ext-md.md [int] IDENTITY(1,1) NOT NULL,  \n[Name] [nvarchar](50) NOT NULL,  \n[Budget] [money] NOT NULL,  \n[StartDate] [datetime] NOT NULL,  \n[Administrator] [int] NULL,  \n CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   \n(  \n[DepartmentID] ASC  \n)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  \n  \nGO  \n  \nINSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  \nINSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  \nINSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  \nINSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  \n  \nSET IDENTITY_INSERT [dbo].[Department] ON   \n  \nINSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  \nINSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  \nINSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  \nINSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  \nSET IDENTITY_INSERT [dbo].[Department] OFF  \n  \nALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  \nREFERENCES [dbo].[Department] ([DepartmentID])  \nGO  \nALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  \nGO  \n```  \n  \n You can now compile and run the sample. [How to modify data in DataTable and update to the data source](http://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4) has Visual Basic and C# projects of this sample.  \n  \n```  \nusing System;  \nusing System.Data;  \nusing System.Data.SqlClient;  \n  \nclass Program {  \n   static void Main(string[] args) {  \n  \n   string MySchoolConnectionString = \"Data Source=(local);Initial Catalog=MySchool;Integrated Security=True\";  \n  \n      // Get Data  \n      String selectString =  \n       @\"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  \n               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] \";  \n  \n      DataSet dataSet = new DataSet();  \n      DataTable course = dataSet.Tables.Add(\"Course\");  \n      DataTable department = dataSet.Tables.Add(\"Department\");  \n  \n      Console.WriteLine(\"Get data from database:\");  \n      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  \n      Console.WriteLine();  \n  \n      // Use DataTable Edits to edit the data  \n      String updateString =  \n              @\"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;\";  \n  \n      course.ColumnChanged += OnColumnChanged;  \n  \n      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  \n      ChangeCredits(course, course.Rows[0], -1);  \n      ChangeCredits(course, course.Rows[1], 11);  \n  \n      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, \"Course\",  \n          new SqlParameter(\"@CourseID\", SqlDbType.NVarChar, 10, \"CourseID\"),  \n          new SqlParameter(\"@Credits\", SqlDbType.Int, 4, \"Credits\"));  \n      Console.WriteLine(\"Only the Credits of second row is changed.\");  \n      ShowDataTable(course);  \n      Console.WriteLine();  \n  \n      // Delete and Remove from DataTable  \n      // Create the foreign key constraint, and set the DeleteRule with Cascade.  \n      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint(\"CourseDepartFK\", department.Columns[\"DepartmentID\"], course.Columns[\"DepartmentID\"]);  \n      courseDepartFK.DeleteRule = Rule.Cascade;  \n      courseDepartFK.UpdateRule = Rule.Cascade;  \n      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  \n      course.Constraints.Add(courseDepartFK);  \n  \n      String deleteString = @\"Delete From [dbo].[Course] Where [CourseID]=@CourseID;\";  \n  \n      department.Rows[0].Delete();  \n      Console.WriteLine(\"If One row in Department table is deleted, the related rows in Course table will also be deleted.\");  \n      Console.WriteLine(\"Department DataTable:\");  \n      ShowDataTable(department);  \n      Console.WriteLine();  \n      Console.WriteLine(\"Course DataTable:\");  \n      ShowDataTable(course);  \n      Console.WriteLine();  \n      // Update the delete operation  \n      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, \"Course\",  \n          new SqlParameter(\"@CourseID\", SqlDbType.NVarChar, 10, \"CourseID\"));  \n      Console.WriteLine(\"After delete operation:\");  \n      Console.WriteLine(\"Course DataTable:\");  \n      ShowDataTable(course);  \n      Console.WriteLine();  \n  \n      course.Rows.RemoveAt(0);  \n      Console.WriteLine(\"Now we remove one row from Course:\");  \n      ShowDataTable(course);  \n      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, \"Course\",  \n          new SqlParameter(\"@CourseID\", SqlDbType.NVarChar, 10, \"CourseID\"));  \n   }  \n  \n   // Use SqlDataAdapter to get data.  \n   private static void GetDataTables(String connectionString, String selectString,  \n       DataSet dataSet, params DataTable[] tables) {  \n      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  \n         adapter.SelectCommand = new SqlCommand(selectString);  \n         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  \n  \n         adapter.Fill(0, 0, tables);  \n  \n         foreach (DataTable table in dataSet.Tables) {  \n            Console.WriteLine(\"Data in {0}:\", table.TableName);  \n            ShowDataTable(table);  \n            Console.WriteLine();  \n         }  \n      }  \n   }  \n  \n   // Use SqlDataAdapter to update the updata operation.  \n   private static void UpdateDataTables(String connectionString, String updateString,  \n       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  \n      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  \n         adapter.UpdateCommand = new SqlCommand(updateString);  \n         adapter.UpdateCommand.Parameters.AddRange(parameters);  \n         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  \n  \n         adapter.Update(dataSet, tableName);  \n      }  \n   }  \n  \n   // Use SqlDataAdapter to update delete operation.  \n   private static void DeleteDataTables(String connectionString, String deleteString,  \n       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  \n      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  \n         adapter.DeleteCommand = new SqlCommand(deleteString);  \n         adapter.DeleteCommand.Parameters.AddRange(parameters);  \n         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  \n  \n         adapter.Update(dataSet, tableName);  \n      }  \n   }  \n  \n   // Use DataTable Edits to modify the data.  \n   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  \n      row.BeginEdit();  \n      Console.WriteLine(\"We change row {0}\", table.Rows.IndexOf(row));  \n      row[\"Credits\"] = credits;  \n      row.EndEdit();  \n   }  \n  \n   // The method will be invoked when the value in DataTable is changed.  \n   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  \n      Int32 credits = 0;  \n      // If Credits is changed and the value is negative, we'll cancel the edit.  \n      if ((args.Column.ColumnName == \"Credits\") &&  \n          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  \n         Console.WriteLine(\"The value of Credits is invalid. Edit canceled.\");  \n         args.Row.CancelEdit();  \n      }  \n   }  \n  \n   // Display the column and value of DataTable.  \n   private static void ShowDataTable(DataTable table) {  \n      foreach (DataColumn col in table.Columns) {  \n         Console.Write(\"{0,-14}\", col.ColumnName);  \n      }  \n      Console.WriteLine(\"{0,-14}\", \"RowState\");  \n  \n      foreach (DataRow row in table.Rows) {  \n         if (row.RowState == DataRowState.Deleted) {  \n            foreach (DataColumn col in table.Columns) {  \n               if (col.DataType.Equals(typeof(DateTime)))  \n                  Console.Write(\"{0,-14:d}\", row[col, DataRowVersion.Original]);  \n               else if (col.DataType.Equals(typeof(Decimal)))  \n                  Console.Write(\"{0,-14:C}\", row[col, DataRowVersion.Original]);  \n               else  \n                  Console.Write(\"{0,-14}\", row[col, DataRowVersion.Original]);  \n            }  \n         }  \n         else {  \n            foreach (DataColumn col in table.Columns) {  \n               if (col.DataType.Equals(typeof(DateTime)))  \n                  Console.Write(\"{0,-14:d}\", row[col]);  \n               else if (col.DataType.Equals(typeof(Decimal)))  \n                  Console.Write(\"{0,-14:C}\", row[col]);  \n               else  \n                  Console.Write(\"{0,-14}\", row[col]);  \n            }  \n         }  \n         Console.WriteLine(\"{0,-14}\", row.RowState);  \n      }  \n   }  \n}  \n```"
  syntax:
    content: public virtual System.Data.DataTable Clone ();
    parameters: []
    return:
      type: System.Data.DataTable
      description: "새 <xref href=&quot;System.Data.DataTable&quot;> </xref> 현재 스키마 같은 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  overload: System.Data.DataTable.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ColumnChanged
  id: ColumnChanged
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ColumnChanged
  nameWithType: DataTable.ColumnChanged
  fullName: System.Data.DataTable.ColumnChanged
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "값이 변경 후에 발생에 대 한 지정 된 <xref href=&quot;System.Data.DataColumn&quot;> </xref> 에 <xref href=&quot;System.Data.DataRow&quot;> </xref>합니다."
  remarks: "자세한 내용은 참조 [DataTable 이벤트 처리](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - >-
    [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/add/codesnippet/visualbasic/e-system.data.datatable._4_1.vb)]
     [!code-cs[Classic WebData DataTable.ColumnChanged Example#1](~/add/codesnippet/csharp/e-system.data.datatable._4_1.cs)]
  syntax:
    content: public event System.Data.DataColumnChangeEventHandler ColumnChanged;
    return:
      type: System.Data.DataColumnChangeEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ColumnChanging
  id: ColumnChanging
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ColumnChanging
  nameWithType: DataTable.ColumnChanging
  fullName: System.Data.DataTable.ColumnChanging
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "값 변경 중일 때 발생 합니다. 지정 된 <xref href=&quot;System.Data.DataColumn&quot;> </xref> 에 <xref href=&quot;System.Data.DataRow&quot;> </xref>합니다."
  remarks: "자세한 내용은 참조 [DataTable 이벤트 처리](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - >-
    [!code-cs[Classic WebData DataTable.ColumnChanging Example#1](~/add/codesnippet/csharp/e-system.data.datatable._5_1.cs)]
     [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/add/codesnippet/visualbasic/e-system.data.datatable._5_1.vb)]
  syntax:
    content: public event System.Data.DataColumnChangeEventHandler ColumnChanging;
    return:
      type: System.Data.DataColumnChangeEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Columns
  id: Columns
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Columns
  nameWithType: DataTable.Columns
  fullName: System.Data.DataTable.Columns
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 테이블에 속하는 열의 컬렉션을 가져옵니다."
  remarks: "<xref:System.Data.DataColumnCollection>각 열의 데이터 형식을 정의 하 여 테이블의 스키마를 결정 합니다.</xref:System.Data.DataColumnCollection>"
  example:
  - "The following example prints each value of each row in a table using the Columns property.  \n  \n [!code-vb[Classic WebData DataTable.Columns Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._12_1.vb)]\n [!code-cs[Classic WebData DataTable.Columns Example#1](~/add/codesnippet/csharp/p-system.data.datatable._12_1.cs)]"
  syntax:
    content: public System.Data.DataColumnCollection Columns { get; }
    return:
      type: System.Data.DataColumnCollection
      description: "A <xref href=&quot;System.Data.DataColumnCollection&quot;> </xref> 의 컬렉션을 포함 하는 <xref href=&quot;System.Data.DataColumn&quot;> </xref> 테이블에 대 한 개체입니다. 없는 경우에 빈 컬렉션이 반환 됩니다 <xref href=&quot;System.Data.DataColumn&quot;> </xref> 개체가 존재 합니다."
  overload: System.Data.DataTable.Columns*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Compute(System.String,System.String)
  id: Compute(System.String,System.String)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Compute(String,String)
  nameWithType: DataTable.Compute(String,String)
  fullName: System.Data.DataTable.Compute(String,String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "필터 조건을 전달 하는 현재 행에서 지정된 된 식을 계산 합니다."
  remarks: "`expression` 매개 변수는 집계 함수가 필요 합니다. 예를 들어 다음은 올바른 식: `Count(Quantity)` 되지만이 식은 않습니다: `Sum (Quantity * UnitPrice)` 두 개 이상의 열에 대 한 작업을 수행 해야 하는 경우 만든는 <xref:System.Data.DataColumn>설정, 해당 <xref:System.Data.DataColumn.Expression%2A>속성을 적절 한 식이 다음 결과 열에 집계 식 사용 합니다.</xref:System.Data.DataColumn.Expression%2A> </xref:System.Data.DataColumn> 지정 된 경우에 <xref:System.Data.DataColumn>이름이 &quot;total&quot;와 및 <xref:System.Data.DataColumn.Expression%2A>이 설정 된 속성: `&quot;Quantity * UnitPrice&quot;` 계산 메서드에 대 한 식 인수 것이: `Sum(total)` 두 번째 매개 변수 `filter`, 식에 사용 될 행을 결정 합니다.</xref:System.Data.DataColumn.Expression%2A> </xref:System.Data.DataColumn> 예를 들어 테이블에 있는 경우 &quot;colDate&quot; 라는 날짜 열을 다음 식으로 행을 제한할 수: `colDate > 1/1/99 AND colDate < 17/1/99` 매개 변수가 모두에 대 한 식을 만드는 방법에 대 한 규칙을 참조 하십시오.는 <xref:System.Data.DataColumn.Expression%2A?displayProperty=fullName>속성.</xref:System.Data.DataColumn.Expression%2A?displayProperty=fullName>"
  example:
  - "The following example sums the values of a column named \"Total\", for the salesperson whose identification number is five.  \n  \n [!code-cs[Classic WebData DataTable.Compute Example#1](~/add/codesnippet/csharp/m-system.data.datatable._24_1.cs)]\n [!code-vb[Classic WebData DataTable.Compute Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._24_1.vb)]"
  syntax:
    content: public object Compute (string expression, string filter);
    parameters:
    - id: expression
      type: System.String
      description: "계산할 식입니다."
    - id: filter
      type: System.String
      description: "필터 식에서 계산 되는 행을 제한입니다."
    return:
      type: System.Object
      description: "<xref:System.Object>, 계산의 결과로 설정 합니다.</xref:System.Object> 식이 null로 반환 값에서 됩니다 <xref href=&quot;System.DBNull.Value&quot;> </xref>합니다."
  overload: System.Data.DataTable.Compute*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Constraints
  id: Constraints
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Constraints
  nameWithType: DataTable.Constraints
  fullName: System.Data.DataTable.Constraints
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 테이블에서 유지 관리 하는 제약 조건의 컬렉션을 가져옵니다."
  remarks: "A <xref:System.Data.ForeignKeyConstraint>열 또는 열에 값이 삭제 되거나 업데이트할 때 수행 하는 작업을 제한 합니다.</xref:System.Data.ForeignKeyConstraint> 이러한 제약 조건은 기본 키 열과 함께 사용 하는 데 사용 됩니다. 두 테이블 간에 부모/자식 관계에서 부모 테이블에서 값을 삭제할 영향을 줄 수 자식 행에서 다음 방법 중 하나입니다.      -자식 행 수도 있습니다 (연계 동작)를 삭제 합니다.      -자식 열 (또는 열)의 값은 null 값으로 설정할 수 있습니다.      -자식 열 (또는 열)의 값을 기본값으로 설정할 수 있습니다.      -예외를 생성할 수 있습니다.       A <xref:System.Data.UniqueConstraint>값이 고유 기본 키의 값을 설정 하려고 할 때 활성화 됩니다.</xref:System.Data.UniqueConstraint>"
  example:
  - "The following example adds a <xref:System.Data.ForeignKeyConstraint> to the collection of constraints.  \n  \n [!code-vb[Classic WebData DataTable.Constraints Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._3_1.vb)]\n [!code-cs[Classic WebData DataTable.Constraints Example#1](~/add/codesnippet/csharp/p-system.data.datatable._3_1.cs)]"
  syntax:
    content: public System.Data.ConstraintCollection Constraints { get; }
    return:
      type: System.Data.ConstraintCollection
      description: "A <xref href=&quot;System.Data.ConstraintCollection&quot;> </xref> 의 컬렉션을 포함 하는 <xref href=&quot;System.Data.Constraint&quot;> </xref> 테이블에 대 한 개체입니다. 없는 경우에 빈 컬렉션이 반환 됩니다 <xref href=&quot;System.Data.Constraint&quot;> </xref> 개체가 존재 합니다."
  overload: System.Data.DataTable.Constraints*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Copy
  id: Copy
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Copy()
  nameWithType: DataTable.Copy()
  fullName: System.Data.DataTable.Copy()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 구조와 데이터를 모두 복사 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  remarks: ''
  example:
  - "The following example uses the Copy method to create a copy of the original <xref:System.Data.DataTable>. The namespace name is not retained if it is inherited from a parent <xref:System.Data.DataTable> or <xref:System.Data.DataSet>.  \n  \n [!code-cs[Classic WebData DataTable.Copy Example#1](~/add/codesnippet/csharp/m-system.data.datatable._5_1.cs)]\n [!code-vb[Classic WebData DataTable.Copy Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._5_1.vb)]"
  syntax:
    content: public System.Data.DataTable Copy ();
    parameters: []
    return:
      type: System.Data.DataTable
      description: "새 <xref href=&quot;System.Data.DataTable&quot;> </xref> 구조 (테이블 스키마 및 제약 조건) 및 데이터 이와 동일한 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다.       이러한 클래스를 파생 된 경우 동일한 파생된 클래스가 복사가 됩니다.       복사를 새로 만들고 <xref href=&quot;System.Data.DataTable&quot;> </xref> 구조 및 데이터 원본과 동일한 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다. 새 구조를 복사 하려면 <xref href=&quot;System.Data.DataTable&quot;> </xref>, 데이터가 아닌 <xref:System.Data.DataTable.Clone*>.</xref:System.Data.DataTable.Clone*> 사용 하지만"
  overload: System.Data.DataTable.Copy*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.CreateDataReader
  id: CreateDataReader
  parent: System.Data.DataTable
  langs:
  - csharp
  name: CreateDataReader()
  nameWithType: DataTable.CreateDataReader()
  fullName: System.Data.DataTable.CreateDataReader()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "반환 된 <xref href=&quot;System.Data.DataTableReader&quot;> </xref> 이 내의 데이터에 해당 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  remarks: ''
  example:
  - "The following console application creates a <xref:System.Data.DataTable> instance. The example then passes the filled <xref:System.Data.DataTable>to a procedure that calls the CreateDataReader method, which iterates through the results contained within the <xref:System.Data.DataTableReader>.  \n  \n [!code-vb[DataWorks DataTable.CreateDataReader#1](~/add/codesnippet/visualbasic/m-system.data.datatable._9_1.vb)]\n [!code-cs[DataWorks DataTable.CreateDataReader#1](~/add/codesnippet/csharp/m-system.data.datatable._9_1.cs)]  \n  \n The example displays the following output in the console window:  \n  \n `1 Mary`  \n  \n `2 Andy`  \n  \n `3 Peter`  \n  \n `4 Russ`"
  syntax:
    content: public System.Data.DataTableReader CreateDataReader ();
    parameters: []
    return:
      type: System.Data.DataTableReader
      description: "A <xref href=&quot;System.Data.DataTableReader&quot;> </xref> 소스에 해당 하는 하나의 결과 집합에 포함 된 <xref href=&quot;System.Data.DataTable&quot;> </xref> 인스턴스."
  overload: System.Data.DataTable.CreateDataReader*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.CreateInstance
  id: CreateInstance
  parent: System.Data.DataTable
  langs:
  - csharp
  name: CreateInstance()
  nameWithType: DataTable.CreateInstance()
  fullName: System.Data.DataTable.CreateInstance()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "새 인스턴스를 만듭니다 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  syntax:
    content: protected virtual System.Data.DataTable CreateInstance ();
    parameters: []
    return:
      type: System.Data.DataTable
      description: "새 식입니다."
  overload: System.Data.DataTable.CreateInstance*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.DataSet
  id: DataSet
  parent: System.Data.DataTable
  langs:
  - csharp
  name: DataSet
  nameWithType: DataTable.DataSet
  fullName: System.Data.DataTable.DataSet
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "가져옵니다는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 이 테이블이 속해 있는 합니다."
  remarks: "컨트롤 데이터에 바인딩된는 <xref:System.Data.DataTable>, 테이블에 속해는 <xref:System.Data.DataSet>에 가져올 수 있습니다는 <xref:System.Data.DataSet>이 속성을 통해.</xref:System.Data.DataSet> </xref:System.Data.DataSet> </xref:System.Data.DataTable>"
  example:
  - "The following example returns the parent <xref:System.Data.DataSet> of a given table through the DataSet property.  \n  \n [!code-vb[Classic WebData DataTable.DataSet Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._10_1.vb)]\n [!code-cs[Classic WebData DataTable.DataSet Example#1](~/add/codesnippet/csharp/p-system.data.datatable._10_1.cs)]"
  syntax:
    content: public System.Data.DataSet DataSet { get; }
    return:
      type: System.Data.DataSet
      description: "<xref href=&quot;System.Data.DataSet&quot;> </xref> 이 테이블이 속해 있는 합니다."
  overload: System.Data.DataTable.DataSet*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.DefaultView
  id: DefaultView
  parent: System.Data.DataTable
  langs:
  - csharp
  name: DefaultView
  nameWithType: DataTable.DefaultView
  fullName: System.Data.DataTable.DefaultView
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "필터링된 된 뷰 또는 커서 위치를 포함할 수 있는 테이블의 사용자 지정된 뷰를 가져옵니다."
  remarks: "<xref:System.Data.DataView>정렬, 필터링 및 <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 를 검색 하는 데</xref:System.Data.DataView> 는 DefaultView 속성 반환"
  example:
  - "The following example sets a property of the <xref:System.Data.DataTable> object's <xref:System.Data.DataView> through the DefaultView property. The example also shows the binding of a <xref:System.Windows.Forms.DataGridView> control to a <xref:System.Data.DataTable> named \"Suppliers\" that includes a column named \"CompanyName.\"  \n  \n [!code-cs[Classic WebData DataTable.DefaultView Example#1](~/add/codesnippet/csharp/p-system.data.datatable._11_1.cs)]\n [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._11_1.vb)]"
  syntax:
    content: public System.Data.DataView DefaultView { get; }
    return:
      type: System.Data.DataView
      description: "<xref href=&quot;System.Data.DataView&quot;> </xref> 연관 된 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  overload: System.Data.DataTable.DefaultView*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.DisplayExpression
  id: DisplayExpression
  parent: System.Data.DataTable
  langs:
  - csharp
  name: DisplayExpression
  nameWithType: DataTable.DisplayExpression
  fullName: System.Data.DataTable.DisplayExpression
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "사용자 인터페이스에서이 테이블을 나타내는 데 사용 되는 값을 반환 하는 식을 가져오거나 설정 합니다. <xref uid=&quot;langword_csharp_DisplayExpression&quot; name=&quot;DisplayExpression&quot; href=&quot;&quot;> </xref> 속성을 사용 하면 사용자 인터페이스에서이 테이블의 이름을 표시 합니다."
  syntax:
    content: public string DisplayExpression { get; set; }
    return:
      type: System.String
      description: "표시 문자열입니다."
  overload: System.Data.DataTable.DisplayExpression*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.EndInit
  id: EndInit
  parent: System.Data.DataTable
  langs:
  - csharp
  name: EndInit()
  nameWithType: DataTable.EndInit()
  fullName: System.Data.DataTable.EndInit()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "초기화를 종료 한 <xref href=&quot;System.Data.DataTable&quot;> </xref> 폼에 사용 되거나 다른 구성 요소에서 사용 하 합니다. 초기화는 런타임에 발생 합니다."
  remarks: "Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소 초기화를 끝냅니다. <xref:System.Data.DataTable.BeginInit%2A>메서드 초기화를 시작 합니다.</xref:System.Data.DataTable.BeginInit%2A> 사용 하 여 <xref:System.Data.DataTable.BeginInit%2A>하 고 컨트롤을 완전히 초기화 되기 전에 사용 되지 않도록 하 EndInit 메서드.</xref:System.Data.DataTable.BeginInit%2A>"
  syntax:
    content: public virtual void EndInit ();
    parameters: []
  overload: System.Data.DataTable.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.EndLoadData
  id: EndLoadData
  parent: System.Data.DataTable
  langs:
  - csharp
  name: EndLoadData()
  nameWithType: DataTable.EndLoadData()
  fullName: System.Data.DataTable.EndLoadData()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "데이터를 로드 한 후 알림, 인덱스 유지 관리 및 제약 조건을 설정 합니다."
  remarks: "EndLoadData <xref:System.Data.DataTable.LoadDataRow%2A>및 <xref:System.Data.DataTable.BeginLoadData%2A>.</xref:System.Data.DataTable.BeginLoadData%2A> </xref:System.Data.DataTable.LoadDataRow%2A> 와 함께에서 사용 하 여"
  syntax:
    content: public void EndLoadData ();
    parameters: []
  overload: System.Data.DataTable.EndLoadData*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ExtendedProperties
  id: ExtendedProperties
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ExtendedProperties
  nameWithType: DataTable.ExtendedProperties
  fullName: System.Data.DataTable.ExtendedProperties
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "사용자 지정된 사용자 정보의 컬렉션을 가져옵니다."
  remarks: "ExtendedProperties를 사용 하 여 사용자 지정 정보에 <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 를 추가 하려면 추가 정보는 `Add` 메서드. 정보를 검색할는 `Item` 메서드.       확장된 속성 <xref:System.String>.</xref:System.String> 형식 이어야 합니다. 문자열 형식이 아닌 속성 유지 되지 않습니다 때는 <xref:System.Data.DataTable>XML로 기록 됩니다.</xref:System.Data.DataTable>"
  example:
  - "The following example adds a timestamp value to the <xref:System.Data.DataTable> through the ExtendedProperties property.  \n  \n [!code-cs[Classic WebData DataTable.ExtendedProperties Example#1](~/add/codesnippet/csharp/p-system.data.datatable._7_1.cs)]\n [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._7_1.vb)]"
  syntax:
    content: public System.Data.PropertyCollection ExtendedProperties { get; }
    return:
      type: System.Data.PropertyCollection
      description: "A <xref href=&quot;System.Data.PropertyCollection&quot;> </xref> 하는 사용자 지정 사용자 정보를 포함 합니다."
  overload: System.Data.DataTable.ExtendedProperties*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.fInitInProgress
  id: fInitInProgress
  parent: System.Data.DataTable
  langs:
  - csharp
  name: fInitInProgress
  nameWithType: DataTable.fInitInProgress
  fullName: System.Data.DataTable.fInitInProgress
  type: Field
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "초기화가 진행 하는지 여부를 확인 합니다. 초기화는 런타임에 발생 합니다."
  syntax:
    content: protected bool fInitInProgress;
    return:
      type: System.Boolean
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.GetChanges
  id: GetChanges
  parent: System.Data.DataTable
  langs:
  - csharp
  name: GetChanges()
  nameWithType: DataTable.GetChanges()
  fullName: System.Data.DataTable.GetChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "복사본을 가져옵니다는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 내용을 로드 된 이후 모든 변경 내용이 들어 있는 또는 <xref:System.Data.DataTable.AcceptChanges*>마지막으로 호출한.</xref:System.Data.DataTable.AcceptChanges*>"
  remarks: "새 <xref:System.Data.DataSet>원래에 모든 행의 복사본이 포함 된 <xref:System.Data.DataSet>보류 중인 변경 내용이 있는.</xref:System.Data.DataSet> </xref:System.Data.DataSet> 관계 제약 조건으로 인해 새에 추가할 추가 변경 되지 않은 행 <xref:System.Data.DataSet>변경 되지 않은 행에는 변경 된 행에서 외래 키에 해당 하는 기본 키를 포함 하는 경우.</xref:System.Data.DataSet> 메서드가 반환 `null` (`Nothing` Visual basic에서)는 원본에서 행이 없는 경우 <xref:System.Data.DataSet>와 보류 중인 변경 내용.</xref:System.Data.DataSet>"
  example:
  - >-
    [!code-cs[Classic WebData DataTable.GetChanges Example#1](~/add/codesnippet/csharp/m-system.data.datatable._25_1.cs)]
     [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._25_1.vb)]
  syntax:
    content: public System.Data.DataTable GetChanges ();
    parameters: []
    return:
      type: System.Data.DataTable
      description: "이 변경의 복사본 <xref href=&quot;System.Data.DataTable&quot;> </xref>, 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 없는 변경 내용이 발견 되는 경우."
  overload: System.Data.DataTable.GetChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.GetChanges(System.Data.DataRowState)
  id: GetChanges(System.Data.DataRowState)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: GetChanges(DataRowState)
  nameWithType: DataTable.GetChanges(DataRowState)
  fullName: System.Data.DataTable.GetChanges(DataRowState)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "복사본을 가져옵니다는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 내용을 마지막 로드 된 이후 또는 이후 모든 변경 내용이 포함 된 <xref:System.Data.DataTable.AcceptChanges*>호출을 기준으로 필터링 <xref href=&quot;System.Data.DataRowState&quot;> </xref>.</xref:System.Data.DataTable.AcceptChanges*>"
  remarks: "<xref:System.Data.DataTable.GetChanges%2A>초를 생성 하기 위해 메서드를 사용 하는 <xref:System.Data.DataTable>원래에 도입 된 변경 내용만 포함 하는 개체입니다.</xref:System.Data.DataTable> </xref:System.Data.DataTable.GetChanges%2A> 사용 하 여는 `rowStates` 인수를 새 개체에 포함 될 변경 유형을 지정 합니다.       관계 제약 조건 하면 변경 되지 않은 부모 행이 포함 될 수 있습니다."
  example:
  - >-
    [!code-cs[Classic WebData DataTable.GetChanges1 Example#1](~/add/codesnippet/csharp/m-system.data.datatable._15_1.cs)]
     [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._15_1.vb)]
  syntax:
    content: public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);
    parameters:
    - id: rowStates
      type: System.Data.DataRowState
      description: "중 하나는 <xref href=&quot;System.Data.DataRowState&quot;> </xref> 값입니다."
    return:
      type: System.Data.DataTable
      description: "필터링 된 복사본은 <xref href=&quot;System.Data.DataTable&quot;> </xref> 작업에 수행, 나중에 다시 병합 될 수 있는 <xref href=&quot;System.Data.DataTable&quot;> </xref> <xref:System.Data.DataSet.Merge*>.</xref:System.Data.DataSet.Merge*> 를 사용 하 여 원하는 행이 없으면 <xref href=&quot;System.Data.DataRowState&quot;> </xref> 발견 되 면 메서드가 반환 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataTable.GetChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)
  id: GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: GetDataTableSchema(XmlSchemaSet)
  nameWithType: DataTable.GetDataTableSchema(XmlSchemaSet)
  fullName: System.Data.DataTable.GetDataTableSchema(XmlSchemaSet)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 메서드는 반환 된 <xref href=&quot;System.Xml.Schema.XmlSchemaSet&quot;> </xref> 는 WSDL 웹 서비스 설명 언어 ()에 대해 설명 하는 포함 하는 인스턴스는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 웹 서비스에 대 한 합니다."
  syntax:
    content: public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);
    parameters:
    - id: schemaSet
      type: System.Xml.Schema.XmlSchemaSet
      description: "<xref href=&quot;System.Xml.Schema.XmlSchemaSet&quot;> </xref> 인스턴스."
    return:
      type: System.Xml.Schema.XmlSchemaComplexType
      description: "<xref href=&quot;System.Xml.Schema.XmlSchemaSet&quot;> </xref> 인스턴스."
  overload: System.Data.DataTable.GetDataTableSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.GetErrors
  id: GetErrors
  parent: System.Data.DataTable
  langs:
  - csharp
  name: GetErrors()
  nameWithType: DataTable.GetErrors()
  fullName: System.Data.DataTable.GetErrors()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "배열을 가져옵니다 <xref href=&quot;System.Data.DataRow&quot;> </xref> 오류가 있는 개체입니다."
  remarks: "목록을 반환 <xref:System.Data.DataRow>개체 <xref:System.Data.DataRow.RowError%2A>설정.</xref:System.Data.DataRow.RowError%2A> </xref:System.Data.DataRow> 호출할 때 오류가 발생할 수 있습니다는 예를 들어 <xref:System.Data.Common.DataAdapter.Update%2A>와 <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>로 설정 **true**.</xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> </xref:System.Data.Common.DataAdapter.Update%2A> 호출 하지 말고 <xref:System.Data.DataTable.AcceptChanges%2A>에 <xref:System.Data.DataTable>모든 오류를 해결 하 고 다시 전송 될 때까지 <xref:System.Data.DataSet>업데이트에 대 한.</xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.DataTable.AcceptChanges%2A>"
  example:
  - "The following example uses the GetErrors method to return an array of <xref:System.Data.DataRow> objects that have errors.  \n  \n [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._18_1.vb)]\n [!code-cs[Classic WebData DataTable.GetErrors Example#1](~/add/codesnippet/csharp/m-system.data.datatable._18_1.cs)]"
  syntax:
    content: public System.Data.DataRow[] GetErrors ();
    parameters: []
    return:
      type: System.Data.DataRow[]
      description: "배열을 <xref href=&quot;System.Data.DataRow&quot;> </xref> 오류가 있는 개체입니다."
  overload: System.Data.DataTable.GetErrors*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: DataTable.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Data.DataTable.GetObjectData(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Serialization 정보 개체를 serialize 하는 데 필요한 데이터로 채우는 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  syntax:
    content: public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "A <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> 개체와 관련 된 serialize 된 데이터를 보유 하는 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "A <xref:System.Runtime.Serialization.StreamingContext>소스와 연결 된 serialize 된 스트림의 대상이 들어 있는 개체는 <xref href=&quot;System.Data.DataTable&quot;> </xref>.</xref:System.Runtime.Serialization.StreamingContext>"
  overload: System.Data.DataTable.GetObjectData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code> info </code> 매개 변수는 null 참조 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> Visual basic에서)."
  platform:
  - net462
- uid: System.Data.DataTable.GetRowType
  id: GetRowType
  parent: System.Data.DataTable
  langs:
  - csharp
  name: GetRowType()
  nameWithType: DataTable.GetRowType()
  fullName: System.Data.DataTable.GetRowType()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "행 형식을 가져옵니다."
  syntax:
    content: protected virtual Type GetRowType ();
    parameters: []
    return:
      type: System.Type
      description: "형식을 반환 된 <xref href=&quot;System.Data.DataRow&quot;> </xref>합니다."
  overload: System.Data.DataTable.GetRowType*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.GetSchema
  id: GetSchema
  parent: System.Data.DataTable
  langs:
  - csharp
  name: GetSchema()
  nameWithType: DataTable.GetSchema()
  fullName: System.Data.DataTable.GetSchema()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 멤버에 대 한 참조 &lt;xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A?displayProperty=fullName&gt;합니다."
  syntax:
    content: protected virtual System.Xml.Schema.XmlSchema GetSchema ();
    parameters: []
    return:
      type: System.Xml.Schema.XmlSchema
      description: "<xref:System.Xml.Schema.XmlSchema>의해 생성 되는 개체의 XML 표현을 설명 하는 <> </> *> 메서드 및에서 소비 되는 <> </> *> 메서드.</xref:System.Xml.Schema.XmlSchema>"
  overload: System.Data.DataTable.GetSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.HasErrors
  id: HasErrors
  parent: System.Data.DataTable
  langs:
  - csharp
  name: HasErrors
  nameWithType: DataTable.HasErrors
  fullName: System.Data.DataTable.HasErrors
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "모든 테이블의 행에 오류가 있는지 여부를 나타내는 값을 가져옵니다는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 테이블이 속해 있는 합니다."
  remarks: "사용자가 작업에 포함 된 데이터 집합에는 <xref:System.Data.DataTable>, 변경으로 인해 일부 유효성 검사 실패 하는 경우 오류가 발생 하 여 각 변경을 표시할 수 있습니다.</xref:System.Data.DataTable> 전체를 표시할 수 있습니다 <xref:System.Data.DataRow>사용 하 여 오류 메시지는 <xref:System.Data.DataRow.RowError%2A>속성.</xref:System.Data.DataRow.RowError%2A> </xref:System.Data.DataRow> 오류가 있는 행의 각 열에 설정할 수도 있습니다는 <xref:System.Data.DataRow.SetColumnError%2A>메서드.</xref:System.Data.DataRow.SetColumnError%2A>       된 <xref:System.Data.DataSet> <xref:System.Data.DataSet.GetChanges%2A> <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 대상에서 메서드</xref:System.Data.DataSet.GetChanges%2A> 를 먼저 호출 하는 것이 좋습니다.</xref:System.Data.DataSet> 데이터 소스를 업데이트 하기 전에 이렇게 한 <xref:System.Data.DataSet>원본에 대 한 변경 내용만 포함 하는.</xref:System.Data.DataSet> 보내기 전에 <xref:System.Data.DataSet>업데이트에 대 한 데이터 원본에 오류 행 또는 행의 열에 연결 되는 경우를 확인 하려면 각 테이블의 HasErrors 속성을 확인 하십시오.</xref:System.Data.DataSet>       각 오류를 해결 한 후 사용 하 여 오류를 지울는 <xref:System.Data.DataRow.ClearErrors%2A>의 메서드는 `DataRow`.</xref:System.Data.DataRow.ClearErrors%2A>"
  example:
  - "The following example uses the HasErrors property to check if a table contains errors.  \n  \n [!code-cs[Classic WebData DataTable.HasErrors Example#1](~/add/codesnippet/csharp/p-system.data.datatable._8_1.cs)]\n [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._8_1.vb)]"
  syntax:
    content: public bool HasErrors { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>오류가 없으면; 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataTable.HasErrors*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ImportRow(System.Data.DataRow)
  id: ImportRow(System.Data.DataRow)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ImportRow(DataRow)
  nameWithType: DataTable.ImportRow(DataRow)
  fullName: System.Data.DataTable.ImportRow(DataRow)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "복사는 <xref href=&quot;System.Data.DataRow&quot;> </xref> 에 <xref href=&quot;System.Data.DataTable&quot;> </xref>, 원래 및 현재 값 뿐만 아니라 모든 속성 설정을 유지 합니다."
  remarks: "호출 <xref:System.Data.DataTable.NewRow%2A>행에 대 한 기본값을 사용 하면서 기존 테이블 스키마를 사용 하 여 테이블 행을 추가 하 고 설정 된 <xref:System.Data.DataRowState>를 `Detached`.</xref:System.Data.DataRowState> </xref:System.Data.DataTable.NewRow%2A> 기존 ImportRow 전처리 호출 <xref:System.Data.DataRowState>행에 다른 값과 함께.</xref:System.Data.DataRowState> 경우는 `DataRow` 분리 된 상태에는 매개 변수는, 무시 되 고 예외가 throw 되지 않습니다 변수로 전달 된입니다.       새 행의 데이터 테이블 끝에 추가 됩니다.       새 행에는 제약 조건을 위반 하는 경우에 데이터 테이블에 추가 되지 않습니다.       DataTable.Rows.Find 및 DataTable.Rows.IndexOf로 새 행의 인덱스를 가져올 수 있습니다. 참조 <xref:System.Data.DataRowCollection>및 <xref:System.Data.DataTable.Rows%2A>자세한 내용은.</xref:System.Data.DataTable.Rows%2A> </xref:System.Data.DataRowCollection>"
  syntax:
    content: public void ImportRow (System.Data.DataRow row);
    parameters:
    - id: row
      type: System.Data.DataRow
      description: "<xref href=&quot;System.Data.DataRow&quot;> </xref> 를 가져올 수 있습니다."
  overload: System.Data.DataTable.ImportRow*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Initialized
  id: Initialized
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Initialized
  nameWithType: DataTable.Initialized
  fullName: System.Data.DataTable.Initialized
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "뒤에 오는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 초기화 됩니다."
  remarks: "자세한 내용은 <xref:System.Data.DataTable.IsInitialized%2A>.</xref:System.Data.DataTable.IsInitialized%2A> 을 참조 하십시오."
  syntax:
    content: public event EventHandler Initialized;
    return:
      type: System.EventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.IsInitialized
  id: IsInitialized
  parent: System.Data.DataTable
  langs:
  - csharp
  name: IsInitialized
  nameWithType: DataTable.IsInitialized
  fullName: System.Data.DataTable.IsInitialized
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "나타내는 값을 가져옵니다 여부는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 초기화 됩니다."
  remarks: "상태를 반환 하는 <xref:System.Data.DataTable>것은 생성 되 고, 예를 들어 Visual Studio에서 동안.</xref:System.Data.DataTable> <xref:System.Data.DataTable.BeginInit%2A>메서드를 설정 `false` 및 <xref:System.Data.DataTable.EndInit%2A>메서드를 설정 `true`.</xref:System.Data.DataTable.EndInit%2A> </xref:System.Data.DataTable.BeginInit%2A>"
  syntax:
    content: public bool IsInitialized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>초기화가 완료를 나타내는 구성 요소 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataTable.IsInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Load(System.Data.IDataReader)
  id: Load(System.Data.IDataReader)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Load(IDataReader)
  nameWithType: DataTable.Load(IDataReader)
  fullName: System.Data.DataTable.Load(IDataReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "채웁니다는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 사용 하 여 제공 된 데이터 원본의 값으로 <xref href=&quot;System.Data.IDataReader&quot;> </xref>합니다. 경우는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 행이 이미 포함 되어 기존 행과 데이터 원본에서 들어오는 데이터를 병합 합니다."
  remarks: "The Loadmethod consumes the first result set from the loaded <xref:System.Data.IDataReader>, and after successful completion, sets the reader's position to the next result set, if any. When converting data, the `Load` method uses the same conversion rules as the <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=fullName> method.  \n  \n The Load method must take into account three specific issues when loading the data from an <xref:System.Data.IDataReader> instance: schema, data, and event operations. When working with the schema, the Load method may encounter conditions as described in the following table. The schema operations take place for all imported result sets, even those containing no data.  \n  \n|Condition|Behavior|  \n|---------------|--------------|  \n|The <xref:System.Data.DataTable> has no schema.|The Load method infers the schema based on the result set from the imported <xref:System.Data.IDataReader>.|  \n|The <xref:System.Data.DataTable> has a schema, but it is incompatible with the loaded schema.|The Load method throws an exception corresponding to the particular error that occurs when attempting to load data into the incompatible schema.|  \n|The schemas are compatible, but the loaded result set schema contains columns that do not exist in the <xref:System.Data.DataTable>.|The Load method adds the extra columns to `DataTable`'s schema. The method throws an exception if corresponding columns in the <xref:System.Data.DataTable> and the loaded result set are not value compatible. The method also retrieves constraint information from the result set for all added columns. Except for the case of Primary Key constraint, this constraint information is used only if the current <xref:System.Data.DataTable> does not contain any columns at the start of the load operation.|  \n|The schemas are compatible, but the loaded result set schema contains fewer columns than does the `DataTable`.|If a missing column has a default value defined or the column's data type is nullable, the Load method allows the rows to be added, substituting the default or `null` value for the missing column. If no default value or `null` can be used, then the `Load` method throws an exception. If no specific default value has been supplied, the `Load` method uses the `null` value as the implied default value.|  \n  \n Before considering the behavior of the `Load` method in terms of data operations, consider that each row within a <xref:System.Data.DataTable> maintains both the current value and the original value for each column. These values may be equivalent, or may be different if the data in the row has been changed since filling the `DataTable`.  For more information, see [Row States and Row Versions](~/add/includes/ajax-current-ext-md.md).  \n  \n This version of the `Load` method attempts to preserve the current values in each row, leaving the original value intact. (If you want finer control over the behavior of incoming data, see <xref:System.Data.DataTable.Load%2A?displayProperty=fullName>.) If the existing row and the incoming row contain corresponding primary key values, the row is processed using its current row state value, otherwise it's treated as a new row.  \n  \n In terms of event operations, the <xref:System.Data.DataTable.RowChanging> event occurs before each row is changed, and the <xref:System.Data.DataTable.RowChanged> event occurs after each row has been changed. In each case, the <xref:System.Data.DataRowChangeEventArgs.Action%2A> property of the <xref:System.Data.DataRowChangeEventArgs> instance passed to the event handler contains information about the particular action associated with the event. This action value depends on the state of the row before the load operation. In each case, both events occur, and the action is the same for each. The action may be applied to either the current or original version of each row, or both, depending on the current row state.  \n  \n The following table displays behavior for the `Load` method. The final row (labeled \"(Not present)\") describes the behavior for incoming rows that don't match any existing row. Each cell in this table describes the current and original value for a field within a row, along with the <xref:System.Data.DataRowState> for the value after the `Load` method has completed. In this case, the method doesn't allow you to indicate the load option, and uses the default, `PreserveChanges`.  \n  \n|Existing DataRowState|Values after `Load` method, and event action|  \n|---------------------------|--------------------------------------------------|  \n|Added|Current = \\<Existing><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Modified><br /><br /> RowAction = ChangeOriginal|  \n|Modified|Current = \\<Existing><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Modified><br /><br /> RowAction = ChangeOriginal|  \n|Deleted|Current = \\<Not available><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Deleted><br /><br /> RowAction = ChangeOriginal|  \n|Unchanged|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|  \n|(Not present)|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|  \n  \n Values in a <xref:System.Data.DataColumn> can be constrained through use of properties such as <xref:System.Data.DataColumn.ReadOnly%2A> and <xref:System.Data.DataColumn.AutoIncrement%2A>. The `Load` method handles such columns in a manner that is consistent with the behavior defined by the column's properties. The read only constraint on a <xref:System.Data.DataColumn> is applicable only for changes that occur in memory. The `Load` method's overwrites the read-only column values, if needed.  \n  \n To determine which version of the primary key field to use for comparing the current row with an incoming row, the `Load` method uses the original version of the primary key value within a row, if it exists. Otherwise, the `Load` method uses the current version of the primary key field."
  example:
  - "The following example demonstrates several of the issues involved with calling the Load method. First, the example focuses on schema issues, including inferring a schema from the loaded <xref:System.Data.IDataReader>, and then handling incompatible schemas, and schemas with missing or additional columns. The example then calls the `Load` method, displaying the data both before and after the load operation.  \n  \n [!code-cs[DataWorks DataTableLoad.IDataReader#1](~/add/codesnippet/csharp/m-system.data.datatable._13_1.cs)]\n [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/add/codesnippet/visualbasic/m-system.data.datatable._13_1.vb)]"
  syntax:
    content: public void Load (System.Data.IDataReader reader);
    parameters:
    - id: reader
      type: System.Data.IDataReader
      description: "<xref href=&quot;System.Data.IDataReader&quot;> </xref> 하는 결과 집합을 제공 합니다."
  overload: System.Data.DataTable.Load*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)
  id: Load(System.Data.IDataReader,System.Data.LoadOption)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Load(IDataReader,LoadOption)
  nameWithType: DataTable.Load(IDataReader,LoadOption)
  fullName: System.Data.DataTable.Load(IDataReader,LoadOption)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "채웁니다는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 사용 하 여 제공 된 데이터 원본의 값으로 <xref href=&quot;System.Data.IDataReader&quot;> </xref>합니다. 경우는 <xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref> 행이 이미 포함 되어 데이터 원본에서 들어오는 데이터의 값에 따라 기존 행과 병합 되는 <code> loadOption </code> 매개 변수입니다."
  remarks: "The `Load` method consumes the first result set from the loaded <xref:System.Data.IDataReader>, and after successful completion, sets the reader's position to the next result set, if any. When converting data, the `Load` method uses the same conversion rules as the <xref:System.Data.Common.DbDataAdapter.Fill%2A> method.  \n  \n The `Load` method must take into account three specific issues when loading the data from an <xref:System.Data.IDataReader> instance: schema, data, and event operations. When working with the schema, the `Load` method may encounter conditions as described in the following table. The schema operations take place for all imported result sets, even those containing no data.  \n  \n|Condition|Behavior|  \n|---------------|--------------|  \n|The <xref:System.Data.DataTable> has no schema.|The `Load` method infers the schema based on the result set from the imported <xref:System.Data.IDataReader>.|  \n|The <xref:System.Data.DataTable> has a schema, but it is incompatible with the loaded schema.|The `Load` method throws an exception corresponding to the particular error that occurs when attempting to load data into the incompatible schema.|  \n|The schemas are compatible, but the loaded result set schema contains columns that don't exist in the `DataTable`.|The `Load` method adds the extra columns to `DataTable`’s schema. The method throws an exception if corresponding columns in the <xref:System.Data.DataTable> and the loaded result set are not value compatible. The method also retrieves constraint information from the result set for all added columns. Except for the case of Primary Key constraint, this constraint information is used only if the current <xref:System.Data.DataTable> does not contain any columns at the start of the load operation.|  \n|The schemas are compatible, but the loaded result set schema contains fewer columns than does the `DataTable`.|If a missing column has a default value defined or the column's data type is nullable, the `Load` method allows the rows to be added, substituting the default or null value for the missing column. If no default value or null can be used, then the `Load` method throws an exception. If no specific default value has been supplied, the `Load` method uses the null value as the implied default value.|  \n  \n Before considering the behavior of the `Load` method in terms of data operations, consider that each row within a <xref:System.Data.DataTable> maintains both the current value and the original value for each column. These values may be equivalent, or may be different if the data in the row has been changed since filling the `DataTable`. See [Row States and Row Versions](~/add/includes/ajax-current-ext-md.md) for more information.  \n  \n In this method call, the specified <xref:System.Data.LoadOption> parameter influences the processing of the incoming data. How should the Load method handle loading rows that have the same primary key as existing rows? Should it modify current values, original values, or both? These issues, and more, are controlled by the `loadOption` parameter.  \n  \n If the existing row and the incoming row contain corresponding primary key values, the row is processed using its current row state value, otherwise it's treated as a new row.  \n  \n In terms of event operations, the <xref:System.Data.DataTable.RowChanging> event occurs before each row is changed, and the <xref:System.Data.DataTable.RowChanged> event occurs after each row has been changed. In each case, the <xref:System.Data.DataRowChangeEventArgs.Action%2A> property of the <xref:System.Data.DataRowChangeEventArgs> instance passed to the event handler contains information about the particular action associated with the event. This action value varies, depending on the state of the row before the load operation. In each case, both events occur, and the action is the same for each. The action may be applied to either the current or original version of each row, or both, depending on the current row state.  \n  \n The following table displays behavior for the Load method when called with each of the `LoadOption` values, and also shows how the values interact with the row state for the row being loaded. The final row (labeled \"(Not present)\") describes the behavior for incoming rows that don't match any existing row. Each cell in this table describes the current and original value for a field within a row, along with the <xref:System.Data.DataRowState> for the value after the `Load` method has completed.  \n  \n|Existing DataRowState|Upsert|OverwriteChanges|PreserveChanges (Default behavior)|  \n|---------------------------|------------|----------------------|------------------------------------------|  \n|Added|Current = \\<Incoming><br /><br /> Original = -\\<Not available><br /><br /> State = \\<Added><br /><br /> RowAction = Change|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Existing><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Modified><br /><br /> RowAction = ChangeOriginal|  \n|Modified|Current = \\<Incoming><br /><br /> Original = \\<Existing><br /><br /> State = \\<Modified><br /><br /> RowAction = Change|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Existing><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Modified><br /><br /> RowAction =ChangeOriginal|  \neleted|(Load does not affect deleted rows)<br /><br /> Current = ---<br /><br /> Original = \\<Existing><br /><br /> State = \\<Deleted><br /><br /> (New row is added with the following characteristics)<br /><br /> Current = \\<Incoming><br /><br /> Original = \\<Not available><br /><br /> State = \\<Added><br /><br /> RowAction = Add|Undo delete and<br /><br /> Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Not available><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Deleted><br /><br /> RowAction = ChangeOriginal|  \n|Unchanged|Current = \\<Incoming><br /><br /> Original = \\<Existing><br /><br /> If new value is the same as the existing value then<br /><br /> State = \\<Unchanged><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> State = \\<Modified><br /><br /> RowAction = Change|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|  \nNot present)|Current = \\<Incoming><br /><br /> Original = \\<Not available><br /><br /> State = \\<Added><br /><br /> RowAction = Add|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|  \n  \n Values in a <xref:System.Data.DataColumn> can be constrained through use of properties such as <xref:System.Data.DataColumn.ReadOnly%2A> and <xref:System.Data.DataColumn.AutoIncrement%2A>. The `Load` method handles such columns in a manner that is consistent with the behavior defined by the column's properties. The read only constraint on a <xref:System.Data.DataColumn> is applicable only for changes that occur in memory. The `Load` method's overwrites the read-only column values, if needed.  \n  \n If you specify the OverwriteChanges or PreserveChanges options when calling the `Load` method, then the assumption is made that the incoming data is coming from the `DataTable`'s primary data source, and the DataTable tracks changes and can propagate the changes back to the data source. If you select the Upsert option, it is assumed that the data is coming from one of a secondary data source, such as data provided by a middle-tier component, perhaps altered by a user. In this case, the assumption is that the intent is to aggregate data from one or more data sources in the `DataTable`, and then perhaps propagate the data back to the primary data source. The <xref:System.Data.LoadOption> parameter is used for determining the specific version of the row that is to be used for primary key comparison. The table below provides the details.  \n  \n|Load option|DataRow version used for primary key comparison|  \n|-----------------|-----------------------------------------------------|  \n|`OverwriteChanges`|Original version, if it exists, otherwise Current version|  \n|`PreserveChanges`|Original version, if it exists, otherwise Current version|  \n|`Upsert`|Current version, if it exists, otherwise Original version|"
  example:
  - "The following example demonstrates several of the issues involved with calling the Load method. First, the example focuses on schema issues, including inferring a schema from the loaded <xref:System.Data.IDataReader>, and then handling incompatible schemas, and schemas with missing or additional columns. The example then focuses on data issues, including handling the various loading options.  \n  \n [!code-cs[DataWorks DataTableLoad.LoadOption#1](~/add/codesnippet/csharp/m-system.data.datatable._29_1.cs)]\n [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/add/codesnippet/visualbasic/m-system.data.datatable._29_1.vb)]"
  syntax:
    content: public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);
    parameters:
    - id: reader
      type: System.Data.IDataReader
      description: "<xref href=&quot;System.Data.IDataReader&quot;> </xref> 하나 이상의 결과 집합을 제공 하는 합니다."
    - id: loadOption
      type: System.Data.LoadOption
      description: "값은 <xref href=&quot;System.Data.LoadOption&quot;> </xref> 를 나타내는 열거형입니다 방법을 있는 행는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 동일한 기본 키를 공유 하는 들어오는 행과 결합 됩니다."
  overload: System.Data.DataTable.Load*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)
  id: Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Load(IDataReader,LoadOption,FillErrorEventHandler)
  nameWithType: DataTable.Load(IDataReader,LoadOption,FillErrorEventHandler)
  fullName: System.Data.DataTable.Load(IDataReader,LoadOption,FillErrorEventHandler)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "채웁니다는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 사용 하 여 제공 된 데이터 원본의 값으로 <xref href=&quot;System.Data.IDataReader&quot;> </xref> 오류 처리 대리자를 사용 하 여 합니다."
  remarks: "The `Load` method consumes the first result set from the loaded <xref:System.Data.IDataReader>, and after successful completion, sets the reader's position to the next result set, if any. When converting data, the `Load` method uses the same conversion rules as the <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=fullName> method.  \n  \n The `Load` method must take into account three specific issues when loading the data from an <xref:System.Data.IDataReader> instance: schema, data, and event operations. When working with the schema, the `Load` method may encounter conditions as described in the following table. The schema operations take place for all imported result sets, even those containing no data.  \n  \n|Condition|Behavior|  \n|---------------|--------------|  \n|The <xref:System.Data.DataTable> has no schema.|The `Load` method infers the schema based on the result set from the imported <xref:System.Data.IDataReader>.|  \n|The <xref:System.Data.DataTable> has a schema, but it is incompatible with the loaded schema.|The `Load` method throws an exception corresponding to the particular error that occurs when attempting to load data into the incompatible schema.|  \n|The schemas are compatible, but the loaded result set schema contains columns that don't exist in the `DataTable`.|The `Load` method adds the extra column(s) to `DataTable`’s schema. The method throws an exception if corresponding columns in the <xref:System.Data.DataTable> and the loaded result set are not value compatible. The method also retrieves constraint information from the result set for all added columns. Except for the case of Primary Key constraint, this constraint information is used only if the current <xref:System.Data.DataTable> does not contain any columns at the start of the load operation.|  \n|The schemas are compatible, but the loaded result set schema contains fewer columns than does the `DataTable`.|If a missing column has a default value defined or the column's data type is nullable, the `Load` method allows the rows to be added, substituting the default or null value for the missing column. If no default value or null can be used, then the `Load` method throws an exception. If no specific default value has been supplied, the `Load` method uses the null value as the implied default value.|  \n  \n Before considering the behavior of the `Load` method in terms of data operations, consider that each row within a <xref:System.Data.DataTable> maintains both the current value and the original value for each column. These values may be equivalent, or may be different if the data in the row has been changed since filling the `DataTable`. See [Row States and Row Versions](~/add/includes/ajax-current-ext-md.md) for more information.  \n  \n In this method call, the specified <xref:System.Data.LoadOption> parameter influences the processing of the incoming data. How should the Load method handle loading rows that have the same primary key as existing rows? Should it modify current values, original values, or both? These issues, and more, are controlled by the `loadOption` parameter.  \n  \n If the existing row and the incoming row contain corresponding primary key values, the row is processed using its current row state value, otherwise it's treated as a new row.  \n  \n In terms of event operations, the <xref:System.Data.DataTable.RowChanging> event occurs before each row is changed, and the <xref:System.Data.DataTable.RowChanged> event occurs after each row has been changed. In each case, the <xref:System.Data.DataRowChangeEventArgs.Action%2A> property of the <xref:System.Data.DataRowChangeEventArgs> instance passed to the event handler contains information about the particular action associated with the event. This action value varies, depending on the state of the row before the load operation. In each case, both events occur, and the action is the same for each. The action may be applied to either the current or original version of each row, or both, depending on the current row state.  \n  \n The following table displays behavior for the Load method when called with each of the `LoadOption` values, and also shows how the values interact with the row state for the row being loaded. The final row (labeled \"(Not present)\") describes the behavior for incoming rows that don't match any existing row. Each cell in this table describes the current and original value for a field within a row, along with the <xref:System.Data.DataRowState> for the value after the `Load` method has completed.  \n  \n|Existing DataRowState|Upsert|OverwriteChanges|PreserveChanges (Default behavior)|  \n|---------------------------|------------|----------------------|------------------------------------------|  \n|Added|Current = \\<Incoming><br /><br /> Original = -\\<Not available><br /><br /> State = \\<Added><br /><br /> RowAction = Change|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Existing><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Modified><br /><br /> RowAction = ChangeOriginal|  \n|Modified|Current = \\<Incoming><br /><br /> Original = \\<Existing><br /><br /> State = \\<Modified><br /><br /> RowAction = Change|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Existing><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Modified><br /><br /> RowAction =ChangeOriginal|  \neleted|(Load does not affect deleted rows)<br /><br /> Current = ---<br /><br /> Original = \\<Existing><br /><br /> State = \\<Deleted><br /><br /> (New row is added with the following characteristics)<br /><br /> Current = \\<Incoming><br /><br /> Original = \\<Not available><br /><br /> State = \\<Added><br /><br /> RowAction = Add|Undo delete and<br /><br /> Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Not available><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Deleted><br /><br /> RowAction = ChangeOriginal|  \n|Unchanged|Current = \\<Incoming><br /><br /> Original = \\<Existing><br /><br /> If new value is the same as the existing value then<br /><br /> State = \\<Unchanged><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> State = \\<Modified><br /><br /> RowAction = Change|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|  \nNot present)|Current = \\<Incoming><br /><br /> Original = \\<Not available><br /><br /> State = \\<Added><br /><br /> RowAction = Add|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|  \n  \n Values in a <xref:System.Data.DataColumn> can be constrained through use of properties such as <xref:System.Data.DataColumn.ReadOnly%2A> and <xref:System.Data.DataColumn.AutoIncrement%2A>. The `Load` method handles such columns in a manner that is consistent with the behavior defined by the column's properties. The read only constraint on a <xref:System.Data.DataColumn> is applicable only for changes that occur in memory. The `Load` method's overwrites the read-only column values, if needed.  \n  \n If you specify the OverwriteChanges or PreserveChanges options when calling the `Load` method, then the assumption is made that the incoming data is coming from the `DataTable`'s primary data source, and the DataTable tracks changes and can propagate the changes back to the data source. If you select the Upsert option, it is assumed that the data is coming from one of a secondary data source, such as data provided by a middle-tier component, perhaps altered by a user. In this case, the assumption is that the intent is to aggregate data from one or more data sources in the `DataTable`, and then perhaps propagate the data back to the primary data source. The <xref:System.Data.LoadOption> parameter is used for determining the specific version of the row that is to be used for primary key comparison. The table below provides the details.  \n  \n|Load option|DataRow version used for primary key comparison|  \n|-----------------|-----------------------------------------------------|  \n|`OverwriteChanges`|Original version, if it exists, otherwise Current version|  \n|`PreserveChanges`|Original version, if it exists, otherwise Current version|  \n|`Upsert`|Current version, if it exists, otherwise Original version|  \n  \n The `errorHandler` parameter is a <xref:System.Data.FillErrorEventHandler> delegate that refers to a procedure that is called when an error occurs while loading data. The <xref:System.Data.FillErrorEventArgs> parameter passed to the procedure provides properties that allow you to retrieve information about the error that occurred, the current row of data, and the <xref:System.Data.DataTable> being filled. Using this delegate mechanism, rather than a simpler try/catch block, allows you to determine the error, handle the situation, and continue processing if you like. The <xref:System.Data.FillErrorEventArgs> parameter supplies a <xref:System.Data.FillErrorEventArgs.Continue%2A> property: set this property to `true` to indicate that you have handled the error and wish to continue processing. Set the property to `false` to indicate that you wish to halt processing. Be aware that setting the property to `false` causes the code that triggered the problem to throw an exception."
  example:
  - >-
    [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/add/codesnippet/visualbasic/e9f1029e-2520-490c-8397-_1.vb)]
     [!code-cs[DataWorks DataTableLoad.ErrorEventHandler#1](~/add/codesnippet/csharp/e9f1029e-2520-490c-8397-_1.cs)]
  syntax:
    content: public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);
    parameters:
    - id: reader
      type: System.Data.IDataReader
      description: "A <xref href=&quot;System.Data.IDataReader&quot;> </xref> 하는 결과 집합을 제공 합니다."
    - id: loadOption
      type: System.Data.LoadOption
      description: "값은 <xref href=&quot;System.Data.LoadOption&quot;> </xref> 를 나타내는 열거형입니다 방법을 있는 행는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 동일한 기본 키를 공유 하는 들어오는 행과 결합 됩니다."
    - id: errorHandler
      type: System.Data.FillErrorEventHandler
      description: "A <xref href=&quot;System.Data.FillErrorEventHandler&quot;> </xref> 데이터를 로드 하는 동안 오류가 발생할 때 호출할 대리자입니다."
  overload: System.Data.DataTable.Load*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)
  id: LoadDataRow(System.Object[],System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: LoadDataRow(Object[],Boolean)
  nameWithType: DataTable.LoadDataRow(Object[],Boolean)
  fullName: System.Data.DataTable.LoadDataRow(Object[],Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "찾아 특정 행을 업데이트 합니다. 일치 하는 특성이 있는 경우 지정된 된 값을 사용 하 여 새 행이 만들어집니다."
  remarks: "LoadDataRow 메서드 값의 배열을 사용 하 고 기본 키 열에 일치 하는 값을 찾습니다.       열에 기본 값, 해당 열에 대 한 기본값을 설정 하는 배열에 null 값을 전달 합니다. 마찬가지로, 열에 있으면 해당 <xref:System.Data.DataColumn.AutoIncrement%2A>속성이 행에 대해 자동으로 생성 된 값을 설정 하는 배열에 null 값을 전달 합니다. true로 설정 합니다.</xref:System.Data.DataColumn.AutoIncrement%2A>       경우는 `fAcceptChanges` 매개 변수는 `true` 하거나 지정 하지 않으면 새 데이터가 추가 되 차례로 <xref:System.Data.DataTable.AcceptChanges%2A>에서 모든 변경 내용을 적용 하기 위해 호출 됩니다는 <xref:System.Data.DataTable>인수가; `false`, 새로 추가 된 행 삽입으로 표시 되 고 기존 행에 대 한 변경 내용은 수정으로 표시 됩니다.</xref:System.Data.DataTable> </xref:System.Data.DataTable.AcceptChanges%2A>       예외도 수행 하는 동안 발생할 수 있습니다는 <xref:System.Data.DataTable.ColumnChanging>또는 <xref:System.Data.DataTable.RowChanging>이벤트.</xref:System.Data.DataTable.RowChanging> </xref:System.Data.DataTable.ColumnChanging> 예외가 발생 하는 경우 테이블에 행 추가 되지 않습니다.       LoadDataRow <xref:System.Data.DataTable.BeginLoadData%2A>및 <xref:System.Data.DataTable.EndLoadData%2A>.</xref:System.Data.DataTable.EndLoadData%2A> </xref:System.Data.DataTable.BeginLoadData%2A> 와 함께에서 사용 하 여"
  example:
  - "The following example uses the LoadDataRow method to attempt to find a row. If no such row is found, the values are used to create a new row.  \n  \n [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._23_1.vb)]\n [!code-cs[Classic WebData DataTable.LoadDataRow Example#1](~/add/codesnippet/csharp/m-system.data.datatable._23_1.cs)]"
  syntax:
    content: public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);
    parameters:
    - id: values
      type: System.Object[]
      description: "새 행을 만들고 사용 하는 값의 배열입니다."
    - id: fAcceptChanges
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>변경 사항을 적용 하려면 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
    return:
      type: System.Data.DataRow
      description: "The new <xref href=&quot;System.Data.DataRow&quot;></xref>."
  overload: System.Data.DataTable.LoadDataRow*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "배열의는 테이블의 열 개수 보다 큽니다."
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "값을 해당 열 형식과 일치 하지 않습니다."
  - type: System.Data.ConstraintException
    commentId: T:System.Data.ConstraintException
    description: "제약 조건을 무효화 행을 추가 합니다."
  - type: System.Data.NoNullAllowedException
    commentId: T:System.Data.NoNullAllowedException
    description: "열에 null을 입력 하려고 합니다. 여기서 <xref:System.Data.DataColumn.AllowDBNull*>false.</xref:System.Data.DataColumn.AllowDBNull*>"
  platform:
  - net462
- uid: System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)
  id: LoadDataRow(System.Object[],System.Data.LoadOption)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: LoadDataRow(Object[],LoadOption)
  nameWithType: DataTable.LoadDataRow(Object[],LoadOption)
  fullName: System.Data.DataTable.LoadDataRow(Object[],LoadOption)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "찾아 특정 행을 업데이트 합니다. 일치 하는 특성이 있는 경우 지정된 된 값을 사용 하 여 새 행이 만들어집니다."
  remarks: "<xref:System.Data.DataTable.LoadDataRow%2A>메서드 값의 배열을 사용 하 고 기본 키 열에 일치 하는 값을 찾습니다.</xref:System.Data.DataTable.LoadDataRow%2A>       열에 기본 값, 해당 열에 대 한 기본값을 설정 하는 배열에 null 값을 전달 합니다. 마찬가지로, 열에 있으면 해당 <xref:System.Data.DataColumn.AutoIncrement%2A>속성이 행에 대해 자동으로 생성 된 값을 설정 하는 배열에 null 값을 전달 합니다. true로 설정 합니다.</xref:System.Data.DataColumn.AutoIncrement%2A>       값은 `loadOption` 매개 변수를 사용 하는 배열의 값이 기존 행에 적용 되는 방식을 결정 합니다. 예를 들어 경우 `loadOption` 로 설정 된 `OverwriteChanges`, `Original` 및 `Current` 각 열의 값이 들어오는 행의 값으로 바뀌는 및 `RowState` 속성이로 설정 된 `Unchanged`합니다.       예외도 수행 하는 동안 발생할 수 있습니다는 <xref:System.Data.DataTable.ColumnChanging>또는 <xref:System.Data.DataTable.RowChanging>이벤트.</xref:System.Data.DataTable.RowChanging> </xref:System.Data.DataTable.ColumnChanging> 예외가 발생 하는 경우 테이블에 행 추가 되지 않습니다.       <xref:System.Data.DataTable.LoadDataRow%2A> <xref:System.Data.DataTable.BeginLoadData%2A>및 <xref:System.Data.DataTable.EndLoadData%2A>.</xref:System.Data.DataTable.EndLoadData%2A> </xref:System.Data.DataTable.BeginLoadData%2A> 와 함께에서</xref:System.Data.DataTable.LoadDataRow%2A> 사용 하 여"
  syntax:
    content: public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);
    parameters:
    - id: values
      type: System.Object[]
      description: "새 행을 만들고 사용 하는 값의 배열입니다."
    - id: loadOption
      type: System.Data.LoadOption
      description: "배열 값은 기존 행에 해당 값에 적용 되는 방식을 결정 하는 데 사용 합니다."
    return:
      type: System.Data.DataRow
      description: "The new <xref href=&quot;System.Data.DataRow&quot;></xref>."
  overload: System.Data.DataTable.LoadDataRow*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Locale
  id: Locale
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Locale
  nameWithType: DataTable.Locale
  fullName: System.Data.DataTable.Locale
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "테이블 내의 문자열을 비교 하는 데 로캘 정보를 가져오거나 설정 합니다."
  remarks: "A <xref:System.Globalization.CultureInfo>특정 문화권 또는 커뮤니티의 소프트웨어 기본 설정을 나타냅니다.</xref:System.Globalization.CultureInfo>       문자열 비교에 사용 되는 경우는 <xref:System.Globalization.CultureInfo>비교, 정렬 및 필터링에 영향을 줍니다.</xref:System.Globalization.CultureInfo>      > [!NOTE] > 식이 포함 된 열에는 <xref:System.StringComparison>사용 됩니다.</xref:System.StringComparison> <xref:System.StringComparison>는 무시 됩니다.</xref:System.StringComparison>"
  example:
  - "The following example sets the <xref:System.Globalization.CultureInfo> through the Locale and prints the ISO language name.  \n  \n [!code-cs[Classic WebData DataTable.Locale Example#1](~/add/codesnippet/csharp/p-system.data.datatable._5_1.cs)]\n [!code-vb[Classic WebData DataTable.Locale Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._5_1.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo Locale { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "A <xref:System.Globalization.CultureInfo>사용자의 컴퓨터 로캘에 대 한 데이터가 들어 있는.</xref:System.Globalization.CultureInfo> 기본값은는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 개체의 <xref:System.Globalization.CultureInfo>(에서 반환 되는 <xref:System.Data.DataSet.Locale*>속성)을는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 속한; 테이블에 속하지는 <xref href=&quot;System.Data.DataSet&quot;> </xref>, 기본값은 현재 시스템 <xref:System.Globalization.CultureInfo>.</xref:System.Globalization.CultureInfo> </xref:System.Data.DataSet.Locale*> </xref:System.Globalization.CultureInfo>"
  overload: System.Data.DataTable.Locale*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Merge(System.Data.DataTable)
  id: Merge(System.Data.DataTable)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Merge(DataTable)
  nameWithType: DataTable.Merge(DataTable)
  fullName: System.Data.DataTable.Merge(DataTable)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "지정 된 병합 <xref href=&quot;System.Data.DataTable&quot;> </xref> 현재의 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  remarks: "Merge 메서드 두 개를 병합 하는 데는 <xref:System.Data.DataTable>비슷하긴 하지만 스키마가 포함 된 개체입니다.</xref:System.Data.DataTable> 데이터 원본에서 최신 변경 내용을 기존 <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 에 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataTable>데이터 원본에서 최신 데이터로.</xref:System.Data.DataTable>       병합 작업은 원래 테이블만 병합 될 테이블을 고려 합니다. 자식 테이블은 영향을 하지 않거나 포함 하십시오. 테이블 관계의 일부분으로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블은 개별적으로 병합 해야 합니다.       `Merge` 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 새로 고침 관련 된 절차의 끝에 호출       병합을 수행할 때 기존 데이터를 병합 하기 전에 변경 내용이 병합 작업 동안 기본적으로 유지 됩니다. 개발자는이 메서드에 대 한 호출 하는 다른 두 오버 로드 중 하나에 대 한 값이 false를 지정 하 여이 동작을 수정할 수는 `preserveChanges` 매개 변수입니다.       클라이언트 응용 프로그램에는 단일 단추가 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 별로있지 않습니다. 이 시나리오는 <xref:System.Data.DataTable.GetChanges%2A>메서드가 먼저 호출 됩니다.</xref:System.Data.DataTable.GetChanges%2A> 이 메서드는 두 번째 <xref:System.Data.DataTable>유효성 검사 및 병합에 대 한 액세스에 최적화 된.</xref:System.Data.DataTable> 이 두 번째 <xref:System.Data.DataTable>개체는 <xref:System.Data.DataRow>원래 <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 의 하위 집합을 변경 된 개체</xref:System.Data.DataRow> 에 대해서만 포함</xref:System.Data.DataTable> 이 하위 집합은 일반적으로 더 작은 때문에 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataTable>(다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.</xref:System.Data.DataTable> (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataTable>클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataTable>병합 메서드로.</xref:System.Data.DataTable> </xref:System.Data.DataTable>       새 소스를 병합할 때 <xref:System.Data.DataTable>대상에 모든 소스 행 한 <xref:System.Data.DataRowState>값 `Unchanged`, `Modified`, 또는 `Deleted`, 동일한 기본 키 값을 가진 대상 행에 일치 합니다.</xref:System.Data.DataRowState> </xref:System.Data.DataTable> 소스 행 한 <xref:System.Data.DataRowState>값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.</xref:System.Data.DataRowState>"
  example:
  - "The following console application creates a simple <xref:System.Data.DataTable> and adds data to the table. The example then creates a copy of the table, adding rows to the copy. Finally, the example calls the Merge method to merge the data in the second table with the data in the first table.  \n  \n [!code-vb[DataWorks DataTable.Merge#1](~/add/codesnippet/visualbasic/m-system.data.datatable._4_1.vb)]\n [!code-cs[DataWorks DataTable.Merge#1](~/add/codesnippet/csharp/m-system.data.datatable._4_1.cs)]"
  syntax:
    content: public void Merge (System.Data.DataTable table);
    parameters:
    - id: table
      type: System.Data.DataTable
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref> 현재와 병합 될 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  overload: System.Data.DataTable.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)
  id: Merge(System.Data.DataTable,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Merge(DataTable,Boolean)
  nameWithType: DataTable.Merge(DataTable,Boolean)
  fullName: System.Data.DataTable.Merge(DataTable,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "지정 된 병합 <xref href=&quot;System.Data.DataTable&quot;> </xref> 현재의 <xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref>, 현재에서 변경 내용을 유지할지 여부를 나타내는 <xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "Merge 메서드 두 개를 병합 하는 데는 <xref:System.Data.DataTable>비슷하긴 하지만 스키마가 포함 된 개체입니다.</xref:System.Data.DataTable> 데이터 원본에서 최신 변경 내용을 기존 <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 에 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataTable>데이터 원본에서 최신 데이터로.</xref:System.Data.DataTable>       병합 작업은 원래 테이블만 병합 될 테이블을 고려 합니다. 자식 테이블은 영향을 하지 않거나 포함 하십시오. 테이블 관계의 일부분으로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블은 개별적으로 병합 해야 합니다.       `Merge` 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 새로 고침 관련 된 절차의 끝에 호출       개발자에 대해서는 false를 지정 하지 않은 경우 기존 데이터를 병합 하기 전에 변경 내용이 병합 작업 동안 유지 됩니다 병합을 수행할 때의 `preserveChanges` 매개 변수입니다. 경우는 `preserveChanges` 로 설정 된 `true`, 들어오는 값은 기존 행의 현재 행 버전의 기존 값을 덮어쓰지 않습니다. 경우는 `preserveChanges` 로 설정 된 `false`, 들어오는 값은 기존 행의 현재 행 버전의 기존 값을 덮어씁니다. 행 버전에 대 한 자세한 내용은 참조 [행 상태 및 행 버전](~/add/includes/ajax-current-ext-md.md)합니다.       클라이언트 응용 프로그램에는 단일 단추가 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 별로있지 않습니다. 이 시나리오는 <xref:System.Data.DataTable.GetChanges%2A>메서드가 먼저 호출 됩니다.</xref:System.Data.DataTable.GetChanges%2A> 이 메서드는 두 번째 <xref:System.Data.DataTable>유효성 검사 및 병합에 대 한 액세스에 최적화 된.</xref:System.Data.DataTable> 이 두 번째 <xref:System.Data.DataTable>개체는 포함 <xref:System.Data.DataTable>하 고 <xref:System.Data.DataRow>원래 <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 의 하위 집합을 변경 된 개체</xref:System.Data.DataRow> </xref:System.Data.DataTable> </xref:System.Data.DataTable> 이 하위 집합 일반적으로 더 작은 이며 따라서이 하위 집합은 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataTable>(다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.</xref:System.Data.DataTable> (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataTable>클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataTable>와 <xref:System.Data.DataTable.Merge%2A>메서드.</xref:System.Data.DataTable.Merge%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable>       새 소스를 병합할 때 <xref:System.Data.DataTable>대상에 모든 소스 행 한 <xref:System.Data.DataRowState>값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.</xref:System.Data.DataRowState> </xref:System.Data.DataTable> 소스 행 한 <xref:System.Data.DataRowState>값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.</xref:System.Data.DataRowState>"
  example:
  - "The following console application creates a <xref:System.Data.DataTable> containing rows, modifies some of the data in those rows, and attempts to merge data from a different <xref:System.Data.DataTable>. The example demonstrates the different behaviors for the `preserveChanges` parameter.  \n  \n [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/add/codesnippet/visualbasic/m-system.data.datatable._2_1.vb)]\n [!code-cs[DataWorks DataTable.MergePreserveChanges#1](~/add/codesnippet/csharp/m-system.data.datatable._2_1.cs)]"
  syntax:
    content: public void Merge (System.Data.DataTable table, bool preserveChanges);
    parameters:
    - id: table
      type: System.Data.DataTable
      description: "<xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref> 현재와 병합 될 <xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref>합니다."
    - id: preserveChanges
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>현재에서 변경 내용을 유지 하려면 <xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref>고, 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다.<xref uid=&quot;langword_csharp_&quot; name=&quot;&quot; href=&quot;&quot;></xref>"
  overload: System.Data.DataTable.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  id: Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Merge(DataTable,Boolean,MissingSchemaAction)
  nameWithType: DataTable.Merge(DataTable,Boolean,MissingSchemaAction)
  fullName: System.Data.DataTable.Merge(DataTable,Boolean,MissingSchemaAction)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "지정 된 병합 <xref href=&quot;System.Data.DataTable&quot;> </xref> 현재의 <xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref>, 변경 내용을 유지할지 여부와 현재의 누락 된 스키마를 처리 하는 방법을 나타내는 <xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "`Merge` 병합할 두 개의 메서드를 사용 하는 <xref:System.Data.DataTable>비슷하긴 하지만 스키마가 포함 된 개체입니다.</xref:System.Data.DataTable> 데이터 원본에서 최신 변경 내용을 기존 <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 에 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataTable>데이터 원본에서 최신 데이터로.</xref:System.Data.DataTable>       병합 작업은 원래 테이블만 병합 될 테이블을 고려 합니다. 자식 테이블은 영향을 하지 않거나 포함 하십시오. 테이블 관계의 일부분으로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블은 개별적으로 병합 해야 합니다.       `Merge` 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 새로 고침 관련 된 절차의 끝에 호출       개발자에 대해서는 false를 지정 하지 않은 경우 기존 데이터를 병합 하기 전에 변경 내용이 병합 작업 동안 유지 됩니다 병합을 수행할 때의 `preserveChanges` 매개 변수입니다. 경우는 `preserveChanges` 로 설정 된 `true`, 들어오는 값은 기존 행의 현재 행 버전의 기존 값을 덮어쓰지 않습니다. 경우는 `preserveChanges` 로 설정 된 `false`, 들어오는 값은 기존 행의 현재 행 버전의 기존 값을 덮어씁니다. 행 버전에 대 한 자세한 내용은 참조 [행 상태 및 행 버전](~/add/includes/ajax-current-ext-md.md)합니다.       클라이언트 응용 프로그램에는 단일 단추가 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 별로있지 않습니다. 이 시나리오는 <xref:System.Data.DataTable.GetChanges%2A>메서드가 먼저 호출 됩니다.</xref:System.Data.DataTable.GetChanges%2A> 이 메서드는 두 번째 <xref:System.Data.DataTable>유효성 검사 및 병합에 대 한 액세스에 최적화 된.</xref:System.Data.DataTable> 이 두 번째 <xref:System.Data.DataTable>개체는 포함 <xref:System.Data.DataTable>하 고 <xref:System.Data.DataRow>원래 <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 의 하위 집합을 변경 된 개체</xref:System.Data.DataRow> </xref:System.Data.DataTable> </xref:System.Data.DataTable> 이 하위 집합 일반적으로 더 작은 이며 따라서이 하위 집합은 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataTable>(다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.</xref:System.Data.DataTable> (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataTable>클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataTable>와 <xref:System.Data.DataTable.Merge%2A>메서드.</xref:System.Data.DataTable.Merge%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable>       경우는 <xref:System.Data.DataTable.Merge%2A>메서드가 호출 되 면 두 스키마 <xref:System.Data.DataTable>개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다.</xref:System.Data.DataTable> </xref:System.Data.DataTable.Merge%2A> 예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다. 경우 소스 <xref:System.Data.DataTable>스키마 요소를 포함 (추가 <xref:System.Data.DataColumn>개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 `missingSchemaAction` 인수 `MissingSchemaAction.Add`.</xref:System.Data.DataColumn> </xref:System.Data.DataTable> 병합 된 경우에서 <xref:System.Data.DataTable>추가 된 스키마와 데이터를 포함 합니다.</xref:System.Data.DataTable>       스키마를 병합 한 후 데이터를 병합 합니다.       새 소스를 병합할 때 <xref:System.Data.DataTable>대상에 모든 소스 행 한 <xref:System.Data.DataRowState>값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.</xref:System.Data.DataRowState> </xref:System.Data.DataTable> 소스 행 한 <xref:System.Data.DataRowState>값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.</xref:System.Data.DataRowState>"
  example:
  - "The following console application demonstrates the behavior of the `missingSchemaAction` parameter of the Merge method. This example creates two versions of the same table, modifying the schema for the second version. The code then attempts to merge the second table into the first.  \n  \n [!code-cs[DataWorks DataTable.MergeMissingSchemaAction#1](~/add/codesnippet/csharp/0a34dc2a-14c3-4d65-b78d-_1.cs)]\n [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/add/codesnippet/visualbasic/0a34dc2a-14c3-4d65-b78d-_1.vb)]"
  syntax:
    content: public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);
    parameters:
    - id: table
      type: System.Data.DataTable
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref> 현재와 병합 될 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
    - id: preserveChanges
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>현재에서 변경 내용을 유지 하려면 <xref href=&quot;System.Data.DataTable&quot;> </xref>고, 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
    - id: missingSchemaAction
      type: System.Data.MissingSchemaAction
      description: "중 하나는 <xref href=&quot;System.Data.MissingSchemaAction&quot;> </xref> 값입니다."
  overload: System.Data.DataTable.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.MinimumCapacity
  id: MinimumCapacity
  parent: System.Data.DataTable
  langs:
  - csharp
  name: MinimumCapacity
  nameWithType: DataTable.MinimumCapacity
  fullName: System.Data.DataTable.MinimumCapacity
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 테이블에 대 한 초기 시작 크기를 가져오거나 설정 합니다."
  remarks: "minimumcapacity는 시스템을에 데이터를 인출 하기 전에 리소스의 적절 한 세트를 만들 수 있습니다. 상황에서이 속성을 설정할 경우 성능 상태가 심각 하면 성능을 최적화할 수 있습니다."
  example:
  - "The following example sets the MinimumCapacity of a <xref:System.Data.DataTable>.  \n  \n [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._6_1.vb)]\n [!code-cs[Classic WebData DataTable.MinimumCapacity Example#1](~/add/codesnippet/csharp/p-system.data.datatable._6_1.cs)]"
  syntax:
    content: public int MinimumCapacity { get; set; }
    return:
      type: System.Int32
      description: "이 테이블의 행에 대 한 초기 시작 크기입니다. 기본값은 50입니다."
  overload: System.Data.DataTable.MinimumCapacity*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Namespace
  id: Namespace
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Namespace
  nameWithType: DataTable.Namespace
  fullName: System.Data.DataTable.Namespace
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 저장 된 데이터의 XML 표현에 대 한 네임 스페이스를 가져오거나 설정 합니다.는 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  syntax:
    content: public string Namespace { get; set; }
    return:
      type: System.String
      description: "네임 스페이스는 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  overload: System.Data.DataTable.Namespace*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.NewRow
  id: NewRow
  parent: System.Data.DataTable
  langs:
  - csharp
  name: NewRow()
  nameWithType: DataTable.NewRow()
  fullName: System.Data.DataTable.NewRow()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "새 <xref href=&quot;System.Data.DataRow&quot;> </xref> 테이블과 동일한 스키마와 함께 합니다."
  remarks: "새 <xref:System.Data.DataRow> <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 와 동일한 스키마를 사용 하 여 개체</xref:System.Data.DataRow> 를 만들 NewRow 메서드를 사용 해야 합니다. 만든 후는 <xref:System.Data.DataRow>를에 추가할 수 있습니다는 <xref:System.Data.DataRowCollection>통해는 <xref:System.Data.DataTable>개체의 <xref:System.Data.DataTable.Rows%2A>속성.</xref:System.Data.DataTable.Rows%2A> </xref:System.Data.DataTable> </xref:System.Data.DataRowCollection> </xref:System.Data.DataRow> NewRow를 사용 하 여 새 행을 만들 때 행은에 추가 하거나 <xref:System.Data.DataTable.Clear%2A>.</xref:System.Data.DataTable.Clear%2A> 를 호출 하기 전에 데이터 테이블에서 삭제 해야"
  example:
  - "The following example creates a <xref:System.Data.DataTable>, adds two <xref:System.Data.DataColumn> objects that determine the table's schema, and creates several new <xref:System.Data.DataRow> objects using the NewRow method. Those <xref:System.Data.DataRow> objects are then added to the <xref:System.Data.DataRowCollection> using the <xref:System.Data.DataRowCollection.Add%2A> method.  \n  \n [!code-vb[Classic WebData DataTable.NewRow Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._27_1.vb)]\n [!code-cs[Classic WebData DataTable.NewRow Example#1](~/add/codesnippet/csharp/m-system.data.datatable._27_1.cs)]"
  syntax:
    content: public System.Data.DataRow NewRow ();
    parameters: []
    return:
      type: System.Data.DataRow
      description: "A <xref href=&quot;System.Data.DataRow&quot;> </xref> 와 동일한 스키마와는 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  overload: System.Data.DataTable.NewRow*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.NewRowArray(System.Int32)
  id: NewRowArray(System.Int32)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: NewRowArray(Int32)
  nameWithType: DataTable.NewRowArray(Int32)
  fullName: System.Data.DataTable.NewRowArray(Int32)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "배열을 반환 <xref href=&quot;System.Data.DataRow&quot;> </xref>합니다."
  syntax:
    content: protected System.Data.DataRow[] NewRowArray (int size);
    parameters:
    - id: size
      type: System.Int32
      description: "A <xref:System.Int32>배열 크기를 설명 하는 값입니다.</xref:System.Int32>"
    return:
      type: System.Data.DataRow[]
      description: "새 배열입니다."
  overload: System.Data.DataTable.NewRowArray*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)
  id: NewRowFromBuilder(System.Data.DataRowBuilder)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: NewRowFromBuilder(DataRowBuilder)
  nameWithType: DataTable.NewRowFromBuilder(DataRowBuilder)
  fullName: System.Data.DataTable.NewRowFromBuilder(DataRowBuilder)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "기존 행에서 새 행을 만듭니다."
  syntax:
    content: protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);
    parameters:
    - id: builder
      type: System.Data.DataRowBuilder
      description: "A <xref href=&quot;System.Data.DataRowBuilder&quot;></xref> object."
    return:
      type: System.Data.DataRow
      description: "A <xref href=&quot;System.Data.DataRow&quot;> </xref> 클래스를 파생 합니다."
  overload: System.Data.DataTable.NewRowFromBuilder*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)
  id: OnColumnChanged(System.Data.DataColumnChangeEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnColumnChanged(DataColumnChangeEventArgs)
  nameWithType: DataTable.OnColumnChanged(DataColumnChangeEventArgs)
  fullName: System.Data.DataTable.OnColumnChanged(DataColumnChangeEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "발생 된 <xref href=&quot;System.Data.DataTable.ColumnChanged&quot;> </xref> 이벤트입니다."
  remarks: '이벤트를 발생 시키는 대리자를 통해 이벤트 처리기를 호출 합니다. 에 대 한 개요 [NIB: 이벤트를 발생 시키는](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)합니다.'
  syntax:
    content: protected virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataColumnChangeEventArgs
      description: "A <xref href=&quot;System.Data.DataColumnChangeEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Data.DataTable.OnColumnChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)
  id: OnColumnChanging(System.Data.DataColumnChangeEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnColumnChanging(DataColumnChangeEventArgs)
  nameWithType: DataTable.OnColumnChanging(DataColumnChangeEventArgs)
  fullName: System.Data.DataTable.OnColumnChanging(DataColumnChangeEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "발생 된 <xref href=&quot;System.Data.DataTable.ColumnChanging&quot;> </xref> 이벤트입니다."
  remarks: '이벤트를 발생 시키는 대리자를 통해 이벤트 처리기를 호출 합니다. 에 대 한 개요 [NIB: 이벤트를 발생 시키는](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)합니다.'
  syntax:
    content: protected virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataColumnChangeEventArgs
      description: "A <xref href=&quot;System.Data.DataColumnChangeEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Data.DataTable.OnColumnChanging*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  id: OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnPropertyChanging(PropertyChangedEventArgs)
  nameWithType: DataTable.OnPropertyChanging(PropertyChangedEventArgs)
  fullName: System.Data.DataTable.OnPropertyChanging(PropertyChangedEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "발생 된 <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged>이벤트.</xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged>"
  remarks: '이벤트를 발생 시키는 대리자를 통해 이벤트 처리기를 호출 합니다. 에 대 한 개요 [NIB: 이벤트를 발생 시키는](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)합니다.'
  syntax:
    content: protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);
    parameters:
    - id: pcevent
      type: System.ComponentModel.PropertyChangedEventArgs
      description: "A <xref:System.ComponentModel.PropertyChangedEventArgs>이벤트 데이터를 포함 하는.</xref:System.ComponentModel.PropertyChangedEventArgs>"
  overload: System.Data.DataTable.OnPropertyChanging*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)
  id: OnRemoveColumn(System.Data.DataColumn)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnRemoveColumn(DataColumn)
  nameWithType: DataTable.OnRemoveColumn(DataColumn)
  fullName: System.Data.DataTable.OnRemoveColumn(DataColumn)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "알립니다는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 하는 <xref href=&quot;System.Data.DataColumn&quot;> </xref> 제거 하는 중입니다."
  remarks: '이벤트를 발생 시키는 대리자를 통해 이벤트 처리기를 호출 합니다. 자세한 내용은 참조 [NIB: 이벤트를 발생 시키는](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)합니다.'
  syntax:
    content: protected virtual void OnRemoveColumn (System.Data.DataColumn column);
    parameters:
    - id: column
      type: System.Data.DataColumn
      description: "<xref href=&quot;System.Data.DataColumn&quot;> </xref> 제거 하 고 있습니다."
  overload: System.Data.DataTable.OnRemoveColumn*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)
  id: OnRowChanged(System.Data.DataRowChangeEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnRowChanged(DataRowChangeEventArgs)
  nameWithType: DataTable.OnRowChanged(DataRowChangeEventArgs)
  fullName: System.Data.DataTable.OnRowChanged(DataRowChangeEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "발생 된 <xref href=&quot;System.Data.DataTable.RowChanged&quot;> </xref> 이벤트입니다."
  remarks: '이벤트를 발생 시키는 대리자를 통해 이벤트 처리기를 호출 합니다. 에 대 한 개요 [NIB: 이벤트를 발생 시키는](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)합니다.'
  syntax:
    content: protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataRowChangeEventArgs
      description: "A <xref href=&quot;System.Data.DataRowChangeEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Data.DataTable.OnRowChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)
  id: OnRowChanging(System.Data.DataRowChangeEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnRowChanging(DataRowChangeEventArgs)
  nameWithType: DataTable.OnRowChanging(DataRowChangeEventArgs)
  fullName: System.Data.DataTable.OnRowChanging(DataRowChangeEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "발생 된 <xref href=&quot;System.Data.DataTable.RowChanging&quot;> </xref> 이벤트입니다."
  remarks: '이벤트를 발생 시키는 대리자를 통해 이벤트 처리기를 호출 합니다. 에 대 한 개요 [NIB: 이벤트를 발생 시키는](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)합니다.'
  syntax:
    content: protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataRowChangeEventArgs
      description: "A <xref href=&quot;System.Data.DataRowChangeEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Data.DataTable.OnRowChanging*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)
  id: OnRowDeleted(System.Data.DataRowChangeEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnRowDeleted(DataRowChangeEventArgs)
  nameWithType: DataTable.OnRowDeleted(DataRowChangeEventArgs)
  fullName: System.Data.DataTable.OnRowDeleted(DataRowChangeEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "발생 된 <xref href=&quot;System.Data.DataTable.RowDeleted&quot;> </xref> 이벤트입니다."
  remarks: '이벤트를 발생 시키는 대리자를 통해 이벤트 처리기를 호출 합니다. 에 대 한 개요 [NIB: 이벤트를 발생 시키는](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)합니다.'
  syntax:
    content: protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataRowChangeEventArgs
      description: "A <xref href=&quot;System.Data.DataRowChangeEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Data.DataTable.OnRowDeleted*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)
  id: OnRowDeleting(System.Data.DataRowChangeEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnRowDeleting(DataRowChangeEventArgs)
  nameWithType: DataTable.OnRowDeleting(DataRowChangeEventArgs)
  fullName: System.Data.DataTable.OnRowDeleting(DataRowChangeEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "발생 된 <xref href=&quot;System.Data.DataTable.RowDeleting&quot;> </xref> 이벤트입니다."
  remarks: '이벤트를 발생 시키는 대리자를 통해 이벤트 처리기를 호출 합니다. 에 대 한 개요 [NIB: 이벤트를 발생 시키는](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)합니다.'
  syntax:
    content: protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataRowChangeEventArgs
      description: "A <xref href=&quot;System.Data.DataRowChangeEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Data.DataTable.OnRowDeleting*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)
  id: OnTableCleared(System.Data.DataTableClearEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnTableCleared(DataTableClearEventArgs)
  nameWithType: DataTable.OnTableCleared(DataTableClearEventArgs)
  fullName: System.Data.DataTable.OnTableCleared(DataTableClearEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "발생 된 <xref href=&quot;System.Data.DataTable.TableCleared&quot;> </xref> 이벤트입니다."
  remarks: "발생는 <xref:System.Data.DataTable.TableCleared>모든 행이 성공적으로 지워진 하기 전에 직후 발생 하는 이벤트는 <xref:System.Data.DataTable.Clear%2A>메서드 호출자에 게 제어를 반환 합니다.</xref:System.Data.DataTable.Clear%2A> </xref:System.Data.DataTable.TableCleared>       이벤트를 발생 시키는 대리자를 통해 이벤트 처리기를 호출 합니다. 에 대 한 개요 [NIB: 이벤트를 발생 시키는](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)합니다."
  syntax:
    content: protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataTableClearEventArgs
      description: "A <xref href=&quot;System.Data.DataTableClearEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Data.DataTable.OnTableCleared*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)
  id: OnTableClearing(System.Data.DataTableClearEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnTableClearing(DataTableClearEventArgs)
  nameWithType: DataTable.OnTableClearing(DataTableClearEventArgs)
  fullName: System.Data.DataTable.OnTableClearing(DataTableClearEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "발생 된 <xref href=&quot;System.Data.DataTable.TableClearing&quot;> </xref> 이벤트입니다."
  remarks: "발생 된 <xref:System.Data.DataTable.TableClearing>처리 되기 전에 발생 하는 이벤트는 <xref:System.Data.DataTable.Clear%2A>작업이 시작.</xref:System.Data.DataTable.Clear%2A> </xref:System.Data.DataTable.TableClearing>       이벤트를 발생 시키는 대리자를 통해 이벤트 처리기를 호출 합니다. 에 대 한 개요 [NIB: 이벤트를 발생 시키는](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)합니다."
  syntax:
    content: protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataTableClearEventArgs
      description: "A <xref href=&quot;System.Data.DataTableClearEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Data.DataTable.OnTableClearing*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)
  id: OnTableNewRow(System.Data.DataTableNewRowEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnTableNewRow(DataTableNewRowEventArgs)
  nameWithType: DataTable.OnTableNewRow(DataTableNewRowEventArgs)
  fullName: System.Data.DataTable.OnTableNewRow(DataTableNewRowEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "발생 된 <xref href=&quot;System.Data.DataTable.TableNewRow&quot;> </xref> 이벤트입니다."
  remarks: "<xref:System.Data.DataTable.TableNewRow>새 <xref:System.Data.DataRow> <xref:System.Data.DataTable.NewRow%2A>.</xref:System.Data.DataTable.NewRow%2A> 를 사용 하 여 만든</xref:System.Data.DataRow> 후에 발생 하는 이벤트</xref:System.Data.DataTable.TableNewRow> 를 발생 시킵니다.       이벤트를 발생 시키는 대리자를 통해 이벤트 처리기를 호출 합니다. 에 대 한 개요 [NIB: 이벤트를 발생 시키는](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)합니다."
  syntax:
    content: protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataTableNewRowEventArgs
      description: "A <xref href=&quot;System.Data.DataTableNewRowEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Data.DataTable.OnTableNewRow*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ParentRelations
  id: ParentRelations
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ParentRelations
  nameWithType: DataTable.ParentRelations
  fullName: System.Data.DataTable.ParentRelations
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 대 한 부모 관계의 컬렉션을 가져옵니다 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  remarks: ''
  example:
  - "The following example uses the ParentRelations property to return each parent <xref:System.Data.DataRelation> in a <xref:System.Data.DataTable>. Each relation is then used as an argument in the <xref:System.Data.DataRow.GetParentRows%2A> method of the <xref:System.Data.DataRow> to return an array of rows. The value of each column in the row is then printed.  \n  \n [!code-cs[Classic WebData DataTable.ParentRelations Example#1](~/add/codesnippet/csharp/p-system.data.datatable._9_1.cs)]\n [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._9_1.vb)]"
  syntax:
    content: public System.Data.DataRelationCollection ParentRelations { get; }
    return:
      type: System.Data.DataRelationCollection
      description: "A <xref href=&quot;System.Data.DataRelationCollection&quot;> </xref> 테이블에 대 한 부모 관계를 포함 하 합니다. 없는 경우에 빈 컬렉션이 반환 됩니다 <xref href=&quot;System.Data.DataRelation&quot;> </xref> 개체가 존재 합니다."
  overload: System.Data.DataTable.ParentRelations*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Prefix
  id: Prefix
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Prefix
  nameWithType: DataTable.Prefix
  fullName: System.Data.DataTable.Prefix
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 저장 된 데이터의 XML 표현에 대 한 네임 스페이스를 가져오거나 설정 합니다.는 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  syntax:
    content: public string Prefix { get; set; }
    return:
      type: System.String
      description: "접두사는 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  overload: System.Data.DataTable.Prefix*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.PrimaryKey
  id: PrimaryKey
  parent: System.Data.DataTable
  langs:
  - csharp
  name: PrimaryKey
  nameWithType: DataTable.PrimaryKey
  fullName: System.Data.DataTable.PrimaryKey
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "데이터 테이블에 대 한 기본 키로 열 배열 해당 함수를 설정 하거나 가져옵니다."
  remarks: "테이블의 기본 키 테이블의 레코드를 식별 하 고유 해야 합니다. 두 개 이상의 열으로 구성 하는 기본 키가 있는 테이블을 가질 수 이기도 합니다. 단일 열 충분 한 고유 값을 포함할 수 없는 경우 발생 합니다. 예를 들어 두 개의 열 기본 키 &quot;FirstName&quot; 및 &quot;LastName&quot; 열의 구성 될 수 있습니다. 기본 키 열이 여러 개 구성 될 수 있습니다, 때문에 PrimaryKey 속성의 배열로 구성 됩니다 <xref:System.Data.DataColumn>개체입니다.</xref:System.Data.DataColumn>"
  example:
  - "The first example shows how to return the primary key columns for a <xref:System.Data.DataTable> displayed in a `DataGrid`. The second example demonstrates how to set the primary key columns for a <xref:System.Data.DataTable>.  \n  \n [!code-cs[Classic WebData DataTable.PrimaryKey Example#1](~/add/codesnippet/csharp/p-system.data.datatable._4_1.cs)]\n [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._4_1.vb)]"
  syntax:
    content: public System.Data.DataColumn[] PrimaryKey { get; set; }
    return:
      type: System.Data.DataColumn[]
      description: "배열을 <xref href=&quot;System.Data.DataColumn&quot;> </xref> 개체입니다."
  overload: System.Data.DataTable.PrimaryKey*
  exceptions:
  - type: System.Data.DataException
    commentId: T:System.Data.DataException
    description: "키는 외래 키입니다."
  platform:
  - net462
- uid: System.Data.DataTable.ReadXml(System.IO.Stream)
  id: ReadXml(System.IO.Stream)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXml(Stream)
  nameWithType: DataTable.ReadXml(Stream)
  fullName: System.Data.DataTable.ReadXml(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "XML 스키마와 데이터를는 <xref href=&quot;System.Data.DataTable&quot;> </xref> <xref:System.IO.Stream>.</xref:System.IO.Stream> 지정된을 사용 하 여"
  remarks: "현재 <xref:System.Data.DataTable>및 <xref:System.IO.Stream>.</xref:System.IO.Stream> 제공 된 데이터와 함께 로드 되는 종속 항목</xref:System.Data.DataTable> 이 메서드의 동작은 동일 합니다는 <xref:System.Data.DataSet.ReadXml%2A?displayProperty=fullName>메서드와 비슷하지만 경우에 데이터는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.</xref:System.Data.DataSet.ReadXml%2A?displayProperty=fullName>       ReadXml 메서드에 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataTable>XML 문서 로부터 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드는 스키마만 읽습니다.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.WriteXml%2A>및 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable.WriteXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>       인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.       인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.      > [!NOTE] >는 `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml (&quot;_&quot;)와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다."
  example:
  - "The following example creates a <xref:System.Data.DataTable> containing two columns and ten rows. The example writes the <xref:System.Data.DataTable> schema and data to a memory stream, by invoking the <xref:System.Data.DataTable.WriteXml%2A> method. The example creates a second <xref:System.Data.DataTable> and calls the ReadXml method to fill it with schema and data.  \n  \n [!code-cs[DataWorks DataTable.ReadXml#1](~/add/codesnippet/csharp/m-system.data.datatable._19_1.cs)]\n [!code-vb[DataWorks DataTable.ReadXml#1](~/add/codesnippet/visualbasic/m-system.data.datatable._19_1.vb)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "파생 되는 개체<xref:System.IO.Stream></xref:System.IO.Stream>"
    return:
      type: System.Data.XmlReadMode
      description: "<xref href=&quot;System.Data.XmlReadMode&quot;> </xref> 데이터를 읽는 데 사용 합니다."
  overload: System.Data.DataTable.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ReadXml(System.IO.TextReader)
  id: ReadXml(System.IO.TextReader)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXml(TextReader)
  nameWithType: DataTable.ReadXml(TextReader)
  fullName: System.Data.DataTable.ReadXml(TextReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "XML 스키마와 데이터를는 <xref href=&quot;System.Data.DataTable&quot;> </xref> <xref:System.IO.TextReader>.</xref:System.IO.TextReader> 지정된을 사용 하 여"
  remarks: "현재 <xref:System.Data.DataTable>및 <xref:System.IO.TextReader>.</xref:System.IO.TextReader> 제공 된 데이터와 함께 로드 되는 종속 항목</xref:System.Data.DataTable> 이 메서드의 동작은 동일 합니다는 <xref:System.Data.DataSet.ReadXml%2A?displayProperty=fullName>메서드와 비슷하지만 경우에 데이터는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.</xref:System.Data.DataSet.ReadXml%2A?displayProperty=fullName>       ReadXml 메서드에 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataTable>XML 문서 로부터 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드는 스키마만 읽습니다.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.WriteXml%2A>및 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable.WriteXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>       인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.       인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.      > [!NOTE] >는 `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml (&quot;_&quot;)와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다."
  example:
  - "The following example creates a <xref:System.Data.DataTable> containing two columns and ten rows. The example writes the <xref:System.Data.DataTable> schema and data to a memory stream, by invoking the <xref:System.Data.DataTable.WriteXml%2A> method. The example creates a second <xref:System.Data.DataTable> and calls the ReadXml method to fill it with schema and data.  \n  \n [!code-vb[DataWorks DataTable.ReadXmlText#1](~/add/codesnippet/visualbasic/m-system.data.datatable._26_1.vb)]\n [!code-cs[DataWorks DataTable.ReadXmlText#1](~/add/codesnippet/csharp/m-system.data.datatable._26_1.cs)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);
    parameters:
    - id: reader
      type: System.IO.TextReader
      description: "<xref:System.IO.TextReader>데이터를 읽을 사용할.</xref:System.IO.TextReader>"
    return:
      type: System.Data.XmlReadMode
      description: "<xref href=&quot;System.Data.XmlReadMode&quot;> </xref> 데이터를 읽는 데 사용 합니다."
  overload: System.Data.DataTable.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ReadXml(System.String)
  id: ReadXml(System.String)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXml(String)
  nameWithType: DataTable.ReadXml(String)
  fullName: System.Data.DataTable.ReadXml(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "XML 스키마와 데이터를는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 지정된 된 파일에서 합니다."
  remarks: "현재 <xref:System.Data.DataTable>및 그 하위 항목에 제공 된 <xref:System.String>.</xref:System.String> 에 표시 된 파일에서 데이터와 함께 로드 되는</xref:System.Data.DataTable> 이 메서드의 동작은 동일 합니다는 <xref:System.Data.DataSet.ReadXml%2A?displayProperty=fullName>메서드와 비슷하지만 경우에 데이터는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.</xref:System.Data.DataSet.ReadXml%2A?displayProperty=fullName>       ReadXml 메서드에 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataTable>XML 문서 로부터 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드는 스키마만 읽습니다.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.WriteXml%2A>및 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable.WriteXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>       인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.       인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.      > [!NOTE] >는 `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml (&quot;_&quot;)와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.      ```   using System.Data;   public class A {      static void Main(string[] args) {         DataTable tabl = new DataTable(&quot;mytable&quot;);         tabl.Columns.Add(new DataColumn(&quot;id&quot;, typeof(int)));         for (int i = 0; i < 10; i++) {            DataRow row = tabl.NewRow();            row[&quot;id&quot;] = i;            tabl.Rows.Add(row);         }         tabl.WriteXml(&quot;f.xml&quot;, XmlWriteMode.WriteSchema);         DataTable newt = new DataTable();         newt.ReadXml(&quot;f.xml&quot;);      }   }   ```"
  example:
  - "The following example creates a <xref:System.Data.DataTable> containing two columns and ten rows. The example writes the <xref:System.Data.DataTable> schema and data to disk. The example creates a second <xref:System.Data.DataTable> and calls the ReadXml method to fill it with schema and data.  \n  \n [!code-cs[DataWorks DataTable.ReadXmlString#1](~/add/codesnippet/csharp/m-system.data.datatable._14_1.cs)]\n [!code-vb[DataWorks DataTable.ReadXmlString#1](~/add/codesnippet/visualbasic/m-system.data.datatable._14_1.vb)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "데이터를 읽을 파일의 이름입니다."
    return:
      type: System.Data.XmlReadMode
      description: "<xref href=&quot;System.Data.XmlReadMode&quot;> </xref> 데이터를 읽는 데 사용 합니다."
  overload: System.Data.DataTable.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ReadXml(System.Xml.XmlReader)
  id: ReadXml(System.Xml.XmlReader)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXml(XmlReader)
  nameWithType: DataTable.ReadXml(XmlReader)
  fullName: System.Data.DataTable.ReadXml(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "XML 스키마와 데이터를는 <xref href=&quot;System.Data.DataTable&quot;> </xref> <xref:System.Xml.XmlReader>.</xref:System.Xml.XmlReader> 지정된을 사용 하 여"
  remarks: "현재 <xref:System.Data.DataTable>및 그 하위 항목에 제공 된 <xref:System.Xml.XmlReader>.</xref:System.Xml.XmlReader> 에 표시 된 파일에서 데이터와 함께 로드 되는</xref:System.Data.DataTable> 이 메서드는 제외 하 고 현재 테이블 및 해당 하위 항목에 대해서만 데이터가 로드 되는 예에서 ReadXml 메서드와 동일 합니다.       ReadXml 메서드에 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataTable>XML 문서 로부터 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드는 스키마만 읽습니다.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.WriteXml%2A>및 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable.WriteXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>       인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.       인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.      > [!NOTE] >는 `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml (&quot;_&quot;)와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다."
  example:
  - "The following example creates a <xref:System.Data.DataTable> containing two columns and ten rows. The example writes the <xref:System.Data.DataTable> schema and data to an <xref:System.Xml.XmlReader>. The example creates a second <xref:System.Data.DataTable> and calls the ReadXml method to fill it with schema and data from the <xref:System.Xml.XmlReader> instance.  \n  \n [!code-cs[DataWorks DataTable.ReadXmlXmlReader#1](~/add/codesnippet/csharp/m-system.data.datatable._10_1.cs)]\n [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/add/codesnippet/visualbasic/m-system.data.datatable._10_1.vb)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>데이터를 읽을 사용할.</xref:System.Xml.XmlReader>"
    return:
      type: System.Data.XmlReadMode
      description: "<xref href=&quot;System.Data.XmlReadMode&quot;> </xref> 데이터를 읽는 데 사용 합니다."
  overload: System.Data.DataTable.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ReadXmlSchema(System.IO.Stream)
  id: ReadXmlSchema(System.IO.Stream)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXmlSchema(Stream)
  nameWithType: DataTable.ReadXmlSchema(Stream)
  fullName: System.Data.DataTable.ReadXmlSchema(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "XML 스키마에 <xref href=&quot;System.Data.DataTable&quot;> </xref> 지정 된 스트림을 사용 하 여 합니다."
  remarks: "ReadXmlSchema 메서드를 사용 하 여에 <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 에 대 한 스키마를 만들려면 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.       스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드.</xref:System.Data.DataTable.WriteXmlSchema%2A>       XML 스키마는 XSD 표준에 따라 해석 됩니다.       msdata:DataType 및 xs:type 형식 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.       `ReadXmlSchema` 메서드는 일반적으로 <xref:System.Data.DataTable.ReadXml%2A> <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 를 채우는 데 사용 되는 메서드</xref:System.Data.DataTable.ReadXml%2A> 를 호출 하기 전에 호출 됩니다.       XML 스키마를 사용 하 여 중첩된 관계를 만들려면 암시적 중첩 된 요소를 사용 합니다. 명시적 열 이름을 사용 하도록 중첩된 관계를 구성할 수 있습니다. 요소 중첩된 관계에 참여 하도록 해당 Datatable에 대 한 순서 대로 암시적으로 중첩 되어야 합니다."
  example:
  - "The following console application creates a new <xref:System.Data.DataTable>, and writes the schema for that table to a <xref:System.IO.MemoryStream>. Then, the example creates a new <xref:System.Data.DataTable> and reads its schema from the saved XML schema.  \n  \n [!code-cs[DataWorks DataTable.ReadXmlIOStream#1](~/add/codesnippet/csharp/m-system.data.datatable._8_1.cs)]\n [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/add/codesnippet/visualbasic/m-system.data.datatable._8_1.vb)]"
  syntax:
    content: public void ReadXmlSchema (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "스키마를 읽는 데 사용 되는 스트림."
  overload: System.Data.DataTable.ReadXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)
  id: ReadXmlSchema(System.IO.TextReader)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXmlSchema(TextReader)
  nameWithType: DataTable.ReadXmlSchema(TextReader)
  fullName: System.Data.DataTable.ReadXmlSchema(TextReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "XML 스키마에 <xref href=&quot;System.Data.DataTable&quot;> </xref> <xref:System.IO.TextReader>.</xref:System.IO.TextReader> 지정된을 사용 하 여"
  remarks: "ReadXmlSchema 메서드를 사용 하 여에 <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 에 대 한 스키마를 만들려면 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.       스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드.</xref:System.Data.DataTable.WriteXmlSchema%2A>       XML 스키마는 XSD 표준에 따라 해석 됩니다.       msdata:DataType 및 xs:type 형식 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.       `ReadXmlSchema` 메서드는 일반적으로 <xref:System.Data.DataTable.ReadXml%2A> <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 를 채우는 데 사용 되는 메서드</xref:System.Data.DataTable.ReadXml%2A> 를 호출 하기 전에 호출 됩니다.       XML 스키마를 사용 하 여 중첩된 관계를 만들려면 암시적 중첩 된 요소를 사용 합니다. 명시적 열 이름을 사용 하도록 중첩된 관계를 재구성할 수 있습니다. 요소 중첩된 관계에 참여 하도록 해당 Datatable에 대 한 순서 대로 암시적으로 중첩 되어야 합니다."
  example:
  - "The following console application creates a new <xref:System.Data.DataTable>, and writes the schema for that table to a <xref:System.IO.MemoryStream>. Then, the example creates a new <xref:System.Data.DataTable> and reads its schema from the saved XML schema, using a <xref:System.IO.StreamReader> (which inherits from <xref:System.IO.TextReader>) as its source.  \n  \n [!code-cs[DataWorks DataTable.ReadXmlSchema#1](~/add/codesnippet/csharp/m-system.data.datatable._12_1.cs)]\n [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/add/codesnippet/visualbasic/m-system.data.datatable._12_1.vb)]"
  syntax:
    content: public void ReadXmlSchema (System.IO.TextReader reader);
    parameters:
    - id: reader
      type: System.IO.TextReader
      description: "<xref:System.IO.TextReader>스키마 정보를 사용 합니다.</xref:System.IO.TextReader>"
  overload: System.Data.DataTable.ReadXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ReadXmlSchema(System.String)
  id: ReadXmlSchema(System.String)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXmlSchema(String)
  nameWithType: DataTable.ReadXmlSchema(String)
  fullName: System.Data.DataTable.ReadXmlSchema(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "XML 스키마에 <xref href=&quot;System.Data.DataTable&quot;> </xref> 지정된 된 파일에서 합니다."
  remarks: "ReadXmlSchema 메서드를 사용 하 여에 <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 에 대 한 스키마를 만들려면 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.       스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드.</xref:System.Data.DataTable.WriteXmlSchema%2A>       XML 스키마는 XSD 표준에 따라 해석 됩니다.       msdata:DataType 및 xs:type 형식 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.       `ReadXmlSchema` 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataTable.ReadXml%2A>채우는 데 사용 되는 메서드는 `DataTable`.</xref:System.Data.DataTable.ReadXml%2A>       XML 스키마를 사용 하 여 중첩된 관계를 만들려면 암시적 중첩 된 요소를 사용 합니다. 명시적 열 이름을 사용 하도록 중첩된 관계를 재구성할 수 있습니다. 요소 중첩된 관계에 참여 하도록 해당 Datatable에 대 한 순서 대로 암시적으로 중첩 되어야 합니다."
  example:
  - "The following console application creates a new <xref:System.Data.DataTable>, and writes the schema for that table to a file. Then, the example creates a new <xref:System.Data.DataTable> and reads its schema from the saved XML schema, using the file as its source.  \n  \n [!code-cs[DataWorks DataTable.ReadXmlSchemaString#1](~/add/codesnippet/csharp/m-system.data.datatable._16_1.cs)]\n [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/add/codesnippet/visualbasic/m-system.data.datatable._16_1.vb)]"
  syntax:
    content: public void ReadXmlSchema (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "스키마 정보를 읽을 수 있는 파일의 이름입니다."
  overload: System.Data.DataTable.ReadXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)
  id: ReadXmlSchema(System.Xml.XmlReader)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXmlSchema(XmlReader)
  nameWithType: DataTable.ReadXmlSchema(XmlReader)
  fullName: System.Data.DataTable.ReadXmlSchema(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "XML 스키마에 <xref href=&quot;System.Data.DataTable&quot;> </xref> <xref:System.Xml.XmlReader>.</xref:System.Xml.XmlReader> 지정된을 사용 하 여"
  remarks: "ReadXmlSchema 메서드를 사용 하 여에 <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 에 대 한 스키마를 만들려면 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.       스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드.</xref:System.Data.DataTable.WriteXmlSchema%2A>       XML 스키마는 XSD 표준에 따라 해석 됩니다.       msdata:DataType 및 xs:type 형식 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.       `ReadXmlSchema` 메서드는 일반적으로 <xref:System.Data.DataTable.ReadXml%2A> <xref:System.Data.DataTable>.</xref:System.Data.DataTable> 를 채우는 데 사용 되는 메서드</xref:System.Data.DataTable.ReadXml%2A> 를 호출 하기 전에 호출 됩니다.      > [!NOTE] > 하는 XML 스키마를 사용 하 여 중첩된 관계를 만들려면 방법은 암시적 중첩 된 요소가 있어야 합니다. 또한 중첩된 관계 명시적 열 이름을 사용 하도록 다시 연결할 수 있습니다. 암시적으로 중첩된 관계에 참여 하도록 해당 Datatable에 대 한 중첩 된 요소에 대 한 필수입니다."
  example:
  - "The following console application creates a new <xref:System.Data.DataTable>, and writes the schema for that table to a <xref:System.IO.MemoryStream>. Then, the example creates a new <xref:System.Data.DataTable> and reads its schema from the saved XML schema, using a <xref:System.Xml.XmlTextReader> (which inherits from <xref:System.Xml.XmlReader>) as its source.  \n  \n [!code-cs[DataWorks DataTable.ReadXmlSchemaReader#1](~/add/codesnippet/csharp/m-system.data.datatable._17_1.cs)]\n [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/add/codesnippet/visualbasic/m-system.data.datatable._17_1.vb)]"
  syntax:
    content: public void ReadXmlSchema (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>스키마 정보를 사용 합니다.</xref:System.Xml.XmlReader>"
  overload: System.Data.DataTable.ReadXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)
  id: ReadXmlSerializable(System.Xml.XmlReader)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXmlSerializable(XmlReader)
  nameWithType: DataTable.ReadXmlSerializable(XmlReader)
  fullName: System.Data.DataTable.ReadXmlSerializable(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "XML 스트림에서 읽습니다."
  syntax:
    content: protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "A <xref:System.Xml.XmlReader>개체입니다.</xref:System.Xml.XmlReader>"
  overload: System.Data.DataTable.ReadXmlSerializable*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.RejectChanges
  id: RejectChanges
  parent: System.Data.DataTable
  langs:
  - csharp
  name: RejectChanges()
  nameWithType: DataTable.RejectChanges()
  fullName: System.Data.DataTable.RejectChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "로드 된 이후 테이블 또는 마지막으로 적용 된 모든 변경 내용이 롤백됩니다 <xref:System.Data.DataTable.AcceptChanges*>호출 되었습니다.</xref:System.Data.DataTable.AcceptChanges*>"
  remarks: "RejectChanges 호출 될 때 모든 <xref:System.Data.DataRow>아직 편집 모드에에서 있는 개체의 편집이 취소 됩니다.</xref:System.Data.DataRow> 새 행이 제거 됩니다. 행의 <xref:System.Data.DataRowState>로 설정 `Modified` 또는 `Deleted` 를 원래 상태로 반환 합니다.</xref:System.Data.DataRowState>"
  example:
  - "The following example makes several changes to a <xref:System.Data.DataTable>, but rejects the changes by invoking the RejectChanges method.  \n  \n [!code-cs[Classic WebData DataTable.RejectChanges Example#1](~/add/codesnippet/csharp/m-system.data.datatable._3_1.cs)]\n [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._3_1.vb)]"
  syntax:
    content: public void RejectChanges ();
    parameters: []
  overload: System.Data.DataTable.RejectChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.RemotingFormat
  id: RemotingFormat
  parent: System.Data.DataTable
  langs:
  - csharp
  name: RemotingFormat
  nameWithType: DataTable.RemotingFormat
  fullName: System.Data.DataTable.RemotingFormat
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Serialization 형식을 가져오거나 설정 합니다."
  syntax:
    content: public System.Data.SerializationFormat RemotingFormat { get; set; }
    return:
      type: System.Data.SerializationFormat
      description: "A <xref href=&quot;System.Data.SerializationFormat&quot;> </xref> 중 하나를 지정 하는 열거형 <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_Xml&quot; name=&quot;Xml&quot; href=&quot;&quot;> </xref> 직렬화 합니다."
  overload: System.Data.DataTable.RemotingFormat*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Reset
  id: Reset
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Reset()
  nameWithType: DataTable.Reset()
  fullName: System.Data.DataTable.Reset()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "다시 설정 된 <xref href=&quot;System.Data.DataTable&quot;> </xref> 원래 상태로 있습니다. 원래 대로 모든 데이터, 인덱스, 관계 및 테이블의 열을 제거합니다. DataSet에 DataTable가 포함 된 경우 테이블 여전히 일부가 될 데이터 집합의 표를 다시 설정 합니다."
  syntax:
    content: public virtual void Reset ();
    parameters: []
  overload: System.Data.DataTable.Reset*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.RowChanged
  id: RowChanged
  parent: System.Data.DataTable
  langs:
  - csharp
  name: RowChanged
  nameWithType: DataTable.RowChanged
  fullName: System.Data.DataTable.RowChanged
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "다음에 발생 한 <xref href=&quot;System.Data.DataRow&quot;> </xref> 성공적으로 변경 되었습니다."
  remarks: "자세한 내용은 참조 [DataTable 이벤트 처리](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - >-
    [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/add/codesnippet/visualbasic/e-system.data.datatable._0_1.vb)]
     [!code-cs[Classic WebData DataTable.RowChanged Example#1](~/add/codesnippet/csharp/e-system.data.datatable._0_1.cs)]
  syntax:
    content: public event System.Data.DataRowChangeEventHandler RowChanged;
    return:
      type: System.Data.DataRowChangeEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.RowChanging
  id: RowChanging
  parent: System.Data.DataTable
  langs:
  - csharp
  name: RowChanging
  nameWithType: DataTable.RowChanging
  fullName: System.Data.DataTable.RowChanging
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "발생 경우는 <xref href=&quot;System.Data.DataRow&quot;> </xref> 변경 됩니다."
  remarks: "자세한 내용은 참조 [DataTable 이벤트 처리](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - >-
    [!code-cs[Classic WebData DataTable.RowChanging Example#1](~/add/codesnippet/csharp/e-system.data.datatable._1_1.cs)]
     [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/add/codesnippet/visualbasic/e-system.data.datatable._1_1.vb)]
  syntax:
    content: public event System.Data.DataRowChangeEventHandler RowChanging;
    return:
      type: System.Data.DataRowChangeEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.RowDeleted
  id: RowDeleted
  parent: System.Data.DataTable
  langs:
  - csharp
  name: RowDeleted
  nameWithType: DataTable.RowDeleted
  fullName: System.Data.DataTable.RowDeleted
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "테이블의 행이 삭제 된 후 발생 합니다."
  remarks: "자세한 내용은 참조 [DataTable 이벤트 처리](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - >-
    [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/add/codesnippet/visualbasic/e-system.data.datatable._3_1.vb)]
     [!code-cs[Classic WebData DataTable.RowDeleted Example#1](~/add/codesnippet/csharp/e-system.data.datatable._3_1.cs)]
  syntax:
    content: public event System.Data.DataRowChangeEventHandler RowDeleted;
    return:
      type: System.Data.DataRowChangeEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.RowDeleting
  id: RowDeleting
  parent: System.Data.DataTable
  langs:
  - csharp
  name: RowDeleting
  nameWithType: DataTable.RowDeleting
  fullName: System.Data.DataTable.RowDeleting
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "테이블의 행이 삭제 될 전에 발생 합니다."
  remarks: "자세한 내용은 참조 [DataTable 이벤트 처리](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - >-
    [!code-cs[Classic WebData DataTable.RowDeleting Example#1](~/add/codesnippet/csharp/e-system.data.datatable._2_1.cs)]
     [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/add/codesnippet/visualbasic/e-system.data.datatable._2_1.vb)]
  syntax:
    content: public event System.Data.DataRowChangeEventHandler RowDeleting;
    return:
      type: System.Data.DataRowChangeEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Rows
  id: Rows
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Rows
  nameWithType: DataTable.Rows
  fullName: System.Data.DataTable.Rows
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 테이블에 속하는 행의 컬렉션을 가져옵니다."
  remarks: "새로 만들려면 <xref:System.Data.DataRow>를 사용 해야 합니다는 <xref:System.Data.DataTable.NewRow%2A>새 개체를 반환 하는 메서드.</xref:System.Data.DataTable.NewRow%2A> </xref:System.Data.DataRow> 이러한 개체에 대해 정의 된 스키마에 따라 자동으로 구성 되는 <xref:System.Data.DataTable>의 컬렉션을 통해 <xref:System.Data.DataColumn>개체.</xref:System.Data.DataColumn> </xref:System.Data.DataTable> 새 행을 만드는 행의 각 열에 대 한 값을 설정 후, 행을 추가 하는 <xref:System.Data.DataRowCollection>를 사용 하는 `Add` 메서드.</xref:System.Data.DataRowCollection>       각 <xref:System.Data.DataRow>컬렉션에는 테이블에 데이터의 행을 나타냅니다.</xref:System.Data.DataRow> 행의 열 값에는 변경 내용을 커밋하지를 호출 해야는 <xref:System.Data.DataTable.AcceptChanges%2A>메서드.</xref:System.Data.DataTable.AcceptChanges%2A>"
  example:
  - "The following shows two examples of returning and setting rows. The first example uses the Rows property and prints the value of each column for every row. The second example uses the <xref:System.Data.DataTable> object's <xref:System.Data.DataTable.NewRow%2A> method to create a new <xref:System.Data.DataRow> object with the schema of the <xref:System.Data.DataTable>. After setting the row values, the row is added to the <xref:System.Data.DataRowCollection> through the `Add` method.  \n  \n [!code-cs[Classic WebData DataTable.Rows Example#1](~/add/codesnippet/csharp/p-system.data.datatable._1_1.cs)]\n [!code-vb[Classic WebData DataTable.Rows Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._1_1.vb)]"
  syntax:
    content: public System.Data.DataRowCollection Rows { get; }
    return:
      type: System.Data.DataRowCollection
      description: "A <xref href=&quot;System.Data.DataRowCollection&quot;> </xref> 포함 된 <xref href=&quot;System.Data.DataRow&quot;> </xref> 개체이 고, 그렇지 않은 경우에 null 값이 없는 경우 <xref href=&quot;System.Data.DataRow&quot;> </xref> 개체가 존재 합니다."
  overload: System.Data.DataTable.Rows*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Select
  id: Select
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Select()
  nameWithType: DataTable.Select()
  fullName: System.Data.DataTable.Select()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "모든 배열을 가져옵니다 <xref href=&quot;System.Data.DataRow&quot;> </xref> 개체입니다."
  remarks: "적절 한 정렬 순서를 보장 하려면 또는 <xref:System.Data.DataTable.Select%2A> <xref:System.Data.DataTable.Select%2A>.</xref:System.Data.DataTable.Select%2A> </xref:System.Data.DataTable.Select%2A> 정렬 조건을 지정합니다"
  example:
  - "The following example returns an array of <xref:System.Data.DataRow> objects through the Select method.  \n  \n [!code-cs[Classic WebData DataTable.Select Example#1](~/add/codesnippet/csharp/m-system.data.datatable._6_1.cs)]\n [!code-vb[Classic WebData DataTable.Select Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._6_1.vb)]"
  syntax:
    content: public System.Data.DataRow[] Select ();
    parameters: []
    return:
      type: System.Data.DataRow[]
      description: "배열을 <xref href=&quot;System.Data.DataRow&quot;> </xref> 개체입니다."
  overload: System.Data.DataTable.Select*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Select(System.String)
  id: Select(System.String)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Select(String)
  nameWithType: DataTable.Select(String)
  fullName: System.Data.DataTable.Select(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "모든 배열을 가져옵니다 <xref href=&quot;System.Data.DataRow&quot;> </xref> 필터 조건과 일치 하는 개체입니다."
  remarks: "만들려는 `filterExpression` 인수에 적용 되는 동일한 규칙을 사용는 <xref:System.Data.DataColumn>클래스의 <xref:System.Data.DataColumn.Expression%2A>필터를 만들기 위한 속성 값.</xref:System.Data.DataColumn.Expression%2A> </xref:System.Data.DataColumn>       적절 한 정렬 순서를 보장 하려면 또는 <xref:System.Data.DataTable.Select%2A> <xref:System.Data.DataTable.Select%2A>.</xref:System.Data.DataTable.Select%2A> </xref:System.Data.DataTable.Select%2A> 정렬 조건을 지정합니다       필터에 열에 null 값이 포함 된 결과에 포함 되지 않습니다."
  example:
  - "The following example uses a filter expression to return an array of <xref:System.Data.DataRow> objects.  \n  \n [!code-cs[Classic WebData DataTable.Select1 Example#1](~/add/codesnippet/csharp/m-system.data.datatable._7_1.cs)]\n [!code-vb[Classic WebData DataTable.Select1 Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._7_1.vb)]"
  syntax:
    content: public System.Data.DataRow[] Select (string filterExpression);
    parameters:
    - id: filterExpression
      type: System.String
      description: "행을 필터링 하는 데 사용 되는 조건입니다. 행을 필터링 하는 방법에 예제를 보려면 [DataView RowFilter 구문 \\[C#\\]](http://www.csharp-examples.net/dataview-rowfilter/)합니다."
    return:
      type: System.Data.DataRow[]
      description: "배열을 <xref href=&quot;System.Data.DataRow&quot;> </xref> 개체입니다."
  overload: System.Data.DataTable.Select*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Select(System.String,System.String)
  id: Select(System.String,System.String)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Select(String,String)
  nameWithType: DataTable.Select(String,String)
  fullName: System.Data.DataTable.Select(String,String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "모든 배열을 가져옵니다 <xref href=&quot;System.Data.DataRow&quot;> </xref> 필터 조건을 지정 된 정렬 순서에서 일치 하는 개체입니다."
  remarks: "양식에 `filterExpression` 인수를 동일한 규칙을 만들기 위한 사용은 <xref:System.Data.DataColumn>클래스의 <xref:System.Data.DataColumn.Expression%2A>속성 값.</xref:System.Data.DataColumn.Expression%2A> </xref:System.Data.DataColumn> `Sort` 인수 클래스의를 만들기 위한 동일한 규칙에도 사용 <xref:System.Data.DataColumn.Expression%2A>문자열.</xref:System.Data.DataColumn.Expression%2A>       필터에 열에 null 값이 포함 된 결과에 포함 되지 않습니다."
  example:
  - "The following example uses a filter expression to return an array of <xref:System.Data.DataRow> objects.  \n  \n [!code-cs[Classic WebData DataTable.Select2 Example#1](~/add/codesnippet/csharp/m-system.data.datatable._11_1.cs)]\n [!code-vb[Classic WebData DataTable.Select2 Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._11_1.vb)]"
  syntax:
    content: public System.Data.DataRow[] Select (string filterExpression, string sort);
    parameters:
    - id: filterExpression
      type: System.String
      description: "행을 필터링 하는 데 사용 되는 조건입니다. 행을 필터링 하는 방법에 예제를 보려면 [DataView RowFilter 구문 \\[C#\\]](http://www.csharp-examples.net/dataview-rowfilter/)합니다."
    - id: sort
      type: System.String
      description: "열과 정렬 방향을 지정 하는 문자열입니다."
    return:
      type: System.Data.DataRow[]
      description: "배열을 <xref href=&quot;System.Data.DataRow&quot;> </xref> 필터 식과 일치 하는 개체입니다."
  overload: System.Data.DataTable.Select*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)
  id: Select(System.String,System.String,System.Data.DataViewRowState)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Select(String,String,DataViewRowState)
  nameWithType: DataTable.Select(String,String,DataViewRowState)
  fullName: System.Data.DataTable.Select(String,String,DataViewRowState)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "모든 배열을 가져옵니다 <xref href=&quot;System.Data.DataRow&quot;> </xref> 지정 된 상태와 일치 하는 필터와 일치 하는 개체입니다."
  remarks: "양식에 `filterExpression` 인수를 동일한 규칙을 만들기 위한 사용은 <xref:System.Data.DataColumn>클래스의 <xref:System.Data.DataColumn.Expression%2A>속성 값.</xref:System.Data.DataColumn.Expression%2A> </xref:System.Data.DataColumn> `Sort` 인수 클래스의를 만들기 위한 동일한 규칙에도 사용 <xref:System.Data.DataColumn.Expression%2A>문자열.</xref:System.Data.DataColumn.Expression%2A>       필터에 열에 null 값이 포함 된 결과에 포함 되지 않습니다."
  example:
  - "The following example uses a filter expression and record state to return an array of <xref:System.Data.DataRow> objects.  \n  \n [!code-cs[Classic WebData DataTable.Select3 Example#1](~/add/codesnippet/csharp/c72cdab9-f58a-41a1-a322-_1.cs)]\n [!code-vb[Classic WebData DataTable.Select3 Example#1](~/add/codesnippet/visualbasic/c72cdab9-f58a-41a1-a322-_1.vb)]"
  syntax:
    content: public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);
    parameters:
    - id: filterExpression
      type: System.String
      description: "행을 필터링 하는 데 사용 되는 조건입니다. 행을 필터링 하는 방법에 예제를 보려면 [DataView RowFilter 구문 \\[C#\\]](http://www.csharp-examples.net/dataview-rowfilter/)합니다."
    - id: sort
      type: System.String
      description: "열과 정렬 방향을 지정 하는 문자열입니다."
    - id: recordStates
      type: System.Data.DataViewRowState
      description: "중 하나는 <xref href=&quot;System.Data.DataViewRowState&quot;> </xref> 값입니다."
    return:
      type: System.Data.DataRow[]
      description: "배열을 <xref href=&quot;System.Data.DataRow&quot;> </xref> 개체입니다."
  overload: System.Data.DataTable.Select*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Site
  id: Site
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Site
  nameWithType: DataTable.Site
  fullName: System.Data.DataTable.Site
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "가져오거나는 <xref href=&quot;System.ComponentModel.ISite&quot;> </xref> 에 대 한는 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  remarks: "사이트 바인딩는 <xref:System.ComponentModel.Component>에 <xref:System.ComponentModel.Container>서로 통신할 수 있도록 할 뿐만 아니라 컨테이너에서 해당 구성 요소를 관리할 수 있는 방법을 제공 합니다.</xref:System.ComponentModel.Container> </xref:System.ComponentModel.Component>"
  syntax:
    content: public override System.ComponentModel.ISite Site { get; set; }
    return:
      type: System.ComponentModel.ISite
      description: "An <xref href=&quot;System.ComponentModel.ISite&quot;></xref> for the <xref href=&quot;System.Data.DataTable&quot;></xref>."
  overload: System.Data.DataTable.Site*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection
  id: System#ComponentModel#IListSource#ContainsListCollection
  isEii: true
  parent: System.Data.DataTable
  langs:
  - csharp
  name: System.ComponentModel.IListSource.ContainsListCollection
  nameWithType: DataTable.System.ComponentModel.IListSource.ContainsListCollection
  fullName: System.Data.DataTable.System.ComponentModel.IListSource.ContainsListCollection
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 멤버에 대 한 참조 &lt;xref:System.ComponentModel.IListSource.ContainsListCollection%2A?displayProperty=fullName&gt;합니다."
  remarks: "이 멤버는 명시적 인터페이스 멤버 구현 이며 사용할 수 있습니다 경우에만 <xref:System.Data.DataTable>인스턴스로 캐스팅 되는 <xref:System.ComponentModel.IListSource>인터페이스.</xref:System.ComponentModel.IListSource> </xref:System.Data.DataTable>"
  syntax:
    content: bool System.ComponentModel.IListSource.ContainsListCollection { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>컬렉션의 컬렉션의 경우 <xref:System.Collections.IList>개체이 고, 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Collections.IList>"
  overload: System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.System#ComponentModel#IListSource#GetList
  id: System#ComponentModel#IListSource#GetList
  isEii: true
  parent: System.Data.DataTable
  langs:
  - csharp
  name: System.ComponentModel.IListSource.GetList()
  nameWithType: DataTable.System.ComponentModel.IListSource.GetList()
  fullName: System.Data.DataTable.System.ComponentModel.IListSource.GetList()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 멤버에 대 한 참조 &lt;xref:System.ComponentModel.IListSource.GetList%2A?displayProperty=fullName&gt;합니다."
  remarks: "이 멤버는 명시적 인터페이스 멤버 구현 이며 사용할 수 있습니다 경우에만 <xref:System.Data.DataTable>인스턴스로 캐스팅 되는 <xref:System.ComponentModel.IListSource>인터페이스.</xref:System.ComponentModel.IListSource> </xref:System.Data.DataTable>"
  syntax:
    content: System.Collections.IList IListSource.GetList ();
    parameters: []
    return:
      type: System.Collections.IList
      description: "<xref:System.Collections.IList>개체에서 데이터 원본에 바인딩할 수 있습니다.</xref:System.Collections.IList>"
  overload: System.Data.DataTable.System#ComponentModel#IListSource#GetList*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema
  id: System#Xml#Serialization#IXmlSerializable#GetSchema
  isEii: true
  parent: System.Data.DataTable
  langs:
  - csharp
  name: System.Xml.Serialization.IXmlSerializable.GetSchema()
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.GetSchema()
  fullName: System.Data.DataTable.System.Xml.Serialization.IXmlSerializable.GetSchema()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 멤버에 대 한 참조 &lt;xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A?displayProperty=fullName&gt;합니다."
  remarks: "이 멤버는 명시적 인터페이스 멤버 구현 이며 사용할 수 있습니다 경우에만 <xref:System.Data.DataSet>인스턴스로 캐스팅 되는 <xref:System.Xml.Serialization.IXmlSerializable>인터페이스.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Data.DataSet>"
  syntax:
    content: System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();
    parameters: []
    return:
      type: System.Xml.Schema.XmlSchema
      description: "<xref:System.Xml.Schema.XmlSchema>의해 생성 되는 개체의 XML 표현을 설명 하는 <> </> *> 메서드 및에서 소비 되는 <> </> *> 메서드.</xref:System.Xml.Schema.XmlSchema>"
  overload: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  id: System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  isEii: true
  parent: System.Data.DataTable
  langs:
  - csharp
  name: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  fullName: System.Data.DataTable.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 멤버에 대 한 참조 &lt;xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A?displayProperty=fullName&gt;합니다."
  remarks: "이 멤버는 명시적 인터페이스 멤버 구현 이며 사용할 수 있습니다 경우에만 <xref:System.Data.DataSet>인스턴스로 캐스팅 되는 <xref:System.Xml.Serialization.IXmlSerializable>인터페이스.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Data.DataSet>"
  syntax:
    content: void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "XmlReader입니다."
  overload: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  id: System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  isEii: true
  parent: System.Data.DataTable
  langs:
  - csharp
  name: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  fullName: System.Data.DataTable.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 멤버에 대 한 참조 &lt;xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A?displayProperty=fullName&gt;합니다."
  remarks: "이 멤버는 명시적 인터페이스 멤버 구현 이며 사용할 수 있습니다 경우에만 <xref:System.Data.DataSet>인스턴스로 캐스팅 되는 <xref:System.Xml.Serialization.IXmlSerializable>인터페이스.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Data.DataSet>"
  syntax:
    content: void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "XmlWriter입니다."
  overload: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.TableCleared
  id: TableCleared
  parent: System.Data.DataTable
  langs:
  - csharp
  name: TableCleared
  nameWithType: DataTable.TableCleared
  fullName: System.Data.DataTable.TableCleared
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "다음에 발생 한 <xref href=&quot;System.Data.DataTable&quot;> </xref> 지워집니다."
  remarks: "모든 행이 성공적으로 지워진 하기 전에 직후 TableCleared 이벤트가 발생 된 <xref:System.Data.DataTable.Clear%2A>메서드 호출자에 게 제어를 반환 합니다.</xref:System.Data.DataTable.Clear%2A> 지우기 작업 중 모든 예외가 있는 경우 TableCleared 이벤트가 발생 하지 않습니다."
  syntax:
    content: public event System.Data.DataTableClearEventHandler TableCleared;
    return:
      type: System.Data.DataTableClearEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.TableClearing
  id: TableClearing
  parent: System.Data.DataTable
  langs:
  - csharp
  name: TableClearing
  nameWithType: DataTable.TableClearing
  fullName: System.Data.DataTable.TableClearing
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "발생 경우는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 지워집니다."
  remarks: "TableClearing 이벤트가 처리 되기 전에 <xref:System.Data.DataTable.Clear%2A>작업이 시작.</xref:System.Data.DataTable.Clear%2A> 이 이벤트는 시기는 <xref:System.Data.DataTable.Clear%2A>테이블&0; 개의 행을 포함 하는 경우에 메서드를 호출 합니다.</xref:System.Data.DataTable.Clear%2A>"
  syntax:
    content: public event System.Data.DataTableClearEventHandler TableClearing;
    return:
      type: System.Data.DataTableClearEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.TableName
  id: TableName
  parent: System.Data.DataTable
  langs:
  - csharp
  name: TableName
  nameWithType: DataTable.TableName
  fullName: System.Data.DataTable.TableName
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이름을 가져오거나 설정 합니다.는 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  remarks: "TableName를 사용 하 여 부모 개체에서이 테이블을 반환 하 <xref:System.Data.DataSet>개체의 <xref:System.Data.DataTableCollection>(에서 반환 되는 <xref:System.Data.DataSet.Tables%2A>속성).</xref:System.Data.DataSet.Tables%2A> </xref:System.Data.DataTableCollection> </xref:System.Data.DataSet>"
  example:
  - "The following example prints the TableName for each table in a collection of <xref:System.Data.DataTable> objects.  \n  \n [!code-cs[Classic WebData DataTable.TableName Example#1](~/add/codesnippet/csharp/p-system.data.datatable._2_1.cs)]\n [!code-vb[Classic WebData DataTable.TableName Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._2_1.vb)]"
  syntax:
    content: public string TableName { get; set; }
    return:
      type: System.String
      description: "이름에서 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  overload: System.Data.DataTable.TableName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>또는 빈 문자열 (&quot;&quot;)에 전달 되 고이 테이블 컬렉션에 속하는 합니다."
  - type: System.Data.DuplicateNameException
    commentId: T:System.Data.DuplicateNameException
    description: "같은 이름의 테이블이 이미 있는 컬렉션에 속해 있습니다. (비교는 대/소문자 구분)입니다."
  platform:
  - net462
- uid: System.Data.DataTable.TableNewRow
  id: TableNewRow
  parent: System.Data.DataTable
  langs:
  - csharp
  name: TableNewRow
  nameWithType: DataTable.TableNewRow
  fullName: System.Data.DataTable.TableNewRow
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "새 발생 <xref href=&quot;System.Data.DataRow&quot;> </xref> 삽입 됩니다."
  remarks: "새 <xref:System.Data.DataRow> <xref:System.Data.DataTable.NewRow%2A>.</xref:System.Data.DataTable.NewRow%2A> 를 사용 하 여 만든</xref:System.Data.DataRow> 후에 발생 이 이벤트가 발생 하기 전에 호출 된 `NewRow` 메서드 반환 합니다. 새 <xref:System.Data.DataRow>인스턴스는 분리 되어 컬렉션에 추가 되지 않으면.</xref:System.Data.DataRow>"
  syntax:
    content: public event System.Data.DataTableNewRowEventHandler TableNewRow;
    return:
      type: System.Data.DataTableNewRowEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ToString
  id: ToString
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ToString()
  nameWithType: DataTable.ToString()
  fullName: System.Data.DataTable.ToString()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "가져옵니다는 <> </> *> 및 <> </> *> 연결 된 문자열로 하나 하는 경우."
  remarks: "가져옵니다 <xref:System.Data.DataTable.TableName%2A>및 <xref:System.Data.DataTable.DisplayExpression%2A> <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.DataTable.DisplayExpression%2A> </xref:System.Data.DataTable.TableName%2A>"
  example:
  - "The following example returns the <xref:System.Data.DataTable.TableName%2A> and <xref:System.Data.DataTable.DisplayExpression%2A> using the ToString method.  \n  \n [!code-cs[Classic WebData DataTable.ToString Example#1](~/add/codesnippet/csharp/m-system.data.datatable._28_1.cs)]\n [!code-vb[Classic WebData DataTable.ToString Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._28_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "구성 된 문자열은 <> </> *> 및 <> </> *> 값입니다."
  overload: System.Data.DataTable.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.IO.Stream)
  id: WriteXml(System.IO.Stream)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(Stream)
  nameWithType: DataTable.WriteXml(Stream)
  fullName: System.Data.DataTable.WriteXml(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 내용을 씁니다는 <xref href=&quot;System.Data.DataTable&quot;> </xref> <xref:System.IO.Stream>.</xref:System.IO.Stream> 지정된을 사용 하 여 XML로"
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable>XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode>매개 변수를 해당 값을 설정 하 고 `WriteSchema`.</xref:System.Data.XmlWriteMode>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A>및 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "데이터를 기록할 스트림."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.IO.TextWriter)
  id: WriteXml(System.IO.TextWriter)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(TextWriter)
  nameWithType: DataTable.WriteXml(TextWriter)
  fullName: System.Data.DataTable.WriteXml(TextWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 내용을 씁니다는 <xref href=&quot;System.Data.DataTable&quot;> </xref> <xref:System.IO.TextWriter>.</xref:System.IO.TextWriter> 지정된을 사용 하 여 XML로"
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable>XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode>매개 변수를 해당 값을 설정 하 고 `WriteSchema`.</xref:System.Data.XmlWriteMode>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A>및 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.TextWriter writer);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>콘텐츠 쓰기에 사용할.</xref:System.IO.TextWriter>"
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.String)
  id: WriteXml(System.String)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(String)
  nameWithType: DataTable.WriteXml(String)
  fullName: System.Data.DataTable.WriteXml(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 내용을 씁니다는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 지정된 된 파일을 사용 하 여 XML로 합니다."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable>XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode>매개 변수를 해당 값을 설정 하 고 `WriteSchema`.</xref:System.Data.XmlWriteMode>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A>및 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "XML 데이터를 쓸 파일입니다."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.Xml.XmlWriter)
  id: WriteXml(System.Xml.XmlWriter)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(XmlWriter)
  nameWithType: DataTable.WriteXml(XmlWriter)
  fullName: System.Data.DataTable.WriteXml(XmlWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 내용을 씁니다는 <xref href=&quot;System.Data.DataTable&quot;> </xref> <xref:System.Xml.XmlWriter>.</xref:System.Xml.XmlWriter> 지정된을 사용 하 여 XML로"
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable>XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode>매개 변수를 해당 값을 설정 하 고 `WriteSchema`.</xref:System.Data.XmlWriteMode>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A>및 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.Xml.XmlWriter writer);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>내용을 쓰기에 사용할.</xref:System.Xml.XmlWriter>"
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)
  id: WriteXml(System.IO.Stream,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(Stream,Boolean)
  nameWithType: DataTable.WriteXml(Stream,Boolean)
  fullName: System.Data.DataTable.WriteXml(Stream,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 내용을 씁니다는 <xref href=&quot;System.Data.DataTable&quot;> </xref> <xref:System.IO.Stream>.</xref:System.IO.Stream> 지정된을 사용 하 여 XML로 테이블 및 모든 하위 항목에 대 한 데이터를 저장 하려면는 <code> writeHierarchy </code> 매개 변수를 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A>에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable>XML 문서에.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.       XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.       XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A>메서드.</xref:System.Data.DataTable.WriteXml%2A>       일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 씁니다. 현재 테이블 및 모든 하위 항목에 대 한 데이터를 쓸 관련 테이블,이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.Stream stream, bool writeHierarchy);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "데이터를 기록할 스트림."
    - id: writeHierarchy
      type: System.Boolean
      description: "경우 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, 현재 테이블 및 모든 하위 항목의 내용을 씁니다. 경우 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (기본값), 현재 테이블에 대 한 데이터를 작성 합니다."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  id: WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(Stream,XmlWriteMode)
  nameWithType: DataTable.WriteXml(Stream,XmlWriteMode)
  fullName: System.Data.DataTable.WriteXml(Stream,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 대 한 현재 데이터 및 필요에 따라 스키마에 기록 된 <xref href=&quot;System.Data.DataTable&quot;> </xref> 사용 하 여 지정된 된 파일에 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>합니다. 스키마를 작성 하려면 설정에 대 한 값은 <code> mode </code> 매개 변수를 <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable>XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode>매개 변수를 해당 값을 설정 하 고 `WriteSchema`.</xref:System.Data.XmlWriteMode>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A>및 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "데이터를 기록할 스트림."
    - id: mode
      type: System.Data.XmlWriteMode
      description: "중 하나는 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> 값입니다."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)
  id: WriteXml(System.IO.TextWriter,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(TextWriter,Boolean)
  nameWithType: DataTable.WriteXml(TextWriter,Boolean)
  fullName: System.Data.DataTable.WriteXml(TextWriter,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 내용을 씁니다는 <xref href=&quot;System.Data.DataTable&quot;> </xref> <xref:System.IO.TextWriter>.</xref:System.IO.TextWriter> 지정된을 사용 하 여 XML로 테이블 및 모든 하위 항목에 대 한 데이터를 저장 하려면는 <code> writeHierarchy </code> 매개 변수를 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable>XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode>매개 변수를 해당 값을 설정 하 고 `WriteSchema`.</xref:System.Data.XmlWriteMode>       일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 씁니다. 현재 테이블 및 모든 하위 항목, 관련 테이블에 대 한 데이터를 작성 하려면이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  example:
  - "The following console application creates two <xref:System.Data.DataTable> instances, adds each to a <xref:System.Data.DataSet>, creates a <xref:System.Data.DataRelation> relating the two tables, and then uses the WriteXml method to write the data contained within the parent table to a <xref:System.IO.TextWriter>. The example demonstrates the behavior when setting the `writeHierarchy` parameter to `true`.  \n  \n [!code-cs[DataWorks DataTable.WriteXml#1](~/add/codesnippet/csharp/m-system.data.datatable._1_1.cs)]\n [!code-vb[DataWorks DataTable.WriteXml#1](~/add/codesnippet/visualbasic/m-system.data.datatable._1_1.vb)]"
  syntax:
    content: public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>콘텐츠 쓰기에 사용할.</xref:System.IO.TextWriter>"
    - id: writeHierarchy
      type: System.Boolean
      description: "경우 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, 현재 테이블 및 모든 하위 항목의 내용을 씁니다. 경우 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (기본값), 현재 테이블에 대 한 데이터를 작성 합니다."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  id: WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(TextWriter,XmlWriteMode)
  nameWithType: DataTable.WriteXml(TextWriter,XmlWriteMode)
  fullName: System.Data.DataTable.WriteXml(TextWriter,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 대 한 현재 데이터를 쓰고 필요에 따라 스키마를 작성은 <xref href=&quot;System.Data.DataTable&quot;> </xref> 사용 하 여 지정 된 <xref:System.IO.TextWriter>및 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>.</xref:System.IO.TextWriter> 스키마를 작성 하려면 설정에 대 한 값은 <code> mode </code> 매개 변수를 <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable>XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode>매개 변수를 해당 값을 설정 하 고 `WriteSchema`.</xref:System.Data.XmlWriteMode>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A>및 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>에서는 문서를 작성 하는 데 사용 합니다.</xref:System.IO.TextWriter>"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "중 하나는 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> 값입니다."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.String,System.Boolean)
  id: WriteXml(System.String,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(String,Boolean)
  nameWithType: DataTable.WriteXml(String,Boolean)
  fullName: System.Data.DataTable.WriteXml(String,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 내용을 씁니다는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 지정된 된 파일을 사용 하 여 XML로 합니다. 테이블 및 모든 하위 항목에 대 한 데이터를 저장 하려면는 <code> writeHierarchy </code> 매개 변수를 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable>XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode>매개 변수를 해당 값을 설정 하 고 `WriteSchema`.</xref:System.Data.XmlWriteMode>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A>및 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.       일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 씁니다. 현재 테이블 및 모든 하위 항목에 대 한 데이터를 쓸 관련 테이블,이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (string fileName, bool writeHierarchy);
    parameters:
    - id: fileName
      type: System.String
      description: "XML 데이터를 쓸 파일입니다."
    - id: writeHierarchy
      type: System.Boolean
      description: "경우 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, 현재 테이블 및 모든 하위 항목의 내용을 씁니다. 경우 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (기본값), 현재 테이블에 대 한 데이터를 작성 합니다."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)
  id: WriteXml(System.String,System.Data.XmlWriteMode)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(String,XmlWriteMode)
  nameWithType: DataTable.WriteXml(String,XmlWriteMode)
  fullName: System.Data.DataTable.WriteXml(String,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 대 한 현재 데이터를 쓰고 필요에 따라 스키마를 작성은 <xref href=&quot;System.Data.DataTable&quot;> </xref> 지정된 된 파일을 사용 하 여 및 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>합니다. 스키마를 작성 하려면 설정에 대 한 값은 <code> mode </code> 매개 변수를 <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable>XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode>매개 변수를 해당 값을 설정 하 고 `WriteSchema`.</xref:System.Data.XmlWriteMode>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A>및 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (string fileName, System.Data.XmlWriteMode mode);
    parameters:
    - id: fileName
      type: System.String
      description: "데이터를 기록할 파일의 이름입니다."
    - id: mode
      type: System.Data.XmlWriteMode
      description: "중 하나는 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> 값입니다."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)
  id: WriteXml(System.Xml.XmlWriter,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(XmlWriter,Boolean)
  nameWithType: DataTable.WriteXml(XmlWriter,Boolean)
  fullName: System.Data.DataTable.WriteXml(XmlWriter,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 내용을 씁니다는 <xref href=&quot;System.Data.DataTable&quot;> </xref> <xref:System.Xml.XmlWriter>.</xref:System.Xml.XmlWriter> 지정된을 사용 하 여 XML로"
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable>XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode>매개 변수를 해당 값을 설정 하 고 `WriteSchema`.</xref:System.Data.XmlWriteMode>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A>및 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.       일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 데이터를 작성 하려면이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>내용을 쓰기에 사용할.</xref:System.Xml.XmlWriter>"
    - id: writeHierarchy
      type: System.Boolean
      description: "경우 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, 현재 테이블 및 모든 하위 항목의 내용을 씁니다. 경우 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (기본값), 현재 테이블에 대 한 데이터를 작성 합니다."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  id: WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(XmlWriter,XmlWriteMode)
  nameWithType: DataTable.WriteXml(XmlWriter,XmlWriteMode)
  fullName: System.Data.DataTable.WriteXml(XmlWriter,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 대 한 현재 데이터를 쓰고 필요에 따라 스키마를 작성은 <xref href=&quot;System.Data.DataTable&quot;> </xref> 사용 하 여 지정 된 <xref:System.Xml.XmlWriter>및 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>.</xref:System.Xml.XmlWriter> 스키마를 작성 하려면 설정에 대 한 값은 <code> mode </code> 매개 변수를 <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable>XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode>매개 변수를 해당 값을 설정 하 고 `WriteSchema`.</xref:System.Data.XmlWriteMode>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A>및 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>에서는 문서를 작성 하는 데 사용 합니다.</xref:System.Xml.XmlWriter>"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "중 하나는 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> 값입니다."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)
  id: WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(Stream,XmlWriteMode,Boolean)
  nameWithType: DataTable.WriteXml(Stream,XmlWriteMode,Boolean)
  fullName: System.Data.DataTable.WriteXml(Stream,XmlWriteMode,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 대 한 현재 데이터 및 필요에 따라 스키마에 기록 된 <xref href=&quot;System.Data.DataTable&quot;> </xref> 사용 하 여 지정된 된 파일에 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>합니다. 스키마를 작성 하려면 설정에 대 한 값은 <code> mode </code> 매개 변수를 <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>합니다. 테이블 및 모든 하위 항목에 대 한 데이터를 저장 하려면는 <code> writeHierarchy </code> 매개 변수를 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 `DataTable` XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable.WriteXml%2A> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 `XmlWriteMode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.       동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A>및 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.       일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 저장 합니다. `WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 `DataTable` XML 문서로 반면는 `WriteXmlSchema` 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 `XmlWriteMode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.       동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A>및 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.       일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 씁니다. 현재 테이블 및 모든 하위 항목에 대 한 데이터를 쓸 관련 테이블,이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "데이터를 기록할 스트림."
    - id: mode
      type: System.Data.XmlWriteMode
      description: "중 하나는 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> 값입니다."
    - id: writeHierarchy
      type: System.Boolean
      description: "경우 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, 현재 테이블 및 모든 하위 항목의 내용을 씁니다. 경우 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (기본값), 현재 테이블에 대 한 데이터를 작성 합니다."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)
  id: WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(TextWriter,XmlWriteMode,Boolean)
  nameWithType: DataTable.WriteXml(TextWriter,XmlWriteMode,Boolean)
  fullName: System.Data.DataTable.WriteXml(TextWriter,XmlWriteMode,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 대 한 현재 데이터를 쓰고 필요에 따라 스키마를 작성은 <xref href=&quot;System.Data.DataTable&quot;> </xref> 사용 하 여 지정 된 <xref:System.IO.TextWriter>및 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>.</xref:System.IO.TextWriter> 스키마를 작성 하려면 설정에 대 한 값은 <code> mode </code> 매개 변수를 <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>합니다. 테이블 및 모든 하위 항목에 대 한 데이터를 저장 하려면는 <code> writeHierarchy </code> 매개 변수를 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable>XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode>매개 변수를 해당 값을 설정 하 고 `WriteSchema`.</xref:System.Data.XmlWriteMode>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A>및 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.       일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 저장 합니다. <xref:System.Data.DataTable.WriteXml%2A>메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable>XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode>매개 변수를 해당 값을 설정 하 고 `WriteSchema`.</xref:System.Data.XmlWriteMode>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A>및 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.       일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 씁니다. 현재 테이블 및 모든 하위 항목에 대 한 데이터를 쓸 관련 테이블,이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  example:
  - "The following console application creates two <xref:System.Data.DataTable> instances, adds each to a <xref:System.Data.DataSet>, creates a <xref:System.Data.DataRelation> relating the two tables, and then uses the WriteXml method to write the data contained within the parent table to a <xref:System.IO.TextWriter>. The example demonstrates the behavior when setting the `writeHierarchy` parameter to each of its values.  \n  \n [!code-cs[DataWorks DataTable.WriteXmlIO#1](~/add/codesnippet/csharp/a21e26c1-61d0-4d79-88a3-_1.cs)]\n [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/add/codesnippet/visualbasic/a21e26c1-61d0-4d79-88a3-_1.vb)]  \n  \n The example displays the following output in the console window:  \n  \n```  \n==============================  \nCustomer table, without hierarchy  \n==============================  \n<NewDataSet>  \n  <xs:schema id=\"NewDataSet\" xmlns=\"\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema  \n\" xmlns:msdata=\"urn:schemas-microsoft-com:xml-msdata\">  \n    <xs:element name=\"NewDataSet\" msdata:IsDataSet=\"true\" msdata:MainDataTable=\"Table1\">  \n      <xs:complexType>  \n        <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">  \n          <xs:element name=\"Table1\">  \n            <xs:complexType>  \n              <xs:sequence>  \n                <xs:element name=\"ID\" type=\"xs:int\" />  \n                <xs:element name=\"Name\" type=\"xs:string\" minOccurs=\"0\" />  \n              </xs:sequence>  \n            </xs:complexType>  \n          </xs:element>  \n        </xs:choice>  \n      </xs:complexType>  \n      <xs:unique name=\"Constraint1\" msdata:PrimaryKey=\"true\">  \n        <xs:selector xpath=\".//Table1\" />  \n        <xs:field xpath=\"ID\" />  \n      </xs:unique>  \n    </xs:element>  \n  </xs:schema>  \n  <Table1>  \n    <ID>1</ID>  \n    <Name>Mary</Name>  \n  </Table1>  \n  <Table1>  \n    <ID>2</ID>  \n    <Name>Andy</Name>  \n  </Table1>  \n  <Table1>  \n    <ID>3</ID>  \n    <Name>Peter</Name>  \n  </Table1>  \n  <Table1>  \n    <ID>4</ID>  \n    <Name>Russ</Name>  \n  </Table1>  \n</NewDataSet>  \n==============================  \nCustomer table, with hierarchy  \n==============================  \n<NewDataSet>  \n  <xs:schema id=\"NewDataSet\" xmlns=\"\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema  \n\" xmlns:msdata=\"urn:schemas-microsoft-com:xml-msdata\">  \n    <xs:element name=\"NewDataSet\" msdata:IsDataSet=\"true\" msdata:MainDataTable=\"Table1\">  \n      <xs:complexType>  \n        <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">  \n          <xs:element name=\"Table1\">  \n            <xs:complexType>  \n              <xs:sequence>  \n                <xs:element name=\"ID\" type=\"xs:int\" />  \n                <xs:element name=\"Name\" type=\"xs:string\" minOccurs=\"0\" />  \n              </xs:sequence>  \n            </xs:complexType>  \n          </xs:element>  \n          <xs:element name=\"Table2\">  \n            <xs:complexType>  \n              <xs:sequence>  \n                <xs:element name=\"OrderID\" type=\"xs:int\" />  \n                <xs:element name=\"CustomerID\" type=\"xs:int\" minOccurs=\"0\" />  \n                <xs:element name=\"OrderDate\" type=\"xs:dateTime\" minOccurs=\"0\" />  \n  \n              </xs:sequence>  \n            </xs:complexType>  \n          </xs:element>  \n        </xs:choice>  \n      </xs:complexType>  \n      <xs:unique name=\"Constraint1\" msdata:PrimaryKey=\"true\">  \n        <xs:selector xpath=\".//Table1\" />  \n        <xs:field xpath=\"ID\" />  \n      </xs:unique>  \n      <xs:unique name=\"Table2_Constraint1\" msdata:ConstraintName=\"Constraint1\" m  \nsdata:PrimaryKey=\"true\">  \n        <xs:selector xpath=\".//Table2\" />  \n        <xs:field xpath=\"OrderID\" />  \n      </xs:unique>  \n      <xs:keyref name=\"CustomerOrder\" refer=\"Constraint1\">  \n        <xs:selector xpath=\".//Table2\" />  \n        <xs:field xpath=\"CustomerID\" />  \n      </xs:keyref>  \n    </xs:element>  \n  </xs:schema>  \n  <Table1>  \n    <ID>1</ID>  \n    <Name>Mary</Name>  \n  </Table1>  \n  <Table1>  \n    <ID>2</ID>  \n    <Name>Andy</Name>  \n  </Table1>  \n  <Table1>  \n    <ID>3</ID>  \n    <Name>Peter</Name>  \n  </Table1>  \n  <Table1>  \n    <ID>4</ID>  \n    <Name>Russ</Name>  \n  </Table1>  \n  <Table2>  \n    <OrderID>1</OrderID>  \n    <CustomerID>1</CustomerID>  \n    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  \n  </Table2>  \n  <Table2>  \n    <OrderID>2</OrderID>  \n    <CustomerID>1</CustomerID>  \n    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  \n  </Table2>  \n  <Table2>  \n    <OrderID>3</OrderID>  \n    <CustomerID>2</CustomerID>  \n    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  \n  </Table2>  \n  <Table2>  \n    <OrderID>4</OrderID>  \n    <CustomerID>3</CustomerID>  \n    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  \n  </Table2>  \n  <Table2>  \n    <OrderID>5</OrderID>  \n    <CustomerID>3</CustomerID>  \n    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  \n  </Table2>  \n  <Table2>  \n    <OrderID>6</OrderID>  \n    <CustomerID>4</CustomerID>  \n    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  \n  </Table2>  \n</NewDataSet>  \n```"
  syntax:
    content: public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>에서는 문서를 작성 하는 데 사용 합니다.</xref:System.IO.TextWriter>"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "중 하나는 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> 값입니다."
    - id: writeHierarchy
      type: System.Boolean
      description: "경우 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, 현재 테이블 및 모든 하위 항목의 내용을 씁니다. 경우 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (기본값), 현재 테이블에 대 한 데이터를 작성 합니다."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)
  id: WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(String,XmlWriteMode,Boolean)
  nameWithType: DataTable.WriteXml(String,XmlWriteMode,Boolean)
  fullName: System.Data.DataTable.WriteXml(String,XmlWriteMode,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 대 한 현재 데이터를 쓰고 필요에 따라 스키마를 작성은 <xref href=&quot;System.Data.DataTable&quot;> </xref> 지정된 된 파일을 사용 하 여 및 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>합니다. 스키마를 작성 하려면 설정에 대 한 값은 <code> mode </code> 매개 변수를 <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>합니다. 테이블 및 모든 하위 항목에 대 한 데이터를 저장 하려면는 <code> writeHierarchy </code> 매개 변수를 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable>XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode>매개 변수를 해당 값을 설정 하 고 `WriteSchema`.</xref:System.Data.XmlWriteMode>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A>및 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.       일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 저장 합니다. 현재 테이블 및 모든 스키마에 대 한 데이터를 저장 하려는 경우는 <xref:System.Data.DataTable.WriteXml%2A>메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable>XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode>매개 변수를 해당 값을 설정 하 고 `WriteSchema`.</xref:System.Data.XmlWriteMode>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A>및 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.       일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 씁니다. 현재 테이블 및 모든 하위 항목, 관련 테이블에 대 한 데이터를 작성 하려면이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);
    parameters:
    - id: fileName
      type: System.String
      description: "데이터를 기록할 파일의 이름입니다."
    - id: mode
      type: System.Data.XmlWriteMode
      description: "중 하나는 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> 값입니다."
    - id: writeHierarchy
      type: System.Boolean
      description: "경우 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, 현재 테이블 및 모든 하위 항목의 내용을 씁니다. 경우 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (기본값), 현재 테이블에 대 한 데이터를 작성 합니다."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)
  id: WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(XmlWriter,XmlWriteMode,Boolean)
  nameWithType: DataTable.WriteXml(XmlWriter,XmlWriteMode,Boolean)
  fullName: System.Data.DataTable.WriteXml(XmlWriter,XmlWriteMode,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 대 한 현재 데이터를 쓰고 필요에 따라 스키마를 작성은 <xref href=&quot;System.Data.DataTable&quot;> </xref> 사용 하 여 지정 된 <xref:System.Xml.XmlWriter>및 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>.</xref:System.Xml.XmlWriter> 스키마를 작성 하려면 설정에 대 한 값은 <code> mode </code> 매개 변수를 <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>합니다. 테이블 및 모든 하위 항목에 대 한 데이터를 저장 하려면는 <code> writeHierarchy </code> 매개 변수를 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable>XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode>매개 변수를 해당 값을 설정 하 고 `WriteSchema`.</xref:System.Data.XmlWriteMode>       동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A>및 <xref:System.Data.DataTable.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.       일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 데이터를 작성 하려면이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>에서는 문서를 작성 하는 데 사용 합니다.</xref:System.Xml.XmlWriter>"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "중 하나는 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> 값입니다."
    - id: writeHierarchy
      type: System.Boolean
      description: "경우 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, 현재 테이블 및 모든 하위 항목의 내용을 씁니다. 경우 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (기본값), 현재 테이블에 대 한 데이터를 작성 합니다."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXmlSchema(System.IO.Stream)
  id: WriteXmlSchema(System.IO.Stream)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXmlSchema(Stream)
  nameWithType: DataTable.WriteXmlSchema(Stream)
  fullName: System.Data.DataTable.WriteXmlSchema(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 데이터 구조를 작성은 <xref href=&quot;System.Data.DataTable&quot;> </xref> 지정 된 스트림에 XML 스키마로 합니다."
  remarks: "사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A>에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable>XML 문서에.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.       XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.       XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A>메서드.</xref:System.Data.DataTable.WriteXml%2A>"
  syntax:
    content: public void WriteXmlSchema (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "XML 스키마를 기록할 스트림."
  overload: System.Data.DataTable.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)
  id: WriteXmlSchema(System.IO.TextWriter)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXmlSchema(TextWriter)
  nameWithType: DataTable.WriteXmlSchema(TextWriter)
  fullName: System.Data.DataTable.WriteXmlSchema(TextWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 데이터 구조를 작성은 <xref href=&quot;System.Data.DataTable&quot;> </xref> <xref:System.IO.TextWriter>.</xref:System.IO.TextWriter> 지정된을 사용 하 여 XML 스키마로"
  remarks: "사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A>에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable>XML 문서에.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.       XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.       XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A>메서드.</xref:System.Data.DataTable.WriteXml%2A>"
  syntax:
    content: public void WriteXmlSchema (System.IO.TextWriter writer);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>쓰기에 사용할.</xref:System.IO.TextWriter>"
  overload: System.Data.DataTable.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXmlSchema(System.String)
  id: WriteXmlSchema(System.String)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXmlSchema(String)
  nameWithType: DataTable.WriteXmlSchema(String)
  fullName: System.Data.DataTable.WriteXmlSchema(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 데이터 구조를 작성은 <xref href=&quot;System.Data.DataTable&quot;> </xref> 지정된 된 파일에 XML 스키마로 합니다."
  remarks: "사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A>에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable>XML 문서에.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.       XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.       XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A>메서드.</xref:System.Data.DataTable.WriteXml%2A>"
  syntax:
    content: public void WriteXmlSchema (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "사용할 파일의 이름입니다."
  overload: System.Data.DataTable.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)
  id: WriteXmlSchema(System.Xml.XmlWriter)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXmlSchema(XmlWriter)
  nameWithType: DataTable.WriteXmlSchema(XmlWriter)
  fullName: System.Data.DataTable.WriteXmlSchema(XmlWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 데이터 구조를 작성은 <xref href=&quot;System.Data.DataTable&quot;> </xref> <xref:System.Xml.XmlWriter>.</xref:System.Xml.XmlWriter> 지정된을 사용 하 여 XML 스키마로"
  remarks: "사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A>에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable>XML 문서에.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.       XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.       XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A>메서드.</xref:System.Data.DataTable.WriteXml%2A>"
  syntax:
    content: public void WriteXmlSchema (System.Xml.XmlWriter writer);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>사용할.</xref:System.Xml.XmlWriter>"
  overload: System.Data.DataTable.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)
  id: WriteXmlSchema(System.IO.Stream,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXmlSchema(Stream,Boolean)
  nameWithType: DataTable.WriteXmlSchema(Stream,Boolean)
  fullName: System.Data.DataTable.WriteXmlSchema(Stream,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 데이터 구조를 작성은 <xref href=&quot;System.Data.DataTable&quot;> </xref> 지정 된 스트림에 XML 스키마로 합니다. 테이블 및 모든 하위 항목에 대 한 스키마를 저장 하려면는 <code> writeHierarchy </code> 매개 변수를 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A>에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable>XML 문서에.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.       XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.       XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A>메서드.</xref:System.Data.DataTable.WriteXml%2A>       일반적으로 `WriteXmlSchema` 메서드는 현재 테이블에 대 한 스키마를 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다."
  syntax:
    content: public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "XML 스키마를 기록할 스트림."
    - id: writeHierarchy
      type: System.Boolean
      description: "경우 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, 현재 테이블 및 모든 하위 항목의 스키마를 씁니다. 경우 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (기본값), 현재 테이블에 대 한 스키마를 작성 합니다."
  overload: System.Data.DataTable.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)
  id: WriteXmlSchema(System.IO.TextWriter,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXmlSchema(TextWriter,Boolean)
  nameWithType: DataTable.WriteXmlSchema(TextWriter,Boolean)
  fullName: System.Data.DataTable.WriteXmlSchema(TextWriter,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 데이터 구조를 작성은 <xref href=&quot;System.Data.DataTable&quot;> </xref> <xref:System.IO.TextWriter>.</xref:System.IO.TextWriter> 지정된을 사용 하 여 XML 스키마로 테이블 및 모든 하위 항목에 대 한 스키마를 저장 하려면는 <code> writeHierarchy </code> 매개 변수를 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A>에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable>XML 문서에.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.       XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.       XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A>메서드.</xref:System.Data.DataTable.WriteXml%2A>       일반적으로 `WriteXmlSchema` 메서드는 현재 테이블에 대 한 스키마를 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다."
  example:
  - "The following console application creates two <xref:System.Data.DataTable> instances, adds each to a <xref:System.Data.DataSet>, creates a <xref:System.Data.DataRelation> relating the two tables, and then uses the WriteXmlSchema method to write the data contained within the parent table to a <xref:System.IO.TextWriter>. The example demonstrates the behavior when setting the `writeHierarchy` parameter to each of its values.  \n  \n [!code-cs[DataWorks DataTable.WriteXmlSchema#1](~/add/codesnippet/csharp/m-system.data.datatable._30_1.cs)]\n [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/add/codesnippet/visualbasic/m-system.data.datatable._30_1.vb)]  \n  \n The example displays the following output in the console window:  \n  \n```  \n==============================  \nCustomer table, without hierarchy  \n==============================  \n<?xml version=\"1.0\" encoding=\"utf-16\"?>  \n<xs:schema id=\"NewDataSet\" xmlns=\"\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"  \nxmlns:msdata=\"urn:schemas-microsoft-com:xml-msdata\">  \n  <xs:element name=\"NewDataSet\" msdata:IsDataSet=\"true\" msdata:MainDataTable=\"Ta  \nble1\">  \n    <xs:complexType>  \n      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">  \n        <xs:element name=\"Table1\">  \n          <xs:complexType>  \n            <xs:sequence>  \n              <xs:element name=\"ID\" type=\"xs:int\" />  \n              <xs:element name=\"Name\" type=\"xs:string\" minOccurs=\"0\" />  \n            </xs:sequence>  \n          </xs:complexType>  \n        </xs:element>  \n      </xs:choice>  \n    </xs:complexType>  \n    <xs:unique name=\"Constraint1\" msdata:PrimaryKey=\"true\">  \n      <xs:selector xpath=\".//Table1\" />  \n      <xs:field xpath=\"ID\" />  \n    </xs:unique>  \n  </xs:element>  \n</xs:schema>  \n==============================  \nCustomer table, with hierarchy  \n==============================  \n<?xml version=\"1.0\" encoding=\"utf-16\"?>  \n<xs:schema id=\"NewDataSet\" xmlns=\"\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"  \nxmlns:msdata=\"urn:schemas-microsoft-com:xml-msdata\">  \n  <xs:element name=\"NewDataSet\" msdata:IsDataSet=\"true\" msdata:MainDataTable=\"Table1\">  \n    <xs:complexType>  \n      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">  \n        <xs:element name=\"Table1\">  \n          <xs:complexType>  \n            <xs:sequence>  \n              <xs:element name=\"ID\" type=\"xs:int\" />  \n              <xs:element name=\"Name\" type=\"xs:string\" minOccurs=\"0\" />  \n            </xs:sequence>  \n          </xs:complexType>  \n        </xs:element>  \n        <xs:element name=\"Table2\">  \n          <xs:complexType>  \n            <xs:sequence>  \n              <xs:element name=\"OrderID\" type=\"xs:int\" />  \n              <xs:element name=\"CustomerID\" type=\"xs:int\" minOccurs=\"0\" />  \n              <xs:element name=\"OrderDate\" type=\"xs:dateTime\" minOccurs=\"0\" />  \n            </xs:sequence>  \n          </xs:complexType>  \n        </xs:element>  \n      </xs:choice>  \n    </xs:complexType>  \n    <xs:unique name=\"Constraint1\" msdata:PrimaryKey=\"true\">  \n      <xs:selector xpath=\".//Table1\" />  \n      <xs:field xpath=\"ID\" />  \n    </xs:unique>  \n    <xs:unique name=\"Table2_Constraint1\" msdata:ConstraintName=\"Constraint1\" msdata:PrimaryKey=\"true\">  \n      <xs:selector xpath=\".//Table2\" />  \n      <xs:field xpath=\"OrderID\" />  \n    </xs:unique>  \n    <xs:keyref name=\"CustomerOrder\" refer=\"Constraint1\">  \n      <xs:selector xpath=\".//Table2\" />  \n      <xs:field xpath=\"CustomerID\" />  \n    </xs:keyref>  \n  </xs:element>  \n</xs:schema>  \n```"
  syntax:
    content: public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>쓰기에 사용할.</xref:System.IO.TextWriter>"
    - id: writeHierarchy
      type: System.Boolean
      description: "경우 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, 현재 테이블 및 모든 하위 항목의 스키마를 씁니다. 경우 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (기본값), 현재 테이블에 대 한 스키마를 작성 합니다."
  overload: System.Data.DataTable.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)
  id: WriteXmlSchema(System.String,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXmlSchema(String,Boolean)
  nameWithType: DataTable.WriteXmlSchema(String,Boolean)
  fullName: System.Data.DataTable.WriteXmlSchema(String,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 데이터 구조를 작성은 <xref href=&quot;System.Data.DataTable&quot;> </xref> 지정된 된 파일에 XML 스키마로 합니다. 테이블 및 모든 하위 항목에 대 한 스키마를 저장 하려면는 <code> writeHierarchy </code> 매개 변수를 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A>에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable>XML 문서에.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.       XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.       XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A>메서드.</xref:System.Data.DataTable.WriteXml%2A>       일반적으로 `WriteXmlSchema` 메서드는 현재 테이블에 대 한 스키마를 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다."
  syntax:
    content: public void WriteXmlSchema (string fileName, bool writeHierarchy);
    parameters:
    - id: fileName
      type: System.String
      description: "사용할 파일의 이름입니다."
    - id: writeHierarchy
      type: System.Boolean
      description: "경우 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, 현재 테이블 및 모든 하위 항목의 스키마를 씁니다. 경우 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (기본값), 현재 테이블에 대 한 스키마를 작성 합니다."
  overload: System.Data.DataTable.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)
  id: WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXmlSchema(XmlWriter,Boolean)
  nameWithType: DataTable.WriteXmlSchema(XmlWriter,Boolean)
  fullName: System.Data.DataTable.WriteXmlSchema(XmlWriter,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 데이터 구조를 작성은 <xref href=&quot;System.Data.DataTable&quot;> </xref> <xref:System.Xml.XmlWriter>.</xref:System.Xml.XmlWriter> 지정된을 사용 하 여 XML 스키마로 테이블 및 모든 하위 항목에 대 한 스키마를 저장 하려면는 <code> writeHierarchy </code> 매개 변수를 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A>에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable>XML 문서에.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.       XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.       XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A>메서드.</xref:System.Data.DataTable.WriteXml%2A>       일반적으로 `WriteXmlSchema` 메서드는 현재 테이블에 대 한 스키마를 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다."
  syntax:
    content: public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>에서는 문서를 작성 하는 데 사용 합니다.</xref:System.Xml.XmlWriter>"
    - id: writeHierarchy
      type: System.Boolean
      description: "경우 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, 현재 테이블 및 모든 하위 항목의 스키마를 씁니다. 경우 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (기본값), 현재 테이블에 대 한 스키마를 작성 합니다."
  overload: System.Data.DataTable.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ComponentModel.MarshalByValueComponent
  isExternal: false
  name: System.ComponentModel.MarshalByValueComponent
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.Data.ConstraintException
  parent: System.Data
  isExternal: false
  name: ConstraintException
  nameWithType: ConstraintException
  fullName: System.Data.ConstraintException
- uid: System.Data.NoNullAllowedException
  parent: System.Data
  isExternal: false
  name: NoNullAllowedException
  nameWithType: NoNullAllowedException
  fullName: System.Data.NoNullAllowedException
- uid: System.Data.DataException
  parent: System.Data
  isExternal: false
  name: DataException
  nameWithType: DataException
  fullName: System.Data.DataException
- uid: System.Data.DuplicateNameException
  parent: System.Data
  isExternal: false
  name: DuplicateNameException
  nameWithType: DuplicateNameException
  fullName: System.Data.DuplicateNameException
- uid: System.Data.DataTable.#ctor
  parent: System.Data.DataTable
  isExternal: false
  name: DataTable()
  nameWithType: DataTable.DataTable()
  fullName: System.Data.DataTable.DataTable()
- uid: System.Data.DataTable.#ctor(System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: DataTable(String)
  nameWithType: DataTable.DataTable(String)
  fullName: System.Data.DataTable.DataTable(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataTable
  isExternal: false
  name: DataTable(SerializationInfo,StreamingContext)
  nameWithType: DataTable.DataTable(SerializationInfo,StreamingContext)
  fullName: System.Data.DataTable.DataTable(SerializationInfo,StreamingContext)
- uid: System.Runtime.Serialization.SerializationInfo
  parent: System.Runtime.Serialization
  isExternal: false
  name: SerializationInfo
  nameWithType: SerializationInfo
  fullName: System.Runtime.Serialization.SerializationInfo
- uid: System.Runtime.Serialization.StreamingContext
  parent: System.Runtime.Serialization
  isExternal: true
  name: StreamingContext
  nameWithType: StreamingContext
  fullName: System.Runtime.Serialization.StreamingContext
- uid: System.Data.DataTable.#ctor(System.String,System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: DataTable(String,String)
  nameWithType: DataTable.DataTable(String,String)
  fullName: System.Data.DataTable.DataTable(String,String)
- uid: System.Data.DataTable.AcceptChanges
  parent: System.Data.DataTable
  isExternal: false
  name: AcceptChanges()
  nameWithType: DataTable.AcceptChanges()
  fullName: System.Data.DataTable.AcceptChanges()
- uid: System.Data.DataTable.BeginInit
  parent: System.Data.DataTable
  isExternal: false
  name: BeginInit()
  nameWithType: DataTable.BeginInit()
  fullName: System.Data.DataTable.BeginInit()
- uid: System.Data.DataTable.BeginLoadData
  parent: System.Data.DataTable
  isExternal: false
  name: BeginLoadData()
  nameWithType: DataTable.BeginLoadData()
  fullName: System.Data.DataTable.BeginLoadData()
- uid: System.Data.DataTable.CaseSensitive
  parent: System.Data.DataTable
  isExternal: false
  name: CaseSensitive
  nameWithType: DataTable.CaseSensitive
  fullName: System.Data.DataTable.CaseSensitive
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Data.DataTable.ChildRelations
  parent: System.Data.DataTable
  isExternal: false
  name: ChildRelations
  nameWithType: DataTable.ChildRelations
  fullName: System.Data.DataTable.ChildRelations
- uid: System.Data.DataRelationCollection
  parent: System.Data
  isExternal: false
  name: DataRelationCollection
  nameWithType: DataRelationCollection
  fullName: System.Data.DataRelationCollection
- uid: System.Data.DataTable.Clear
  parent: System.Data.DataTable
  isExternal: false
  name: Clear()
  nameWithType: DataTable.Clear()
  fullName: System.Data.DataTable.Clear()
- uid: System.Data.DataTable.Clone
  parent: System.Data.DataTable
  isExternal: false
  name: Clone()
  nameWithType: DataTable.Clone()
  fullName: System.Data.DataTable.Clone()
- uid: System.Data.DataTable
  parent: System.Data
  isExternal: false
  name: DataTable
  nameWithType: DataTable
  fullName: System.Data.DataTable
- uid: System.Data.DataTable.ColumnChanged
  parent: System.Data.DataTable
  isExternal: false
  name: ColumnChanged
  nameWithType: DataTable.ColumnChanged
  fullName: System.Data.DataTable.ColumnChanged
- uid: System.Data.DataColumnChangeEventHandler
  parent: System.Data
  isExternal: false
  name: DataColumnChangeEventHandler
  nameWithType: DataColumnChangeEventHandler
  fullName: System.Data.DataColumnChangeEventHandler
- uid: System.Data.DataTable.ColumnChanging
  parent: System.Data.DataTable
  isExternal: false
  name: ColumnChanging
  nameWithType: DataTable.ColumnChanging
  fullName: System.Data.DataTable.ColumnChanging
- uid: System.Data.DataTable.Columns
  parent: System.Data.DataTable
  isExternal: false
  name: Columns
  nameWithType: DataTable.Columns
  fullName: System.Data.DataTable.Columns
- uid: System.Data.DataColumnCollection
  parent: System.Data
  isExternal: false
  name: DataColumnCollection
  nameWithType: DataColumnCollection
  fullName: System.Data.DataColumnCollection
- uid: System.Data.DataTable.Compute(System.String,System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: Compute(String,String)
  nameWithType: DataTable.Compute(String,String)
  fullName: System.Data.DataTable.Compute(String,String)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Data.DataTable.Constraints
  parent: System.Data.DataTable
  isExternal: false
  name: Constraints
  nameWithType: DataTable.Constraints
  fullName: System.Data.DataTable.Constraints
- uid: System.Data.ConstraintCollection
  parent: System.Data
  isExternal: false
  name: ConstraintCollection
  nameWithType: ConstraintCollection
  fullName: System.Data.ConstraintCollection
- uid: System.Data.DataTable.Copy
  parent: System.Data.DataTable
  isExternal: false
  name: Copy()
  nameWithType: DataTable.Copy()
  fullName: System.Data.DataTable.Copy()
- uid: System.Data.DataTable.CreateDataReader
  parent: System.Data.DataTable
  isExternal: false
  name: CreateDataReader()
  nameWithType: DataTable.CreateDataReader()
  fullName: System.Data.DataTable.CreateDataReader()
- uid: System.Data.DataTableReader
  parent: System.Data
  isExternal: false
  name: DataTableReader
  nameWithType: DataTableReader
  fullName: System.Data.DataTableReader
- uid: System.Data.DataTable.CreateInstance
  parent: System.Data.DataTable
  isExternal: false
  name: CreateInstance()
  nameWithType: DataTable.CreateInstance()
  fullName: System.Data.DataTable.CreateInstance()
- uid: System.Data.DataTable.DataSet
  parent: System.Data.DataTable
  isExternal: false
  name: DataSet
  nameWithType: DataTable.DataSet
  fullName: System.Data.DataTable.DataSet
- uid: System.Data.DataSet
  parent: System.Data
  isExternal: false
  name: DataSet
  nameWithType: DataSet
  fullName: System.Data.DataSet
- uid: System.Data.DataTable.DefaultView
  parent: System.Data.DataTable
  isExternal: false
  name: DefaultView
  nameWithType: DataTable.DefaultView
  fullName: System.Data.DataTable.DefaultView
- uid: System.Data.DataView
  parent: System.Data
  isExternal: false
  name: DataView
  nameWithType: DataView
  fullName: System.Data.DataView
- uid: System.Data.DataTable.DisplayExpression
  parent: System.Data.DataTable
  isExternal: false
  name: DisplayExpression
  nameWithType: DataTable.DisplayExpression
  fullName: System.Data.DataTable.DisplayExpression
- uid: System.Data.DataTable.EndInit
  parent: System.Data.DataTable
  isExternal: false
  name: EndInit()
  nameWithType: DataTable.EndInit()
  fullName: System.Data.DataTable.EndInit()
- uid: System.Data.DataTable.EndLoadData
  parent: System.Data.DataTable
  isExternal: false
  name: EndLoadData()
  nameWithType: DataTable.EndLoadData()
  fullName: System.Data.DataTable.EndLoadData()
- uid: System.Data.DataTable.ExtendedProperties
  parent: System.Data.DataTable
  isExternal: false
  name: ExtendedProperties
  nameWithType: DataTable.ExtendedProperties
  fullName: System.Data.DataTable.ExtendedProperties
- uid: System.Data.PropertyCollection
  parent: System.Data
  isExternal: false
  name: PropertyCollection
  nameWithType: PropertyCollection
  fullName: System.Data.PropertyCollection
- uid: System.Data.DataTable.fInitInProgress
  parent: System.Data.DataTable
  isExternal: false
  name: fInitInProgress
  nameWithType: DataTable.fInitInProgress
  fullName: System.Data.DataTable.fInitInProgress
- uid: System.Data.DataTable.GetChanges
  parent: System.Data.DataTable
  isExternal: false
  name: GetChanges()
  nameWithType: DataTable.GetChanges()
  fullName: System.Data.DataTable.GetChanges()
- uid: System.Data.DataTable.GetChanges(System.Data.DataRowState)
  parent: System.Data.DataTable
  isExternal: false
  name: GetChanges(DataRowState)
  nameWithType: DataTable.GetChanges(DataRowState)
  fullName: System.Data.DataTable.GetChanges(DataRowState)
- uid: System.Data.DataRowState
  parent: System.Data
  isExternal: false
  name: DataRowState
  nameWithType: DataRowState
  fullName: System.Data.DataRowState
- uid: System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)
  parent: System.Data.DataTable
  isExternal: false
  name: GetDataTableSchema(XmlSchemaSet)
  nameWithType: DataTable.GetDataTableSchema(XmlSchemaSet)
  fullName: System.Data.DataTable.GetDataTableSchema(XmlSchemaSet)
- uid: System.Xml.Schema.XmlSchemaComplexType
  parent: System.Xml.Schema
  isExternal: false
  name: XmlSchemaComplexType
  nameWithType: XmlSchemaComplexType
  fullName: System.Xml.Schema.XmlSchemaComplexType
- uid: System.Xml.Schema.XmlSchemaSet
  parent: System.Xml.Schema
  isExternal: false
  name: XmlSchemaSet
  nameWithType: XmlSchemaSet
  fullName: System.Xml.Schema.XmlSchemaSet
- uid: System.Data.DataTable.GetErrors
  parent: System.Data.DataTable
  isExternal: false
  name: GetErrors()
  nameWithType: DataTable.GetErrors()
  fullName: System.Data.DataTable.GetErrors()
- uid: System.Data.DataRow[]
  parent: System.Data
  isExternal: false
  name: DataRow
  nameWithType: DataRow
  fullName: System.Data.DataRow[]
  spec.csharp:
  - uid: System.Data.DataRow
    name: DataRow
    nameWithType: DataRow
    fullName: DataRow[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataTable
  isExternal: false
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: DataTable.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Data.DataTable.GetObjectData(SerializationInfo,StreamingContext)
- uid: System.Data.DataTable.GetRowType
  parent: System.Data.DataTable
  isExternal: false
  name: GetRowType()
  nameWithType: DataTable.GetRowType()
  fullName: System.Data.DataTable.GetRowType()
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Data.DataTable.GetSchema
  parent: System.Data.DataTable
  isExternal: false
  name: GetSchema()
  nameWithType: DataTable.GetSchema()
  fullName: System.Data.DataTable.GetSchema()
- uid: System.Xml.Schema.XmlSchema
  parent: System.Xml.Schema
  isExternal: true
  name: XmlSchema
  nameWithType: XmlSchema
  fullName: System.Xml.Schema.XmlSchema
- uid: System.Data.DataTable.HasErrors
  parent: System.Data.DataTable
  isExternal: false
  name: HasErrors
  nameWithType: DataTable.HasErrors
  fullName: System.Data.DataTable.HasErrors
- uid: System.Data.DataTable.ImportRow(System.Data.DataRow)
  parent: System.Data.DataTable
  isExternal: false
  name: ImportRow(DataRow)
  nameWithType: DataTable.ImportRow(DataRow)
  fullName: System.Data.DataTable.ImportRow(DataRow)
- uid: System.Data.DataRow
  parent: System.Data
  isExternal: false
  name: DataRow
  nameWithType: DataRow
  fullName: System.Data.DataRow
- uid: System.Data.DataTable.Initialized
  parent: System.Data.DataTable
  isExternal: false
  name: Initialized
  nameWithType: DataTable.Initialized
  fullName: System.Data.DataTable.Initialized
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Data.DataTable.IsInitialized
  parent: System.Data.DataTable
  isExternal: false
  name: IsInitialized
  nameWithType: DataTable.IsInitialized
  fullName: System.Data.DataTable.IsInitialized
- uid: System.Data.DataTable.Load(System.Data.IDataReader)
  parent: System.Data.DataTable
  isExternal: false
  name: Load(IDataReader)
  nameWithType: DataTable.Load(IDataReader)
  fullName: System.Data.DataTable.Load(IDataReader)
- uid: System.Data.IDataReader
  parent: System.Data
  isExternal: false
  name: IDataReader
  nameWithType: IDataReader
  fullName: System.Data.IDataReader
- uid: System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)
  parent: System.Data.DataTable
  isExternal: false
  name: Load(IDataReader,LoadOption)
  nameWithType: DataTable.Load(IDataReader,LoadOption)
  fullName: System.Data.DataTable.Load(IDataReader,LoadOption)
- uid: System.Data.LoadOption
  parent: System.Data
  isExternal: false
  name: LoadOption
  nameWithType: LoadOption
  fullName: System.Data.LoadOption
- uid: System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)
  parent: System.Data.DataTable
  isExternal: false
  name: Load(IDataReader,LoadOption,FillErrorEventHandler)
  nameWithType: DataTable.Load(IDataReader,LoadOption,FillErrorEventHandler)
  fullName: System.Data.DataTable.Load(IDataReader,LoadOption,FillErrorEventHandler)
- uid: System.Data.FillErrorEventHandler
  parent: System.Data
  isExternal: false
  name: FillErrorEventHandler
  nameWithType: FillErrorEventHandler
  fullName: System.Data.FillErrorEventHandler
- uid: System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: LoadDataRow(Object[],Boolean)
  nameWithType: DataTable.LoadDataRow(Object[],Boolean)
  fullName: System.Data.DataTable.LoadDataRow(Object[],Boolean)
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)
  parent: System.Data.DataTable
  isExternal: false
  name: LoadDataRow(Object[],LoadOption)
  nameWithType: DataTable.LoadDataRow(Object[],LoadOption)
  fullName: System.Data.DataTable.LoadDataRow(Object[],LoadOption)
- uid: System.Data.DataTable.Locale
  parent: System.Data.DataTable
  isExternal: false
  name: Locale
  nameWithType: DataTable.Locale
  fullName: System.Data.DataTable.Locale
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Data.DataTable.Merge(System.Data.DataTable)
  parent: System.Data.DataTable
  isExternal: false
  name: Merge(DataTable)
  nameWithType: DataTable.Merge(DataTable)
  fullName: System.Data.DataTable.Merge(DataTable)
- uid: System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: Merge(DataTable,Boolean)
  nameWithType: DataTable.Merge(DataTable,Boolean)
  fullName: System.Data.DataTable.Merge(DataTable,Boolean)
- uid: System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataTable
  isExternal: false
  name: Merge(DataTable,Boolean,MissingSchemaAction)
  nameWithType: DataTable.Merge(DataTable,Boolean,MissingSchemaAction)
  fullName: System.Data.DataTable.Merge(DataTable,Boolean,MissingSchemaAction)
- uid: System.Data.MissingSchemaAction
  parent: System.Data
  isExternal: false
  name: MissingSchemaAction
  nameWithType: MissingSchemaAction
  fullName: System.Data.MissingSchemaAction
- uid: System.Data.DataTable.MinimumCapacity
  parent: System.Data.DataTable
  isExternal: false
  name: MinimumCapacity
  nameWithType: DataTable.MinimumCapacity
  fullName: System.Data.DataTable.MinimumCapacity
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Data.DataTable.Namespace
  parent: System.Data.DataTable
  isExternal: false
  name: Namespace
  nameWithType: DataTable.Namespace
  fullName: System.Data.DataTable.Namespace
- uid: System.Data.DataTable.NewRow
  parent: System.Data.DataTable
  isExternal: false
  name: NewRow()
  nameWithType: DataTable.NewRow()
  fullName: System.Data.DataTable.NewRow()
- uid: System.Data.DataTable.NewRowArray(System.Int32)
  parent: System.Data.DataTable
  isExternal: false
  name: NewRowArray(Int32)
  nameWithType: DataTable.NewRowArray(Int32)
  fullName: System.Data.DataTable.NewRowArray(Int32)
- uid: System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)
  parent: System.Data.DataTable
  isExternal: false
  name: NewRowFromBuilder(DataRowBuilder)
  nameWithType: DataTable.NewRowFromBuilder(DataRowBuilder)
  fullName: System.Data.DataTable.NewRowFromBuilder(DataRowBuilder)
- uid: System.Data.DataRowBuilder
  parent: System.Data
  isExternal: false
  name: DataRowBuilder
  nameWithType: DataRowBuilder
  fullName: System.Data.DataRowBuilder
- uid: System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnColumnChanged(DataColumnChangeEventArgs)
  nameWithType: DataTable.OnColumnChanged(DataColumnChangeEventArgs)
  fullName: System.Data.DataTable.OnColumnChanged(DataColumnChangeEventArgs)
- uid: System.Data.DataColumnChangeEventArgs
  parent: System.Data
  isExternal: false
  name: DataColumnChangeEventArgs
  nameWithType: DataColumnChangeEventArgs
  fullName: System.Data.DataColumnChangeEventArgs
- uid: System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnColumnChanging(DataColumnChangeEventArgs)
  nameWithType: DataTable.OnColumnChanging(DataColumnChangeEventArgs)
  fullName: System.Data.DataTable.OnColumnChanging(DataColumnChangeEventArgs)
- uid: System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnPropertyChanging(PropertyChangedEventArgs)
  nameWithType: DataTable.OnPropertyChanging(PropertyChangedEventArgs)
  fullName: System.Data.DataTable.OnPropertyChanging(PropertyChangedEventArgs)
- uid: System.ComponentModel.PropertyChangedEventArgs
  parent: System.ComponentModel
  isExternal: true
  name: PropertyChangedEventArgs
  nameWithType: PropertyChangedEventArgs
  fullName: System.ComponentModel.PropertyChangedEventArgs
- uid: System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)
  parent: System.Data.DataTable
  isExternal: false
  name: OnRemoveColumn(DataColumn)
  nameWithType: DataTable.OnRemoveColumn(DataColumn)
  fullName: System.Data.DataTable.OnRemoveColumn(DataColumn)
- uid: System.Data.DataColumn
  parent: System.Data
  isExternal: false
  name: DataColumn
  nameWithType: DataColumn
  fullName: System.Data.DataColumn
- uid: System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnRowChanged(DataRowChangeEventArgs)
  nameWithType: DataTable.OnRowChanged(DataRowChangeEventArgs)
  fullName: System.Data.DataTable.OnRowChanged(DataRowChangeEventArgs)
- uid: System.Data.DataRowChangeEventArgs
  parent: System.Data
  isExternal: false
  name: DataRowChangeEventArgs
  nameWithType: DataRowChangeEventArgs
  fullName: System.Data.DataRowChangeEventArgs
- uid: System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnRowChanging(DataRowChangeEventArgs)
  nameWithType: DataTable.OnRowChanging(DataRowChangeEventArgs)
  fullName: System.Data.DataTable.OnRowChanging(DataRowChangeEventArgs)
- uid: System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnRowDeleted(DataRowChangeEventArgs)
  nameWithType: DataTable.OnRowDeleted(DataRowChangeEventArgs)
  fullName: System.Data.DataTable.OnRowDeleted(DataRowChangeEventArgs)
- uid: System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnRowDeleting(DataRowChangeEventArgs)
  nameWithType: DataTable.OnRowDeleting(DataRowChangeEventArgs)
  fullName: System.Data.DataTable.OnRowDeleting(DataRowChangeEventArgs)
- uid: System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnTableCleared(DataTableClearEventArgs)
  nameWithType: DataTable.OnTableCleared(DataTableClearEventArgs)
  fullName: System.Data.DataTable.OnTableCleared(DataTableClearEventArgs)
- uid: System.Data.DataTableClearEventArgs
  parent: System.Data
  isExternal: false
  name: DataTableClearEventArgs
  nameWithType: DataTableClearEventArgs
  fullName: System.Data.DataTableClearEventArgs
- uid: System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnTableClearing(DataTableClearEventArgs)
  nameWithType: DataTable.OnTableClearing(DataTableClearEventArgs)
  fullName: System.Data.DataTable.OnTableClearing(DataTableClearEventArgs)
- uid: System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnTableNewRow(DataTableNewRowEventArgs)
  nameWithType: DataTable.OnTableNewRow(DataTableNewRowEventArgs)
  fullName: System.Data.DataTable.OnTableNewRow(DataTableNewRowEventArgs)
- uid: System.Data.DataTableNewRowEventArgs
  parent: System.Data
  isExternal: false
  name: DataTableNewRowEventArgs
  nameWithType: DataTableNewRowEventArgs
  fullName: System.Data.DataTableNewRowEventArgs
- uid: System.Data.DataTable.ParentRelations
  parent: System.Data.DataTable
  isExternal: false
  name: ParentRelations
  nameWithType: DataTable.ParentRelations
  fullName: System.Data.DataTable.ParentRelations
- uid: System.Data.DataTable.Prefix
  parent: System.Data.DataTable
  isExternal: false
  name: Prefix
  nameWithType: DataTable.Prefix
  fullName: System.Data.DataTable.Prefix
- uid: System.Data.DataTable.PrimaryKey
  parent: System.Data.DataTable
  isExternal: false
  name: PrimaryKey
  nameWithType: DataTable.PrimaryKey
  fullName: System.Data.DataTable.PrimaryKey
- uid: System.Data.DataColumn[]
  parent: System.Data
  isExternal: false
  name: DataColumn
  nameWithType: DataColumn
  fullName: System.Data.DataColumn[]
  spec.csharp:
  - uid: System.Data.DataColumn
    name: DataColumn
    nameWithType: DataColumn
    fullName: DataColumn[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.DataTable.ReadXml(System.IO.Stream)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXml(Stream)
  nameWithType: DataTable.ReadXml(Stream)
  fullName: System.Data.DataTable.ReadXml(Stream)
- uid: System.Data.XmlReadMode
  parent: System.Data
  isExternal: false
  name: XmlReadMode
  nameWithType: XmlReadMode
  fullName: System.Data.XmlReadMode
- uid: System.IO.Stream
  parent: System.IO
  isExternal: true
  name: Stream
  nameWithType: Stream
  fullName: System.IO.Stream
- uid: System.Data.DataTable.ReadXml(System.IO.TextReader)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXml(TextReader)
  nameWithType: DataTable.ReadXml(TextReader)
  fullName: System.Data.DataTable.ReadXml(TextReader)
- uid: System.IO.TextReader
  parent: System.IO
  isExternal: true
  name: TextReader
  nameWithType: TextReader
  fullName: System.IO.TextReader
- uid: System.Data.DataTable.ReadXml(System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXml(String)
  nameWithType: DataTable.ReadXml(String)
  fullName: System.Data.DataTable.ReadXml(String)
- uid: System.Data.DataTable.ReadXml(System.Xml.XmlReader)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXml(XmlReader)
  nameWithType: DataTable.ReadXml(XmlReader)
  fullName: System.Data.DataTable.ReadXml(XmlReader)
- uid: System.Xml.XmlReader
  parent: System.Xml
  isExternal: true
  name: XmlReader
  nameWithType: XmlReader
  fullName: System.Xml.XmlReader
- uid: System.Data.DataTable.ReadXmlSchema(System.IO.Stream)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXmlSchema(Stream)
  nameWithType: DataTable.ReadXmlSchema(Stream)
  fullName: System.Data.DataTable.ReadXmlSchema(Stream)
- uid: System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXmlSchema(TextReader)
  nameWithType: DataTable.ReadXmlSchema(TextReader)
  fullName: System.Data.DataTable.ReadXmlSchema(TextReader)
- uid: System.Data.DataTable.ReadXmlSchema(System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXmlSchema(String)
  nameWithType: DataTable.ReadXmlSchema(String)
  fullName: System.Data.DataTable.ReadXmlSchema(String)
- uid: System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXmlSchema(XmlReader)
  nameWithType: DataTable.ReadXmlSchema(XmlReader)
  fullName: System.Data.DataTable.ReadXmlSchema(XmlReader)
- uid: System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXmlSerializable(XmlReader)
  nameWithType: DataTable.ReadXmlSerializable(XmlReader)
  fullName: System.Data.DataTable.ReadXmlSerializable(XmlReader)
- uid: System.Data.DataTable.RejectChanges
  parent: System.Data.DataTable
  isExternal: false
  name: RejectChanges()
  nameWithType: DataTable.RejectChanges()
  fullName: System.Data.DataTable.RejectChanges()
- uid: System.Data.DataTable.RemotingFormat
  parent: System.Data.DataTable
  isExternal: false
  name: RemotingFormat
  nameWithType: DataTable.RemotingFormat
  fullName: System.Data.DataTable.RemotingFormat
- uid: System.Data.SerializationFormat
  parent: System.Data
  isExternal: false
  name: SerializationFormat
  nameWithType: SerializationFormat
  fullName: System.Data.SerializationFormat
- uid: System.Data.DataTable.Reset
  parent: System.Data.DataTable
  isExternal: false
  name: Reset()
  nameWithType: DataTable.Reset()
  fullName: System.Data.DataTable.Reset()
- uid: System.Data.DataTable.RowChanged
  parent: System.Data.DataTable
  isExternal: false
  name: RowChanged
  nameWithType: DataTable.RowChanged
  fullName: System.Data.DataTable.RowChanged
- uid: System.Data.DataRowChangeEventHandler
  parent: System.Data
  isExternal: false
  name: DataRowChangeEventHandler
  nameWithType: DataRowChangeEventHandler
  fullName: System.Data.DataRowChangeEventHandler
- uid: System.Data.DataTable.RowChanging
  parent: System.Data.DataTable
  isExternal: false
  name: RowChanging
  nameWithType: DataTable.RowChanging
  fullName: System.Data.DataTable.RowChanging
- uid: System.Data.DataTable.RowDeleted
  parent: System.Data.DataTable
  isExternal: false
  name: RowDeleted
  nameWithType: DataTable.RowDeleted
  fullName: System.Data.DataTable.RowDeleted
- uid: System.Data.DataTable.RowDeleting
  parent: System.Data.DataTable
  isExternal: false
  name: RowDeleting
  nameWithType: DataTable.RowDeleting
  fullName: System.Data.DataTable.RowDeleting
- uid: System.Data.DataTable.Rows
  parent: System.Data.DataTable
  isExternal: false
  name: Rows
  nameWithType: DataTable.Rows
  fullName: System.Data.DataTable.Rows
- uid: System.Data.DataRowCollection
  parent: System.Data
  isExternal: false
  name: DataRowCollection
  nameWithType: DataRowCollection
  fullName: System.Data.DataRowCollection
- uid: System.Data.DataTable.Select
  parent: System.Data.DataTable
  isExternal: false
  name: Select()
  nameWithType: DataTable.Select()
  fullName: System.Data.DataTable.Select()
- uid: System.Data.DataTable.Select(System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: Select(String)
  nameWithType: DataTable.Select(String)
  fullName: System.Data.DataTable.Select(String)
- uid: System.Data.DataTable.Select(System.String,System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: Select(String,String)
  nameWithType: DataTable.Select(String,String)
  fullName: System.Data.DataTable.Select(String,String)
- uid: System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)
  parent: System.Data.DataTable
  isExternal: false
  name: Select(String,String,DataViewRowState)
  nameWithType: DataTable.Select(String,String,DataViewRowState)
  fullName: System.Data.DataTable.Select(String,String,DataViewRowState)
- uid: System.Data.DataViewRowState
  parent: System.Data
  isExternal: false
  name: DataViewRowState
  nameWithType: DataViewRowState
  fullName: System.Data.DataViewRowState
- uid: System.Data.DataTable.Site
  parent: System.Data.DataTable
  isExternal: false
  name: Site
  nameWithType: DataTable.Site
  fullName: System.Data.DataTable.Site
- uid: System.ComponentModel.ISite
  parent: System.ComponentModel
  isExternal: false
  name: ISite
  nameWithType: ISite
  fullName: System.ComponentModel.ISite
- uid: System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection
  parent: System.Data.DataTable
  isExternal: false
  name: System.ComponentModel.IListSource.ContainsListCollection
  nameWithType: DataTable.System.ComponentModel.IListSource.ContainsListCollection
  fullName: System.Data.DataTable.System.ComponentModel.IListSource.ContainsListCollection
- uid: System.Data.DataTable.System#ComponentModel#IListSource#GetList
  parent: System.Data.DataTable
  isExternal: false
  name: System.ComponentModel.IListSource.GetList()
  nameWithType: DataTable.System.ComponentModel.IListSource.GetList()
  fullName: System.Data.DataTable.System.ComponentModel.IListSource.GetList()
- uid: System.Collections.IList
  parent: System.Collections
  isExternal: true
  name: IList
  nameWithType: IList
  fullName: System.Collections.IList
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema
  parent: System.Data.DataTable
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.GetSchema()
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.GetSchema()
  fullName: System.Data.DataTable.System.Xml.Serialization.IXmlSerializable.GetSchema()
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  parent: System.Data.DataTable
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  fullName: System.Data.DataTable.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  parent: System.Data.DataTable
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  fullName: System.Data.DataTable.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
- uid: System.Xml.XmlWriter
  parent: System.Xml
  isExternal: true
  name: XmlWriter
  nameWithType: XmlWriter
  fullName: System.Xml.XmlWriter
- uid: System.Data.DataTable.TableCleared
  parent: System.Data.DataTable
  isExternal: false
  name: TableCleared
  nameWithType: DataTable.TableCleared
  fullName: System.Data.DataTable.TableCleared
- uid: System.Data.DataTableClearEventHandler
  parent: System.Data
  isExternal: false
  name: DataTableClearEventHandler
  nameWithType: DataTableClearEventHandler
  fullName: System.Data.DataTableClearEventHandler
- uid: System.Data.DataTable.TableClearing
  parent: System.Data.DataTable
  isExternal: false
  name: TableClearing
  nameWithType: DataTable.TableClearing
  fullName: System.Data.DataTable.TableClearing
- uid: System.Data.DataTable.TableName
  parent: System.Data.DataTable
  isExternal: false
  name: TableName
  nameWithType: DataTable.TableName
  fullName: System.Data.DataTable.TableName
- uid: System.Data.DataTable.TableNewRow
  parent: System.Data.DataTable
  isExternal: false
  name: TableNewRow
  nameWithType: DataTable.TableNewRow
  fullName: System.Data.DataTable.TableNewRow
- uid: System.Data.DataTableNewRowEventHandler
  parent: System.Data
  isExternal: false
  name: DataTableNewRowEventHandler
  nameWithType: DataTableNewRowEventHandler
  fullName: System.Data.DataTableNewRowEventHandler
- uid: System.Data.DataTable.ToString
  parent: System.Data.DataTable
  isExternal: false
  name: ToString()
  nameWithType: DataTable.ToString()
  fullName: System.Data.DataTable.ToString()
- uid: System.Data.DataTable.WriteXml(System.IO.Stream)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(Stream)
  nameWithType: DataTable.WriteXml(Stream)
  fullName: System.Data.DataTable.WriteXml(Stream)
- uid: System.Data.DataTable.WriteXml(System.IO.TextWriter)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(TextWriter)
  nameWithType: DataTable.WriteXml(TextWriter)
  fullName: System.Data.DataTable.WriteXml(TextWriter)
- uid: System.IO.TextWriter
  parent: System.IO
  isExternal: true
  name: TextWriter
  nameWithType: TextWriter
  fullName: System.IO.TextWriter
- uid: System.Data.DataTable.WriteXml(System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(String)
  nameWithType: DataTable.WriteXml(String)
  fullName: System.Data.DataTable.WriteXml(String)
- uid: System.Data.DataTable.WriteXml(System.Xml.XmlWriter)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(XmlWriter)
  nameWithType: DataTable.WriteXml(XmlWriter)
  fullName: System.Data.DataTable.WriteXml(XmlWriter)
- uid: System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(Stream,Boolean)
  nameWithType: DataTable.WriteXml(Stream,Boolean)
  fullName: System.Data.DataTable.WriteXml(Stream,Boolean)
- uid: System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(Stream,XmlWriteMode)
  nameWithType: DataTable.WriteXml(Stream,XmlWriteMode)
  fullName: System.Data.DataTable.WriteXml(Stream,XmlWriteMode)
- uid: System.Data.XmlWriteMode
  parent: System.Data
  isExternal: false
  name: XmlWriteMode
  nameWithType: XmlWriteMode
  fullName: System.Data.XmlWriteMode
- uid: System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(TextWriter,Boolean)
  nameWithType: DataTable.WriteXml(TextWriter,Boolean)
  fullName: System.Data.DataTable.WriteXml(TextWriter,Boolean)
- uid: System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(TextWriter,XmlWriteMode)
  nameWithType: DataTable.WriteXml(TextWriter,XmlWriteMode)
  fullName: System.Data.DataTable.WriteXml(TextWriter,XmlWriteMode)
- uid: System.Data.DataTable.WriteXml(System.String,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(String,Boolean)
  nameWithType: DataTable.WriteXml(String,Boolean)
  fullName: System.Data.DataTable.WriteXml(String,Boolean)
- uid: System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(String,XmlWriteMode)
  nameWithType: DataTable.WriteXml(String,XmlWriteMode)
  fullName: System.Data.DataTable.WriteXml(String,XmlWriteMode)
- uid: System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(XmlWriter,Boolean)
  nameWithType: DataTable.WriteXml(XmlWriter,Boolean)
  fullName: System.Data.DataTable.WriteXml(XmlWriter,Boolean)
- uid: System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(XmlWriter,XmlWriteMode)
  nameWithType: DataTable.WriteXml(XmlWriter,XmlWriteMode)
  fullName: System.Data.DataTable.WriteXml(XmlWriter,XmlWriteMode)
- uid: System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(Stream,XmlWriteMode,Boolean)
  nameWithType: DataTable.WriteXml(Stream,XmlWriteMode,Boolean)
  fullName: System.Data.DataTable.WriteXml(Stream,XmlWriteMode,Boolean)
- uid: System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(TextWriter,XmlWriteMode,Boolean)
  nameWithType: DataTable.WriteXml(TextWriter,XmlWriteMode,Boolean)
  fullName: System.Data.DataTable.WriteXml(TextWriter,XmlWriteMode,Boolean)
- uid: System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(String,XmlWriteMode,Boolean)
  nameWithType: DataTable.WriteXml(String,XmlWriteMode,Boolean)
  fullName: System.Data.DataTable.WriteXml(String,XmlWriteMode,Boolean)
- uid: System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(XmlWriter,XmlWriteMode,Boolean)
  nameWithType: DataTable.WriteXml(XmlWriter,XmlWriteMode,Boolean)
  fullName: System.Data.DataTable.WriteXml(XmlWriter,XmlWriteMode,Boolean)
- uid: System.Data.DataTable.WriteXmlSchema(System.IO.Stream)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema(Stream)
  nameWithType: DataTable.WriteXmlSchema(Stream)
  fullName: System.Data.DataTable.WriteXmlSchema(Stream)
- uid: System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema(TextWriter)
  nameWithType: DataTable.WriteXmlSchema(TextWriter)
  fullName: System.Data.DataTable.WriteXmlSchema(TextWriter)
- uid: System.Data.DataTable.WriteXmlSchema(System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema(String)
  nameWithType: DataTable.WriteXmlSchema(String)
  fullName: System.Data.DataTable.WriteXmlSchema(String)
- uid: System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema(XmlWriter)
  nameWithType: DataTable.WriteXmlSchema(XmlWriter)
  fullName: System.Data.DataTable.WriteXmlSchema(XmlWriter)
- uid: System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema(Stream,Boolean)
  nameWithType: DataTable.WriteXmlSchema(Stream,Boolean)
  fullName: System.Data.DataTable.WriteXmlSchema(Stream,Boolean)
- uid: System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema(TextWriter,Boolean)
  nameWithType: DataTable.WriteXmlSchema(TextWriter,Boolean)
  fullName: System.Data.DataTable.WriteXmlSchema(TextWriter,Boolean)
- uid: System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema(String,Boolean)
  nameWithType: DataTable.WriteXmlSchema(String,Boolean)
  fullName: System.Data.DataTable.WriteXmlSchema(String,Boolean)
- uid: System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema(XmlWriter,Boolean)
  nameWithType: DataTable.WriteXmlSchema(XmlWriter,Boolean)
  fullName: System.Data.DataTable.WriteXmlSchema(XmlWriter,Boolean)
- uid: System.Data.DataTable.#ctor*
  parent: System.Data.DataTable
  isExternal: false
  name: DataTable
  nameWithType: DataTable.DataTable
- uid: System.Data.DataTable.AcceptChanges*
  parent: System.Data.DataTable
  isExternal: false
  name: AcceptChanges
  nameWithType: DataTable.AcceptChanges
- uid: System.Data.DataTable.BeginInit*
  parent: System.Data.DataTable
  isExternal: false
  name: BeginInit
  nameWithType: DataTable.BeginInit
- uid: System.Data.DataTable.BeginLoadData*
  parent: System.Data.DataTable
  isExternal: false
  name: BeginLoadData
  nameWithType: DataTable.BeginLoadData
- uid: System.Data.DataTable.CaseSensitive*
  parent: System.Data.DataTable
  isExternal: false
  name: CaseSensitive
  nameWithType: DataTable.CaseSensitive
- uid: System.Data.DataTable.ChildRelations*
  parent: System.Data.DataTable
  isExternal: false
  name: ChildRelations
  nameWithType: DataTable.ChildRelations
- uid: System.Data.DataTable.Clear*
  parent: System.Data.DataTable
  isExternal: false
  name: Clear
  nameWithType: DataTable.Clear
- uid: System.Data.DataTable.Clone*
  parent: System.Data.DataTable
  isExternal: false
  name: Clone
  nameWithType: DataTable.Clone
- uid: System.Data.DataTable.Columns*
  parent: System.Data.DataTable
  isExternal: false
  name: Columns
  nameWithType: DataTable.Columns
- uid: System.Data.DataTable.Compute*
  parent: System.Data.DataTable
  isExternal: false
  name: Compute
  nameWithType: DataTable.Compute
- uid: System.Data.DataTable.Constraints*
  parent: System.Data.DataTable
  isExternal: false
  name: Constraints
  nameWithType: DataTable.Constraints
- uid: System.Data.DataTable.Copy*
  parent: System.Data.DataTable
  isExternal: false
  name: Copy
  nameWithType: DataTable.Copy
- uid: System.Data.DataTable.CreateDataReader*
  parent: System.Data.DataTable
  isExternal: false
  name: CreateDataReader
  nameWithType: DataTable.CreateDataReader
- uid: System.Data.DataTable.CreateInstance*
  parent: System.Data.DataTable
  isExternal: false
  name: CreateInstance
  nameWithType: DataTable.CreateInstance
- uid: System.Data.DataTable.DataSet*
  parent: System.Data.DataTable
  isExternal: false
  name: DataSet
  nameWithType: DataTable.DataSet
- uid: System.Data.DataTable.DefaultView*
  parent: System.Data.DataTable
  isExternal: false
  name: DefaultView
  nameWithType: DataTable.DefaultView
- uid: System.Data.DataTable.DisplayExpression*
  parent: System.Data.DataTable
  isExternal: false
  name: DisplayExpression
  nameWithType: DataTable.DisplayExpression
- uid: System.Data.DataTable.EndInit*
  parent: System.Data.DataTable
  isExternal: false
  name: EndInit
  nameWithType: DataTable.EndInit
- uid: System.Data.DataTable.EndLoadData*
  parent: System.Data.DataTable
  isExternal: false
  name: EndLoadData
  nameWithType: DataTable.EndLoadData
- uid: System.Data.DataTable.ExtendedProperties*
  parent: System.Data.DataTable
  isExternal: false
  name: ExtendedProperties
  nameWithType: DataTable.ExtendedProperties
- uid: System.Data.DataTable.GetChanges*
  parent: System.Data.DataTable
  isExternal: false
  name: GetChanges
  nameWithType: DataTable.GetChanges
- uid: System.Data.DataTable.GetDataTableSchema*
  parent: System.Data.DataTable
  isExternal: false
  name: GetDataTableSchema
  nameWithType: DataTable.GetDataTableSchema
- uid: System.Data.DataTable.GetErrors*
  parent: System.Data.DataTable
  isExternal: false
  name: GetErrors
  nameWithType: DataTable.GetErrors
- uid: System.Data.DataTable.GetObjectData*
  parent: System.Data.DataTable
  isExternal: false
  name: GetObjectData
  nameWithType: DataTable.GetObjectData
- uid: System.Data.DataTable.GetRowType*
  parent: System.Data.DataTable
  isExternal: false
  name: GetRowType
  nameWithType: DataTable.GetRowType
- uid: System.Data.DataTable.GetSchema*
  parent: System.Data.DataTable
  isExternal: false
  name: GetSchema
  nameWithType: DataTable.GetSchema
- uid: System.Data.DataTable.HasErrors*
  parent: System.Data.DataTable
  isExternal: false
  name: HasErrors
  nameWithType: DataTable.HasErrors
- uid: System.Data.DataTable.ImportRow*
  parent: System.Data.DataTable
  isExternal: false
  name: ImportRow
  nameWithType: DataTable.ImportRow
- uid: System.Data.DataTable.IsInitialized*
  parent: System.Data.DataTable
  isExternal: false
  name: IsInitialized
  nameWithType: DataTable.IsInitialized
- uid: System.Data.DataTable.Load*
  parent: System.Data.DataTable
  isExternal: false
  name: Load
  nameWithType: DataTable.Load
- uid: System.Data.DataTable.LoadDataRow*
  parent: System.Data.DataTable
  isExternal: false
  name: LoadDataRow
  nameWithType: DataTable.LoadDataRow
- uid: System.Data.DataTable.Locale*
  parent: System.Data.DataTable
  isExternal: false
  name: Locale
  nameWithType: DataTable.Locale
- uid: System.Data.DataTable.Merge*
  parent: System.Data.DataTable
  isExternal: false
  name: Merge
  nameWithType: DataTable.Merge
- uid: System.Data.DataTable.MinimumCapacity*
  parent: System.Data.DataTable
  isExternal: false
  name: MinimumCapacity
  nameWithType: DataTable.MinimumCapacity
- uid: System.Data.DataTable.Namespace*
  parent: System.Data.DataTable
  isExternal: false
  name: Namespace
  nameWithType: DataTable.Namespace
- uid: System.Data.DataTable.NewRow*
  parent: System.Data.DataTable
  isExternal: false
  name: NewRow
  nameWithType: DataTable.NewRow
- uid: System.Data.DataTable.NewRowArray*
  parent: System.Data.DataTable
  isExternal: false
  name: NewRowArray
  nameWithType: DataTable.NewRowArray
- uid: System.Data.DataTable.NewRowFromBuilder*
  parent: System.Data.DataTable
  isExternal: false
  name: NewRowFromBuilder
  nameWithType: DataTable.NewRowFromBuilder
- uid: System.Data.DataTable.OnColumnChanged*
  parent: System.Data.DataTable
  isExternal: false
  name: OnColumnChanged
  nameWithType: DataTable.OnColumnChanged
- uid: System.Data.DataTable.OnColumnChanging*
  parent: System.Data.DataTable
  isExternal: false
  name: OnColumnChanging
  nameWithType: DataTable.OnColumnChanging
- uid: System.Data.DataTable.OnPropertyChanging*
  parent: System.Data.DataTable
  isExternal: false
  name: OnPropertyChanging
  nameWithType: DataTable.OnPropertyChanging
- uid: System.Data.DataTable.OnRemoveColumn*
  parent: System.Data.DataTable
  isExternal: false
  name: OnRemoveColumn
  nameWithType: DataTable.OnRemoveColumn
- uid: System.Data.DataTable.OnRowChanged*
  parent: System.Data.DataTable
  isExternal: false
  name: OnRowChanged
  nameWithType: DataTable.OnRowChanged
- uid: System.Data.DataTable.OnRowChanging*
  parent: System.Data.DataTable
  isExternal: false
  name: OnRowChanging
  nameWithType: DataTable.OnRowChanging
- uid: System.Data.DataTable.OnRowDeleted*
  parent: System.Data.DataTable
  isExternal: false
  name: OnRowDeleted
  nameWithType: DataTable.OnRowDeleted
- uid: System.Data.DataTable.OnRowDeleting*
  parent: System.Data.DataTable
  isExternal: false
  name: OnRowDeleting
  nameWithType: DataTable.OnRowDeleting
- uid: System.Data.DataTable.OnTableCleared*
  parent: System.Data.DataTable
  isExternal: false
  name: OnTableCleared
  nameWithType: DataTable.OnTableCleared
- uid: System.Data.DataTable.OnTableClearing*
  parent: System.Data.DataTable
  isExternal: false
  name: OnTableClearing
  nameWithType: DataTable.OnTableClearing
- uid: System.Data.DataTable.OnTableNewRow*
  parent: System.Data.DataTable
  isExternal: false
  name: OnTableNewRow
  nameWithType: DataTable.OnTableNewRow
- uid: System.Data.DataTable.ParentRelations*
  parent: System.Data.DataTable
  isExternal: false
  name: ParentRelations
  nameWithType: DataTable.ParentRelations
- uid: System.Data.DataTable.Prefix*
  parent: System.Data.DataTable
  isExternal: false
  name: Prefix
  nameWithType: DataTable.Prefix
- uid: System.Data.DataTable.PrimaryKey*
  parent: System.Data.DataTable
  isExternal: false
  name: PrimaryKey
  nameWithType: DataTable.PrimaryKey
- uid: System.Data.DataTable.ReadXml*
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXml
  nameWithType: DataTable.ReadXml
- uid: System.Data.DataTable.ReadXmlSchema*
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXmlSchema
  nameWithType: DataTable.ReadXmlSchema
- uid: System.Data.DataTable.ReadXmlSerializable*
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXmlSerializable
  nameWithType: DataTable.ReadXmlSerializable
- uid: System.Data.DataTable.RejectChanges*
  parent: System.Data.DataTable
  isExternal: false
  name: RejectChanges
  nameWithType: DataTable.RejectChanges
- uid: System.Data.DataTable.RemotingFormat*
  parent: System.Data.DataTable
  isExternal: false
  name: RemotingFormat
  nameWithType: DataTable.RemotingFormat
- uid: System.Data.DataTable.Reset*
  parent: System.Data.DataTable
  isExternal: false
  name: Reset
  nameWithType: DataTable.Reset
- uid: System.Data.DataTable.Rows*
  parent: System.Data.DataTable
  isExternal: false
  name: Rows
  nameWithType: DataTable.Rows
- uid: System.Data.DataTable.Select*
  parent: System.Data.DataTable
  isExternal: false
  name: Select
  nameWithType: DataTable.Select
- uid: System.Data.DataTable.Site*
  parent: System.Data.DataTable
  isExternal: false
  name: Site
  nameWithType: DataTable.Site
- uid: System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection*
  parent: System.Data.DataTable
  isExternal: false
  name: System.ComponentModel.IListSource.ContainsListCollection
  nameWithType: DataTable.System.ComponentModel.IListSource.ContainsListCollection
- uid: System.Data.DataTable.System#ComponentModel#IListSource#GetList*
  parent: System.Data.DataTable
  isExternal: false
  name: System.ComponentModel.IListSource.GetList
  nameWithType: DataTable.System.ComponentModel.IListSource.GetList
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema*
  parent: System.Data.DataTable
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.GetSchema
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.GetSchema
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml*
  parent: System.Data.DataTable
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.ReadXml
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.ReadXml
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml*
  parent: System.Data.DataTable
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.WriteXml
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.WriteXml
- uid: System.Data.DataTable.TableName*
  parent: System.Data.DataTable
  isExternal: false
  name: TableName
  nameWithType: DataTable.TableName
- uid: System.Data.DataTable.ToString*
  parent: System.Data.DataTable
  isExternal: false
  name: ToString
  nameWithType: DataTable.ToString
- uid: System.Data.DataTable.WriteXml*
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml
  nameWithType: DataTable.WriteXml
- uid: System.Data.DataTable.WriteXmlSchema*
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema
  nameWithType: DataTable.WriteXmlSchema
