### YamlMime:ManagedReference
items:
- uid: System.Security.SecurityManager
  id: SecurityManager
  children:
  - System.Security.SecurityManager.CheckExecutionRights
  - System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture
  - System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)
  - System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)
  - System.Security.SecurityManager.IsGranted(System.Security.IPermission)
  - System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)
  - System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)
  - System.Security.SecurityManager.PolicyHierarchy
  - System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)
  - System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])
  - System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)
  - System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)
  - System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)
  - System.Security.SecurityManager.SavePolicy
  - System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)
  - System.Security.SecurityManager.SecurityEnabled
  langs:
  - csharp
  name: SecurityManager
  nameWithType: SecurityManager
  fullName: System.Security.SecurityManager
  type: Class
  summary: "보안 시스템과 상호 작용 하는 클래스에 대 한 주 액세스 지점을 제공 합니다. 이 클래스는 상속 될 수 없습니다."
  remarks: "보안 액세스 하 고 보안 정책 구성을 처리 하는 메서드를 제공 합니다. SecurityManager의 인스턴스를 만들 수 없습니다."
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public static class SecurityManager
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Security.SecurityManager.CheckExecutionRights
  id: CheckExecutionRights
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: CheckExecutionRights
  nameWithType: SecurityManager.CheckExecutionRights
  fullName: System.Security.SecurityManager.CheckExecutionRights
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "코드 있어야 하는지 여부를 나타내는 값을 가져오거나 설정 합니다. <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref> 실행할 수 있도록 합니다."
  remarks: "이 속성이 `false`, 없이 코드에도 <xref:System.Security.Permissions.SecurityPermissionFlag>실행할 수 있습니다.</xref:System.Security.Permissions.SecurityPermissionFlag> 실행 검사 상당히 소모 되며 지연 정책 결정의 장점의 제거할 수 있습니다. 필요한 경우 실행 검사 하지 않으려면이 속성은 제공 합니다.       이 속성에 대 한 변경 될 때까지 지속 되지 않는 <xref:System.Security.SecurityManager.SavePolicy%2A>호출 됩니다.</xref:System.Security.SecurityManager.SavePolicy%2A> 레지스트리에 유지 될 때까지 새 프로세스 변경의 적용 되지 않습니다."
  syntax:
    content: public static bool CheckExecutionRights { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>코드에 있어야 하는 경우 <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref> ; 실행 하기 위해 이렇게 하지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Security.SecurityManager.CheckExecutionRights*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "이 메서드를 호출 하는 코드에 없는 <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture
  id: CurrentThreadRequiresSecurityContextCapture
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: CurrentThreadRequiresSecurityContextCapture()
  nameWithType: SecurityManager.CurrentThreadRequiresSecurityContextCapture()
  fullName: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "현재 스레드의 보안 상태는 시간에 나중에 다시 생성 해야 하는 경우 보안 컨텍스트 캡처 필요한 지 여부를 결정 합니다."
  remarks: "성공적인 보안 요구 후에 얻은 중요 한 데이터를 캐시 하기 전에 CurrentThreadRequiresSecurityContextCapture 메서드를 사용할 수 있습니다.       경우는 <xref:System.Security.CodeAccessPermission.Assert%2A>메서드를 호출한 더 높은 스택에, 해당 보안 컨텍스트를 캡처하지 않고 데이터를 캐시 하지 않아야 합니다.</xref:System.Security.CodeAccessPermission.Assert%2A> 그렇지 않으면 중요 한 데이터에서 가져온는 <xref:System.Security.CodeAccessPermission.Assert%2A>코드에 사용할 수 있게 된 더 이상 실행 되지 <xref:System.Security.CodeAccessPermission.Assert%2A>위치에.</xref:System.Security.CodeAccessPermission.Assert%2A> </xref:System.Security.CodeAccessPermission.Assert%2A>      > [!IMPORTANT] > 반환 값은 신뢰할 수 있는 경우에 `false`, 스레드가 필요한 보안 컨텍스트 캡처 수 없도록 보장을 의미 합니다. 보안 컨텍스트 캡처 보안 취약성을 방지 하기 위해 필요 하지 않은 경우 메서드가 true 반환할 수 있습니다.       CurrentThreadRequiresSecurityContextCapture 이므로 보안에 중요 한 기본 사용 불필요 한 보안 컨텍스트를 방지 하기 위해 캡처를 사용 하는 코드 보안에 중요 하 고 감사 해야 합니다."
  syntax:
    content: public static bool CurrentThreadRequiresSecurityContextCapture ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>부분적으로 신뢰할 수 있는 응용 프로그램 도메인이 없습니다, 부분적으로 신뢰할 수 없는 어셈블리 및 아니요 스택의 포함 된 경우 현재 활성 <> </> *> 또는 <> </> *>; 한정자 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> 경우 공용 언어 런타임 스택에 포함 되지 않을 수도 있습니다."
  overload: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)
  id: GetStandardSandbox(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: GetStandardSandbox(Evidence)
  nameWithType: SecurityManager.GetStandardSandbox(Evidence)
  fullName: System.Security.SecurityManager.GetStandardSandbox(Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "제공된 된 증거에 응용 프로그램에 부여 해도 안전한 권한 집합을 가져옵니다."
  remarks: "> [!NOTE]>에 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], 증명 정보에 호스트 `evidence` 있어야 <xref:System.Security.Policy.Zone?displayProperty=fullName>증거.</xref:System.Security.Policy.Zone?displayProperty=fullName>   >> 다음 표에서 각 영역에 대해 반환 되는 사용 권한 집합을 보여 줍니다.      | 영역 | 사용 권한 집합 |   |----------|--------------------|   | <xref:System.Security.SecurityZone>| `FullTrust`|   | <xref:System.Security.SecurityZone>| `LocalIntranet`|   | <xref:System.Security.SecurityZone>| `Internet`|   | <xref:System.Security.SecurityZone>| `Internet`|   | <xref:System.Security.SecurityZone>| None |   | <xref:System.Security.SecurityZone>| None |       다른 증명 정보 같은 <xref:System.Security.Policy.Url>또는 <xref:System.Security.Policy.Site>, 간주 될 수 있습니다.</xref:System.Security.Policy.Site> </xref:System.Security.Policy.Url> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone>       반환 된 권한 집합 응용 프로그램을 실행 하는 샌드박스에서 사용할 수 있습니다. 참고가이 방법의 정책을 지정 하지 않습니다 되지만 호스트 응용 프로그램에서 요청한 권한 집합이 합리적인 인지 확인 하는 데 도움이 됩니다. 샌드박스에 영역을 매핑할이 메서드를 사용할 수 있습니다."
  example:
  - "The following example shows how to use the GetStandardSandbox method to obtain the permission set for a sandboxed application. For more information about running an application in a sandbox, see [How to: Run Partially Trusted Code in a Sandbox](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[sandboxingApis#1](~/add/codesnippet/visualbasic/2aad9996-0182-4c3d-a405-_1.vb)]\n [!code-cs[sandboxingApis#1](~/add/codesnippet/csharp/2aad9996-0182-4c3d-a405-_1.cs)]"
  syntax:
    content: public static System.Security.PermissionSet GetStandardSandbox (System.Security.Policy.Evidence evidence);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "사용 권한 집합에 일치 하도록 호스트 증거입니다."
    return:
      type: System.Security.PermissionSet
      description: "권한 부여가 제공된 된 증거 응용 프로그램에 대 한 설정으로 사용할 수 있는 권한 집합입니다."
  overload: System.Security.SecurityManager.GetStandardSandbox*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>evidence</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)
  id: GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: GetZoneAndOrigin(ArrayList,ArrayList)
  nameWithType: SecurityManager.GetZoneAndOrigin(ArrayList,ArrayList)
  fullName: System.Security.SecurityManager.GetZoneAndOrigin(ArrayList,ArrayList)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "현재 어셈블리에 대 한 부여 된 영역 id 및 URL id 권한 집합을 가져옵니다."
  remarks: "메서드 대신이이 메서드를 호출 하는 실행 중인 어셈블리에 대 한 URL 및 영역 증명 정보를 사용 하는 것 <xref:System.Security.SecurityManager.ResolvePolicy%2A>증거 유형별로.</xref:System.Security.SecurityManager.ResolvePolicy%2A> 반환 된 사용 권한 집합은 <xref:System.Security.SecurityManager.ResolvePolicy%2A>호출 영역 및 원본 URL에 따라 실행 중인 어셈블리에 부여 된 권한을 식별 합니다.</xref:System.Security.SecurityManager.ResolvePolicy%2A>      > [!NOTE] >이 멤버는 올바른 암호화 키가 아니라 의사 키 있는 ECMA 공개 키에 대 한 링크 요청을 만듭니다. .NET Framework 내에서 링크 요청 ECMA 의사 키에 대 한 자동으로 Microsoft 공개 키에 대 한 링크 요청으로 변환 됩니다. 보안 예외가 ECMA 의사 키가 아니라 Microsoft 공개 키를 기반으로 합니다."
  syntax:
    content: public static void GetZoneAndOrigin (out System.Collections.ArrayList zone, out System.Collections.ArrayList origin);
    parameters:
    - id: zone
      type: System.Collections.ArrayList
      description: "포함 하는 출력 매개 변수는 <xref href=&quot;System.Collections.ArrayList&quot;> </xref> 의 부여한 <xref:System.Security.Permissions.ZoneIdentityPermissionAttribute.Zone*>개체입니다.</xref:System.Security.Permissions.ZoneIdentityPermissionAttribute.Zone*>"
    - id: origin
      type: System.Collections.ArrayList
      description: "포함 하는 출력 매개 변수는 <xref href=&quot;System.Collections.ArrayList&quot;> </xref> 의 부여한 <xref href=&quot;System.Security.Permissions.UrlIdentityPermission&quot;> </xref> 개체입니다."
  overload: System.Security.SecurityManager.GetZoneAndOrigin*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "에 대 한 요청 <xref href=&quot;System.Security.Permissions.StrongNameIdentityPermission&quot;> </xref> 실패 했습니다."
  platform:
  - net462
- uid: System.Security.SecurityManager.IsGranted(System.Security.IPermission)
  id: IsGranted(System.Security.IPermission)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: IsGranted(IPermission)
  nameWithType: SecurityManager.IsGranted(IPermission)
  fullName: System.Security.SecurityManager.IsGranted(IPermission)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "사용 권한을 호출자에 게 부여 되었는지 여부를 결정 합니다."
  remarks: "사용 권한 부여 정책에 따라 결정 및는 어설션과 같은 재정의 하기 쉬운 요청과와에서 다릅니다. 또한 IsGranted 부여 스택의 다른 호출자에 게 독립적 호출 코드 어셈블리를 검사 합니다."
  syntax:
    content: public static bool IsGranted (System.Security.IPermission perm);
    parameters:
    - id: perm
      type: System.Security.IPermission
      description: "호출자에 게 권한을 부여 하는 조건을 검사할 권한입니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>호출자에 게 부여 된 권한 사용 권한을 포함 하는 경우 <code> perm </code>, 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Security.SecurityManager.IsGranted*
  exceptions: []
  platform:
  - net462
- uid: System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)
  id: LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: LoadPolicyLevelFromFile(String,PolicyLevelType)
  nameWithType: SecurityManager.LoadPolicyLevelFromFile(String,PolicyLevelType)
  fullName: System.Security.SecurityManager.LoadPolicyLevelFromFile(String,PolicyLevelType)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "로드 한 <xref href=&quot;System.Security.Policy.PolicyLevel&quot;> </xref> 지정된 된 파일에서 합니다."
  syntax:
    content: public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromFile (string path, System.Security.PolicyLevelType type);
    parameters:
    - id: path
      type: System.String
      description: "보안 정책 정보를 포함 하는 파일에는 실제 파일 경로입니다."
    - id: type
      type: System.Security.PolicyLevelType
      description: "로드 된 정책 수준의 유형을 지정 하는 열거형 값 중 하나입니다."
    return:
      type: System.Security.Policy.PolicyLevel
      description: "로드 된 정책 수준입니다."
  overload: System.Security.SecurityManager.LoadPolicyLevelFromFile*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "가리키는 파일이 <code> path </code> 매개 변수가 없습니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "이 메서드를 호출 하는 코드에 없는 <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>합니다.       -또는-이 메서드를 호출 하는 코드에 없는 <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>합니다.       -또는-이 메서드를 호출 하는 코드에 없는 <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>합니다.       -또는-이 메서드를 호출 하는 코드에 없는 <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>합니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "이 메서드는 코드 액세스 보안 (CA) 정책에서 사용 되지 않는 사용은 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]합니다. .NET Framework의 이전 버전과 호환성을 위해 CAS 정책을 사용 하려면 사용 된 [ &lt;legacyCasPolicy&gt; 요소](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)합니다."
  platform:
  - net462
- uid: System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)
  id: LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: LoadPolicyLevelFromString(String,PolicyLevelType)
  nameWithType: SecurityManager.LoadPolicyLevelFromString(String,PolicyLevelType)
  fullName: System.Security.SecurityManager.LoadPolicyLevelFromString(String,PolicyLevelType)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "로드 한 <xref href=&quot;System.Security.Policy.PolicyLevel&quot;> </xref> 에서 지정된 된 문자열입니다."
  syntax:
    content: public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromString (string str, System.Security.PolicyLevelType type);
    parameters:
    - id: str
      type: System.String
      description: "구성 파일에 나타나는 같은 폼의 보안 정책 수준 XML 표현입니다."
    - id: type
      type: System.Security.PolicyLevelType
      description: "로드 된 정책 수준의 유형을 지정 하는 열거형 값 중 하나입니다."
    return:
      type: System.Security.Policy.PolicyLevel
      description: "로드 된 정책 수준입니다."
  overload: System.Security.SecurityManager.LoadPolicyLevelFromString*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>str</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> str </code> 매개 변수가 올바르지 않습니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "이 메서드를 호출 하는 코드에 없는 <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Security.SecurityManager.PolicyHierarchy
  id: PolicyHierarchy
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: PolicyHierarchy()
  nameWithType: SecurityManager.PolicyHierarchy()
  fullName: System.Security.SecurityManager.PolicyHierarchy()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "예: 컴퓨터 정책 및 사용자 정책 수준에 따라 보안 정책 계층 구조에 액세스 하는 열거자를 제공 합니다."
  remarks: "반환 된 열거자를 제공 연속 <xref:System.Security.Policy.PolicyLevel>해당 정책을 나타내는 개체 (컴퓨터, 사용자, 엔터프라이즈, 응용 프로그램 도메인) 계층의 수준.</xref:System.Security.Policy.PolicyLevel> 이러한 개체는 정책 라이브 개체입니다. 이러한 개체를 변경 하면 예기치 않은 결과가 있을 수 있습니다.       최소 정책 계층 구조의 컴퓨터 수준, 엔터프라이즈 수준 및 사용자 수준 구성 됩니다. 그러나 계층 수준을 포함할 수 있습니다."
  syntax:
    content: public static System.Collections.IEnumerator PolicyHierarchy ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "에 대 한 열거자 <xref href=&quot;System.Security.Policy.PolicyLevel&quot;> </xref> 보안 정책 계층 구조를 구성 하는 개체입니다."
  overload: System.Security.SecurityManager.PolicyHierarchy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "이 메서드는 코드 액세스 보안 (CA) 정책에서 사용 되지 않는 사용은 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]합니다. .NET Framework의 이전 버전과 호환성을 위해 CAS 정책을 사용 하려면 사용 된 [ &lt;legacyCasPolicy&gt; 요소](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)합니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "이 메서드를 호출 하는 코드에 없는 <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)
  id: ResolvePolicy(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolvePolicy(Evidence)
  nameWithType: SecurityManager.ResolvePolicy(Evidence)
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "지정한 증명 정보 기반 코드에 부여할 권한을 결정 합니다."
  remarks: "이 메서드는 호출 코드의 id의 증명 정보를 제공 하는 보안 정책 엔진을 호출 합니다. 결과 보안 정책에 의해 결정 됩니다."
  syntax:
    content: public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "증명 정보 집합 정책을 평가 하는 데 사용 합니다."
    return:
      type: System.Security.PermissionSet
      description: "보안 시스템으로 부여할 수 있는 사용 권한 집합입니다."
  overload: System.Security.SecurityManager.ResolvePolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "이 메서드는 코드 액세스 보안 (CA) 정책에서 사용 되지 않는 사용은 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]합니다. .NET Framework의 이전 버전과 호환성을 위해 CAS 정책을 사용 하려면 사용 된 [ &lt;legacyCasPolicy&gt; 요소](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)합니다."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])
  id: ResolvePolicy(System.Security.Policy.Evidence[])
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolvePolicy(Evidence[])
  nameWithType: SecurityManager.ResolvePolicy(Evidence[])
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "지정한 증명 정보 기반 코드에 부여할 권한을 결정 합니다."
  remarks: "이 메서드 호출의 배열을 사용 하 여 제공 하는 보안 정책 엔진 <xref:System.Security.Policy.Evidence>개체입니다.</xref:System.Security.Policy.Evidence> 반환 된 권한 집합에는 배열에 있는 모든 증명 정보에 적용 되는 권한을만 나타냅니다. 이러한 권한은 동일 하거나 하위 집합 정책 각 개별 증거에 부여한 사용 권한을 적용 합니다. 각 정책을 확인의 결과에 교차를 수행 하는 경우에 따라이 메서드는 동작의 <xref:System.Security.Policy.Evidence>배열의 개체에에서.</xref:System.Security.Policy.Evidence>"
  syntax:
    content: public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence[] evidences);
    parameters:
    - id: evidences
      type: System.Security.Policy.Evidence[]
      description: "정책을 평가 하는 데 사용 되는 증명 정보 개체의 배열입니다."
    return:
      type: System.Security.PermissionSet
      description: "모든 제공된 된 증거에 대 한 적절 한 사용 권한의 집합."
  overload: System.Security.SecurityManager.ResolvePolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "이 메서드는 코드 액세스 보안 (CA) 정책에서 사용 되지 않는 사용은 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]합니다. .NET Framework의 이전 버전과 호환성을 위해 CAS 정책을 사용 하려면 사용 된 [ &lt;legacyCasPolicy&gt; 요소](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)합니다."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)
  id: ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: SecurityManager.ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "지정한 증명 정보 및 요청에 따라 될 코드에 부여할 권한을 결정 합니다."
  remarks: "이 메서드 호출의 코드 호출 코드의 id 및 사용 권한 집합에 제공 하는 보안 정책 엔진 요청 합니다. 결과 보안 정책에 의해 결정 됩니다. 이 메서드는 보안 시스템에서 부여 될 사용 권한 집합을 반환 하 고 출력 매개 변수로 거부 될 수 있는 사용 권한 집합을 반환 합니다. 유효 이전에 부여한 사용 권한을의 거부 집합에 없는 부여 된 권한 집합입니다."
  syntax:
    content: public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence, System.Security.PermissionSet reqdPset, System.Security.PermissionSet optPset, System.Security.PermissionSet denyPset, out System.Security.PermissionSet denied);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "증명 정보 집합 정책을 평가 하는 데 사용 합니다."
    - id: reqdPset
      type: System.Security.PermissionSet
      description: "필요한 권한을 코드에서 실행 되어야 합니다."
    - id: optPset
      type: System.Security.PermissionSet
      description: "선택적 권한 부여 하는 경우에 사용 되는 코드를 실행 하려면 필요한는입니다."
    - id: denyPset
      type: System.Security.PermissionSet
      description: "그렇지 않으면 정책에서 허용 하는 경우에 코드에 부여 되지 않아야 거부 된 권한입니다."
    - id: denied
      type: System.Security.PermissionSet
      description: "사용 권한 부여 되지 않은 집합을 포함 하는 출력 매개 변수입니다."
    return:
      type: System.Security.PermissionSet
      description: "보안 시스템으로 부여할 사용 권한 집합입니다."
  overload: System.Security.SecurityManager.ResolvePolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "이 메서드는 코드 액세스 보안 (CA) 정책에서 사용 되지 않는 사용은 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]합니다. .NET Framework의 이전 버전과 호환성을 위해 CAS 정책을 사용 하려면 사용 된 [ &lt;legacyCasPolicy&gt; 요소](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)합니다."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "정책이 실패 하 여 지정 된 최소 필요한 권한을 부여 하는 <code> reqdPset </code> 매개 변수입니다."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)
  id: ResolvePolicyGroups(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolvePolicyGroups(Evidence)
  nameWithType: SecurityManager.ResolvePolicyGroups(Evidence)
  fullName: System.Security.SecurityManager.ResolvePolicyGroups(Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "지정한 증명 정보를 일치 하는 코드 그룹의 컬렉션을 가져옵니다."
  remarks: "이 메서드는 지정 된 정책 구성이 어떤 방식으로 특정 종류의 증명 정보를 분석에 유용 합니다.       코드 그룹 정책 계층 구조 비교의 적용 가능한 모든 수준에서 반환 됩니다는 `evidence` 매개 변수입니다."
  syntax:
    content: public static System.Collections.IEnumerator ResolvePolicyGroups (System.Security.Policy.Evidence evidence);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "증명 정보 집합 정책을 평가 합니다."
    return:
      type: System.Collections.IEnumerator
      description: "증거를 일치 하는 코드 그룹 집합의 열거형입니다."
  overload: System.Security.SecurityManager.ResolvePolicyGroups*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "이 메서드는 코드 액세스 보안 (CA) 정책에서 사용 되지 않는 사용은 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]합니다. .NET Framework의 이전 버전과 호환성을 위해 CAS 정책을 사용 하려면 사용 된 [ &lt;legacyCasPolicy&gt; 요소](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)합니다."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)
  id: ResolveSystemPolicy(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolveSystemPolicy(Evidence)
  nameWithType: SecurityManager.ResolveSystemPolicy(Evidence)
  fullName: System.Security.SecurityManager.ResolveSystemPolicy(Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "지정한 증명 정보에 대 한 정책 제외를 기준으로 코드에 부여할 권한을 결정는 <xref href=&quot;System.AppDomain&quot;> </xref> 수준입니다."
  remarks: "이 메서드는 보안 정책 엔진을 호출 하 고 호출 코드의 id의 증명 정보를 제공 합니다. 결과 제외한 모든 시스템 보안 정책에 의해 결정 <xref:System.AppDomain>정책.</xref:System.AppDomain>"
  syntax:
    content: public static System.Security.PermissionSet ResolveSystemPolicy (System.Security.Policy.Evidence evidence);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "증명 정보 집합 정책을 평가 하는 데 사용 합니다."
    return:
      type: System.Security.PermissionSet
      description: "보안 시스템으로 부여할 수 있는 사용 권한 집합입니다."
  overload: System.Security.SecurityManager.ResolveSystemPolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "이 메서드는 코드 액세스 보안 (CA) 정책에서 사용 되지 않는 사용은 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]합니다. .NET Framework의 이전 버전과 호환성을 위해 CAS 정책을 사용 하려면 사용 된 [ &lt;legacyCasPolicy&gt; 요소](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)합니다."
  platform:
  - net462
- uid: System.Security.SecurityManager.SavePolicy
  id: SavePolicy
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: SavePolicy()
  nameWithType: SecurityManager.SavePolicy()
  fullName: System.Security.SecurityManager.SavePolicy()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "수정 된 보안 정책 상태를 저장합니다."
  remarks: "이 메서드는로 노출 정책을 저장 <xref:System.Security.SecurityManager.PolicyHierarchy%2A>, <xref:System.Security.Policy.PolicyLevel>, 및 기타 보안 정책의 구성을 나타내는 클래스입니다.</xref:System.Security.Policy.PolicyLevel> </xref:System.Security.SecurityManager.PolicyHierarchy%2A> 이 메서드를 호출 하지 않으면 정책 개체에 대 한 변경 내용이 저장 되지 않습니다 및 후속 응용 프로그램 실행에 영향을 주지 않습니다."
  syntax:
    content: public static void SavePolicy ();
    parameters: []
  overload: System.Security.SecurityManager.SavePolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "이 메서드는 코드 액세스 보안 (CA) 정책에서 사용 되지 않는 사용은 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]합니다. .NET Framework의 이전 버전과 호환성을 위해 CAS 정책을 사용 하려면 사용 된 [ &lt;legacyCasPolicy&gt; 요소](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)합니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "이 메서드를 호출 하는 코드에 없는 <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)
  id: SavePolicyLevel(System.Security.Policy.PolicyLevel)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: SavePolicyLevel(PolicyLevel)
  nameWithType: SecurityManager.SavePolicyLevel(PolicyLevel)
  fullName: System.Security.SecurityManager.SavePolicyLevel(PolicyLevel)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "수정 된 보안 정책 수준 <xref:System.Security.SecurityManager.LoadPolicyLevelFromFile*>.</xref:System.Security.SecurityManager.LoadPolicyLevelFromFile*> 로드를 저장 합니다."
  remarks: "<xref:System.Security.Policy.PolicyLevel>로드 된 같은 위치에 저장 됩니다.</xref:System.Security.Policy.PolicyLevel>"
  syntax:
    content: public static void SavePolicyLevel (System.Security.Policy.PolicyLevel level);
    parameters:
    - id: level
      type: System.Security.Policy.PolicyLevel
      description: "저장할 정책 수준 개체입니다."
  overload: System.Security.SecurityManager.SavePolicyLevel*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "이 메서드를 호출 하는 코드에 없는 <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>합니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "이 메서드는 코드 액세스 보안 (CA) 정책에서 사용 되지 않는 사용은 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]합니다. .NET Framework의 이전 버전과 호환성을 위해 CAS 정책을 사용 하려면 사용 된 [ &lt;legacyCasPolicy&gt; 요소](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)합니다."
  platform:
  - net462
- uid: System.Security.SecurityManager.SecurityEnabled
  id: SecurityEnabled
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: SecurityEnabled
  nameWithType: SecurityManager.SecurityEnabled
  fullName: System.Security.SecurityManager.SecurityEnabled
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "보안을 사용할 수 있는지 여부를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "이 속성은 사용 된 [Caspol.exe (코드 액세스 보안 정책 도구)](~/add/includes/ajax-current-ext-md.md) `-security` (`-s`) 코드 기반 보안을 해제 하는 옵션입니다.              SecurityEnabled는 관리자가 코드 액세스 보안을 사용 하지 않도록 설정할 수 있는 방법을 제공 합니다. 코드 액세스 보안을 해제 하면 모든 코드 액세스 요청이 성공 합니다. 모든 코드 부여 효과적으로 `FullTrust`합니다. 코드를 수행할 수 있도록 보안 시스템을 무시 코드 액세스 보안을 해제 하면 해당 하는 보안 정책 부여 보다 조금 더 나은 `FullTrust` 모든 코드입니다. 이 속성은 역할 기반 보안을 비활성화 하지 않습니다. 따라서 <xref:System.Security.Permissions.PrincipalPermission>수요에 영향을 받지 않습니다.</xref:System.Security.Permissions.PrincipalPermission>      > [!CAUTION] > 코드 액세스 보안을 해제 하면 시스템이 공격에 취약해 바이러스나 웜과 같은 악의적 코드를 사용한 합니다. 코드 액세스 보안을 해제 하면 관리 되는 코드의 어떤 방식으로 실행이 자동으로 차단 되지 않습니다. It 부서에서 유일한 원인은 관리 코드가 코드 액세스 보안 시스템에서 제한 없이 실행 및 가장 극단적인 주의 해 서 수행 해야 합니다. 보안 성능을 추가로 얻을을 해제 해야 경우에 수행할 시스템 보안 보호를 위해 수행 된 다른 보안 조치입니다. 다른 보안 예방 조치의 예로 공용 네트워크에 컴퓨터를 물리적으로 보호에서 연결을 끊거나 등에입니다.       이 속성에 대 한 변경 될 때까지 레지스트리 지속 되지 않으므로 <xref:System.Security.SecurityManager.SavePolicy%2A>호출 됩니다.</xref:System.Security.SecurityManager.SavePolicy%2A> 레지스트리에 유지 될 때까지 새 프로세스 변경의 적용 되지 않습니다. 실행 중인 프로세스에서이 속성의 값을 변경 반드시 바뀌지 않습니다 상태 정상적으로. 호출 해야 변경 사항이 적용 되도록 <xref:System.Security.SecurityManager.SavePolicy%2A>새 프로세스를 시작 합니다.</xref:System.Security.SecurityManager.SavePolicy%2A>"
  syntax:
    content: public static bool SecurityEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>보안을 사용 하면 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Security.SecurityManager.SecurityEnabled*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "이 메서드를 호출 하는 코드에 없는 <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>합니다."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Security.Policy.PolicyException
  parent: System.Security.Policy
  isExternal: false
  name: PolicyException
  nameWithType: PolicyException
  fullName: System.Security.Policy.PolicyException
- uid: System.Security.SecurityManager.CheckExecutionRights
  parent: System.Security.SecurityManager
  isExternal: false
  name: CheckExecutionRights
  nameWithType: SecurityManager.CheckExecutionRights
  fullName: System.Security.SecurityManager.CheckExecutionRights
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture
  parent: System.Security.SecurityManager
  isExternal: false
  name: CurrentThreadRequiresSecurityContextCapture()
  nameWithType: SecurityManager.CurrentThreadRequiresSecurityContextCapture()
  fullName: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture()
- uid: System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  isExternal: false
  name: GetStandardSandbox(Evidence)
  nameWithType: SecurityManager.GetStandardSandbox(Evidence)
  fullName: System.Security.SecurityManager.GetStandardSandbox(Evidence)
- uid: System.Security.PermissionSet
  parent: System.Security
  isExternal: false
  name: PermissionSet
  nameWithType: PermissionSet
  fullName: System.Security.PermissionSet
- uid: System.Security.Policy.Evidence
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence
- uid: System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)
  parent: System.Security.SecurityManager
  isExternal: false
  name: GetZoneAndOrigin(ArrayList,ArrayList)
  nameWithType: SecurityManager.GetZoneAndOrigin(ArrayList,ArrayList)
  fullName: System.Security.SecurityManager.GetZoneAndOrigin(ArrayList,ArrayList)
- uid: System.Collections.ArrayList
  parent: System.Collections
  isExternal: false
  name: ArrayList
  nameWithType: ArrayList
  fullName: System.Collections.ArrayList
- uid: System.Security.SecurityManager.IsGranted(System.Security.IPermission)
  parent: System.Security.SecurityManager
  isExternal: false
  name: IsGranted(IPermission)
  nameWithType: SecurityManager.IsGranted(IPermission)
  fullName: System.Security.SecurityManager.IsGranted(IPermission)
- uid: System.Security.IPermission
  parent: System.Security
  isExternal: false
  name: IPermission
  nameWithType: IPermission
  fullName: System.Security.IPermission
- uid: System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)
  parent: System.Security.SecurityManager
  isExternal: false
  name: LoadPolicyLevelFromFile(String,PolicyLevelType)
  nameWithType: SecurityManager.LoadPolicyLevelFromFile(String,PolicyLevelType)
  fullName: System.Security.SecurityManager.LoadPolicyLevelFromFile(String,PolicyLevelType)
- uid: System.Security.Policy.PolicyLevel
  parent: System.Security.Policy
  isExternal: false
  name: PolicyLevel
  nameWithType: PolicyLevel
  fullName: System.Security.Policy.PolicyLevel
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Security.PolicyLevelType
  parent: System.Security
  isExternal: false
  name: PolicyLevelType
  nameWithType: PolicyLevelType
  fullName: System.Security.PolicyLevelType
- uid: System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)
  parent: System.Security.SecurityManager
  isExternal: false
  name: LoadPolicyLevelFromString(String,PolicyLevelType)
  nameWithType: SecurityManager.LoadPolicyLevelFromString(String,PolicyLevelType)
  fullName: System.Security.SecurityManager.LoadPolicyLevelFromString(String,PolicyLevelType)
- uid: System.Security.SecurityManager.PolicyHierarchy
  parent: System.Security.SecurityManager
  isExternal: false
  name: PolicyHierarchy()
  nameWithType: SecurityManager.PolicyHierarchy()
  fullName: System.Security.SecurityManager.PolicyHierarchy()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicy(Evidence)
  nameWithType: SecurityManager.ResolvePolicy(Evidence)
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence)
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicy(Evidence[])
  nameWithType: SecurityManager.ResolvePolicy(Evidence[])
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence[])
- uid: System.Security.Policy.Evidence[]
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence[]
  spec.csharp:
  - uid: System.Security.Policy.Evidence
    name: Evidence
    nameWithType: Evidence
    fullName: Evidence[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: SecurityManager.ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
- uid: System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicyGroups(Evidence)
  nameWithType: SecurityManager.ResolvePolicyGroups(Evidence)
  fullName: System.Security.SecurityManager.ResolvePolicyGroups(Evidence)
- uid: System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolveSystemPolicy(Evidence)
  nameWithType: SecurityManager.ResolveSystemPolicy(Evidence)
  fullName: System.Security.SecurityManager.ResolveSystemPolicy(Evidence)
- uid: System.Security.SecurityManager.SavePolicy
  parent: System.Security.SecurityManager
  isExternal: false
  name: SavePolicy()
  nameWithType: SecurityManager.SavePolicy()
  fullName: System.Security.SecurityManager.SavePolicy()
- uid: System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)
  parent: System.Security.SecurityManager
  isExternal: false
  name: SavePolicyLevel(PolicyLevel)
  nameWithType: SecurityManager.SavePolicyLevel(PolicyLevel)
  fullName: System.Security.SecurityManager.SavePolicyLevel(PolicyLevel)
- uid: System.Security.SecurityManager.SecurityEnabled
  parent: System.Security.SecurityManager
  isExternal: false
  name: SecurityEnabled
  nameWithType: SecurityManager.SecurityEnabled
  fullName: System.Security.SecurityManager.SecurityEnabled
- uid: System.Security.SecurityManager.CheckExecutionRights*
  parent: System.Security.SecurityManager
  isExternal: false
  name: CheckExecutionRights
  nameWithType: SecurityManager.CheckExecutionRights
- uid: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture*
  parent: System.Security.SecurityManager
  isExternal: false
  name: CurrentThreadRequiresSecurityContextCapture
  nameWithType: SecurityManager.CurrentThreadRequiresSecurityContextCapture
- uid: System.Security.SecurityManager.GetStandardSandbox*
  parent: System.Security.SecurityManager
  isExternal: false
  name: GetStandardSandbox
  nameWithType: SecurityManager.GetStandardSandbox
- uid: System.Security.SecurityManager.GetZoneAndOrigin*
  parent: System.Security.SecurityManager
  isExternal: false
  name: GetZoneAndOrigin
  nameWithType: SecurityManager.GetZoneAndOrigin
- uid: System.Security.SecurityManager.IsGranted*
  parent: System.Security.SecurityManager
  isExternal: false
  name: IsGranted
  nameWithType: SecurityManager.IsGranted
- uid: System.Security.SecurityManager.LoadPolicyLevelFromFile*
  parent: System.Security.SecurityManager
  isExternal: false
  name: LoadPolicyLevelFromFile
  nameWithType: SecurityManager.LoadPolicyLevelFromFile
- uid: System.Security.SecurityManager.LoadPolicyLevelFromString*
  parent: System.Security.SecurityManager
  isExternal: false
  name: LoadPolicyLevelFromString
  nameWithType: SecurityManager.LoadPolicyLevelFromString
- uid: System.Security.SecurityManager.PolicyHierarchy*
  parent: System.Security.SecurityManager
  isExternal: false
  name: PolicyHierarchy
  nameWithType: SecurityManager.PolicyHierarchy
- uid: System.Security.SecurityManager.ResolvePolicy*
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicy
  nameWithType: SecurityManager.ResolvePolicy
- uid: System.Security.SecurityManager.ResolvePolicyGroups*
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicyGroups
  nameWithType: SecurityManager.ResolvePolicyGroups
- uid: System.Security.SecurityManager.ResolveSystemPolicy*
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolveSystemPolicy
  nameWithType: SecurityManager.ResolveSystemPolicy
- uid: System.Security.SecurityManager.SavePolicy*
  parent: System.Security.SecurityManager
  isExternal: false
  name: SavePolicy
  nameWithType: SecurityManager.SavePolicy
- uid: System.Security.SecurityManager.SavePolicyLevel*
  parent: System.Security.SecurityManager
  isExternal: false
  name: SavePolicyLevel
  nameWithType: SecurityManager.SavePolicyLevel
- uid: System.Security.SecurityManager.SecurityEnabled*
  parent: System.Security.SecurityManager
  isExternal: false
  name: SecurityEnabled
  nameWithType: SecurityManager.SecurityEnabled
