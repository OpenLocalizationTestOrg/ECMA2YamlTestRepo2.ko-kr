### YamlMime:ManagedReference
items:
- uid: System.Runtime.Remoting.RemotingServices
  id: RemotingServices
  children:
  - System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)
  - System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)
  - System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  - System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  - System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)
  - System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)
  - System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  - System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  - System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)
  - System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)
  - System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)
  - System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)
  - System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)
  - System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)
  - System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)
  - System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  - System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)
  - System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  langs:
  - csharp
  name: RemotingServices
  nameWithType: RemotingServices
  fullName: System.Runtime.Remoting.RemotingServices
  type: Class
  summary: "사용 하 고 원격 개체와 프록시를 게시 하기 위한 여러 가지 방법을 제공 합니다. 이 클래스는 상속 될 수 없습니다."
  remarks: "정품 인증, 수명 관리 또는 transactions와 같은 문제를 다루는 서비스 공급자 인 경우 하지 않는 한 프록시 참조 한 개체 참조를 구분할 필요가 없습니다. 원격 인프라는 원격 개체는 클라이언트의 공간에 상주 하는 것 처럼 보일 투명 프록시를 사용 합니다. 프록시는 원격 위치의 실제 개체에에 대 한 호출을 전달 하 여이 작업을 수행 합니다."
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public static class RemotingServices
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)
  id: Connect(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Connect(Type,String)
  nameWithType: RemotingServices.Connect(Type,String)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "지정 된 잘 알려진 개체에 대 한 프록시를 만듭니다는 <xref:System.Type>및 URL.</xref:System.Type>"
  remarks: "반환 된 프록시 개체는 지정된 된 잘 알려진 개체에서 끝점을 가리킵니다. 프록시에는 메서드를 호출할 때까지 메시지가 네트워크를 통해 전송 됩니다."
  example:
  - "The following code example demonstrates how to use the Connect method to create a proxy to a well-known object.  \n  \n [!code-cpp[RemotingServices.BasicSample#1](~/add/codesnippet/cpp/m-system.runtime.remotin_104_1.cpp)]\n [!code-cs[RemotingServices.BasicSample#1](~/add/codesnippet/csharp/m-system.runtime.remotin_104_1.cs)]\n [!code-vb[RemotingServices.BasicSample#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_104_1.vb)]"
  syntax:
    content: public static object Connect (Type classToProxy, string url);
    parameters:
    - id: classToProxy
      type: System.Type
      description: "<xref:System.Type>연결 하려는 서버 쪽에 잘 알려진 개체의.</xref:System.Type>"
    - id: url
      type: System.String
      description: "서버 클래스의 URL입니다."
    return:
      type: System.Object
      description: "원격 개체에 지정 된 잘 알려진 개체에서 제공 하는 끝점을 가리키는 프록시입니다."
  overload: System.Runtime.Remoting.RemotingServices.Connect*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "직접 실행 호출자 원격 형식 및 채널을 구성할 수 있는 권한이 없는 합니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)
  id: Connect(System.Type,System.String,System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Connect(Type,String,Object)
  nameWithType: RemotingServices.Connect(Type,String,Object)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "지정 된 잘 알려진 개체에 대 한 프록시를 만듭니다는 <xref:System.Type>, URL 및 채널 관련 데이터로.</xref:System.Type>"
  remarks: "반환 된 프록시 개체는 지정된 된 잘 알려진 개체에서 끝점을 가리킵니다. 프록시에는 메서드를 호출할 때까지 메시지가 네트워크를 통해 전송 됩니다.       `data` 개체는 채널에 대 한 정보를 전달 하는 데 사용 되 고 전달 되는 <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=fullName>메서드.</xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=fullName>"
  syntax:
    content: public static object Connect (Type classToProxy, string url, object data);
    parameters:
    - id: classToProxy
      type: System.Type
      description: "<xref:System.Type>연결 하려는 잘 알려진 개체의.</xref:System.Type>"
    - id: url
      type: System.String
      description: "잘 알려진 개체의 URL입니다."
    - id: data
      type: System.Object
      description: "특정 데이터 채널입니다. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "요청된 된 잘 알려진 개체에서 제공 되는 끝점을 가리키는 프록시입니다."
  overload: System.Runtime.Remoting.RemotingServices.Connect*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "직접 실행 호출자 원격 형식 및 채널을 구성할 수 있는 권한이 없는 합니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)
  id: Disconnect(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Disconnect(MarshalByRefObject)
  nameWithType: RemotingServices.Disconnect(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Disconnect(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "등록된 된 원격 채널을 통해 메시지를 더 이상 받을 개체를 중지 합니다."
  remarks: ''
  example:
  - "The following code example demonstrates how to use the Disconnect method to disconnect an object from the remoting channels.  \n  \n [!code-cpp[RemotingServices.BasicSample#2](~/add/codesnippet/cpp/m-system.runtime.remotin_81_1.cpp)]\n [!code-cs[RemotingServices.BasicSample#2](~/add/codesnippet/csharp/m-system.runtime.remotin_81_1.cs)]\n [!code-vb[RemotingServices.BasicSample#2](~/add/codesnippet/visualbasic/m-system.runtime.remotin_81_1.vb)]"
  syntax:
    content: public static bool Disconnect (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "채널에서 연결을 끊으려면 개체입니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>개체가 등록된 된 원격 채널에서 성공적으로 끊어진 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Runtime.Remoting.RemotingServices.Disconnect*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>obj</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> obj </code> 매개 변수는 프록시입니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "직접 실행 호출자 원격 형식 및 채널을 구성할 수 있는 권한이 없는 합니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  id: ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  nameWithType: RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  fullName: System.Runtime.Remoting.RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "지정된 된 원격 개체에 연결 하 고 제공 된 실행 <xref href=&quot;System.Runtime.Remoting.Messaging.IMethodCallMessage&quot;> </xref> 에 있습니다."
  remarks: "현재 메서드는 다른, 가능 하면 원격 개체에 지정 된 메서드 호출을 전달 하는 서버에서 특별 한 경우에 사용 됩니다. 이 메서드는 호출자가 적절 한 컨텍스트에 있는 경우에 호출할 수 있습니다."
  example:
  - "The following code example demonstrates how to use the ExecuteMessage method to forward method calls to remote objects.  \n  \n [!code-cs[RemotingServices.ExecuteMessage#1](~/add/codesnippet/csharp/491f5c62-582d-42d8-b526-_1.cs)]\n [!code-cpp[RemotingServices.ExecuteMessage#1](~/add/codesnippet/cpp/491f5c62-582d-42d8-b526-_1.cpp)]\n [!code-vb[RemotingServices.ExecuteMessage#1](~/add/codesnippet/visualbasic/491f5c62-582d-42d8-b526-_1.vb)]"
  syntax:
    content: public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);
    parameters:
    - id: target
      type: System.MarshalByRefObject
      description: "원격 개체 메서드를 호출 하려는입니다."
    - id: reqMsg
      type: System.Runtime.Remoting.Messaging.IMethodCallMessage
      description: "지정된 된 원격 개체의 메서드에 메서드 호출 메시지입니다."
    return:
      type: System.Runtime.Remoting.Messaging.IMethodReturnMessage
      description: "원격 방법의 응답입니다."
  overload: System.Runtime.Remoting.RemotingServices.ExecuteMessage*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "직접 실행 호출자를 인프라 수 있는 권한이 없습니다."
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "메서드는 개체의 네이티브 컨텍스트 이외의 컨텍스트에서 호출 되었습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)
  id: GetEnvoyChainForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetEnvoyChainForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "지정된 된 프록시를 나타내는 원격 개체에 메시지를 보낼 때 사용 해야 하는 엔보이 싱크 체인을 반환 합니다."
  remarks: "엔보이 싱크는와 함께 보내는 싱크는 <xref:System.Runtime.Remoting.ObjRef>메시지 해당 개체를 반환할 때 사용 되는 개체입니다.</xref:System.Runtime.Remoting.ObjRef> 현재 메서드는 개체의 프록시 및 개체 자체 간의 통신 중에 사용 되는 엔보이 싱크를 반환 합니다."
  syntax:
    content: public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "엔보이 싱크를 요청 하는 원격 개체의 프록시 연관 됩니다."
    return:
      type: System.Runtime.Remoting.Messaging.IMessageSink
      description: "지정된 된 프록시 연관 엔보이 싱크 체인입니다."
  overload: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "직접 실행 호출자를 인프라 수 있는 권한이 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)
  id: GetLifetimeService(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetLifetimeService(MarshalByRefObject)
  nameWithType: RemotingServices.GetLifetimeService(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetLifetimeService(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "지정된 된 개체의 수명 정책을 제어 하는 수명이 서비스 개체를 반환 합니다."
  remarks: "기본값에 대 한 수명 서비스는 반환 된 개체 형식의 <xref:System.Runtime.Remoting.Lifetime.ILease>.</xref:System.Runtime.Remoting.Lifetime.ILease> 개체 수 있습니다. 경우는 `obj` 매개 변수는 `null`, 메서드가 반환 `null`합니다."
  example:
  - "The following code example demonstrates how to use the GetLifetimeService method to get a lifetime lease for the specified object.  \n  \n [!code-cpp[RemotingServices.TimerSample#1](~/add/codesnippet/cpp/a7d2891c-3dad-448c-949c-_1.cpp)]\n [!code-cs[RemotingServices.TimerSample#1](~/add/codesnippet/csharp/a7d2891c-3dad-448c-949c-_1.cs)]\n [!code-vb[RemotingServices.TimerSample#1](~/add/codesnippet/visualbasic/a7d2891c-3dad-448c-949c-_1.vb)]  \n  \n To compile and run this example, you will need to compile and run a server, timerserver.exe, and compile a shared library, timerservice.dll.  \n  \n The source for timerserver.exe follows:  \n  \n [!code-vb[RemotingServices.TimerSample#2](~/add/codesnippet/visualbasic/a7d2891c-3dad-448c-949c-_2.vb)]\n [!code-cs[RemotingServices.TimerSample#2](~/add/codesnippet/csharp/a7d2891c-3dad-448c-949c-_2.cs)]  \n  \n The source for timerservice.dll follows:  \n  \n [!code-vb[RemotingServices.TimerSample#3](~/add/codesnippet/visualbasic/a7d2891c-3dad-448c-949c-_3.vb)]\n [!code-cs[RemotingServices.TimerSample#3](~/add/codesnippet/csharp/a7d2891c-3dad-448c-949c-_3.cs)]"
  syntax:
    content: public static object GetLifetimeService (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "에 대 한 수명 서비스를 가져올 개체입니다."
    return:
      type: System.Object
      description: "수명을 제어 하는 개체 <code> obj </code>합니다."
  overload: System.Runtime.Remoting.RemotingServices.GetLifetimeService*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "직접 실행 호출자를 인프라 수 있는 권한이 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  id: GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetMethodBaseFromMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "기본 메서드를 반환 된 주어진 <xref href=&quot;System.Runtime.Remoting.Messaging.IMethodMessage&quot;> </xref>합니다."
  remarks: "기본 메서드를 결정는 <xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>, <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>, 및 <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A>의 속성 <xref:System.Runtime.Remoting.Messaging.IMethodMessage>및 구현 하는 클래스에서 사용 되는 <xref:System.Runtime.Remoting.Messaging.IMethodMessage>인터페이스.</xref:System.Runtime.Remoting.Messaging.IMethodMessage> </xref:System.Runtime.Remoting.Messaging.IMethodMessage> </xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> </xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A> </xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A> 소비자가 <xref:System.Runtime.Remoting.Messaging.IMethodMessage>클래스를 참조 해야는 <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=fullName>속성.</xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=fullName> </xref:System.Runtime.Remoting.Messaging.IMethodMessage>"
  syntax:
    content: public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);
    parameters:
    - id: msg
      type: System.Runtime.Remoting.Messaging.IMethodMessage
      description: "기본 메서드를 추출 하는 메서드 메시지입니다."
    return:
      type: System.Reflection.MethodBase
      description: "메서드 기본에서 추출 된 <code> msg </code> 매개 변수입니다."
  overload: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "직접 실행 호출자 인프라 권한이 없는 또는 public이 아닌 멤버의 형식 정보를 검색할 수 있는 권한이 없는 호출 스택의 상위 호출자 중 하나 이상 있습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetObjectData(Object,SerializationInfo,StreamingContext)
  nameWithType: RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "제공 된에 참조 방식 개체에서 지정 된 마샬링 serialize <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>합니다."
  syntax:
    content: public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: obj
      type: System.Object
      description: "직렬화 할 개체입니다."
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> 개체를 직렬화 할 대상으로 합니다."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "소스 및 직렬화 대상입니다."
  overload: System.Runtime.Remoting.RemotingServices.GetObjectData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>obj</code> or <code>info</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "직접 실행 호출자를 인프라 수 있는 권한이 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)
  id: GetObjectUri(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetObjectUri(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjectUri(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectUri(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "지정된 된 개체에 대 한 URI를 검색합니다."
  remarks: ''
  example:
  - >-
    [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/add/codesnippet/visualbasic/318892c3-7b62-40bd-9e3b-_1.vb)]
     [!code-cs[System.Runtime.Remoting.RemotingServices#18](~/add/codesnippet/csharp/318892c3-7b62-40bd-9e3b-_1.cs)]
     [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/add/codesnippet/cpp/318892c3-7b62-40bd-9e3b-_1.cpp)]
  syntax:
    content: public static string GetObjectUri (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "<xref href=&quot;System.MarshalByRefObject&quot;> </xref> URI를 요청에 대 한 합니다."
    return:
      type: System.String
      description: "있는 경우 지정된 된 개체의 URI 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 개체가 아직 마샬링되지 않은 경우."
  overload: System.Runtime.Remoting.RemotingServices.GetObjectUri*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "직접 실행 호출자를 인프라 수 있는 권한이 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)
  id: GetObjRefForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetObjRefForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjRefForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "반환 된 <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> 에서 지정된 된 프록시는 원격 개체를 나타내는입니다."
  remarks: "A <xref:System.Runtime.Remoting.ObjRef>응용 프로그램 도메인 경계를 넘어 개체 참조를 전송 하는 데 사용 되는 개체의 직렬화 가능 표현인.</xref:System.Runtime.Remoting.ObjRef> 만들기는 <xref:System.Runtime.Remoting.ObjRef>마샬링 라고 개체에 대 한.</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>채널을 통해 다른 응용 프로그램 도메인에 전송할 수 있습니다 (수에 다른 프로세스 또는 컴퓨터).</xref:System.Runtime.Remoting.ObjRef> 다른 응용 프로그램 도메인에서 한 번의 <xref:System.Runtime.Remoting.ObjRef>일반적으로 실제 개체에 연결 하는 개체에 대 한 프록시를 만드는 구문 분석 되어야 합니다.</xref:System.Runtime.Remoting.ObjRef> 이 작업을 역마샬링 라고 합니다. 역마샬링 동안는 <xref:System.Runtime.Remoting.ObjRef>원격 개체와 투명 프록시 개체의 메서드 정보를 추출 하는 구문 분석 하 고 <xref:System.Runtime.Remoting.Proxies.RealProxy>개체가 만들어집니다.</xref:System.Runtime.Remoting.Proxies.RealProxy> </xref:System.Runtime.Remoting.ObjRef>       A <xref:System.Runtime.Remoting.ObjRef>설명 하는 정보가 포함 된 <xref:System.Type>는 마샬링하는 개체의 클래스, 특정 개체 인스턴스 및 통신을 고유 하 게 식별 하는 URI 관련 개체가 있는 원격 응용 프로그램에 도달 하는 방법에 대 한 정보 및.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>"
  example:
  - "The following code example demonstrates how to get a <xref:System.Runtime.Remoting.ObjRef> instance for the specified object.  \n  \n [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/add/codesnippet/cpp/d6ce9a9a-8ec9-4559-9b2d-_1.cpp)]\n [!code-vb[RemotingServices.GetObjRefForProxy#1](~/add/codesnippet/visualbasic/d6ce9a9a-8ec9-4559-9b2d-_1.vb)]\n [!code-cs[RemotingServices.GetObjRefForProxy#1](~/add/codesnippet/csharp/d6ce9a9a-8ec9-4559-9b2d-_1.cs)]"
  syntax:
    content: public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "만들려는 개체에 연결 되어 있는 프록시는 <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> 에 대 한 합니다."
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "A <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> 지정된 된 프록시를 연결할 원격 개체를 나타내는 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 개체 또는 프록시 마샬링되지 않은 한 경우."
  overload: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "직접 실행 호출자를 인프라 수 있는 권한이 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)
  id: GetRealProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetRealProxy(Object)
  nameWithType: RemotingServices.GetRealProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.GetRealProxy(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "지정 된 투명 프록시를 지 원하는 실제 프록시를 반환 합니다."
  remarks: "모든 종류의 원격 경계에서 개체를 사용 하는 클라이언트 투명 프록시를 사용 하 여 개체에 대 한 실제로 됩니다. 투명 프록시 실제 개체가 있는 클라이언트의 공간에는 느낄을 수 있습니다. 에 원격 인프라를 사용 하 여 실제 개체에 대 한 호출을 전달 하 여 얻습니다.       투명 프록시 <xref:System.Runtime.Remoting.Proxies.RealProxy>.</xref:System.Runtime.Remoting.Proxies.RealProxy> 형식의 관리 되는 런타임 클래스의 인스턴스에 의해 지원 됩니다. <xref:System.Runtime.Remoting.Proxies.RealProxy>투명 프록시에서 작업을 전달 하는 데 필요한 기능 중 일부를 구현 합니다.</xref:System.Runtime.Remoting.Proxies.RealProxy>       프록시 개체는 가비지 수집, 멤버 및 방법에 대 한 지원 등의 관리 되는 개체의 관련된 의미를 상속 하 고 클래스를 만들기 위해 새 확장 될 수 있습니다. 프록시 역할을 원격 개체 (투명 프록시)와 같은 클래스의 개체 및 관리 되는 개체 이기도 합니다."
  syntax:
    content: public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);
    parameters:
    - id: proxy
      type: System.Object
      description: "투명 프록시입니다."
    return:
      type: System.Runtime.Remoting.Proxies.RealProxy
      description: "투명 프록시를 지 원하는 실제 프록시 인스턴스."
  overload: System.Runtime.Remoting.RemotingServices.GetRealProxy*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "직접 실행 호출자를 인프라 수 있는 권한이 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)
  id: GetServerTypeForUri(System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetServerTypeForUri(String)
  nameWithType: RemotingServices.GetServerTypeForUri(String)
  fullName: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "반환 된 <xref:System.Type>URI가 지정된 된 개체의.</xref:System.Type>"
  remarks: "Uri를 사용 하는 끝점을 식별 하는 원격 작업, GetServerTypeForUri 메서드를 사용 하는 플러그형 원격 인프라 (예: 채널 싱크, 동적 싱크 및 컨텍스트 싱크) 일부에 매우 유용 <xref:System.Runtime.Remoting.Messaging.IMessage>개체를 현재 메서드를 URI에서 연결 된 형식 개체를 반환 합니다.</xref:System.Runtime.Remoting.Messaging.IMessage>"
  example:
  - >-
    [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/add/codesnippet/visualbasic/m-system.runtime.remotin_84_1.vb)]
     [!code-cs[System.Runtime.Remoting.RemotingServices#7](~/add/codesnippet/csharp/m-system.runtime.remotin_84_1.cs)]
     [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/add/codesnippet/cpp/m-system.runtime.remotin_84_1.cpp)]
  syntax:
    content: public static Type GetServerTypeForUri (string URI);
    parameters:
    - id: URI
      type: System.String
      description: "개체의 URI 인 <xref:System.Type>요청.</xref:System.Type>"
    return:
      type: System.Type
      description: "<xref:System.Type>URI가 지정된 된 개체의.</xref:System.Type>"
  overload: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "직접 실행 호출자 인프라 권한이 없는 또는 public이 아닌 멤버의 형식 정보를 검색할 수 있는 권한이 없는 호출 스택의 상위 호출자 중 하나 이상 있습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  id: GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetSessionIdForMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "메시지에 대 한 세션 ID를 검색합니다."
  remarks: "동일한 세션 ID는 동일한 응용 프로그램의 개체에 대해 반환 될 수 있습니다 하지만이 메서드는 다른 원격 응용 프로그램에서 두 개체에 대해 동일한 세션 ID를 반환 하지 않습니다.       세션 및 세션 Id 식별 하는 방법에 대 한 자세한 내용은 참조 ASP.Net [ASP.NET 세션 상태 개요](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following code example demonstrates how to get the session ID string for the current session.  \n  \n [!code-cs[RemotingServices.ExecuteMessage#1](~/add/codesnippet/csharp/b83444fc-48c3-47e9-b264-_1.cs)]\n [!code-cpp[RemotingServices.ExecuteMessage#1](~/add/codesnippet/cpp/b83444fc-48c3-47e9-b264-_1.cpp)]\n [!code-vb[RemotingServices.ExecuteMessage#1](~/add/codesnippet/visualbasic/b83444fc-48c3-47e9-b264-_1.vb)]"
  syntax:
    content: public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);
    parameters:
    - id: msg
      type: System.Runtime.Remoting.Messaging.IMethodMessage
      description: "<xref href=&quot;System.Runtime.Remoting.Messaging.IMethodMessage&quot;> </xref> 세션 ID를 요청에 대 한 합니다."
    return:
      type: System.String
      description: "현재 세션을 고유 하 게 식별 하는 세션 ID 문자열입니다."
  overload: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "직접 실행 호출자를 인프라 수 있는 권한이 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  id: IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsMethodOverloaded(IMethodMessage)
  nameWithType: RemotingServices.IsMethodOverloaded(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(IMethodMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "지정된 된 메시지의 메서드는 오버 로드 여부를 나타내는 부울 값을 반환 합니다."
  syntax:
    content: public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);
    parameters:
    - id: msg
      type: System.Runtime.Remoting.Messaging.IMethodMessage
      description: "해당 메서드에 대 한 호출을 포함 하는 메시지입니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>메서드가 호출 <code> msg </code> 그렇지 않으면 오버 로드 된 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "직접 실행 호출자를 인프라 수 있는 권한이 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)
  id: IsObjectOutOfAppDomain(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsObjectOutOfAppDomain(Object)
  nameWithType: RemotingServices.IsObjectOutOfAppDomain(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "지정 된 투명 프록시에 의해 지정 된 개체가 현재 메서드를 호출 하는 개체와는 다른 응용 프로그램 도메인에 포함 되는지 여부를 나타내는 부울 값을 반환 합니다."
  remarks: "응용 프로그램 도메인에 대 한 정보를 참조 하십시오. [응용 프로그램 도메인](http://msdn.microsoft.com/en-us/39e57d07-a740-4cd4-ae82-e119ea3856c1)합니다."
  example:
  - >-
    [!code-cpp[RemotingServices IsObject Snippets#1](~/add/codesnippet/cpp/m-system.runtime.remotin_103_1.cpp)]
     [!code-vb[RemotingServices IsObject Snippets#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_103_1.vb)]
     [!code-cs[RemotingServices IsObject Snippets#1](~/add/codesnippet/csharp/m-system.runtime.remotin_103_1.cs)]
  syntax:
    content: public static bool IsObjectOutOfAppDomain (object tp);
    parameters:
    - id: tp
      type: System.Object
      description: "검사할 개체입니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>개체가 현재 응용 프로그램 도메인; 부족 한 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)
  id: IsObjectOutOfContext(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsObjectOutOfContext(Object)
  nameWithType: RemotingServices.IsObjectOutOfContext(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "개체가 지정 된 프록시를 나타내는 현재 메서드를 호출한 개체가 아닌 다른 컨텍스트에 포함 되는지 여부를 나타내는 부울 값을 반환 합니다."
  remarks: "컨텍스트는 한 일련의 내부에 상주 하는 개체에 대 한 환경을 정의 하는 속성입니다. 컨텍스트는 자동 서비스 이러한 동기화, 트랜잭션, 적시에 정품 인증, 보안, 및 등을 요구 하도록 구성 하는 개체에 대 한 정품 인증 과정 중에 만들어집니다. 여러 개체는 컨텍스트 내에 있을 수 있습니다."
  example:
  - >-
    [!code-cpp[RemotingServices IsObject Snippets#1](~/add/codesnippet/cpp/m-system.runtime.remotin_37_1.cpp)]
     [!code-vb[RemotingServices IsObject Snippets#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_37_1.vb)]
     [!code-cs[RemotingServices IsObject Snippets#1](~/add/codesnippet/csharp/m-system.runtime.remotin_37_1.cs)]
  syntax:
    content: public static bool IsObjectOutOfContext (object tp);
    parameters:
    - id: tp
      type: System.Object
      description: "검사할 개체입니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>개체를 현재 컨텍스트를 벗어나는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)
  id: IsOneWay(System.Reflection.MethodBase)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsOneWay(MethodBase)
  nameWithType: RemotingServices.IsOneWay(MethodBase)
  fullName: System.Runtime.Remoting.RemotingServices.IsOneWay(MethodBase)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "메서드 실행을 계속 하기 전에 처리를 완료 하려면 서버에 대 한 지정된 된 메시지를 기다리고 메서드를 호출한 클라이언트에 지정 되었는지 여부를 나타내는 부울 값을 반환 합니다."
  remarks: "단방향 메서드를 호출 하는 경우에 메시지 처리를 완료 하려면 서버에 대 한 클라이언트 기다리지 않습니다. 클라이언트 메서드는 서버에서 메시지를 처리 했습니다. 여부의 정보가 전혀 없는 응용 프로그램에 반환 합니다. 메서드는 <xref:System.Runtime.Remoting.Messaging.OneWayAttribute>.</xref:System.Runtime.Remoting.Messaging.OneWayAttribute> 를 사용 하 여 한 가지 방법으로 표시       단방향 메서드는 반환 값 또는 out 매개 변수를 가질 수 없습니다."
  example:
  - >-
    [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/add/codesnippet/visualbasic/e9c4a9fc-d92a-4e43-97a5-_1.vb)]
     [!code-cs[System.Runtime.Remoting.RemotingServices#2](~/add/codesnippet/csharp/e9c4a9fc-d92a-4e43-97a5-_1.cs)]
     [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/add/codesnippet/cpp/e9c4a9fc-d92a-4e43-97a5-_1.cpp)]
  syntax:
    content: public static bool IsOneWay (System.Reflection.MethodBase method);
    parameters:
    - id: method
      type: System.Reflection.MethodBase
      description: "해당 하는 메서드."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>방법이 한 가지 방법은; 인 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Runtime.Remoting.RemotingServices.IsOneWay*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "직접 실행 호출자를 인프라 수 있는 권한이 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)
  id: IsTransparentProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsTransparentProxy(Object)
  nameWithType: RemotingServices.IsTransparentProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "지정된 된 개체는 투명 프록시 또는 실제 개체 인지 여부를 나타내는 부울 값을 반환 합니다."
  remarks: "모든 종류의 원격 경계에서 개체를 사용 하는 클라이언트 투명 프록시를 사용 하 여 개체에 대 한 실제로 됩니다. 투명 프록시 실제 개체가 있는 클라이언트의 공간에는 느낄을 수 있습니다. 에 원격 인프라를 사용 하 여 실제 개체에 대 한 호출을 전달 하 여 얻습니다.       투명 프록시는 자체 관리 <xref:System.Runtime.Remoting.Proxies.RealProxy>.</xref:System.Runtime.Remoting.Proxies.RealProxy> 형식의 관리 되는 런타임 클래스의 인스턴스 <xref:System.Runtime.Remoting.Proxies.RealProxy>투명 프록시에서 작업을 전달 하는 데 필요한 기능 중 일부를 구현 합니다.</xref:System.Runtime.Remoting.Proxies.RealProxy> 프록시 개체는 가비지 수집, 멤버 및 방법에 대 한 지원 등의 관리 되는 개체의 관련된 의미를 상속 하 고 클래스를 만들기 위해 새 확장 될 수 있습니다. 따라서 프록시에는 이중 특성이 있습니다. 반면에 원격 개체 (투명 프록시)와 같은 클래스의 개체 역할을 해야 하 고 다른 개체인 경우 관리 되는 자체입니다.       프록시 개체에 <xref:System.AppDomain>.</xref:System.AppDomain> 내 원격 창 나누기에 관계 없이 사용할 수 있습니다. 응용 프로그램 프록시 참조 한 개체 참조를 구분 하지 않습니다 필요 합니다. 그러나 활성화 등의 문제를 다룰 서비스 공급자 수명 관리 및 트랜잭션 해야 차이점을 확인 합니다."
  example:
  - "The following code example demonstrates the use of the IsTransparentProxy method to determine whether an object is a proxy or a real object. For the complete example code, see the example for the <xref:System.Runtime.Remoting.Messaging.AsyncResult> class.  \n  \n [!code-cpp[AsyncResult.NewExamples#6](~/add/codesnippet/cpp/m-system.runtime.remotin_47_1.cpp)]\n [!code-vb[AsyncResult.NewExamples#6](~/add/codesnippet/visualbasic/m-system.runtime.remotin_47_1.vb)]\n [!code-cs[AsyncResult.NewExamples#6](~/add/codesnippet/csharp/m-system.runtime.remotin_47_1.cs)]"
  syntax:
    content: public static bool IsTransparentProxy (object proxy);
    parameters:
    - id: proxy
      type: System.Object
      description: "확인할 개체에 대 한 참조입니다."
    return:
      type: System.Boolean
      description: "에 지정 된 개체가 있는지 여부를 나타내는 부울 값은 <code> proxy </code> 매개 변수는 투명 프록시 또는 실제 개체입니다."
  overload: System.Runtime.Remoting.RemotingServices.IsTransparentProxy*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)
  id: LogRemotingStage(System.Int32)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: LogRemotingStage(Int32)
  nameWithType: RemotingServices.LogRemotingStage(Int32)
  fullName: System.Runtime.Remoting.RemotingServices.LogRemotingStage(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "외부 디버거에 원격 교환의 스테이지를 기록합니다."
  remarks: "A `&quot;REMOTING_PERF&quot;` 전처리 기호를 사용 하 여 메서드에 적용 되는 <xref:System.Diagnostics.ConditionalAttribute>특성.</xref:System.Diagnostics.ConditionalAttribute>"
  syntax:
    content: public static void LogRemotingStage (int stage);
    parameters:
    - id: stage
      type: System.Int32
      description: "원격 교환의 단계를 식별 하는 내부적으로 정의 된 상수입니다."
  overload: System.Runtime.Remoting.RemotingServices.LogRemotingStage*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)
  id: Marshal(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Marshal(MarshalByRefObject)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "사용 된 <xref href=&quot;System.MarshalByRefObject&quot;> </xref>, 원격 인프라를 등록 하 고의 인스턴스로 변환는 <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> 클래스입니다."
  remarks: "A <xref:System.Runtime.Remoting.ObjRef>응용 프로그램 도메인 경계를 넘어 개체 참조를 전송 하는 데 사용 되는 개체의 직렬화 가능 표현인.</xref:System.Runtime.Remoting.ObjRef> 만들기는 <xref:System.Runtime.Remoting.ObjRef>마샬링 라고 개체에 대 한.</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>채널을 통해 다른 응용 프로그램 도메인에 전송할 수 있습니다 (수에 다른 프로세스 또는 컴퓨터).</xref:System.Runtime.Remoting.ObjRef> 다른 응용 프로그램 도메인에서 한 번의 <xref:System.Runtime.Remoting.ObjRef>일반적으로 실제 개체에 연결 하는 개체에 대 한 프록시를 만드는 구문 분석 되어야 합니다.</xref:System.Runtime.Remoting.ObjRef> 이 작업을 역마샬링 라고 합니다.       A <xref:System.Runtime.Remoting.ObjRef>설명 하는 정보가 포함 되어는 <xref:System.Type>및 클래스는 마샬링하는 개체의 특정 개체 인스턴스 및 통신을 고유 하 게 식별 하는 URI 관련 개체가 위치한 원격 하위 영역에 도달 하는 방법에 대 한 정보.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       마샬링을 하는 동안 현재 스레드에서 컨텍스트를 사용, 컨텍스트가 아닌 때 활성화 되었던 개체가 만들어진 합니다. URI 명시적으로 설정 되지 않은 경우는 <xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A>메서드를 원격 id 인프라에서 자동으로 생성 됩니다.</xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A>       두 가지 이유 중 하나에 대 한 프록시를 사용한 URI를 연결할 수 없습니다:을 나타내는 개체에 대 한 서버 쪽에서 생성 된 URI 또는 URI를 알 경우 개체는 잘 알려져 있습니다. 이 경우는 `Obj` 매개 변수는 프록시, 예외가 throw 됩니다. 사용자 지정 프록시에 대 한 투명 프록시 서버 개체 처리 되기 때문에 이러한 제한이 완화 됩니다."
  syntax:
    content: public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);
    parameters:
    - id: Obj
      type: System.MarshalByRefObject
      description: "변환할 개체입니다."
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "인스턴스는 <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> 에 지정 된 개체를 나타내는 클래스는 <code> Obj </code> 매개 변수입니다."
  overload: System.Runtime.Remoting.RemotingServices.Marshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code> Obj </code> 매개 변수는 개체 프록시입니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)
  id: Marshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Marshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "변환 된 주어진 <xref href=&quot;System.MarshalByRefObject&quot;> </xref> 의 인스턴스로 <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> URI가 지정된 된 클래스."
  remarks: "A <xref:System.Runtime.Remoting.ObjRef>응용 프로그램 도메인 경계를 넘어 개체 참조를 전송 하는 데 사용 되는 개체의 직렬화 가능 표현인.</xref:System.Runtime.Remoting.ObjRef> 만들기는 <xref:System.Runtime.Remoting.ObjRef>마샬링 라고 개체에 대 한.</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>채널을 통해 다른 응용 프로그램 도메인에 전송할 수 있습니다 (수에 다른 프로세스 또는 컴퓨터).</xref:System.Runtime.Remoting.ObjRef> 다른 응용 프로그램 도메인에서 한 번의 <xref:System.Runtime.Remoting.ObjRef>일반적으로 실제 개체에 연결 하는 개체에 대 한 프록시를 만드는 구문 분석 되어야 합니다.</xref:System.Runtime.Remoting.ObjRef> 이 작업을 역마샬링 라고 합니다.       A <xref:System.Runtime.Remoting.ObjRef>설명 하는 정보가 포함 되어는 <xref:System.Type>및 클래스는 마샬링하는 개체의 특정 개체 인스턴스 및 통신을 고유 하 게 식별 하는 URI 관련 개체가 위치한 원격 하위 영역에 도달 하는 방법에 대 한 정보.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       마샬링을 하는 동안 현재 스레드에서 컨텍스트를 사용, 컨텍스트가 아닌 때 활성화 되었던 개체가 만들어진 합니다.       두 가지 이유 중 하나에 대 한 프록시를 사용한 URI를 연결할 수 없습니다:을 나타내는 개체에 대 한 서버 쪽에서 생성 된 URI 또는 URI를 알 경우 개체는 잘 알려져 있습니다. 이 경우는 `Obj` 매개 변수는 프록시, 예외가 throw 됩니다. 사용자 지정 프록시에 대 한 투명 프록시 서버 개체 처리 되기 때문에 이러한 제한이 완화 됩니다."
  example:
  - "The following code example demonstrates how to use the current <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> method to marshal a specified object.  \n  \n [!code-cpp[RemotingServices.BasicSample#2](~/add/codesnippet/cpp/01236a8e-f8c3-4b7b-875d-_1.cpp)]\n [!code-cs[RemotingServices.BasicSample#2](~/add/codesnippet/csharp/01236a8e-f8c3-4b7b-875d-_1.cs)]\n [!code-vb[RemotingServices.BasicSample#2](~/add/codesnippet/visualbasic/01236a8e-f8c3-4b7b-875d-_1.vb)]"
  syntax:
    content: public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);
    parameters:
    - id: Obj
      type: System.MarshalByRefObject
      description: "변환할 개체입니다."
    - id: URI
      type: System.String
      description: "새 초기화 하는 지정된 된 URI <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>합니다. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "인스턴스는 <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> 에 지정 된 개체를 나타내는 클래스는 <code> Obj </code> 매개 변수입니다."
  overload: System.Runtime.Remoting.RemotingServices.Marshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code>Obj</code>한 개체 프록시가 및 <code>URI</code> 매개 변수가 않습니다 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)
  id: Marshal(System.MarshalByRefObject,System.String,System.Type)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Marshal(MarshalByRefObject,String,Type)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String,Type)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String,Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "사용 된 <xref href=&quot;System.MarshalByRefObject&quot;> </xref> 의 인스턴스로 변환 하 고는 <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> URI 및 <xref:System.Type>.</xref:System.Type> 제공 된 지정 된 클래스"
  remarks: "A <xref:System.Runtime.Remoting.ObjRef>응용 프로그램 도메인 경계를 넘어 개체 참조를 전송 하는 데 사용 되는 개체의 직렬화 가능 표현인.</xref:System.Runtime.Remoting.ObjRef> 만들기는 <xref:System.Runtime.Remoting.ObjRef>마샬링 라고 개체에 대 한.</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>채널을 통해 다른 응용 프로그램 도메인에 전송할 수 있습니다 (수에 다른 프로세스 또는 컴퓨터).</xref:System.Runtime.Remoting.ObjRef> 다른 응용 프로그램 도메인에서 한 번의 <xref:System.Runtime.Remoting.ObjRef>일반적으로 실제 개체에 연결 하는 개체에 대 한 프록시를 만드는 구문 분석 되어야 합니다.</xref:System.Runtime.Remoting.ObjRef> 이 작업을 역마샬링 라고 합니다.       A <xref:System.Runtime.Remoting.ObjRef>설명 하는 정보가 포함 되어는 <xref:System.Type>및 클래스는 마샬링하는 개체의 특정 개체 인스턴스 및 통신을 고유 하 게 식별 하는 URI 관련 개체가 위치한 원격 하위 영역에 도달 하는 방법에 대 한 정보.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       지정 된 <xref:System.Type>원격 인프라 노출 된 형식 계층 구조의 범위를 제한 하는 데 사용 합니다.</xref:System.Type> 예를 들어 개체 A B C 개체에서 파생 되는 개체에서 파생 <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A>호출 된 경우, 다음 클라이언트 파생 된 a 있지만 B와 C 간의       컨텍스트가 아닌 때 활성화 되었던 개체가 만들어진, 마샬링을 하는 동안 현재 스레드에서 컨텍스트를 사용 합니다.</xref:System.Runtime.Remoting.RemotingServices.Marshal%2A>       두 가지 이유 중 하나에 대 한 프록시를 사용한 URI를 연결할 수 없습니다:을 나타내는 개체에 대 한 서버 쪽에서 생성 된 URI 또는 URI를 알 경우 개체는 잘 알려져 있습니다. 이 경우는 `Obj` 매개 변수는 프록시, 예외가 throw 됩니다. 사용자 지정 프록시에 대 한 투명 프록시 서버 개체 처리 되기 때문에 이러한 제한이 완화 됩니다."
  syntax:
    content: public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);
    parameters:
    - id: Obj
      type: System.MarshalByRefObject
      description: "으로 변환 하는 개체는 <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>합니다."
    - id: ObjURI
      type: System.String
      description: "URI에 지정 된 개체는 `Obj` 와 매개 변수는 마샬링됩니다. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    - id: RequestedType
      type: System.Type
      description: "<xref:System.Type> `Obj` 로 마샬링됩니다.</xref:System.Type> Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "인스턴스는 <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> 에 지정 된 개체를 나타내는 클래스는 <code> Obj </code> 매개 변수입니다."
  overload: System.Runtime.Remoting.RemotingServices.Marshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code>Obj</code>원격 개체의 프록시 및 <code>ObjUri</code> 매개 변수가 않습니다 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  id: SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: SetObjectUriForMarshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "설정에 대 한 후속 호출에 대 한 URI는 <xref:System.Runtime.Remoting.RemotingServices.Marshal*>메서드.</xref:System.Runtime.Remoting.RemotingServices.Marshal*>"
  remarks: "The URI set by the current method is used when marshaling the given object.  \n  \n After marshaling, the URI of the specified object is set to the string in the `uri` parameter appended onto the <xref:System.Guid> of the current <xref:System.AppDomain>.  \n  \n If the current application is listening on an HTTP port, then both the string specified in the `uri` parameter and the `uri` string appended onto the <xref:System.Guid> of the current <xref:System.AppDomain> route to the specified object. For example, if the application is listening on HTTP port 9000, then both http://localhost:9000/objectUri, and http://localhost:9000/\\<appdomainguid>/objectUri route to the object specified in the `obj` parameter."
  example:
  - "The following code example demonstrates how to set the URI that will be used by the <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> method when marshaling the specified object.  \n  \n [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/add/codesnippet/cpp/2ed6d271-806d-4778-95aa-_1.cpp)]\n [!code-cs[RemotingServices.SetObjectUriForMarshal#1](~/add/codesnippet/csharp/2ed6d271-806d-4778-95aa-_1.cs)]\n [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/add/codesnippet/visualbasic/2ed6d271-806d-4778-95aa-_1.vb)]"
  syntax:
    content: public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "에 대 한 URI를 설정 하는 개체입니다."
    - id: uri
      type: System.String
      description: "지정된 된 개체에 할당할 URI입니다."
  overload: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code>obj</code>로컬 개체가 아니라 이미 마샬링 또는 현재 메서드가 이미 호출 되었습니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)
  id: Unmarshal(System.Runtime.Remoting.ObjRef)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Unmarshal(ObjRef)
  nameWithType: RemotingServices.Unmarshal(ObjRef)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "사용 된 <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> 프록시 개체를 만듭니다."
  remarks: "A <xref:System.Runtime.Remoting.ObjRef>응용 프로그램 도메인 경계를 넘어 개체 참조를 전송 하는 데 사용 되는 개체의 직렬화 가능 표현인.</xref:System.Runtime.Remoting.ObjRef> 만들기는 <xref:System.Runtime.Remoting.ObjRef>마샬링 라고 개체에 대 한.</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>채널을 통해 다른 응용 프로그램 도메인에 전송할 수 있습니다 (수에 다른 프로세스 또는 컴퓨터).</xref:System.Runtime.Remoting.ObjRef> 다른 응용 프로그램 도메인에서 한 번의 <xref:System.Runtime.Remoting.ObjRef>일반적으로 실제 개체에 연결 하는 개체에 대 한 프록시를 만드는 구문 분석 되어야 합니다.</xref:System.Runtime.Remoting.ObjRef> 이 작업을 역마샬링 라고 합니다. 역마샬링 동안는 <xref:System.Runtime.Remoting.ObjRef>원격 개체와 투명 프록시 개체의 메서드 정보를 추출 하는 구문 분석 하 고 <xref:System.Runtime.Remoting.Proxies.RealProxy>개체가 만들어집니다.</xref:System.Runtime.Remoting.Proxies.RealProxy> </xref:System.Runtime.Remoting.ObjRef> 구문 분석 된 내용의 <xref:System.Runtime.Remoting.ObjRef>투명 프록시는 공용 언어 런타임에 등록 되기 전에 투명 프록시에 추가 됩니다.</xref:System.Runtime.Remoting.ObjRef>       A <xref:System.Runtime.Remoting.ObjRef>설명 하는 정보가 포함 되어는 <xref:System.Type>및 클래스는 마샬링하는 개체의 특정 개체 인스턴스 및 통신을 고유 하 게 식별 하는 URI 관련 개체가 위치한 원격 하위 영역에 도달 하는 방법에 대 한 정보.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>"
  example:
  - "The following code example demonstrates how to unmarshal an object.  \n  \n [!code-vb[RemotingServices.Unmarshal#2](~/add/codesnippet/visualbasic/b4be8871-533a-4641-8763-_1.vb)]\n [!code-cpp[RemotingServices.Unmarshal#2](~/add/codesnippet/cpp/b4be8871-533a-4641-8763-_1.cpp)]\n [!code-cs[RemotingServices.Unmarshal#2](~/add/codesnippet/csharp/b4be8871-533a-4641-8763-_1.cs)]"
  syntax:
    content: public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);
    parameters:
    - id: objectRef
      type: System.Runtime.Remoting.ObjRef
      description: "<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> 프록시를 만들 원격 개체를 나타내는입니다."
    return:
      type: System.Object
      description: "개체에 대 한 프록시 하는 지정 된 <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> 나타냅니다."
  overload: System.Runtime.Remoting.RemotingServices.Unmarshal*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> 에 지정 된 인스턴스에 <code> objectRef </code> 매개 변수 형식이 올바르지 않습니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  id: Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Unmarshal(ObjRef,Boolean)
  nameWithType: RemotingServices.Unmarshal(ObjRef,Boolean)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "사용 된 <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> 서버에 형식으로 구체화을 옵트아웃 프록시에 대 한 개체를 만듭니다."
  remarks: "A <xref:System.Runtime.Remoting.ObjRef>응용 프로그램 도메인 경계를 넘어 개체 참조를 전송 하는 데 사용 되는 개체의 직렬화 가능 표현인.</xref:System.Runtime.Remoting.ObjRef> 만들기는 <xref:System.Runtime.Remoting.ObjRef>마샬링 라고 개체에 대 한.</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>채널을 통해 다른 응용 프로그램 도메인에 전송할 수 있습니다 (수에 다른 프로세스 또는 컴퓨터).</xref:System.Runtime.Remoting.ObjRef> 다른 응용 프로그램 도메인에서 한 번의 <xref:System.Runtime.Remoting.ObjRef>일반적으로 실제 개체에 연결 하는 개체에 대 한 프록시를 만드는 구문 분석 되어야 합니다.</xref:System.Runtime.Remoting.ObjRef> 이 작업을 역마샬링 라고 합니다. 역마샬링 동안는 <xref:System.Runtime.Remoting.ObjRef>원격 개체와 투명 프록시 개체의 메서드 정보를 추출 하는 구문 분석 하 고 <xref:System.Runtime.Remoting.Proxies.RealProxy>개체가 만들어집니다.</xref:System.Runtime.Remoting.Proxies.RealProxy> </xref:System.Runtime.Remoting.ObjRef> 구문 분석 된 내용의 <xref:System.Runtime.Remoting.ObjRef>투명 프록시는 공용 언어 런타임에 등록 되기 전에 투명 프록시에 추가 됩니다.</xref:System.Runtime.Remoting.ObjRef>       A <xref:System.Runtime.Remoting.ObjRef>설명 하는 정보가 포함 되어는 <xref:System.Type>및 클래스는 마샬링하는 개체의 특정 개체 인스턴스 및 통신을 고유 하 게 식별 하는 URI 관련 개체가 위치한 원격 하위 영역에 도달 하는 방법에 대 한 정보.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       프록시는 <xref:System.MarshalByRefObject>.</xref:System.MarshalByRefObject> 형식의 처음 만들 때 다른 형식으로 캐스팅 하면 원격 인프라는 추적의 종류를 불필요 하 게 부하를 방지 하려면 가장 사용 되는 형식을 합니다."
  syntax:
    content: public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);
    parameters:
    - id: objectRef
      type: System.Runtime.Remoting.ObjRef
      description: "<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> 프록시를 만들 원격 개체를 나타내는입니다."
    - id: fRefine
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>프록시 서버에 형식에 적용 하려면 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
    return:
      type: System.Object
      description: "개체에 대 한 프록시 하는 지정 된 <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> 나타냅니다."
  overload: System.Runtime.Remoting.RemotingServices.Unmarshal*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> 에 지정 된 인스턴스에 <code> objectRef </code> 매개 변수 형식이 올바르지 않습니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Runtime.Remoting.RemotingException
  parent: System.Runtime.Remoting
  isExternal: false
  name: RemotingException
  nameWithType: RemotingException
  fullName: System.Runtime.Remoting.RemotingException
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Connect(Type,String)
  nameWithType: RemotingServices.Connect(Type,String)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Connect(Type,String,Object)
  nameWithType: RemotingServices.Connect(Type,String,Object)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String,Object)
- uid: System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Disconnect(MarshalByRefObject)
  nameWithType: RemotingServices.Disconnect(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Disconnect(MarshalByRefObject)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.MarshalByRefObject
  parent: System
  isExternal: false
  name: MarshalByRefObject
  nameWithType: MarshalByRefObject
  fullName: System.MarshalByRefObject
- uid: System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  nameWithType: RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  fullName: System.Runtime.Remoting.RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
- uid: System.Runtime.Remoting.Messaging.IMethodReturnMessage
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMethodReturnMessage
  nameWithType: IMethodReturnMessage
  fullName: System.Runtime.Remoting.Messaging.IMethodReturnMessage
- uid: System.Runtime.Remoting.Messaging.IMethodCallMessage
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMethodCallMessage
  nameWithType: IMethodCallMessage
  fullName: System.Runtime.Remoting.Messaging.IMethodCallMessage
- uid: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetEnvoyChainForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
- uid: System.Runtime.Remoting.Messaging.IMessageSink
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMessageSink
  nameWithType: IMessageSink
  fullName: System.Runtime.Remoting.Messaging.IMessageSink
- uid: System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetLifetimeService(MarshalByRefObject)
  nameWithType: RemotingServices.GetLifetimeService(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetLifetimeService(MarshalByRefObject)
- uid: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetMethodBaseFromMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
- uid: System.Reflection.MethodBase
  parent: System.Reflection
  isExternal: true
  name: MethodBase
  nameWithType: MethodBase
  fullName: System.Reflection.MethodBase
- uid: System.Runtime.Remoting.Messaging.IMethodMessage
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMethodMessage
  nameWithType: IMethodMessage
  fullName: System.Runtime.Remoting.Messaging.IMethodMessage
- uid: System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectData(Object,SerializationInfo,StreamingContext)
  nameWithType: RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
- uid: System.Runtime.Serialization.SerializationInfo
  parent: System.Runtime.Serialization
  isExternal: false
  name: SerializationInfo
  nameWithType: SerializationInfo
  fullName: System.Runtime.Serialization.SerializationInfo
- uid: System.Runtime.Serialization.StreamingContext
  parent: System.Runtime.Serialization
  isExternal: true
  name: StreamingContext
  nameWithType: StreamingContext
  fullName: System.Runtime.Serialization.StreamingContext
- uid: System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectUri(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjectUri(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectUri(MarshalByRefObject)
- uid: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjRefForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjRefForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(MarshalByRefObject)
- uid: System.Runtime.Remoting.ObjRef
  parent: System.Runtime.Remoting
  isExternal: false
  name: ObjRef
  nameWithType: ObjRef
  fullName: System.Runtime.Remoting.ObjRef
- uid: System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetRealProxy(Object)
  nameWithType: RemotingServices.GetRealProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.GetRealProxy(Object)
- uid: System.Runtime.Remoting.Proxies.RealProxy
  parent: System.Runtime.Remoting.Proxies
  isExternal: false
  name: RealProxy
  nameWithType: RealProxy
  fullName: System.Runtime.Remoting.Proxies.RealProxy
- uid: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetServerTypeForUri(String)
  nameWithType: RemotingServices.GetServerTypeForUri(String)
  fullName: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(String)
- uid: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetSessionIdForMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
- uid: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsMethodOverloaded(IMethodMessage)
  nameWithType: RemotingServices.IsMethodOverloaded(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(IMethodMessage)
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfAppDomain(Object)
  nameWithType: RemotingServices.IsObjectOutOfAppDomain(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(Object)
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfContext(Object)
  nameWithType: RemotingServices.IsObjectOutOfContext(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(Object)
- uid: System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsOneWay(MethodBase)
  nameWithType: RemotingServices.IsOneWay(MethodBase)
  fullName: System.Runtime.Remoting.RemotingServices.IsOneWay(MethodBase)
- uid: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsTransparentProxy(Object)
  nameWithType: RemotingServices.IsTransparentProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(Object)
- uid: System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: LogRemotingStage(Int32)
  nameWithType: RemotingServices.LogRemotingStage(Int32)
  fullName: System.Runtime.Remoting.RemotingServices.LogRemotingStage(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal(MarshalByRefObject)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject)
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String)
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal(MarshalByRefObject,String,Type)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String,Type)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String,Type)
- uid: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: SetObjectUriForMarshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Unmarshal(ObjRef)
  nameWithType: RemotingServices.Unmarshal(ObjRef)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef)
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Unmarshal(ObjRef,Boolean)
  nameWithType: RemotingServices.Unmarshal(ObjRef,Boolean)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef,Boolean)
- uid: System.Runtime.Remoting.RemotingServices.Connect*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Connect
  nameWithType: RemotingServices.Connect
- uid: System.Runtime.Remoting.RemotingServices.Disconnect*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Disconnect
  nameWithType: RemotingServices.Disconnect
- uid: System.Runtime.Remoting.RemotingServices.ExecuteMessage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: ExecuteMessage
  nameWithType: RemotingServices.ExecuteMessage
- uid: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetEnvoyChainForProxy
  nameWithType: RemotingServices.GetEnvoyChainForProxy
- uid: System.Runtime.Remoting.RemotingServices.GetLifetimeService*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetLifetimeService
  nameWithType: RemotingServices.GetLifetimeService
- uid: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetMethodBaseFromMethodMessage
  nameWithType: RemotingServices.GetMethodBaseFromMethodMessage
- uid: System.Runtime.Remoting.RemotingServices.GetObjectData*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectData
  nameWithType: RemotingServices.GetObjectData
- uid: System.Runtime.Remoting.RemotingServices.GetObjectUri*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectUri
  nameWithType: RemotingServices.GetObjectUri
- uid: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjRefForProxy
  nameWithType: RemotingServices.GetObjRefForProxy
- uid: System.Runtime.Remoting.RemotingServices.GetRealProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetRealProxy
  nameWithType: RemotingServices.GetRealProxy
- uid: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetServerTypeForUri
  nameWithType: RemotingServices.GetServerTypeForUri
- uid: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetSessionIdForMethodMessage
  nameWithType: RemotingServices.GetSessionIdForMethodMessage
- uid: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsMethodOverloaded
  nameWithType: RemotingServices.IsMethodOverloaded
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfAppDomain
  nameWithType: RemotingServices.IsObjectOutOfAppDomain
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfContext
  nameWithType: RemotingServices.IsObjectOutOfContext
- uid: System.Runtime.Remoting.RemotingServices.IsOneWay*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsOneWay
  nameWithType: RemotingServices.IsOneWay
- uid: System.Runtime.Remoting.RemotingServices.IsTransparentProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsTransparentProxy
  nameWithType: RemotingServices.IsTransparentProxy
- uid: System.Runtime.Remoting.RemotingServices.LogRemotingStage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: LogRemotingStage
  nameWithType: RemotingServices.LogRemotingStage
- uid: System.Runtime.Remoting.RemotingServices.Marshal*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal
  nameWithType: RemotingServices.Marshal
- uid: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: SetObjectUriForMarshal
  nameWithType: RemotingServices.SetObjectUriForMarshal
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Unmarshal
  nameWithType: RemotingServices.Unmarshal
