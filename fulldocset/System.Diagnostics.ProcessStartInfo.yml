### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.ProcessStartInfo
  id: ProcessStartInfo
  children:
  - System.Diagnostics.ProcessStartInfo.#ctor
  - System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  - System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  - System.Diagnostics.ProcessStartInfo.Arguments
  - System.Diagnostics.ProcessStartInfo.CreateNoWindow
  - System.Diagnostics.ProcessStartInfo.Domain
  - System.Diagnostics.ProcessStartInfo.Environment
  - System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  - System.Diagnostics.ProcessStartInfo.ErrorDialog
  - System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  - System.Diagnostics.ProcessStartInfo.FileName
  - System.Diagnostics.ProcessStartInfo.LoadUserProfile
  - System.Diagnostics.ProcessStartInfo.Password
  - System.Diagnostics.ProcessStartInfo.PasswordInClearText
  - System.Diagnostics.ProcessStartInfo.RedirectStandardError
  - System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  - System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  - System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  - System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  - System.Diagnostics.ProcessStartInfo.UserName
  - System.Diagnostics.ProcessStartInfo.UseShellExecute
  - System.Diagnostics.ProcessStartInfo.Verb
  - System.Diagnostics.ProcessStartInfo.Verbs
  - System.Diagnostics.ProcessStartInfo.WindowStyle
  - System.Diagnostics.ProcessStartInfo.WorkingDirectory
  langs:
  - csharp
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo
  fullName: System.Diagnostics.ProcessStartInfo
  type: Class
  summary: "프로세스를 시작할 때 사용 되는 값 집합을 지정 합니다."
  remarks: "ProcessStartInfo와 함께 사용 되는 <xref:System.Diagnostics.Process>구성 요소.</xref:System.Diagnostics.Process> 사용 하 여 프로세스를 시작할 때는 <xref:System.Diagnostics.Process>실행 중인 프로세스에 연결 하는 경우 프로세스를 사용할 수 있는 정보에 액세스할 수 있는 클래스입니다.</xref:System.Diagnostics.Process>       시작 하는 프로세스를 보다 효율적으로 제어할 ProcessStartInfo 클래스를 사용할 수 있습니다. 이상 설정 해야 합니다는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>속성을 수동으로 또는 생성자를 사용 하 여.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 파일 이름은 응용 프로그램이 나 문서입니다. 여기서 문서 열린 모든 파일 형식 또는 작업이 연결 된 기본으로 정의 됩니다. 볼 수 있습니다 등록 된 파일 형식과 연결 된 응용 프로그램 컴퓨터에 대 한 사용 하 여는 **폴더 옵션** 운영 체제를 통해 사용할 수 있는 대화 상자. **고급** 단추는 등록 된 특정 파일 형식과 연결 열기 동작이 있는지 여부를 보여 주는 대화 상자에 연결 합니다.       또한 해당 파일과 함께 수행할 작업을 정의 하는 기타 속성을 설정할 수 있습니다. 형식에 특정 값을 지정할 수는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>속성에 대 한는 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>속성.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 예를 들어 &quot;인쇄&quot; 문서 형식에 지정할 수 있습니다. 지정할 수는 또한 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>속성 값을 해당 파일의 open 프로시저가에 전달할 명령줄 인수입니다.</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> 예를 들어, 텍스트 편집기에서 응용 프로그램을 지정 하는 경우는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>속성, 있습니다 사용할 수는 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>속성 편집기에서 열 수를 텍스트 파일을 지정 합니다.</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A>       표준 입력은 일반적으로 키보드 및 표준 출력과 표준 오류는 일반적으로 모니터 화면입니다. 사용할 수 있습니다는 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A>, <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>, 및 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>속성으로 인해 프로세스에서 입력 또는 출력 파일 또는 기타 장치로 반환을.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> </xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> </xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A> 사용 하는 경우는 <xref:System.Diagnostics.Process.StandardInput%2A>, <xref:System.Diagnostics.Process.StandardOutput%2A>, 또는 <xref:System.Diagnostics.Process.StandardError%2A>속성에는 <xref:System.Diagnostics.Process>구성 요소를 먼저 설정 해야 해당 값 ProcessStartInfo 속성에.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process.StandardInput%2A> 그렇지 않으면 시스템 읽거나 스트림에 쓸 때 예외가 throw 됩니다.       설정 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>운영 체제 셸을 사용 하 여 프로세스를 시작 하려면 여부를 지정 합니다.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>       프로세스가 시작 될 때까지 ProcessStartInfo 속성의 값을 변경할 수 있습니다. 프로세스를 시작 하면이 기본값을 변경 효과가 없습니다.      > [!NOTE] >이 클래스는 모든 멤버에 적용 되는 클래스 수준에서 링크 요청을 포함 합니다. A <xref:System.Security.SecurityException>직접 실행 호출자에 완전 신뢰 권한이 없는 경우에 throw 됩니다.</xref:System.Security.SecurityException> 보안 요청에 대 한 세부 정보를 참조 하십시오. [링크 요청](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following code example demonstrates how to use the ProcessStartInfo class to start Internet Explorer, providing the destination URLs as ProcessStartInfo arguments.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_2_1.cpp)]"
  syntax:
    content: >-
      [System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]

      public sealed class ProcessStartInfo
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.#ctor
  id: '#ctor'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ProcessStartInfo()
  nameWithType: ProcessStartInfo.ProcessStartInfo()
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> 하는 프로세스를 시작 하는 데 사용할 파일 이름을 지정 하지 않고 클래스입니다."
  remarks: "설정 해야 적어도 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>프로세스를 시작 하기 전에 속성.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 파일 이름은 응용 프로그램이 나 문서입니다. 이 경우 문서 열린 모든 파일 형식 또는 작업이 연결 된 기본으로 정의 됩니다. 볼 수 있습니다 등록 된 파일 형식과 연결 된 응용 프로그램 컴퓨터에 대 한 사용 하 여는 **폴더 옵션** 운영 체제를 통해 사용할 수 있는 대화 상자. **고급** 단추는 등록 된 특정 파일 형식과 연결 열기 동작이 있는지 여부를 보여 주는 대화 상자에 연결 합니다.       필요에 따라 프로세스를 시작 하기 전에 다른 속성을 설정할 수도 있습니다. <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>속성이 제공 수행할 동작을, &quot;print&quot; 등의 지정 된 파일의 사용은 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>속성.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.ProcessStartInfo.Verb%2A> <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>속성이 제공 합니다. 열립니다 때 파일에 명령줄 인수를 전달 하는 방법</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>"
  syntax:
    content: public ProcessStartInfo ();
    parameters: []
  overload: System.Diagnostics.ProcessStartInfo.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ProcessStartInfo(String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> 클래스 및 응용 프로그램이 나 프로세스를 시작 하는 문서와 같은 파일 이름을 지정 합니다."
  remarks: "파일 이름은 응용 프로그램이 나 문서입니다. 이 경우 문서 열린 모든 파일 형식 또는 작업이 연결 된 기본으로 정의 됩니다. 볼 수 있습니다 등록 된 파일 형식과 연결 된 응용 프로그램 컴퓨터에 대 한 사용 하 여는 **폴더 옵션** 운영 체제를 통해 사용할 수 있는 대화 상자. **고급** 단추는 등록 된 특정 파일 형식과 연결 열기 동작이 있는지 여부를 보여 주는 대화 상자에 연결 합니다.       변경할 수는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>속성 프로세스가 시작 될 때까지이 생성자를 호출 하 고 나면.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 프로세스를 시작 하면이 기본값을 변경 효과가 없습니다."
  syntax:
    content: public ProcessStartInfo (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "응용 프로그램이 나 문서 프로세스를 시작할 수입니다."
  overload: System.Diagnostics.ProcessStartInfo.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ProcessStartInfo(String,String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String,String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> 클래스는 프로세스를 시작 하는 데 사용할 응용 프로그램 파일 이름을 지정 하 고 응용 프로그램에 전달할 명령줄 인수 집합을 지정 합니다."
  remarks: "파일 이름은 응용 프로그램이 나 문서입니다. 이 경우 문서 열린 모든 파일 형식 또는 작업이 연결 된 기본으로 정의 됩니다. 볼 수 있습니다 등록 된 파일 형식과 연결 된 응용 프로그램 컴퓨터에 대 한 사용 하 여는 **폴더 옵션** 운영 체제를 통해 사용할 수 있는 대화 상자. **고급** 단추는 등록 된 특정 파일 형식과 연결 열기 동작이 있는지 여부를 보여 주는 대화 상자에 연결 합니다.       변경할 수는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>또는 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>속성 프로세스가 시작 될 때까지이 생성자를 호출 하 고 나면.</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 프로세스를 시작 하면이 기본값을 변경 효과가 없습니다."
  syntax:
    content: public ProcessStartInfo (string fileName, string arguments);
    parameters:
    - id: fileName
      type: System.String
      description: "프로세스를 시작 하는 응용 프로그램입니다."
    - id: arguments
      type: System.String
      description: "프로세스가 시작 될 때 응용 프로그램에 전달할 명령줄 인수입니다."
  overload: System.Diagnostics.ProcessStartInfo.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Arguments
  id: Arguments
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Arguments
  nameWithType: ProcessStartInfo.Arguments
  fullName: System.Diagnostics.ProcessStartInfo.Arguments
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "응용 프로그램을 시작할 때 사용할 명령줄 인수 집합을 가져오거나 설정 합니다."
  remarks: ''
  example:
  - "The first example below creates a small application (argsecho.exe) that echos its arguments to the console. The second example creates an application that invokes argsecho.exe to demonstrate different variations for the Arguments property.  \n  \n [!code-vb[Process.Start_static#3](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#3](~/add/codesnippet/csharp/p-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#3](~/add/codesnippet/cpp/p-system.diagnostics.pro_2_1.cpp)]  \n  \n [!code-vb[Process.Start_static#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_2_2.vb)]\n [!code-cs[Process.Start_static#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_2_2.cs)]\n [!code-cpp[Process.Start_static#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_2_2.cpp)]"
  syntax:
    content: public string Arguments { get; set; }
    return:
      type: System.String
      description: "단일 문자열에 지정 된 대상 응용 프로그램에 전달할 인수를 포함 하는 <xref:System.Diagnostics.ProcessStartInfo.FileName*>속성.</xref:System.Diagnostics.ProcessStartInfo.FileName*> 기본값은 빈 문자열 (&quot;&quot;). Windows Vista 이전 버전의 Windows 운영 체제에서 프로세스에 대 한 전체 경로 길이에 추가 하는 인수의 길이 2080 자 보다 짧아야 이어야 합니다. Windows 7 및 이후 버전에서는 길이가 32699 미만 이어야 합니다.       인수는 구문 분석 하 고 되므로 해당 응용 프로그램의 예상과 일치 해야 합니다는 대상 응용 프로그램에서 해석 됩니다. 와 같은.net 응용 프로그램 공백은 여러 인수 사이의 구분 기호로 해석 됩니다, 아래 예제에 나와 있습니다. 공백이 포함 된 단일 인수를 따옴표로 묶어야 하지만 따옴표는 대상 응용 프로그램에 전달 되지 않습니다. 따옴표에 포함 되어 최종 분석 인수 트리플 이스케이프를 각 표시 합니다."
  overload: System.Diagnostics.ProcessStartInfo.Arguments*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.CreateNoWindow
  id: CreateNoWindow
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: CreateNoWindow
  nameWithType: ProcessStartInfo.CreateNoWindow
  fullName: System.Diagnostics.ProcessStartInfo.CreateNoWindow
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "새 창에서 프로세스 시작 여부를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "경우는 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>속성은 `true` 또는 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>및 <xref:System.Diagnostics.ProcessStartInfo.Password%2A>속성이 `null`CreateNoWindow 속성 값을 무시 하 고 새 창이 만들어집니다.</xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>"
  example:
  - >-
    [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_19_1.cpp)]
     [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_19_1.vb)]
     [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_19_1.cs)]
  syntax:
    content: public bool CreateNoWindow { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>; 포함할 새 창을 만들지 않고 프로세스를 시작 해야 하는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Diagnostics.ProcessStartInfo.CreateNoWindow*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Domain
  id: Domain
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Domain
  nameWithType: ProcessStartInfo.Domain
  fullName: System.Diagnostics.ProcessStartInfo.Domain
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "프로세스를 시작할 때 사용할 도메인을 식별 하는 값을 가져오거나 설정 합니다."
  syntax:
    content: public string Domain { get; set; }
    return:
      type: System.String
      description: "프로세스를 시작할 때 사용할 Active Directory 도메인. 도메인 속성은 주로 Active Directory를 사용 하는 엔터프라이즈 환경 내의 사용자에 게 합니다."
  overload: System.Diagnostics.ProcessStartInfo.Domain*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Environment
  id: Environment
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Environment
  nameWithType: ProcessStartInfo.Environment
  fullName: System.Diagnostics.ProcessStartInfo.Environment
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "이 프로세스와 해당 자식 프로세스에 적용 되는 환경 변수를 가져옵니다."
  remarks: "The environment variables contain search paths for files, directories for temporary files, application-specific options, and other similar information. Although you cannot directly set the Environment property, you can modify the generic dictionary returned by the property. For example, the following code adds a TempPath environment variable: `myProcess.StartInfo.Environment.Add(\"TempPath\", \"C:\\\\Temp\")`.  You must set the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> property to `false` to start the process after changing the Environment property. If <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true`, an <xref:System.InvalidOperationException> is thrown when the <xref:System.Diagnostics.Process.Start%2A> method is called.  \n  \n On .NET Framework applications, using the Environment property is the same as using the <xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A> property."
  syntax:
    content: public System.Collections.Generic.IDictionary<string,string> Environment { get; }
    return:
      type: System.Collections.Generic.IDictionary{System.String,System.String}
      description: "이 프로세스와 해당 자식 프로세스에 적용 되는 환경 변수를 포함 하는 제네릭 사전입니다. 기본값은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Diagnostics.ProcessStartInfo.Environment*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  id: EnvironmentVariables
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: EnvironmentVariables
  nameWithType: ProcessStartInfo.EnvironmentVariables
  fullName: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "검색 파일에 대 한 경로, 임시 파일, 응용 프로그램별 옵션 및 기타 유사한 정보에 대 한 디렉터리를 가져옵니다."
  remarks: 'EnvironmentVariables 속성을 설정할 수 있지만 수정할 수는 <xref:System.Collections.Specialized.StringDictionary>속성에서 반환 합니다.</xref:System.Collections.Specialized.StringDictionary> 다음 코드에서는 TempPath 환경 변수를 추가 하는 예를 들어: `myProcess.StartInfo.EnvironmentVariables.Add(&quot;TempPath&quot;, &quot;C:\\Temp&quot;)`합니다.  설정 해야 합니다는 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>속성을 `false` EnvironmentVariables 속성을 변경한 후 프로세스를 시작할 수 있습니다.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 경우 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>은 `true`, <xref:System.InvalidOperationException>경우 throw 되는 <xref:System.Diagnostics.Process.Start%2A>메서드를 호출 합니다.</xref:System.Diagnostics.Process.Start%2A> </xref:System.InvalidOperationException> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>'
  syntax:
    content: public System.Collections.Specialized.StringDictionary EnvironmentVariables { get; }
    return:
      type: System.Collections.Specialized.StringDictionary
      description: "이 프로세스와 자식 프로세스에 적용 되는 환경 변수를 제공 하는 문자열 사전입니다. 기본값은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Diagnostics.ProcessStartInfo.EnvironmentVariables*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialog
  id: ErrorDialog
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ErrorDialog
  nameWithType: ProcessStartInfo.ErrorDialog
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialog
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "프로세스를 시작할 수 없는 경우 사용자에 게 오류 대화 상자가 표시 되는지를 나타내는 값을 가져오거나 설정 합니다."
  remarks: >-
    > [!NOTE]

    >  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> must be `true` if you want to set ErrorDialog to `true`.
  syntax:
    content: public bool ErrorDialog { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>프로세스를 시작할 수 없는 경우 오류 대화 상자를 화면에 표시 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Diagnostics.ProcessStartInfo.ErrorDialog*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  id: ErrorDialogParentHandle
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ErrorDialogParentHandle
  nameWithType: ProcessStartInfo.ErrorDialogParentHandle
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "프로세스를 시작할 수 없는 오류 대화 상자가 표시 될 때 사용할 창 핸들을 가져오거나 설정 합니다."
  remarks: "경우 <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>은 `true`, ErrorDialogParentHandle 속성에 표시 되는 대화 상자에 대 한 부모 창을 지정 합니다.</xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A> 응용 프로그램 전면에 대화 상자에 부모를 지정 하는 것이 유용 합니다."
  syntax:
    content: public IntPtr ErrorDialogParentHandle { get; set; }
    return:
      type: System.IntPtr
      description: "결과 프로세스를 시작 실패 오류 대화 상자의 핸들에 대 한 포인터입니다."
  overload: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.FileName
  id: FileName
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: FileName
  nameWithType: ProcessStartInfo.FileName
  fullName: System.Diagnostics.ProcessStartInfo.FileName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "응용 프로그램 또는 문서를 시작 값을 가져오거나 설정 합니다."
  remarks: "설정 해야 이상 FileName 속성 프로세스를 시작 하기 전에. 파일 이름은 응용 프로그램이 나 문서입니다. 문서 열린 모든 파일 형식 또는 작업이 연결 된 기본으로 정의 됩니다. 볼 수 있습니다 등록 된 파일 형식과 연결 된 응용 프로그램 컴퓨터에 대 한 사용 하 여는 **폴더 옵션** 운영 체제를 통해 사용할 수 있는 대화 상자. **고급** 단추는 등록 된 특정 파일 형식과 연결 열기 동작이 있는지 여부를 보여 주는 대화 상자에 연결 합니다.       파일 형식 집합을 사용할 수 정도 따라 결정의 값에는 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>속성.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 경우 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>은 `true`를 모든 문서를 시작 하 고 사용 하 여 인쇄, 같은 파일에 대 한 작업을 수행할 수는 <xref:System.Diagnostics.Process>구성 요소.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 때 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>은 `false`와 실행 파일만 시작할 수 있습니다는 <xref:System.Diagnostics.Process>구성 요소.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>       FileName 속성 위치 (예를 들어 웹 주소)를 처음 설치한 응용 프로그램을 설정 하 여 ClickOnce 응용 프로그램을 시작할 수 있습니다. 하드 디스크에 설치 된 위치를 지정 하 여 ClickOnce 응용 프로그램을 시작 하지 않습니다."
  example:
  - >-
    [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_27_1.cpp)]
     [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_27_1.vb)]
     [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_27_1.cs)]
  syntax:
    content: public string FileName { get; set; }
    return:
      type: System.String
      description: "응용 프로그램에 연결 되며 기본 열기 동작이를 사용할 수 있는 파일 형식의 문서 이름 또는 시작할 응용 프로그램의 이름. 기본값은 빈 문자열 (&quot;&quot;)."
  overload: System.Diagnostics.ProcessStartInfo.FileName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.LoadUserProfile
  id: LoadUserProfile
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: LoadUserProfile
  nameWithType: ProcessStartInfo.LoadUserProfile
  fullName: System.Diagnostics.ProcessStartInfo.LoadUserProfile
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "레지스트리에서 로드 되도록 Windows 사용자 프로필 인지 여부를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "이 속성은 사용자 이름, 암호 및 도메인을 사용 하 여 프로세스가 시작 되는 경우 참조 됩니다.       값이 `true`, 사용자의 프로필에는 `HKEY_USERS` 레지스트리 키를 로드 합니다. 프로필을 로드 하는 것은 시간이 많이 걸릴 수 있습니다. 따라서 것이 정보에 액세스 해야 하는 경우에이 값을 사용 하는 `HKEY_CURRENT_USER` 레지스트리 키입니다.       Windows Server 2003 및 Windows 2000 프로필 언로드될 새 프로세스가 종료 되, 여부는 프로세스를 만들었습니다 자식 프로세스에 관계 없이 합니다.       Windows XP에서 프로필은 새 프로세스 후와 만들어진 모든 자식 프로세스가 종료 되었습니다."
  syntax:
    content: public bool LoadUserProfile { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Windows 사용자 프로필; 로드 해야 하는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Diagnostics.ProcessStartInfo.LoadUserProfile*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Password
  id: Password
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Password
  nameWithType: ProcessStartInfo.Password
  fullName: System.Diagnostics.ProcessStartInfo.Password
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "프로세스를 시작할 때 사용할 사용자 암호를 포함 하는 보안 문자열을 가져오거나 설정 합니다."
  remarks: "> [!IMPORTANT]\n>  The <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> property must be set if <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and Password are provided. If the property is not set, the default working directory is %SYSTEMROOT%\\system32.  \n  \n> [!NOTE]\n>  Setting the <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, and the Password properties in a <xref:System.Diagnostics.ProcessStartInfo> object is the recommended practice for starting a process with user credentials.  \n  \n A <xref:System.Security.SecureString> object is like a <xref:System.String> object in that it has a text value. However, the value of a <xref:System.Security.SecureString> object is automatically encrypted, it can be modified until your application marks it as read-only, and it can be deleted from computer memory by either your application or the .NET Framework garbage collector.  \n  \n For more information about secure strings and an example of how to obtain a password to set this property, see the <xref:System.Security.SecureString> class.  \n  \n> [!NOTE]\n>  If you provide a value for the Password property, the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> property must be `false`, or an <xref:System.InvalidOperationException> will be thrown when the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> method is called."
  syntax:
    content: public System.Security.SecureString Password { get; set; }
    return:
      type: System.Security.SecureString
      description: "프로세스를 시작할 때 사용할 사용자 암호입니다."
  overload: System.Diagnostics.ProcessStartInfo.Password*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.PasswordInClearText
  id: PasswordInClearText
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: PasswordInClearText
  nameWithType: ProcessStartInfo.PasswordInClearText
  fullName: System.Diagnostics.ProcessStartInfo.PasswordInClearText
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "프로세스를 시작할 때 사용할 일반 텍스트에 사용자 암호를 가져오거나 설정 합니다."
  syntax:
    content: public string PasswordInClearText { get; set; }
    return:
      type: System.String
      description: "일반 텍스트로 사용자 암호입니다."
  overload: System.Diagnostics.ProcessStartInfo.PasswordInClearText*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardError
  id: RedirectStandardError
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: RedirectStandardError
  nameWithType: ProcessStartInfo.RedirectStandardError
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardError
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "응용 프로그램의 오류 출력에 쓸지 여부를 나타내는 값을 가져오거나 설정 합니다.는 &lt;xref:System.Diagnostics.Process.StandardError%2A?displayProperty=fullName&gt; 스트림 합니다."
  remarks: "경우는 <xref:System.Diagnostics.Process>표준 오류 스트림에 텍스트를 쓰는 해당 텍스트는 일반적으로 콘솔에 표시 됩니다.</xref:System.Diagnostics.Process> 리디렉션하여는 <xref:System.Diagnostics.Process.StandardError%2A>스트림을 조작 하거나 프로세스의 오류 출력을 표시 하지 않을 수 있습니다.</xref:System.Diagnostics.Process.StandardError%2A> 예를 들어 텍스트를 필터링 서식을 다르게 지정 하거나 콘솔 및 지정 된 로그 파일 모두에 출력을 쓸 수 있습니다.      > [!NOTE] > 설정 해야 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>를 `false` RedirectStandardError로 설정 하려는 경우 `true`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 그렇지 않은 경우에서 읽기는 <xref:System.Diagnostics.Process.StandardError%2A>스트림 예외를 throw 합니다.</xref:System.Diagnostics.Process.StandardError%2A>       리디렉션된 <xref:System.Diagnostics.Process.StandardError%2A>동기적 또는 비동기적으로 스트림은 읽을 수 있습니다.</xref:System.Diagnostics.Process.StandardError%2A> 와 같은 메서드 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>및 <xref:System.IO.StreamReader.ReadToEnd%2A>프로세스의 오류 출력 스트림에서 동기 읽기 작업을 수행 합니다.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> 이들 동기 읽기 작업이 연결 될 때까지 완료 되지 않고 <xref:System.Diagnostics.Process>씁니다 해당 <xref:System.Diagnostics.Process.StandardError%2A>스트리밍하거나 스트림을 닫습니다.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       반면, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>시작 비동기 읽기 작업에는 <xref:System.Diagnostics.Process.StandardError%2A>스트림.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 이 메서드는 스트림 출력에 대 한 지정 된 이벤트 처리기 하 고 이벤트 처리기에 스트림을 출력 하는 동안 다른 작업을 수행할 수 있는 호출자에 게 즉시 반환 합니다.      > [!NOTE] > 비동기 출력을 처리 하는 응용 프로그램은 <xref:System.Diagnostics.Process.WaitForExit%2A>메서드를 출력 버퍼 플러시 되었습니다.</xref:System.Diagnostics.Process.WaitForExit%2A>       동기 작업에서 읽는 호출자 간의 종속성을 유발 읽기는 <xref:System.Diagnostics.Process.StandardError%2A>스트림 및 자식 프로세스 스트림에 쓰는.</xref:System.Diagnostics.Process.StandardError%2A> 이러한 종속성으로 인해 교착 상태가 발생할 수 있습니다. 호출자에 게 자식 프로세스의 리디렉션된 스트림에서 읽으면 자식에 종속 됩니다. 호출자에 게 자식 스트림에 쓰거나 스트림이 닫을 때까지 읽기 작업에 대 한 대기 합니다. 리디렉션된 스트림을 맞게 충분 한 데이터를 기록 하는 자식 프로세스를 부모에 종속 됩니다. 자식 프로세스 부모 전체 스트림을 읽기 / 스트림의 닫을 때까지 다음 쓰기 작업에 대 한 대기 합니다. 호출자와 자식 프로세스는 작업을 완료 하려면 서로 대기 하 고 아무 작업도 처리할 수 하는 경우 교착 상태가 발생 합니다. 호출자와 자식 프로세스 간의 종속성을 평가 하 여 교착 상태를 방지할 수 있습니다.       예를 들어 다음 C# 코드에서 리디렉션된 스트림에서 읽고 자식 프로세스가 종료 될 때까지 대기 하는 방법을 보여 줍니다.      ```   // Start the child process.    Process p = new Process();    // Redirect the error stream of the child process.    p.StartInfo.UseShellExecute = false;    p.StartInfo.RedirectStandardError = true;    p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;    p.Start();    // Do not wait for the child process to exit before    // reading to the end of its redirected error stream.    // p.WaitForExit();    // Read the error stream first and then wait.    string error = p.StandardError.ReadToEnd();    p.WaitForExit();   ```호출 하 여 교착 상태를 방지 하는 코드 예제에서는 `p.StandardError.ReadToEnd` 전에 `p.WaitForExit`합니다. 부모 호출을 처리 하는 경우 교착 상태가 발생할 수 있습니다 `p.WaitForExit` 전에 `p.StandardError.ReadToEnd` 자식 프로세스 리디렉션된 스트림에 맞게 충분 한 텍스트를 씁니다. 부모 프로세스를 종료 하는 자식 프로세스 무기한 대기 합니다. 자식 프로세스 전체에서 읽을 수 부모 무기한 대기 <xref:System.Diagnostics.Process.StandardError%2A>스트림.</xref:System.Diagnostics.Process.StandardError%2A>       표준 출력과 표준 오류 스트림 모두에서 모든 텍스트를 읽을 때에 유사한 문제가 있습니다. 예를 들어 다음 C# 코드는 두 스트림이 읽기 작업을 수행합니다.      ```   // Do not perform a synchronous read to the end of both   // redirected streams.   // string output = p.StandardOutput.ReadToEnd();   // string error = p.StandardError.ReadToEnd();   // p.WaitForExit();   // Use asynchronous read operations on at least one of the streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```비동기 읽기 작업에서 수행 하 여 교착 상태를 방지 하는 코드 예제는 <xref:System.Diagnostics.Process.StandardOutput%2A>스트림.</xref:System.Diagnostics.Process.StandardOutput%2A> 부모 호출을 처리 하는 경우 교착 상태가 발생 `p.StandardOutput.ReadToEnd` 이어서 `p.StandardError.ReadToEnd` 자식 프로세스 오류 스트림을 맞게 충분 한 텍스트를 씁니다. 부모 프로세스는 자식 프로세스를 닫으려면 무기한 대기 해당 <xref:System.Diagnostics.Process.StandardOutput%2A>스트림.</xref:System.Diagnostics.Process.StandardOutput%2A> 자식 프로세스 전체에서 읽을 수 부모 무기한 대기 <xref:System.Diagnostics.Process.StandardError%2A>스트림.</xref:System.Diagnostics.Process.StandardError%2A>       이러한 종속성과 교착 방지 하기 위해 비동기 읽기 작업을 사용할 수 있습니다. 또는 두 개의 스레드를 만들고 각 스트림에서 별도 스레드에서 출력을 읽는 하 여 교착 상태를 방지할 수 있습니다."
  example:
  - "The following example uses the `net use` command together with a user-supplied argument to map a network resource. It then reads the standard error stream of the net command and writes it to console.  \n  \n [!code-cs[Process_StandardError#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_31_1.cs)]\n [!code-cpp[Process_StandardError#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_31_1.cpp)]\n [!code-vb[Process_StandardError#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_31_1.vb)]"
  syntax:
    content: public bool RedirectStandardError { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>오류 출력을 쓸 경우 &lt;xref:System.Diagnostics.Process.StandardError%2A?displayProperty=fullName&gt;, 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Diagnostics.ProcessStartInfo.RedirectStandardError*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  id: RedirectStandardInput
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: RedirectStandardInput
  nameWithType: ProcessStartInfo.RedirectStandardInput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "응용 프로그램에 대 한 입력을에서 읽을 수 있는지 여부를 나타내는 값을 가져오거나 설정 합니다.는 &lt;xref:System.Diagnostics.Process.StandardInput%2A?displayProperty=fullName&gt; 스트림 합니다."
  remarks: "A <xref:System.Diagnostics.Process>는 표준 입력된 스트림 일반적으로 키보드에서에서 입력된 텍스트를 읽을 수 있습니다.</xref:System.Diagnostics.Process> 리디렉션하여는 <xref:System.Diagnostics.Process.StandardInput%2A>스트림에 프로세스의 입력을 프로그래밍 방식으로 지정할 수 있습니다.</xref:System.Diagnostics.Process.StandardInput%2A> 예를 들어, 키보드 입력을 사용 하는 대신 지정 된 파일의 내용에서 텍스트 또는 다른 응용 프로그램에서 출력을 제공할 수 있습니다.      > [!NOTE] > 설정 해야 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>를 `false` RedirectStandardInput로 설정 하려는 경우 `true`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 그렇지 않은 경우에 쓰기는 <xref:System.Diagnostics.Process.StandardInput%2A>스트림 예외를 throw 합니다.</xref:System.Diagnostics.Process.StandardInput%2A>"
  example:
  - "The following example illustrates how to redirect the <xref:System.Diagnostics.Process.StandardInput%2A> stream of a process. The `sort` command is a console application that reads and sorts text input.  \n  \n The example starts the `sort` command with redirected input. It then prompts the user for text, and passes the text to the `sort` process through the redirected <xref:System.Diagnostics.Process.StandardInput%2A> stream. The `sort` results are displayed to the user on the console.  \n  \n [!code-cs[Process_StandardInput#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_43_1.cs)]\n [!code-cpp[Process_StandardInput#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_43_1.cpp)]\n [!code-vb[Process_StandardInput#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_43_1.vb)]"
  syntax:
    content: public bool RedirectStandardInput { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>입력에서 읽어야 하는 경우 &lt;xref:System.Diagnostics.Process.StandardInput%2A?displayProperty=fullName&gt;, 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Diagnostics.ProcessStartInfo.RedirectStandardInput*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  id: RedirectStandardOutput
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: RedirectStandardOutput
  nameWithType: ProcessStartInfo.RedirectStandardOutput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "응용 프로그램의 텍스트 출력을 쓸지 여부를 나타내는 값을 가져오거나 설정 합니다.는 &lt;xref:System.Diagnostics.Process.StandardOutput%2A?displayProperty=fullName&gt; 스트림 합니다."
  remarks: "경우는 <xref:System.Diagnostics.Process>해당 텍스트는 일반적으로 콘솔에 표시 됩니다 텍스트를 표준 스트림에 씁니다.</xref:System.Diagnostics.Process> RedirectStandardOutput를 설정 하 여 `true` 리디렉션하는 <xref:System.Diagnostics.Process.StandardOutput%2A>스트림을 조작 하거나 프로세스의 출력을 표시 하지 않을 수 있습니다.</xref:System.Diagnostics.Process.StandardOutput%2A> 예를 들어 텍스트를 필터링 서식을 다르게 지정 하거나 콘솔 및 지정 된 로그 파일 모두에 출력을 쓸 수 있습니다.      > [!NOTE] > 설정 해야 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>를 `false` RedirectStandardOutput로 설정 하려는 경우 `true`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 그렇지 않은 경우에서 읽기는 <xref:System.Diagnostics.Process.StandardOutput%2A>스트림 예외를 throw 합니다.</xref:System.Diagnostics.Process.StandardOutput%2A>       리디렉션된 <xref:System.Diagnostics.Process.StandardOutput%2A>동기적 또는 비동기적으로 스트림은 읽을 수 있습니다.</xref:System.Diagnostics.Process.StandardOutput%2A> 와 같은 메서드 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, 및 <xref:System.IO.StreamReader.ReadToEnd%2A>프로세스의 출력 스트림에서 동기 읽기 작업을 수행 합니다.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> 이들 동기 읽기 작업이 연결 될 때까지 완료 되지 않고 <xref:System.Diagnostics.Process>쓰려는 해당 <xref:System.Diagnostics.Process.StandardOutput%2A>스트리밍하거나 스트림을 닫습니다.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       반면, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>시작 비동기 읽기 작업에는 <xref:System.Diagnostics.Process.StandardOutput%2A>스트림.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 이 메서드는 지정 된 이벤트 처리기를 사용 하면 (참조 <xref:System.Diagnostics.Process.OutputDataReceived>) 출력 스트림 및 즉시 호출자에 게 반환는 작업을 수행할 수 다른 이벤트 처리기에 스트림을 출력 하는 동안.</xref:System.Diagnostics.Process.OutputDataReceived>      > [!NOTE] > 비동기 출력을 처리 하는 응용 프로그램은 <xref:System.Diagnostics.Process.WaitForExit%2A>메서드를 출력 버퍼 플러시 되었습니다.</xref:System.Diagnostics.Process.WaitForExit%2A>       동기 작업에서 읽는 호출자 간의 종속성을 유발 읽기는 <xref:System.Diagnostics.Process.StandardOutput%2A>스트림 및 자식 프로세스 스트림에 쓰는.</xref:System.Diagnostics.Process.StandardOutput%2A> 이러한 종속성으로 인해 교착 상태가 발생할 수 있습니다. 호출자에 게 자식 프로세스의 리디렉션된 스트림에서 읽으면 자식에 종속 됩니다. 호출자에 게 자식 스트림에 쓰거나 스트림이 닫을 때까지 읽기 작업에 대 한 대기 합니다. 리디렉션된 스트림을 맞게 충분 한 데이터를 기록 하는 자식 프로세스를 부모에 종속 됩니다. 자식 프로세스 부모 전체 스트림을 읽기 / 스트림의 닫을 때까지 다음 쓰기 작업에 대 한 대기 합니다. 호출자와 자식 프로세스는 작업을 완료 하려면 서로 대기 하 고 아무 작업도 처리할 수 하는 경우 교착 상태가 발생 합니다. 호출자와 자식 프로세스 간의 종속성을 평가 하 여 교착 상태를 방지할 수 있습니다.       예를 들어 다음 C# 코드에서 리디렉션된 스트림에서 읽고 자식 프로세스가 종료 될 때까지 대기 하는 방법을 보여 줍니다.      ```   Process p = new Process();   p.StartInfo.UseShellExecute = false;   p.StartInfo.RedirectStandardOutput = true;   p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;   p.Start();      // To avoid deadlocks, always read the output stream first and then wait.   string output = p.StandardOutput.ReadToEnd();   p.WaitForExit();   ```호출 하 여 교착 상태를 방지 하는 코드 예제에서는 `p.StandardOutput.ReadToEnd` 전에 `p.WaitForExit`합니다. 부모 호출을 처리 하는 경우 교착 상태가 발생할 수 있습니다 `p.WaitForExit` 전에 `p.StandardOutput.ReadToEnd` 자식 프로세스 리디렉션된 스트림에 맞게 충분 한 텍스트를 씁니다. 부모 프로세스를 종료 하는 자식 프로세스 무기한 대기 합니다. 자식 프로세스 전체에서 읽을 수 부모 무기한 대기 <xref:System.Diagnostics.Process.StandardOutput%2A>스트림.</xref:System.Diagnostics.Process.StandardOutput%2A>       표준 출력과 표준 오류 스트림 모두에서 모든 텍스트를 읽을 때에 유사한 문제가 있습니다. 예를 들어 다음 C# 코드는 두 스트림이 읽기 작업을 수행합니다.      ```   // To avoid deadlocks, use asynchronous read operations on at least one of the streams.   // Do not perform a synchronous read to the end of both redirected streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```비동기 읽기 작업에서 수행 하 여 교착 상태를 방지 하는 코드 예제는 <xref:System.Diagnostics.Process.StandardOutput%2A>스트림.</xref:System.Diagnostics.Process.StandardOutput%2A> 부모 호출을 처리 하는 경우 교착 상태가 발생 `p.StandardOutput.ReadToEnd` 이어서 `p.StandardError.ReadToEnd` 자식 프로세스 오류 스트림을 맞게 충분 한 텍스트를 씁니다. 부모 프로세스는 자식 프로세스를 닫으려면 무기한 대기 해당 <xref:System.Diagnostics.Process.StandardOutput%2A>스트림.</xref:System.Diagnostics.Process.StandardOutput%2A> 자식 프로세스 전체에서 읽을 수 부모 무기한 대기 <xref:System.Diagnostics.Process.StandardError%2A>스트림.</xref:System.Diagnostics.Process.StandardError%2A>       이러한 종속성과 교착 방지 하기 위해 비동기 읽기 작업을 사용할 수 있습니다. 또는 두 개의 스레드를 만들고 각 스트림에서 별도 스레드에서 출력을 읽는 하 여 교착 상태를 방지할 수 있습니다."
  example:
  - >-
    [!code-cpp[ProcessOneStream#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_20_1.cpp)]
     [!code-cs[ProcessOneStream#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_20_1.cs)]
     [!code-vb[ProcessOneStream#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_20_1.vb)]
  syntax:
    content: public bool RedirectStandardOutput { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>출력을 쓸 경우 &lt;xref:System.Diagnostics.Process.StandardOutput%2A?displayProperty=fullName&gt;, 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  id: StandardErrorEncoding
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: StandardErrorEncoding
  nameWithType: ProcessStartInfo.StandardErrorEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "오류 출력에 대 한 기본 설정 인코딩을 가져오거나 설정 합니다."
  remarks: "StandardErrorEncoding 속성의 값이 `null`, 프로세스 오류 출력에 대 한 기본 표준 오류 인코딩을 사용 합니다. StandardErrorEncoding 속성 프로세스가 시작 되기 전에 설정 되어야 합니다. 이 속성을 설정 해도 지정 된 인코딩을;는 프로세스에서 사용 되도록 보장 하지 않습니다 프로세스에는 지 원하는 인코딩을 사용 합니다. 지원 되는 인코딩을 결정 하는 응용 프로그램을 테스트 되어야 합니다."
  syntax:
    content: public System.Text.Encoding StandardErrorEncoding { get; set; }
    return:
      type: System.Text.Encoding
      description: "오류 출력에 대 한 기본 설정된 인코딩을 나타내는 개체입니다. 기본값은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  id: StandardOutputEncoding
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: StandardOutputEncoding
  nameWithType: ProcessStartInfo.StandardOutputEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "표준 출력에 대 한 기본 설정 인코딩을 가져오거나 설정 합니다."
  remarks: "StandardOutputEncoding 속성의 값이 `null`, 프로세스는 표준 출력에 대 한 기본 표준 출력 인코딩을 사용 합니다. StandardOutputEncoding 속성 프로세스가 시작 되기 전에 설정 되어야 합니다. 이 속성을 설정 해도 프로세스에서 지정 된 인코딩을 사용 되도록 보장 하지 않습니다. 지원 되는 인코딩을 결정 하는 응용 프로그램을 테스트 되어야 합니다."
  syntax:
    content: public System.Text.Encoding StandardOutputEncoding { get; set; }
    return:
      type: System.Text.Encoding
      description: "표준 출력에 대 한 기본 설정된 인코딩을 나타내는 개체입니다. 기본값은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.UserName
  id: UserName
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: UserName
  nameWithType: ProcessStartInfo.UserName
  fullName: System.Diagnostics.ProcessStartInfo.UserName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "프로세스를 시작할 때 사용할 사용자 이름을 가져오거나 설정 합니다."
  remarks: "> [!IMPORTANT]\n>  The <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> property must be set if UserName and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> are provided. If the property is not set, the default working directory is %SYSTEMROOT%\\system32.  \n  \n If the UserName property is not `null` or an empty string, the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> property must be `false`, or an <xref:System.InvalidOperationException> will be thrown when the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> method is called."
  syntax:
    content: public string UserName { get; set; }
    return:
      type: System.String
      description: "프로세스를 시작할 때 사용할 사용자 이름입니다."
  overload: System.Diagnostics.ProcessStartInfo.UserName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.UseShellExecute
  id: UseShellExecute
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: UseShellExecute
  nameWithType: ProcessStartInfo.UseShellExecute
  fullName: System.Diagnostics.ProcessStartInfo.UseShellExecute
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "운영 체제 셸을 사용 하 여 프로세스를 시작 하려면 여부를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "이 속성을 설정 `false` 입력, 출력 및 오류 스트림을 리디렉션할 수 있습니다.      > [!NOTE] > UseShellExecute 이어야 합니다 `false` 경우는 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>속성은 `null` 또는 빈 문자열인 경우 또는 <xref:System.InvalidOperationException>throw 됩니다는 <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName>메서드를 호출 합니다.</xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> </xref:System.InvalidOperationException> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A>       운영 체제 셸을 사용 하 여 프로세스를 시작 하는 경우에 문서 (즉, 기본 열기 동작이 있는 실행 개체와 연결 된 모든 등록 된 파일 형식)를 시작할 고 사용 하 여 인쇄, 같은 파일에 대 한 작업을 수행할 수 있습니다는 <xref:System.Diagnostics.Process>개체입니다.</xref:System.Diagnostics.Process> UseShellExecute 다음과 같은 경우 `false`를 사용 하 여 실행 파일만 시작할 수는 <xref:System.Diagnostics.Process>개체입니다.</xref:System.Diagnostics.Process>      > [!NOTE] > UseShellExecute 해야 `true` 설정 하는 경우는 <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>속성을 `true`.</xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>       <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>속성의 UseShellExecute 속성의 값에 따라 다르게 동작 합니다.</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> UseShellExecute 다음과 같은 경우 `true`, <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>속성 실행 파일의 위치를 지정 합니다.</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> 경우 <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>이 빈 문자열인 경우 현재 디렉터리에 실행 파일이 포함 되어 있음을 가정 합니다.</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>       UseShellExecute 다음과 같은 경우 `false`, <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>실행 파일을 찾으려고 속성이 사용 되지 않습니다.</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> 대신, 시작 되 고 새 프로세스의 컨텍스트 내 에서만 의미가 하는 프로세스에 의해서만 사용 됩니다. UseShellExecute 다음과 같은 경우 `false`, <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>속성, 실행 파일에는 정규화 된 경로 또는 시스템이 PATH 환경 변수에서 지정한 폴더 내에서 찾아야 하는 간단한 실행 파일 이름이 될 수 있습니다.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>"
  example:
  - >-
    [!code-cpp[ProcessOneStream#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_44_1.cpp)]
     [!code-cs[ProcessOneStream#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_44_1.cs)]
     [!code-vb[ProcessOneStream#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_44_1.vb)]
  syntax:
    content: public bool UseShellExecute { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>셸 프로세스를 시작할 때 사용 해야 하는 경우 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 는 프로세스 실행 파일에서 직접 만들어야 하는 경우. 기본값은 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Diagnostics.ProcessStartInfo.UseShellExecute*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Verb
  id: Verb
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Verb
  nameWithType: ProcessStartInfo.Verb
  fullName: System.Diagnostics.ProcessStartInfo.Verb
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "응용 프로그램 또는로 지정 된 문서를 열 때 사용할 동사를 가져오거나 설정 합니다.는 <xref:System.Diagnostics.ProcessStartInfo.FileName*>속성.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  remarks: "각 파일 이름 확장명은 고유한을 사용 하 여 가져올 수 있는 동사는 <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>속성.</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> 예를 들어는 &quot;`print`&quot; 동사 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 를 사용 하 여 지정 하는 문서를 인쇄 기본 동사는 빈 문자열을 사용 하 여 지정할 수 있습니다 (&quot;&quot;). 동사에는 &quot;편집&quot;, &quot;열기&quot;, &quot;OpenAsReadOnly&quot;, &quot;Print&quot; 및 &quot;Printto&quot;이 있습니다. 반환 하는 동사 집합에 표시 되는 동사에만 사용 해야는 <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>속성.</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>       값을 설정할 때 파일 이름 확장명을 포함 해야 Verb 속성을 사용 하면는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>속성.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 파일 이름 확장명이 Verb 속성에 대 한 값을 직접 입력 하는 경우 필요는 없습니다."
  example:
  - "The following code example starts a new process by using the specified verb and file name. This code example is part of a larger example provided for the <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> property.  \n  \n [!code-vb[ProcessVerbs_Diagnostics#4](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_9_1.vb)]\n [!code-cs[ProcessVerbs_Diagnostics#4](~/add/codesnippet/csharp/p-system.diagnostics.pro_9_1.cs)]"
  syntax:
    content: public string Verb { get; set; }
    return:
      type: System.String
      description: "작업 프로세스에서 열린 파일에 수행 하는입니다. 기본값은 빈 문자열 (&quot;&quot;), 작업이 없음을 나타내는입니다."
  overload: System.Diagnostics.ProcessStartInfo.Verb*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Verbs
  id: Verbs
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Verbs
  nameWithType: ProcessStartInfo.Verbs
  fullName: System.Diagnostics.ProcessStartInfo.Verbs
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "로 지정 된 파일의 형식과 연결 된 동사 집합을 가져옵니다는 <xref:System.Diagnostics.ProcessStartInfo.FileName*>속성.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  remarks: "동사 속성으로 지정 된 파일에 사용할 수 있는 동사를 확인할 수 있습니다는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>속성.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 설정할 수 있습니다는 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>속성 집합의 모든 동사 값.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> 동사에는 &quot;편집&quot;, &quot;열기&quot;, &quot;OpenAsReadOnly&quot;, &quot;Print&quot; 및 &quot;Printto&quot;이 있습니다.       값을 설정할 때 파일 이름 확장명을 포함 해야 Verbs 속성을 사용 하면는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>속성.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 파일 이름 확장명 가능한 동사 집합을 결정합니다."
  example:
  - "The following code example displays the defined verbs for the chosen file name. If the user selects one of the defined verbs, the example starts a new process using the selected verb and the input file name.  \n  \n [!code-vb[ProcessVerbs_Diagnostics#3](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_7_1.vb)]\n [!code-cs[ProcessVerbs_Diagnostics#3](~/add/codesnippet/csharp/p-system.diagnostics.pro_7_1.cs)]"
  syntax:
    content: public string[] Verbs { get; }
    return:
      type: System.String[]
      description: "시스템 파일에 적용할 수 있는 작업으로 표시 된 <xref:System.Diagnostics.ProcessStartInfo.FileName*>속성.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  overload: System.Diagnostics.ProcessStartInfo.Verbs*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.WindowStyle
  id: WindowStyle
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: WindowStyle
  nameWithType: ProcessStartInfo.WindowStyle
  fullName: System.Diagnostics.ProcessStartInfo.WindowStyle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "프로세스가 시작 될 때 사용할 창 상태를 가져오거나 설정 합니다."
  remarks: ''
  example:
  - >-
    [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_42_1.vb)]
     [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_42_1.cs)]
     [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_42_1.cpp)]
  syntax:
    content: public System.Diagnostics.ProcessWindowStyle WindowStyle { get; set; }
    return:
      type: System.Diagnostics.ProcessWindowStyle
      description: "최대화, 창에 프로세스 시작 여부를 나타내는 열거형 값 중 하나 최소화, 표준 (둘 다 최대화 또는 최소화) 또는 표시 되지 않습니다. 기본값은 <xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Diagnostics.ProcessStartInfo.WindowStyle*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "창 스타일 중 하나는 <xref href=&quot;System.Diagnostics.ProcessWindowStyle&quot;> </xref> 열거형 멤버입니다."
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.WorkingDirectory
  id: WorkingDirectory
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: WorkingDirectory
  nameWithType: ProcessStartInfo.WorkingDirectory
  fullName: System.Diagnostics.ProcessStartInfo.WorkingDirectory
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "경우는 <> </> *> 속성은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>가져오거나 시작할 프로세스에 대 한 작업 디렉터리입니다. 때 <> </> *>은 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>가져오거나 시작할 프로세스가 들어 있는 디렉터리입니다."
  remarks: "> [!IMPORTANT]\n>  The WorkingDirectory property must be set if <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> are provided. If the property is not set, the default working directory is %SYSTEMROOT%\\system32.  \n  \n If the directory is already part of the system path variable, you do not have to repeat the directory's location in this property.  \n  \n The WorkingDirectory property behaves differently when <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` than when <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `false`. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true`, the WorkingDirectory property specifies the location of the executable. If WorkingDirectory is an empty string, the current directory is understood to contain the executable.  \n  \n> [!NOTE]\n>  When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true`, the working directory of the application that starts the executable is also the working directory of the executable.  \n  \n When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `false`, the WorkingDirectory property is not used to find the executable. Instead, its value applies to the process that is started and only has meaning within the context of the new process."
  syntax:
    content: public string WorkingDirectory { get; set; }
    return:
      type: System.String
      description: "때 <> </> *>은 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, 시작할 프로세스가 포함 된 디렉터리의 정규화 된 이름입니다. 경우는 <> </> *> 속성은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>를 시작 하는 프로세스에 대 한 작업 디렉터리입니다. 기본값은 빈 문자열 (&quot;&quot;)."
  overload: System.Diagnostics.ProcessStartInfo.WorkingDirectory*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Diagnostics.ProcessStartInfo.#ctor
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo()
  nameWithType: ProcessStartInfo.ProcessStartInfo()
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo()
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo(String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo(String,String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String,String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String,String)
- uid: System.Diagnostics.ProcessStartInfo.Arguments
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Arguments
  nameWithType: ProcessStartInfo.Arguments
  fullName: System.Diagnostics.ProcessStartInfo.Arguments
- uid: System.Diagnostics.ProcessStartInfo.CreateNoWindow
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: CreateNoWindow
  nameWithType: ProcessStartInfo.CreateNoWindow
  fullName: System.Diagnostics.ProcessStartInfo.CreateNoWindow
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.ProcessStartInfo.Domain
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Domain
  nameWithType: ProcessStartInfo.Domain
  fullName: System.Diagnostics.ProcessStartInfo.Domain
- uid: System.Diagnostics.ProcessStartInfo.Environment
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Environment
  nameWithType: ProcessStartInfo.Environment
  fullName: System.Diagnostics.ProcessStartInfo.Environment
- uid: System.Collections.Generic.IDictionary{System.String,System.String}
  parent: System.Collections.Generic
  isExternal: true
  name: IDictionary<String,String>
  nameWithType: IDictionary<String,String>
  fullName: System.Collections.Generic.IDictionary<System.String,System.String>
  spec.csharp:
  - uid: System.Collections.Generic.IDictionary`2
    name: IDictionary
    nameWithType: IDictionary
    fullName: IDictionary<System.String,System.String>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: EnvironmentVariables
  nameWithType: ProcessStartInfo.EnvironmentVariables
  fullName: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
- uid: System.Collections.Specialized.StringDictionary
  parent: System.Collections.Specialized
  isExternal: false
  name: StringDictionary
  nameWithType: StringDictionary
  fullName: System.Collections.Specialized.StringDictionary
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialog
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialog
  nameWithType: ProcessStartInfo.ErrorDialog
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialog
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialogParentHandle
  nameWithType: ProcessStartInfo.ErrorDialogParentHandle
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.ProcessStartInfo.FileName
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: FileName
  nameWithType: ProcessStartInfo.FileName
  fullName: System.Diagnostics.ProcessStartInfo.FileName
- uid: System.Diagnostics.ProcessStartInfo.LoadUserProfile
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: LoadUserProfile
  nameWithType: ProcessStartInfo.LoadUserProfile
  fullName: System.Diagnostics.ProcessStartInfo.LoadUserProfile
- uid: System.Diagnostics.ProcessStartInfo.Password
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Password
  nameWithType: ProcessStartInfo.Password
  fullName: System.Diagnostics.ProcessStartInfo.Password
- uid: System.Security.SecureString
  parent: System.Security
  isExternal: false
  name: SecureString
  nameWithType: SecureString
  fullName: System.Security.SecureString
- uid: System.Diagnostics.ProcessStartInfo.PasswordInClearText
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: PasswordInClearText
  nameWithType: ProcessStartInfo.PasswordInClearText
  fullName: System.Diagnostics.ProcessStartInfo.PasswordInClearText
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardError
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardError
  nameWithType: ProcessStartInfo.RedirectStandardError
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardError
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardInput
  nameWithType: ProcessStartInfo.RedirectStandardInput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardOutput
  nameWithType: ProcessStartInfo.RedirectStandardOutput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
- uid: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardErrorEncoding
  nameWithType: ProcessStartInfo.StandardErrorEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
- uid: System.Text.Encoding
  parent: System.Text
  isExternal: true
  name: Encoding
  nameWithType: Encoding
  fullName: System.Text.Encoding
- uid: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardOutputEncoding
  nameWithType: ProcessStartInfo.StandardOutputEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
- uid: System.Diagnostics.ProcessStartInfo.UserName
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UserName
  nameWithType: ProcessStartInfo.UserName
  fullName: System.Diagnostics.ProcessStartInfo.UserName
- uid: System.Diagnostics.ProcessStartInfo.UseShellExecute
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UseShellExecute
  nameWithType: ProcessStartInfo.UseShellExecute
  fullName: System.Diagnostics.ProcessStartInfo.UseShellExecute
- uid: System.Diagnostics.ProcessStartInfo.Verb
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verb
  nameWithType: ProcessStartInfo.Verb
  fullName: System.Diagnostics.ProcessStartInfo.Verb
- uid: System.Diagnostics.ProcessStartInfo.Verbs
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verbs
  nameWithType: ProcessStartInfo.Verbs
  fullName: System.Diagnostics.ProcessStartInfo.Verbs
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.ProcessStartInfo.WindowStyle
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WindowStyle
  nameWithType: ProcessStartInfo.WindowStyle
  fullName: System.Diagnostics.ProcessStartInfo.WindowStyle
- uid: System.Diagnostics.ProcessWindowStyle
  parent: System.Diagnostics
  isExternal: false
  name: ProcessWindowStyle
  nameWithType: ProcessWindowStyle
  fullName: System.Diagnostics.ProcessWindowStyle
- uid: System.Diagnostics.ProcessStartInfo.WorkingDirectory
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WorkingDirectory
  nameWithType: ProcessStartInfo.WorkingDirectory
  fullName: System.Diagnostics.ProcessStartInfo.WorkingDirectory
- uid: System.Diagnostics.ProcessStartInfo.#ctor*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo.ProcessStartInfo
- uid: System.Diagnostics.ProcessStartInfo.Arguments*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Arguments
  nameWithType: ProcessStartInfo.Arguments
- uid: System.Diagnostics.ProcessStartInfo.CreateNoWindow*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: CreateNoWindow
  nameWithType: ProcessStartInfo.CreateNoWindow
- uid: System.Diagnostics.ProcessStartInfo.Domain*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Domain
  nameWithType: ProcessStartInfo.Domain
- uid: System.Diagnostics.ProcessStartInfo.Environment*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Environment
  nameWithType: ProcessStartInfo.Environment
- uid: System.Diagnostics.ProcessStartInfo.EnvironmentVariables*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: EnvironmentVariables
  nameWithType: ProcessStartInfo.EnvironmentVariables
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialog*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialog
  nameWithType: ProcessStartInfo.ErrorDialog
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialogParentHandle
  nameWithType: ProcessStartInfo.ErrorDialogParentHandle
- uid: System.Diagnostics.ProcessStartInfo.FileName*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: FileName
  nameWithType: ProcessStartInfo.FileName
- uid: System.Diagnostics.ProcessStartInfo.LoadUserProfile*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: LoadUserProfile
  nameWithType: ProcessStartInfo.LoadUserProfile
- uid: System.Diagnostics.ProcessStartInfo.Password*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Password
  nameWithType: ProcessStartInfo.Password
- uid: System.Diagnostics.ProcessStartInfo.PasswordInClearText*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: PasswordInClearText
  nameWithType: ProcessStartInfo.PasswordInClearText
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardError*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardError
  nameWithType: ProcessStartInfo.RedirectStandardError
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardInput*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardInput
  nameWithType: ProcessStartInfo.RedirectStandardInput
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardOutput
  nameWithType: ProcessStartInfo.RedirectStandardOutput
- uid: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardErrorEncoding
  nameWithType: ProcessStartInfo.StandardErrorEncoding
- uid: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardOutputEncoding
  nameWithType: ProcessStartInfo.StandardOutputEncoding
- uid: System.Diagnostics.ProcessStartInfo.UserName*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UserName
  nameWithType: ProcessStartInfo.UserName
- uid: System.Diagnostics.ProcessStartInfo.UseShellExecute*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UseShellExecute
  nameWithType: ProcessStartInfo.UseShellExecute
- uid: System.Diagnostics.ProcessStartInfo.Verb*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verb
  nameWithType: ProcessStartInfo.Verb
- uid: System.Diagnostics.ProcessStartInfo.Verbs*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verbs
  nameWithType: ProcessStartInfo.Verbs
- uid: System.Diagnostics.ProcessStartInfo.WindowStyle*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WindowStyle
  nameWithType: ProcessStartInfo.WindowStyle
- uid: System.Diagnostics.ProcessStartInfo.WorkingDirectory*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WorkingDirectory
  nameWithType: ProcessStartInfo.WorkingDirectory
