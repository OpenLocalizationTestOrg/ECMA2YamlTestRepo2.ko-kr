### YamlMime:ManagedReference
items:
- uid: System.Threading.Thread
  id: Thread
  children:
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  - System.Threading.Thread.Abort
  - System.Threading.Thread.Abort(System.Object)
  - System.Threading.Thread.AllocateDataSlot
  - System.Threading.Thread.AllocateNamedDataSlot(System.String)
  - System.Threading.Thread.ApartmentState
  - System.Threading.Thread.BeginCriticalRegion
  - System.Threading.Thread.BeginThreadAffinity
  - System.Threading.Thread.CurrentContext
  - System.Threading.Thread.CurrentCulture
  - System.Threading.Thread.CurrentPrincipal
  - System.Threading.Thread.CurrentThread
  - System.Threading.Thread.CurrentUICulture
  - System.Threading.Thread.DisableComObjectEagerCleanup
  - System.Threading.Thread.EndCriticalRegion
  - System.Threading.Thread.EndThreadAffinity
  - System.Threading.Thread.ExecutionContext
  - System.Threading.Thread.Finalize
  - System.Threading.Thread.FreeNamedDataSlot(System.String)
  - System.Threading.Thread.GetApartmentState
  - System.Threading.Thread.GetCompressedStack
  - System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  - System.Threading.Thread.GetDomain
  - System.Threading.Thread.GetDomainID
  - System.Threading.Thread.GetHashCode
  - System.Threading.Thread.GetNamedDataSlot(System.String)
  - System.Threading.Thread.Interrupt
  - System.Threading.Thread.IsAlive
  - System.Threading.Thread.IsBackground
  - System.Threading.Thread.IsThreadPoolThread
  - System.Threading.Thread.Join
  - System.Threading.Thread.Join(System.Int32)
  - System.Threading.Thread.Join(System.TimeSpan)
  - System.Threading.Thread.ManagedThreadId
  - System.Threading.Thread.MemoryBarrier
  - System.Threading.Thread.Name
  - System.Threading.Thread.Priority
  - System.Threading.Thread.ResetAbort
  - System.Threading.Thread.Resume
  - System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  - System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  - System.Threading.Thread.Sleep(System.Int32)
  - System.Threading.Thread.Sleep(System.TimeSpan)
  - System.Threading.Thread.SpinWait(System.Int32)
  - System.Threading.Thread.Start
  - System.Threading.Thread.Start(System.Object)
  - System.Threading.Thread.Suspend
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.Threading.Thread.ThreadState
  - System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.VolatileRead(System.Byte@)
  - System.Threading.Thread.VolatileRead(System.Double@)
  - System.Threading.Thread.VolatileRead(System.Int16@)
  - System.Threading.Thread.VolatileRead(System.Int32@)
  - System.Threading.Thread.VolatileRead(System.Int64@)
  - System.Threading.Thread.VolatileRead(System.IntPtr@)
  - System.Threading.Thread.VolatileRead(System.Object@)
  - System.Threading.Thread.VolatileRead(System.SByte@)
  - System.Threading.Thread.VolatileRead(System.Single@)
  - System.Threading.Thread.VolatileRead(System.UInt16@)
  - System.Threading.Thread.VolatileRead(System.UInt32@)
  - System.Threading.Thread.VolatileRead(System.UInt64@)
  - System.Threading.Thread.VolatileRead(System.UIntPtr@)
  - System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  - System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  - System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  - System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  - System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  - System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  - System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  - System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  - System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  - System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  - System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  - System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  - System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  - System.Threading.Thread.Yield
  langs:
  - csharp
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
  type: Class
  summary: "만듭니다 및 스레드를 제어 하의 우선 순위를 설정 하 고 상태를 가져옵니다."
  remarks: "프로세스가 시작 되 면 공용 언어 런타임 응용 프로그램 코드를 실행 하는 단일 포그라운드 스레드를 자동으로 만듭니다. 이 기본 전경 스레드 함께 프로세스는 프로세스와 관련 된 프로그램 코드의 일부를 실행 하려면 하나 이상의 스레드를 만들 수 있습니다. 이러한 스레드는 포그라운드에서 또는 백그라운드에서 실행할 수 있습니다. 또한 사용할 수 있습니다는 <xref:System.Threading.ThreadPool>공용 언어 런타임에 의해 관리 되는 작업자 스레드에 대 한 코드를 실행 하는 클래스입니다.</xref:System.Threading.ThreadPool>       이 섹션에서는 [스레드 시작](#Starting)[스레드 검색 개체](#Retrieving)[포그라운드 및 백그라운드 스레드](#Foreground)[문화권 및 스레드](#Culture)[및에 대 한 제어 스레드 정보를 가져오는](#Properties)[스레드 클래스에 대 한 소스 코드 액세스](#Source) <a name=&quot;Starting&quot;> </a> # # 스레드는 스레드는 해당 클래스 생성자에서를 실행 하는 메서드를 나타내는 대리자를 제공 하 여 시작 스레드 시작 합니다.                                그런 다음 호출에서 <xref:System.Threading.Thread.Start%2A>메서드 실행을 시작 합니다.</xref:System.Threading.Thread.Start%2A>       스레드 생성자 실행할 메서드를 인수를 전달할 수 있는지 여부에 따라 두 대리자 유형 중 하나를 수행:-전달 하면 메서드는 인수가 없는 경우는 <xref:System.Threading.ThreadStart>생성자에 위임 합니다.</xref:System.Threading.ThreadStart> 시그니처가: ```c#       public delegate void ThreadStart()       ``` ```vb       Public Delegate Sub ThreadStart()       ``` 다음 예제를 만들고 실행 하는 스레드를 시작는 `ExecuteInForeground` 메서드.           메서드가 일부 스레드 속성에 대 한 정보를 표시 한 다음는&0;.5 초 일시 중지 하 고 경과 된 초 수를 표시 하는 루프를 실행 합니다. 스레드가&5; 초 이상 동안 실행 된 경우 루프 종료 되 고 스레드는 실행을 종료 합니다.           [!code-cs[System.Threading.Thread#1](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)][!code-vb[System.Threading.Thread#1](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb) ] -메서드는 인수를 전달 하면 한 <xref:System.Threading.ParameterizedThreadStart>생성자에 위임 합니다.</xref:System.Threading.ParameterizedThreadStart>       시그니처가: ```c#       public delegate void ParameterizedThreadStart(object obj)       ``` ```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ``` 메서드가 대리자가 실행 수 다음 캐스팅 (C#) 또는 변환 (Visual Basic)에서는 매개 변수는 적절 한 형식입니다.                     다음 예제는 이전 쿼리와 동일 호출 한다는 점을 제외 하 고는 <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>생성자.</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> 이 버전의는 `ExecuteInForeground` 메서드는 루프를 실행 하는 시간 (밀리초). 대략적인 수를 나타내는 단일 매개 변수입니다.           [!code-cs[System.Threading.Thread#2](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)][!code-vb[System.Threading.Thread#2](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb) ] 스레드를 시작 되 면 스레드 개체에 대 한 참조를 유지할 필요는 없습니다.       스레드 실행 스레드 프로시저가 완료 될 때까지 계속 합니다.      <a name=&quot;Retrieving&quot;></a># #-스레드를 검색 하는 중 개체를 정적을 사용할 수 있습니다 (`Shared` Visual basic에서) <xref:System.Threading.Thread.CurrentThread%2A>스레드가 실행 하는 코드에서 현재 실행 중인 스레드에 대 한 참조를 검색할 속성.</xref:System.Threading.Thread.CurrentThread%2A> 다음 예제에서는 <xref:System.Threading.Thread.CurrentThread%2A>속성을 기본 응용 프로그램 스레드, 다른 포그라운드 스레드, 백그라운드 스레드 및 스레드 풀 스레드에 대 한 정보를 표시 합니다.</xref:System.Threading.Thread.CurrentThread%2A>       [!code-cs[System.Threading.Thread#4](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)][!code-vb[System.Threading.Thread#4](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb) ] <a name=&quot;Foreground&quot;> </a> # # 전경 스레드 또는 백그라운드 스레드 포그라운드 및 백그라운드 스레드는 스레드 클래스의 인스턴스를 나타냅니다.         백그라운드 스레드는 한 가지 예외로 포그라운드 스레드 동일: 모든 포그라운드 스레드가 했습니다. 종료 하는 경우 백그라운드 스레드에서 실행 되는 프로세스를 보관 하지 않습니다. 모든 포그라운드 스레드가 중지 되 면 런타임은 모든 백그라운드 스레드를 중지 하 고 종료 합니다.       기본적으로 다음 스레드 포그라운드에서 실행:-주 응용 프로그램 스레드입니다.      -모든 스레드가 스레드 클래스 생성자를 호출 하 여 만듭니다.       기본적으로 백그라운드에서 실행 하는 다음과 같은 스레드:-스레드는 런타임에서 유지 관리 되는 작업자 스레드 풀은 풀 스레드를 합니다.  <xref:System.Threading.ThreadPool>클래스</xref:System.Threading.ThreadPool> 를 사용 하 여 스레드 풀에서 스레드 풀 및 일정 작업을 구성할 수 있습니다.          > [!NOTE] > 작업 기반 비동기 작업을 스레드 풀 스레드에서 자동으로 실행 합니다. 사용 하 여 작업 기반 비동기 작업의 <xref:System.Threading.Tasks.Task>및 <xref:System.Threading.Tasks.Task%601>클래스를 구현 하는 [작업 기반 비동기 패턴](~/add/includes/ajax-current-ext-md.md).</xref:System.Threading.Tasks.Task%601> </xref:System.Threading.Tasks.Task>      -비관리 코드에서 관리 되는 실행 환경에 들어가는 모든 스레드입니다.       설정 하 여 백그라운드에서 실행 하는 스레드를 변경할 수는 <xref:System.Threading.Thread.IsBackground%2A>언제 든 지 속성.</xref:System.Threading.Thread.IsBackground%2A>  백그라운드 스레드는 응용 프로그램이 실행 되 고 있지만 응용 프로그램의 파일 시스템 변경 사항 또는 들어오는 소켓 연결을 모니터링 하는 등 종료를 방지 해야 한다면 계속 해야 하는 모든 작업에 유용 합니다.       다음 예제에서는 포그라운드 및 백그라운드 스레드 간의 차이점을 보여 줍니다. 첫 번째 예제 비슷합니다는 [스레드 시작](#Starting) 섹션을 제외 하 고 스레드를 시작 하기 전에 백그라운드에서 실행할 설정 합니다. 출력에서 볼 수 있듯이&5; 초 동안 실행 하기 전에 루프 중단 됩니다.       [!code-cs[System.Threading.Thread#3](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)][!code-vb[System.Threading.Thread#3](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb) ] <a name=&quot;Culture&quot;> </a> # # 각 스레드에로 표시 되는 문화권, 문화권 및 스레드는 <xref:System.Threading.Thread.CurrentCulture%2A>속성 및 UI 문화권에서 표시 된 <xref:System.Threading.Thread.CurrentUICulture%2A>속성.</xref:System.Threading.Thread.CurrentUICulture%2A> </xref:System.Threading.Thread.CurrentCulture%2A>          현재 문화권 등의 문화권 구분 작업 구문 분석 및 형식 지정, 문자열 비교 및 정렬을 지원 하 고 또한 쓰기 시스템 및 사용 하 여 스레드에서 일정을 제어 합니다. 현재 UI 문화권 리소스 파일에서 리소스의 문화권 구분 검색을 위해 제공합니다.       새 스레드를 인스턴스화할 때 해당 culture 및 UL culture 문화권 및 UI 스레드의 문화권에 새 스레드가 만들어집니다가 아니라 및 현재 시스템 문화권 및 UI 문화권에 의해 정의 됩니다. 즉, 예를 들어 있는 경우 현재 시스템 문화권이 영어 (미국) 및 기본 응용 프로그램 스레드의 현재 문화권이 프랑스어 (프랑스) 문화권 호출 하 여 만든 새 스레드는 <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>주 스레드에서 생성자는 영어 (미국) 및 프랑스어 (프랑스) 되지 않습니다.</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> 자세한 내용은의 &quot;문화권 및 스레드&quot; 섹션을 참조 하십시오.는 <xref:System.Globalization.CultureInfo>클래스 항목.</xref:System.Globalization.CultureInfo>      > [!IMPORTANT] > 대상으로 하는 앱에 대 한 비동기 작업을 실행 하는 스레드는 적용 되지 않습니다는 [!INCLUDE[net_v46](~/add/includes/net-v46-md.md)] 및 이상 버전에서는이 경우, 문화권 및 UI 문화권에는 비동기 작업 컨텍스트의 일부인; 기본적으로 비동기 작업을 실행 하는 스레드 문화권 및 비동기 작업을 시작 하는 스레드의 UI 문화권을 상속 합니다. 자세한 내용은의 &quot;문화권 및 작업 기반 비동기 작업&quot; 섹션을 참조 하십시오.는 <xref:System.Globalization.CultureInfo>클래스 항목.</xref:System.Globalization.CultureInfo>       하나를 수행 하면 같은 culture 및 UL culture 공유 응용 프로그램에서 실행 되도록 하는 모든 스레드는 다음 중:-전달할 수 있습니다는 <xref:System.Globalization.CultureInfo>해당 문화권을 나타내는 개체는 <xref:System.Threading.ParameterizedThreadStart>위임 또는 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName>메서드.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName> </xref:System.Threading.ParameterizedThreadStart> </xref:System.Globalization.CultureInfo>      -실행 되는 앱에 대 한는 [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] 이상 버전, 문화권 및 UI 문화권의 값을 설정 하 여 응용 프로그램 도메인에서 만든 모든 스레드에 할당 하는 정의할 수 있습니다는 <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName>및 <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName>속성.</xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName> </xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName> 이것은 응용 프로그램별 도메인 설정 note 합니다.       자세한 내용 및 예제에 대 한의 &quot;문화권 및 스레드&quot; 섹션을 참조는 <xref:System.Globalization.CultureInfo>클래스 항목.</xref:System.Globalization.CultureInfo>      <a name=&quot;Properties&quot;></a># # 스레드 제어 및에 대 한 정보를 가져오는 다양 한 스레드에 대 한 정보를 제공 하는 속성 값을 검색할 수 있습니다. 경우에 따라 스레드 작업을 제어 하려면 이러한 속성 값을 설정할 수도 있습니다. 이러한 스레드 속성에 포함:-이름입니다. <xref:System.Threading.Thread.Name%2A>대 한 쓰기-스레드를 식별 하는 데 사용할 수 있는 속성에 한 번입니다.</xref:System.Threading.Thread.Name%2A>  기본값은 `null`합니다.      -해시 코드를 호출 하 여 검색할 수 있는 <xref:System.Threading.Thread.GetHashCode%2A>메서드.</xref:System.Threading.Thread.GetHashCode%2A> 해시 코드를 사용 하 여 고유 하 게 식별 스레드 수 있습니다. 스레드 수명 동안에 대 한 해시 코드 값을 가져온 응용 프로그램 도메인과 관계 없이 다른 스레드의 값과 충돌 하지 않습니다.      -스레드 id입니다. 읽기 전용 값 <xref:System.Threading.Thread.ManagedThreadId%2A>속성 런타임에 의해 할당 되 고 해당 프로세스 내에서 스레드를 고유 하 게 식별 합니다.</xref:System.Threading.Thread.ManagedThreadId%2A>          > [!NOTE] > 운영 체제 [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) 은 관리 되지 않는 호스트가 관리 되는 스레드와 관리 되지 않는 스레드 간의 관계를 제어할 수 있으므로 관리 되는 스레드를 고정된 관계가 없습니다. 특히, 정교한 호스트를 사용할 수는 [CLR 호스팅 API](https://msdn.microsoft.com/library/ms404385.aspx) 를 동일한 운영 체제 스레드에 대해 관리 되는 여러 스레드를 예약 하거나 다양 한 운영 체제 스레드 간에 관리 되는 스레드를 이동할 수 있습니다.      -는 스레드의 현재 상태입니다. 존재 기간에 대 한 스레드는 항상 하나 이상으로 정의 된 상태에는 <xref:System.Threading.ThreadState>속성.</xref:System.Threading.ThreadState>      -일정 예약 우선 순위 수준, 문자로 정의 되는 <xref:System.Threading.ThreadPriority>속성.</xref:System.Threading.ThreadPriority> 스레드의 우선 순위를 요청 하려면이 값을 설정할 수 있지만 운영 체제에 의해 적용 되는 것 보장할 수는 없습니다.      -읽기 전용 <xref:System.Threading.Thread.IsThreadPoolThread%2A>스레드는 스레드 풀 스레드 인지 여부를 나타내는 속성입니다.</xref:System.Threading.Thread.IsThreadPoolThread%2A>      - <xref:System.Threading.Thread.IsBackground%2A>속성.</xref:System.Threading.Thread.IsBackground%2A> 자세한 내용은 참조는 [포그라운드 및 백그라운드 스레드](#Foreground) 섹션.      <a name=&quot;Source&quot;></a># # 참조 스레드 클래스에 대 한.NET Framework 소스 코드를 보려면 스레드 클래스에 대 한 소스 코드에 액세스 하는 [참조 소스](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)합니다. 소스 코드를 온라인, 오프 라인에서 살펴보고에 대 한 참조를 다운로드 및; 디버그 시 소스 (패치 및 업데이트 포함)를 단계별로 실행 참조 [지침](http://referencesource.microsoft.com/)합니다."
  example:
  - "The following example demonstrates simple threading functionality.  \n  \n [!code-cpp[Classic Thread Example#1](~/add/codesnippet/cpp/t-system.threading.thread_5.cpp)]\n [!code-vb[Classic Thread Example#1](~/add/codesnippet/visualbasic/t-system.threading.thread_5.vb)]\n [!code-cs[Classic Thread Example#1](~/add/codesnippet/csharp/t-system.threading.thread_5.cs)]  \n  \n This code produces output similar to the following:  \n  \n```  \n[VB, C++, C#]  \nMain thread: Start a second thread.  \nMain thread: Do some work.  \nThreadProc: 0  \nMain thread: Do some work.  \nThreadProc: 1  \nMain thread: Do some work.  \nThreadProc: 2  \nMain thread: Do some work.  \nThreadProc: 3  \nMain thread: Call Join(), to wait until ThreadProc ends.  \nThreadProc: 4  \nThreadProc: 5  \nThreadProc: 6  \nThreadProc: 7  \nThreadProc: 8  \nThreadProc: 9  \nMain thread: ThreadProc.Join has returned.  Press Enter to end program.  \n```"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread
  inheritance:
  - System.Object
  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  implements:
  - System.Runtime.InteropServices._Thread
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  id: '#ctor(System.Threading.ParameterizedThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Threading.Thread&quot;> </xref> 개체가 스레드가 시작 될 때 스레드로 전달할 수 있도록 하는 대리자를 지정 하는 클래스입니다."
  remarks: "스레드 생성 될 때 실행을 시작 하지 않습니다. 스레드 실행을 예약 하려면 호출 된 <xref:System.Threading.Thread.Start%2A>메서드.</xref:System.Threading.Thread.Start%2A> 스레드에 데이터 개체를 전달 하려면는 <xref:System.Threading.Thread.Start%28System.Object%29>메서드 오버 로드.</xref:System.Threading.Thread.Start%28System.Object%29>      > [!NOTE] > Visual Basic 사용자를 생략할 수는 <xref:System.Threading.ThreadStart>스레드를 만드는 경우 생성자.</xref:System.Threading.ThreadStart> 사용 하 여는 `AddressOf` 예를 들어 메서드를 전달할 때 연산자 `Dim t As New Thread(AddressOf ThreadProc)`합니다. Visual Basic에서 자동으로 호출 된 <xref:System.Threading.ThreadStart>생성자.</xref:System.Threading.ThreadStart>"
  example:
  - "The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_19_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_19_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_19_1.cs)]"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "이 스레드의 실행이 시작 될 때 호출할 메서드를 나타내는 대리자입니다."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  id: '#ctor(System.Threading.ThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Threading.Thread&quot;> </xref> 클래스입니다."
  remarks: "스레드 생성 될 때 실행을 시작 하지 않습니다. 스레드 실행을 예약 하려면 호출 된 <xref:System.Threading.Thread.Start%2A>메서드.</xref:System.Threading.Thread.Start%2A>      > [!NOTE] > Visual Basic 사용자를 생략할 수는 <xref:System.Threading.ThreadStart>스레드를 만드는 경우 생성자.</xref:System.Threading.ThreadStart> 사용 하 여는 `AddressOf` 예를 들어 메서드를 전달할 때 연산자 `Dim t As New Thread(AddressOf ThreadProc)`합니다. Visual Basic에서 자동으로 호출 된 <xref:System.Threading.ThreadStart>생성자.</xref:System.Threading.ThreadStart>"
  example:
  - "The following code example shows how to create a thread that executes a static method.  \n  \n [!code-cpp[System.Threading.Thread.ctor#1](~/add/codesnippet/cpp/m-system.threading.threa_18_1.cpp)]\n [!code-vb[System.Threading.Thread.ctor#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_1.vb)]\n [!code-cs[System.Threading.Thread.ctor#1](~/add/codesnippet/csharp/m-system.threading.threa_18_1.cs)]  \n  \n The following code example shows how to create a thread that executes an instance method.  \n  \n [!code-cs[System.Threading.Thread.ctor2#1](~/add/codesnippet/csharp/m-system.threading.threa_18_2.cs)]\n [!code-vb[System.Threading.Thread.ctor2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_2.vb)]\n [!code-cpp[System.Threading.Thread.ctor2#1](~/add/codesnippet/cpp/m-system.threading.threa_18_2.cpp)]"
  syntax:
    content: public Thread (System.Threading.ThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "A <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> 이 스레드의 실행이 시작 될 때 호출 될 메서드를 나타내는 대리자입니다."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>start</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  id: '#ctor(System.Threading.ParameterizedThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Threading.Thread&quot;> </xref> 개체가 스레드가 시작 될 때 스레드로 전달할 수 있도록 하는 대리자를 지정 하 고 스레드의 최대 스택 크기를 지정 하는 클래스입니다."
  remarks: "이 생성자 오버 로드를 사용 하지 마십시오. 사용 하는 기본 스택 크기는 <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>생성자 오버 로드는 스레드에 대 한 권장된 스택 크기.</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> 스레드가 메모리 문제가 발생 하는 경우는 가장 일반적인 원인은 프로그래밍 무한 재귀 같은 오류입니다.      > [!IMPORTANT] > 부터는 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]코드 설정할 수 있습니다 완전히 신뢰할 수 있는, `maxStackSize` (1mb)의 기본 스택 크기 보다 큰 값으로. 더 큰 값을 지정 하는 경우 `maxStackSize` 코드가 부분 신뢰로 실행 되 고 때 `maxStackSize` 는 무시 됩니다 기본 스택 크기는 데 사용 됩니다. 예외가 throw 되지 않습니다. 코드 모든 신뢰 수준에서 설정할 수 있습니다 `maxStackSize` 기본 스택 크기 보다 작은 값으로.      > [!NOTE] > 경우 부분적으로 신뢰할 수 있는 코드에 의해 사용 될 완전히 신뢰할 수 있는 라이브러리를 개발 하는 고 큰 스택이 필요로 하는 스레드를 시작 해야 할 스레드를 만들기 전에 완전 신뢰를 어설션해야 또는 기본 스택 크기를 사용 됩니다. 스레드에서 실행 되는 코드를 완벽 하 게 제어 하지 않는 한에 이렇게 하지 마십시오.       경우 `maxStackSize` 작으면 최소 스택 크기 보다 최소 스택 크기가 사용 됩니다. 경우 `maxStackSize` 배수가 아닙니다. 페이지 크기의 큰 페이지 크기의 배수로 반올림 됩니다. 예를 들어.NET Framework 버전 2.0은 Windows vista를 사용 하는 256KB (262, 144 바이트)는 최소 스택 크기 및 페이지 크기는 64KB (65536 바이트)입니다.      > [!NOTE] > Windows XP 및 Windows Server 2003 이전 버전에서 `maxStackSize` 무시 되는 실행 파일 헤더에 지정 된 스택 크기는 데 사용 됩니다.       매우 작은 스택 크기를 지정 하면 스택 오버플로 검색을 사용 하지 않도록 설정 해야 합니다. 스택에 엄격 하 게 제한 하는 경우 찾기 자체 지정 하면 스택 오버플로가 발생 했습니다. 스택 오버플로 검색을 사용 하지 않으려면 다음 응용 프로그램 구성 파일을 추가 합니다.      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "A <xref href=&quot;System.Threading.ParameterizedThreadStart&quot;> </xref> 이 스레드의 실행이 시작 될 때 호출 될 메서드를 나타내는 대리자입니다."
    - id: maxStackSize
      type: System.Int32
      description: "최대 스택 크기 (바이트)를 실행 파일에 대 한 헤더에 지정 된 기본 최대 스택 크기를 사용 하는 스레드 또는 0에서 사용할 수 있습니다.       중요 한 부분적으로 신뢰할 수 있는 코드, `maxStackSize` 기본 스택 크기 보다 큰 경우 무시 됩니다. 예외가 throw 되지 않습니다."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>가&0; 보다 작습니다."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  id: '#ctor(System.Threading.ThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Threading.Thread&quot;> </xref> 스레드의 최대 스택 크기를 지정 하는 클래스입니다."
  remarks: "이 생성자 오버 로드를 사용 하지 마십시오. 사용 하는 기본 스택 크기는 <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>생성자 오버 로드는 스레드에 대 한 권장된 스택 크기.</xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> 스레드가 메모리 문제가 발생 하는 경우는 가장 일반적인 원인은 프로그래밍 무한 재귀 같은 오류입니다.      > [!IMPORTANT] > 부터는 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]코드 설정할 수 있습니다 완전히 신뢰할 수 있는, `maxStackSize` (1mb)의 기본 스택 크기 보다 큰 값으로. 더 큰 값을 지정 하는 경우 `maxStackSize` 코드가 부분 신뢰로 실행 되 고 때 `maxStackSize` 는 무시 됩니다 기본 스택 크기는 데 사용 됩니다. 예외가 throw 되지 않습니다. 코드 모든 신뢰 수준에서 설정할 수 있습니다 `maxStackSize` 기본 스택 크기 보다 작은 값으로.      > [!NOTE] > 경우 부분적으로 신뢰할 수 있는 코드에 의해 사용 될 완전히 신뢰할 수 있는 라이브러리를 개발 하는 고 큰 스택이 필요로 하는 스레드를 시작 해야 할 스레드를 만들기 전에 완전 신뢰를 어설션해야 또는 기본 스택 크기를 사용 됩니다. 스레드에서 실행 되는 코드를 완벽 하 게 제어 하지 않는 한에 이렇게 하지 마십시오.       경우 `maxStackSize` 작으면 최소 스택 크기 보다 최소 스택 크기가 사용 됩니다. 경우 `maxStackSize` 배수가 아닙니다. 페이지 크기의 큰 페이지 크기의 배수로 반올림 됩니다. 예를 들어.NET Framework 버전 2.0은 Windows vista를 사용 하는 256KB (262, 144 바이트)는 최소 스택 크기 및 페이지 크기는 64KB (65536 바이트)입니다.      > [!NOTE] > Windows XP 및 Windows Server 2003 이전 버전에서 `maxStackSize` 무시 되는 실행 파일 헤더에 지정 된 스택 크기는 데 사용 됩니다.       매우 작은 스택 크기를 지정 하면 스택 오버플로 검색을 사용 하지 않도록 설정 해야 합니다. 스택에 엄격 하 게 제한 하는 경우 찾기 자체 지정 하면 스택 오버플로가 발생 했습니다. 스택 오버플로 검색을 사용 하지 않으려면 다음 응용 프로그램 구성 파일을 추가 합니다.      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "A <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> 이 스레드의 실행이 시작 될 때 호출 될 메서드를 나타내는 대리자입니다."
    - id: maxStackSize
      type: System.Int32
      description: "최대 스택 크기 (바이트)를 실행 파일에 대 한 헤더에 지정 된 기본 최대 스택 크기를 사용 하는 스레드 또는 0에서 사용할 수 있습니다.       중요 한 부분적으로 신뢰할 수 있는 코드, `maxStackSize` 기본 스택 크기 보다 큰 경우 무시 됩니다. 예외가 throw 되지 않습니다."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>가&0; 보다 작습니다."
  platform:
  - net462
- uid: System.Threading.Thread.Abort
  id: Abort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "발생 한 <xref href=&quot;System.Threading.ThreadAbortException&quot;> </xref> 있는 메서드가 호출, 스레드 종료 프로세스를 시작 하려면 스레드에서 합니다. 일반적으로이 메서드를 호출 스레드를 종료 합니다."
  remarks: "이 메서드는 스레드에서 호출 되 면 시스템은 throw <xref:System.Threading.ThreadAbortException>에서 스레드를 중단 합니다.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`응용 프로그램 코드에서 사용할 수 있는 특별 한 예외가 있지만 끝날 때 다시 throw 된 `catch` 차단 하지 않는 한 <xref:System.Threading.Thread.ResetAbort%2A>호출 됩니다.</xref:System.Threading.Thread.ResetAbort%2A> `ResetAbort`중단을 요청을 취소 하 고 방지는 `ThreadAbortException` 의 스레드를 종료 합니다. 실행 되지 않은 `finally` 블록 스레드가 중단 되기 전에 실행 됩니다.      > [!NOTE] > 호출 하면 스레드 `Abort` 효과 자기 비슷합니다 자체에 <xref:System.Threading.ThreadAbortException>즉시 발생 하는 결과 예측 가능한.</xref:System.Threading.ThreadAbortException> 그러나 한 스레드가 `Abort` 다른 스레드에서 abort 인터럽트 모든 코드가 실행 되 고 있습니다. 정적 생성자를 중단 될 수 있는 기회 이기도 합니다. 드문 경우에서 해당 클래스의 인스턴스로 해당 응용 프로그램 도메인에서 생성 되지 못할 수도 있습니다. .NET Framework 버전 1.0 및 1.1은 스레드가 중단 수 있는 기회 동안는 `finally` 블록이 실행 되는 경우, 고 `finally` 블록이 중단 됩니다.       스레드가 즉시 또는 전혀 중단 보장 되지 않습니다. 스레드 제한 없는에 계산의 경우 이러한 상황이 발생할 수 있습니다는 `finally` 무한정 중단이 지연 되는 중단 절차의 일부분으로 호출 된 합니다. 스레드가 중단 될 때까지 기다려야 호출할 수 있습니다는 <xref:System.Threading.Thread.Join%2A>Abort 메서드를 호출한 후 스레드에서 메서드가 있지만 될 보장 되지 않습니다.</xref:System.Threading.Thread.Join%2A>      > [!NOTE] > 중단 중인 스레드가 코드의 보호 된 영역에 같은 이면 Abort를 호출 하는 스레드를 차단할 수는 `catch` 블록 `finally` 블록 또는 제약이 있는 실행 영역입니다. Abort를 호출 하는 스레드가 중단 된 스레드 필요한 잠금을 유지 하는 경우 교착 상태가 발생할 수 있습니다.       경우 `Abort` 라고 시작 되지 않은 스레드에서 스레드가 될 때 중단 됩니다 <xref:System.Threading.Thread.Start%2A>호출 됩니다.</xref:System.Threading.Thread.Start%2A> 경우 `Abort` 라고 차단 되었거나 대기 중인 스레드에 스레드가 중단 되며 완전히 중단 됩니다.       경우 `Abort` 중단 된 스레드에서 호출는 <xref:System.Threading.ThreadStateException>호출 스레드에서 throw 되 <xref:System.Threading.Thread.Abort%2A>, 및 <xref:System.Threading.ThreadState>에 추가 되는 <xref:System.Threading.Thread.ThreadState%2A>중단 중인 스레드 속성입니다.</xref:System.Threading.Thread.ThreadState%2A> </xref:System.Threading.ThreadState> </xref:System.Threading.Thread.Abort%2A> </xref:System.Threading.ThreadStateException> A <xref:System.Threading.ThreadAbortException>될 때까지 일시 중단 된 스레드에서 throw 되지 <xref:System.Threading.Thread.Resume%2A>호출 됩니다.</xref:System.Threading.Thread.Resume%2A> </xref:System.Threading.ThreadAbortException>       경우 `Abort` 비관리 코드를 실행 하는 동안 관리 되는 스레드에서 호출 됩니다는 `ThreadAbortException` 스레드가 관리 코드에 반환 될 때까지 throw 되지 않습니다.       두 번 호출 하는 경우 `Abort` 제공 같은 시간에 대해 불가능 한 상태 정보를 설정 하는 한 번 호출 하 고 실행 하 고 다른 호출에서 `Abort`합니다. 그러나 응용 프로그램이이 상황을 검색할 수 없습니다.       후 `Abort` 호출 되는 스레드에서 스레드의 상태를 <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> 포함 성공적으로 호출의 결과로 스레드가 종료 후 `Abort`, <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> 변경 되는 스레드의 상태 충분 한 권한이 있는 스레드는의 대상이 되는 `Abort` 사용 하 여 중단을 취소할 수는 `ResetAbort` 메서드. 에 대 한 호출을 보여 주는 예제는 `ResetAbort` 메서드를 참조는 `ThreadAbortException` 클래스입니다."
  syntax:
    content: public void Abort ();
    parameters: []
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "중단 중인 스레드가 현재 일시 중단 합니다."
  platform:
  - net462
- uid: System.Threading.Thread.Abort(System.Object)
  id: Abort(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "발생 한 <xref href=&quot;System.Threading.ThreadAbortException&quot;> </xref> 있는 메서드가 호출, 스레드 종료에 대 한 예외 정보를 제공 하는 동시 스레드 종료 프로세스를 시작 하려면 스레드에서 합니다. 일반적으로이 메서드를 호출 스레드를 종료 합니다."
  remarks: "이 메서드는 스레드에서 호출 되 면 시스템은 throw <xref:System.Threading.ThreadAbortException>에서 스레드를 중단 합니다.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`응용 프로그램 코드에서 사용할 수 있는 특별 한 예외가 있지만 끝날 때 다시 throw 된 `catch` 차단 하지 않는 한 <xref:System.Threading.Thread.ResetAbort%2A>호출 됩니다.</xref:System.Threading.Thread.ResetAbort%2A> `ResetAbort`중단을 요청을 취소 하 고 방지는 `ThreadAbortException` 의 스레드를 종료 합니다. 실행 되지 않은 `finally` 블록 스레드가 중단 되기 전에 실행 됩니다.      > [!NOTE] > 호출 하면 스레드 `Abort` 효과 자기 비슷합니다 자체에 <xref:System.Threading.ThreadAbortException>즉시 발생 하는 결과 예측 가능한.</xref:System.Threading.ThreadAbortException> 그러나 한 스레드가 `Abort` 다른 스레드에서 abort 인터럽트 모든 코드가 실행 되 고 있습니다. 수 있으므로 정적 생성자를 중단할 수 없습니다. 드문 경우에서 해당 클래스의 인스턴스로 해당 응용 프로그램 도메인에서 생성 되지 못할 수도 있습니다. .NET Framework 버전 1.0 및 1.1은 스레드가 중단 수 있는 기회 동안는 `finally` 블록이 실행 되는 경우, 고 `finally` 블록이 중단 됩니다.       스레드가 즉시 또는 전혀 중단 보장 되지 않습니다. 스레드 제한 없는에 계산의 경우 이러한 상황이 발생할 수 있습니다는 `finally` 무한정 중단이 지연 되는 중단 절차의 일부분으로 호출 된 합니다. 스레드가 중단 될 때까지 기다려야 호출할 수 있습니다는 <xref:System.Threading.Thread.Join%2A>Abort 메서드를 호출한 후 스레드에서 메서드가 있지만 될 보장 되지 않습니다.</xref:System.Threading.Thread.Join%2A>      > [!NOTE] > 호출 하는 스레드에서 <xref:System.Threading.Thread.Abort%2A>중단 중인 스레드가 코드의 보호 된 영역에 같은 경우를 차단할 수는 `catch` 블록 `finally` 블록 또는 제약이 있는 실행 영역.</xref:System.Threading.Thread.Abort%2A> 호출 하는 스레드가 <xref:System.Threading.Thread.Abort%2A>잠금이 중단 된 스레드 필요한 교착 상태가 발생할 수 있습니다.</xref:System.Threading.Thread.Abort%2A>       경우 `Abort` 라고 시작 되지 않은 스레드에서 스레드가 될 때 중단 됩니다 <xref:System.Threading.Thread.Start%2A>호출 됩니다.</xref:System.Threading.Thread.Start%2A> 경우 `Abort` 라고 차단 되었거나 대기 중인 스레드에 스레드가 중단 되며 완전히 중단 됩니다.       경우 `Abort` 중단 된 스레드에서 호출는 <xref:System.Threading.ThreadStateException>호출 스레드에서 throw 되 <xref:System.Threading.Thread.Abort%2A>, 및 <xref:System.Threading.ThreadState>에 추가 되는 <xref:System.Threading.Thread.ThreadState%2A>중단 중인 스레드 속성입니다.</xref:System.Threading.Thread.ThreadState%2A> </xref:System.Threading.ThreadState> </xref:System.Threading.Thread.Abort%2A> </xref:System.Threading.ThreadStateException> A <xref:System.Threading.ThreadAbortException>될 때까지 일시 중단 된 스레드에서 throw 되지 <xref:System.Threading.Thread.Resume%2A>호출 됩니다.</xref:System.Threading.Thread.Resume%2A> </xref:System.Threading.ThreadAbortException>       경우 `Abort` 비관리 코드를 실행 하는 동안 관리 되는 스레드에서 호출 됩니다는 `ThreadAbortException` 스레드가 관리 코드에 반환 될 때까지 throw 되지 않습니다.       두 번 호출 하는 경우 `Abort` 제공 같은 시간에 대해 불가능 한 상태 정보를 설정 하는 한 번 호출 하 고 실행 하 고 다른 호출에서 `Abort`합니다. 그러나 응용 프로그램이이 상황을 검색할 수 없습니다.       후 `Abort` 호출 되는 스레드에서 스레드의 상태를 <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> 포함 성공적으로 호출의 결과로 스레드가 종료 후 `Abort`, <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> 변경 되는 스레드의 상태 충분 한 권한이 있는 스레드는의 대상이 되는 `Abort` 사용 하 여 중단을 취소할 수는 `ResetAbort` 메서드. 에 대 한 호출을 보여 주는 예제는 `ResetAbort` 메서드를 참조는 `ThreadAbortException` 클래스입니다."
  example:
  - "The following code example shows how to pass information to a thread that is being aborted.  \n  \n [!code-cs[System.Threading.Thread.Abort2#1](~/add/codesnippet/csharp/m-system.threading.threa_12_1.cs)]\n [!code-cpp[System.Threading.Thread.Abort2#1](~/add/codesnippet/cpp/m-system.threading.threa_12_1.cpp)]\n [!code-vb[System.Threading.Thread.Abort2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_12_1.vb)]"
  syntax:
    content: public void Abort (object stateInfo);
    parameters:
    - id: stateInfo
      type: System.Object
      description: "상태와 같이 중단 중인 스레드에서 사용할 수 있는 응용 프로그램 관련 정보를 포함 하는 개체입니다."
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "중단 중인 스레드가 현재 일시 중단 합니다."
  platform:
  - net462
- uid: System.Threading.Thread.AllocateDataSlot
  id: AllocateDataSlot
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "모든 스레드에 대 한 명명 되지 않은 데이터 슬롯을 할당 합니다. 성능 향상을 위해 표시 된 필드를 사용 하 여는 <xref:System.ThreadStaticAttribute>특성을 대신 합니다.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 <xref:System.ThreadStaticAttribute>특성) 및 데이터 슬롯.</xref:System.ThreadStaticAttribute> 스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다. TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/add/includes/ajax-current-ext-md.md)합니다.       슬롯 모든 스레드가 할당 됩니다.       스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다. 공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다. 스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드가 만료 된 후 다시 사용 하기 위해 슬롯을 해제 합니다. 데이터 슬롯은 스레드당 고유 합니다. 다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_16_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_16_1.cpp)]  \n  \n **Second Example**  \n  \n The following code example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_16_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_16_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateDataSlot ();
    parameters: []
    return:
      type: System.LocalDataStoreSlot
      description: "할당 된 명명 된 모든 스레드에서 데이터 슬롯입니다."
  overload: System.Threading.Thread.AllocateDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  id: AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "모든 스레드에 명명 된 데이터 슬롯을 할당 합니다. 성능 향상을 위해 표시 된 필드를 사용 하 여는 <xref:System.ThreadStaticAttribute>특성을 대신 합니다.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 <xref:System.ThreadStaticAttribute>특성) 및 데이터 슬롯.</xref:System.ThreadStaticAttribute> 스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다. TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/add/includes/ajax-current-ext-md.md)합니다.       스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다. 공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다. 스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드가 만료 된 후 다시 사용 하기 위해 슬롯을 해제 합니다. 데이터 슬롯은 스레드당 고유 합니다. 다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다.       되었기 때문에 명명 된 데이터 슬롯을 할당 하려면 AllocateNamedDataSlot 메서드를 사용 하는 데 필요한는 <xref:System.Threading.Thread.GetNamedDataSlot%2A>메서드가 아직 할당 되지 않은 경우 슬롯을 할당 합니다.</xref:System.Threading.Thread.GetNamedDataSlot%2A>      > [!NOTE] > AllocateNamedDataSlot 메서드를 사용 하는 경우 호출 해야 프로그램을 시작할 때 주 스레드에서 지정 된 이름의 슬롯이 이미 할당 되어 있으면 예외를 throw 하기 때문에 있습니다. 슬롯이 이미 할당 되어 있는지 여부를 테스트 방식은 없습니다.       이 메서드를 사용 하 여 할당 슬롯 <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</xref:System.Threading.Thread.FreeNamedDataSlot%2A> 해제 해야 합니다."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_7_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_7_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n> [!NOTE]\n>  The example code does not use the AllocateNamedDataSlot method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated. If the AllocateNamedDataSlot method is used, it should be called in the main thread at program startup.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_7_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_7_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "할당할 데이터 슬롯의 이름입니다."
    return:
      type: System.LocalDataStoreSlot
      description: "할당 된 명명 된 모든 스레드에서 데이터 슬롯입니다."
  overload: System.Threading.Thread.AllocateNamedDataSlot*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "지정 된 이름 가진 명명 된 데이터 슬롯이 이미 있습니다."
  platform:
  - net462
- uid: System.Threading.Thread.ApartmentState
  id: ApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "이 스레드의 아파트 상태를 가져오거나 설정 합니다."
  remarks: "**ApartmentState 속성은 사용 되지 않습니다.**  대체 방법은 사용 되는 <xref:System.Threading.Thread.GetApartmentState%2A>아파트 상태를 검색 하는 메서드 및 <xref:System.Threading.Thread.SetApartmentState%2A>아파트 상태를 설정 하는 방법은.</xref:System.Threading.Thread.SetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>       .NET Framework 버전 1.0 및 1.1에서는 `ApartmentState` 속성은 스레드가 단일 스레드 또는 다중 스레드 아파트에서 실행 될를 표시 합니다. 이 속성은 스레드가 때 설정할 수 있습니다는 `Unstarted` 또는 `Running` 스레드 상태; 그러나 설정할 수 있습니다 한 번만 스레드에 대 한 합니다. 반환 하는 경우 속성에 설정 되어 있지 `Unknown`합니다.       아파트 상태가 이미 설정 되어 스레드의 아파트 상태를 설정 하려면 ApartmentState 속성을 사용 하도록 시도 무시 됩니다. 그러나는 <xref:System.Threading.Thread.SetApartmentState%2A>메서드가 throw 한 <xref:System.InvalidOperationException>이 예제의.</xref:System.InvalidOperationException> </xref:System.Threading.Thread.SetApartmentState%2A>      > [!IMPORTANT] >에서.NET Framework 버전 2.0에서 새 스레드로 초기화 됩니다 <xref:System.Threading.ApartmentState?displayProperty=fullName>아파트 상태 설정 있지 않은 경우 되어 시작 되기 전에.</xref:System.Threading.ApartmentState?displayProperty=fullName> 기본 응용 프로그램 스레드도 초기화 됩니다 <xref:System.Threading.ApartmentState?displayProperty=fullName>기본적으로.</xref:System.Threading.ApartmentState?displayProperty=fullName> 기본 응용 프로그램 스레드를 더 이상 설정할 수 없습니다 <xref:System.Threading.ApartmentState?displayProperty=fullName>설정 하 여는 <xref:System.Threading.ApartmentState?displayProperty=fullName>코드의 첫 번째 줄에는 속성.</xref:System.Threading.ApartmentState?displayProperty=fullName> </xref:System.Threading.ApartmentState?displayProperty=fullName> 사용 하 여 <xref:System.STAThreadAttribute>대신.</xref:System.STAThreadAttribute>       .NET Framework 버전 2.0에서에서의 COM 스레딩 모델이 사용 하 여 c + + 응용 프로그램에 대 한를 지정할 수 있습니다는 [/CLRTHREADATTRIBUTE (CLR 스레드 특성 설정)](~/add/includes/ajax-current-ext-md.md) 링커 옵션입니다."
  example:
  - "The following code example demonstrates how to set the apartment state of a thread.  \n  \n [!code-cs[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/csharp/p-system.threading.threa_8_1.cs)]\n [!code-cpp[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/cpp/p-system.threading.threa_8_1.cpp)]\n [!code-vb[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_8_1.vb)]"
  syntax:
    content: public System.Threading.ApartmentState ApartmentState { get; set; }
    return:
      type: System.Threading.ApartmentState
      description: "중 하나는 <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> 값입니다. 초기 값은 <xref uid=&quot;langword_csharp_Unknown&quot; name=&quot;Unknown&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Threading.Thread.ApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "잘못 된 아파트 상태가 되지 않는 상태로이 속성을 설정 하려고 시도 (단일 스레드 아파트 이외의 상태 (<xref uid=&quot;langword_csharp_STA&quot; name=&quot;STA&quot; href=&quot;&quot;></xref>) 또는 다중 스레드 아파트 (<xref uid=&quot;langword_csharp_MTA&quot; name=&quot;MTA&quot; href=&quot;&quot;></xref>))."
  platform:
  - net462
- uid: System.Threading.Thread.BeginCriticalRegion
  id: BeginCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "입력 스레드 중단 또는 처리 되지 않은 예외는 응용 프로그램 도메인에서 다른 작업을 위협할 수 코드 영역이 실행 될 호스트에 알립니다."
  remarks: "Microsoft SQL Server 2005와 같은 공용 언어 런타임 (CLR)의 호스트에는 코드의 중요 하 고 중요 하지 않은 영역에서 발생 한 실패에 대해 다른 정책을 설정할 수 있습니다. 중요 한 영역을는 하는 스레드 중단 또는 처리 되지 않은 예외가 국한 되지 않는 현재 작업에 하나입니다. 반면, 한 중단 이나 오류 코드는 중요 하지 않은 영역에서 오류가 발생 하는 작업을만 영향을 줍니다.       예를 들어 잠금을 보유 하는 동안 메모리를 할당 하려고 시도 하는 작업을 살펴보겠습니다. 메모리 할당이 실패 하면 현재 작업이 중단 만으로는의 안정성을 보장 하는 <xref:System.AppDomain>도메인에 동일한 잠금을 대기 하는 다른 작업이 있을 수 있으므로,.</xref:System.AppDomain> 현재 작업이 종료 되는 경우 다른 작업 교착 상태가 될 수 없습니다.       중요 한 영역에서 오류가 발생 하는 경우 호스트는 전체 언로드 결정할 수 <xref:System.AppDomain>하지 않고는 잠재적으로 불안정 한 상태에서 실행을 계속 위험.</xref:System.AppDomain> 코드의 중요 영역 시작 하는 호스트에 제공, BeginCriticalRegion를 호출 합니다. 호출 <xref:System.Threading.Thread.EndCriticalRegion%2A>실행 중요 하지 않은 코드 영역을 반환 하는 경우.</xref:System.Threading.Thread.EndCriticalRegion%2A>       이 메서드를 사용 하 여 SQL Server 2005에서 실행 되는 코드에서 가장 높은 호스트 보호 수준에서 실행할 코드를 필요 합니다."
  example:
  - "The following example demonstrates the use of the BeginCriticalRegion and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_5_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_5_1.vb)]"
  syntax:
    content: public static void BeginCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.BeginCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.BeginThreadAffinity
  id: BeginThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "관리 코드는 호스트를 현재 실제 운영 체제 스레드의 id에 종속 되는 명령을 실행 하려고에 알립니다."
  remarks: "Microsoft SQL Server 2005 등 공용 언어 런타임의 일부 호스트는 고유한 스레드 관리를 제공합니다. 고유한 스레드 관리를 제공 하는 호스트 간에 이동할 수는 실행 중인 작업 실제 운영 체제 스레드 간에 언제 든 지 합니다. 이 전환 하 여 대부분의 작업 영향을 받지 않습니다. 그러나 일부 작업에는 스레드 선호도-즉, 실제 운영 체제 스레드의 id에 종속 됩니다. 이러한 작업은 코드를 안을 실행 하는 동안 호스트에 게 알려야 합니다.       예를 들어 응용 프로그램이 시스템에서 Win32 CRITICAL_SECTION 같은 스레드 선호도 있는 운영 체제 잠금을 획득 하는 API를 호출 하는 경우 호출 해야 BeginThreadAffinity 잠금을 획득 하기 전에 및 <xref:System.Threading.Thread.EndThreadAffinity%2A>잠금을 해제 한 후.</xref:System.Threading.Thread.EndThreadAffinity%2A>       이 메서드를 사용 하 여 SQL Server 2005에서 실행 되는 코드에서 가장 높은 호스트 보호 수준에서 실행할 코드를 필요 합니다."
  example:
  - "The following example demonstrates the use of the BeginThreadAffinity and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_0_1.vb)]"
  syntax:
    content: public static void BeginThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.BeginThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentContext
  id: CurrentContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "스레드가 실행 중인 현재 컨텍스트를 가져옵니다."
  syntax:
    content: public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }
    return:
      type: System.Runtime.Remoting.Contexts.Context
      description: "A <xref href=&quot;System.Runtime.Remoting.Contexts.Context&quot;> </xref> 현재 스레드 컨텍스트를 나타내는입니다."
  overload: System.Threading.Thread.CurrentContext*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentCulture
  id: CurrentCulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "현재 스레드 culture를 가져오거나 설정 합니다."
  remarks: "<xref:System.Globalization.CultureInfo>날짜에 대 한 기본 형식, 시간, 숫자, 통화 값, 텍스트의 순서 정렬, 대/소문자 규칙을 확인 하 고 문자열을 비교 하는 연결된 된 개체와 함께이 속성에서 반환 되는 개체입니다.</xref:System.Globalization.CultureInfo> 참조는 <xref:System.Globalization.CultureInfo>문화권 이름 및 식별자, 고정, 중립 및 특정 문화권 간의 차이점에 대 한 자세한 내용은 클래스와 스레드 및 응용 프로그램 도메인 방식으로 문화권 정보에 영향을 줍니다.</xref:System.Globalization.CultureInfo> 참조는 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>속성 스레드의 기본 문화권을 결정 하는 방법 및 사용자가 자신의 컴퓨터에 대 한 문화권 정보를 설정 하는 방법을 알아보려면.</xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>       부터는 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], 중립 문화권을 CurrentCulture 속성을 설정할 수 있습니다. ¿¡´의 동작은 <xref:System.Globalization.CultureInfo>클래스가 변경 된: 때 중립 문화권에 해당 속성 값을 나타냅니다 (특히는 <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, 및 <xref:System.Globalization.CultureInfo.TextInfo%2A>속성) 이제 중립 문화권 연관 된 특정 문화권을 반영 합니다.</xref:System.Globalization.CultureInfo.TextInfo%2A> </xref:System.Globalization.CultureInfo.NumberFormat%2A> </xref:System.Globalization.CultureInfo.DateTimeFormat%2A> </xref:System.Globalization.CultureInfo.CompareInfo%2A> </xref:System.Globalization.CultureInfo.Calendar%2A> </xref:System.Globalization.CultureInfo> CurrentCulture 속성에서.NET Framework의 이전 버전에서는 <xref:System.NotSupportedException>중립 문화권 할당 하는 동안 예외가 발생 했습니다.</xref:System.NotSupportedException>"
  example:
  - "The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_3_1.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentCulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "현재 스레드 문화권을 나타내는 개체입니다."
  overload: System.Threading.Thread.CurrentCulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "속성이로 설정 되어 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentPrincipal
  id: CurrentPrincipal
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "스레드의 현재 보안 주체 (역할 기반 보안)을 가져오거나 설정 합니다."
  remarks: ''
  example:
  - "The following code example shows how to set and retrieve the principal of a thread.  \n  \n [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/cpp/p-system.threading.threa_11_1.cpp)]\n [!code-cs[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/csharp/p-system.threading.threa_11_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/visualbasic/p-system.threading.threa_11_1.vb)]"
  syntax:
    content: public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }
    return:
      type: System.Security.Principal.IPrincipal
      description: "<xref:System.Security.Principal.IPrincipal>보안 컨텍스트를 나타내는 값입니다.</xref:System.Security.Principal.IPrincipal>"
  overload: System.Threading.Thread.CurrentPrincipal*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 보안 주체를 설정 하는 데 필요한 사용 권한이 없습니다."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentThread
  id: CurrentThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "현재 실행 중인 스레드를 가져옵니다."
  remarks: ''
  example:
  - "The following example creates a task that in turn creates 20 child tasks. The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the CurrentThread property  to display information about the thread on which it is running.  \n  \n [!code-vb[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_1_1.vb)]\n [!code-cs[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/csharp/p-system.threading.threa_1_1.cs)]  \n  \n Each child task generates 1 million random numbers between 1 and 1 million and returns their mean. The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.  \n  \n Note that while the application runs on a foreground thread, each task runs on a thread pool thread."
  syntax:
    content: public static System.Threading.Thread CurrentThread { get; }
    return:
      type: System.Threading.Thread
      description: "A <xref href=&quot;System.Threading.Thread&quot;> </xref> 현재 실행 중인 스레드의 표현입니다."
  overload: System.Threading.Thread.CurrentThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.CurrentUICulture
  id: CurrentUICulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "리소스 관리자가 런타임 시 문화권별 리소스를 찾기 위해 사용 되는 현재 문화권을 가져오거나 설정 합니다."
  remarks: "The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture. See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains. See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> property to learn how a thread's default UI culture is determined.  \n  \n The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture. Neutral cultures should not be used with formatting methods such as [String.Format(IFormatProvider, String, Object\\[\\])](assetId:///M:System.String.Format(System.IFormatProvider,System.String,System.Object[])?qualifyHint=True&autoUpgrade=False), <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=fullName>. Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.  \n  \n> [!NOTE]\n>  The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method throws <xref:System.ArgumentException> for the neutral cultures \"zh-Hant\" (\"zh-CHT\") and \"zh-Hans\" (\"zh-CHS\")."
  example:
  - "The following example determines whether the language of the current thread's UI culture is French. If it is not, it sets the UI culture of the current thread to English (United States).  \n  \n [!code-cs[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_1.vb)]  \n  \n The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_2_2.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_2.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_2.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentUICulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "현재 문화권을 나타내는 개체입니다."
  overload: System.Threading.Thread.CurrentUICulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "속성이로 설정 되어 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "속성이는 리소스 파일을 찾는 데 사용할 수 없는 문화권 이름으로 설정 됩니다. 리소스 파일 이름에는 문자, 숫자, 하이픈 또는 밑줄만 포함 해야 합니다."
  platform:
  - net462
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  id: DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  langs:
  - csharp
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "현재 스레드에 대 한 런타임 호출 가능 래퍼 (RCW)의 자동 정리를 해제합니다."
  remarks: "기본적으로 공용 언어 런타임 (CLR) 런타임 호출 가능 래퍼 자동으로 정리 합니다. CLR 비정상적인는 다음 조건을 충족 하는 몇 가지 응용 프로그램에서 재진입 문제를 일으킬 수 있는 정리 하는 동안 메시지를 펌핑:-응용 프로그램 자체 메시지 펌프를 수행 합니다.      -응용 프로그램 메시지 펌핑이 발생 하는 경우에 정확 하 게 제어 해야 합니다.       이러한 응용 프로그램 DisableComObjectEagerCleanup 메서드를 사용 하 여 CLR 런타임 호출 가능 래퍼를 자동으로 회수 것는 것을 방지 수 있습니다.       스레드에서이 메서드를 호출 하는 경우 자동 정리를 해당 스레드에 대 한 다시 활성화 수 없습니다. 사용 하 여 응용 프로그램 런타임 호출 가능 래퍼를 정리 하도록 준비 되 면는 <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName>메서드를 현재 컨텍스트의 모든 런타임 호출 가능 래퍼를 정리 하도록 런타임에 지시 합니다.</xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName> 메시지 펌프 메서드가 실행 하는 동안 발생 합니다."
  syntax:
    content: public void DisableComObjectEagerCleanup ();
    parameters: []
  overload: System.Threading.Thread.DisableComObjectEagerCleanup*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndCriticalRegion
  id: EndCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "입력 스레드 중단 또는 처리 되지 않은 예외가 현재 작업에 만된 있는 코드 영역이 실행 될 호스트에 알립니다."
  remarks: "Microsoft SQL Server 2005와 같은 공용 언어 런타임 (CLR)의 호스트에는 코드의 중요 하 고 중요 하지 않은 영역에서 발생 한 실패에 대해 다른 정책을 설정할 수 있습니다. 중요 한 영역을는 하는 스레드 중단 또는 처리 되지 않은 예외가 국한 되지 않는 현재 작업에 하나입니다. 반면, 한 중단 이나 오류 코드는 중요 하지 않은 영역에서 오류가 발생 하는 작업을만 영향을 줍니다.       예를 들어 잠금을 보유 하는 동안 메모리를 할당 하려고 시도 하는 작업을 살펴보겠습니다. 메모리 할당이 실패 하면 현재 작업이 중단 만으로는의 안정성을 보장 하는 <xref:System.AppDomain>도메인에 동일한 잠금을 대기 하는 다른 작업이 있을 수 있으므로,.</xref:System.AppDomain> 현재 작업이 종료 되는 경우 다른 작업 교착 상태가 될 수 없습니다.       중요 한 영역에서 오류가 발생 하는 경우 호스트는 전체 언로드 결정할 수 <xref:System.AppDomain>하지 않고는 잠재적으로 불안정 한 상태에서 실행을 계속 위험.</xref:System.AppDomain> 코드의 중요 영역 시작 하는 호스트에 제공, <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</xref:System.Threading.Thread.BeginCriticalRegion%2A> 호출 중요 하지 않은 코드 영역이 실행이 반환 하는 경우 EndCriticalRegion를 호출 합니다.       이 메서드를 사용 하 여 SQL Server 2005에서 실행 되는 코드에서 가장 높은 호스트 보호 수준에서 실행할 코드를 필요 합니다."
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and EndCriticalRegion methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_1_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_1_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_1_1.vb)]"
  syntax:
    content: public static void EndCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.EndCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndThreadAffinity
  id: EndThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "관리 코드는 호스트의 현재 실제 운영 체제 스레드의 id에 종속 되는 명령의 실행을 완료 했음을 알립니다."
  remarks: "Microsoft SQL Server 2005 등 공용 언어 런타임의 일부 호스트는 고유한 스레드 관리를 제공합니다. 고유한 스레드 관리를 제공 하는 호스트 간에 이동할 수는 실행 중인 작업 실제 운영 체제 스레드 간에 언제 든 지 합니다. 이 전환 하 여 대부분의 작업 영향을 받지 않습니다. 그러나 일부 작업에는 스레드 선호도-즉, 실제 운영 체제 스레드의 id에 종속 됩니다. 이러한 작업은 코드를 안을 실행 하는 동안 호스트에 게 알려야 합니다.       예를 들어, 스레드 선호도 Win32 CRITICAL_SECTION 갖는 응용 프로그램 호출 시스템 API를 운영 체제를 획득을 잠그는 경우에 호출 해야 <xref:System.Threading.Thread.BeginThreadAffinity%2A>잠금 및 EndThreadAffinity 잠금을 해제 한 후에 획득 하기 전에.</xref:System.Threading.Thread.BeginThreadAffinity%2A>       이 메서드를 사용 하 여 SQL Server 2005에서 실행 되는 코드에서 가장 높은 호스트 보호 수준에서 실행할 코드를 필요 합니다."
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and EndThreadAffinity methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_3_1.vb)]"
  syntax:
    content: public static void EndThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.EndThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  platform:
  - net462
- uid: System.Threading.Thread.ExecutionContext
  id: ExecutionContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "가져옵니다는 <xref:System.Threading.ExecutionContext>현재 스레드의 다양 한 컨텍스트 정보가 들어 있는 개체입니다.</xref:System.Threading.ExecutionContext>"
  remarks: "<xref:System.Threading.ExecutionContext>클래스는 실행의 논리적 스레드와 관련 된 모든 정보에 대 한 단일 컨테이너를 제공 합니다.</xref:System.Threading.ExecutionContext> 보안 컨텍스트, 호출 컨텍스트에, 동기화 컨텍스트, 지역화 컨텍스트 및 트랜잭션 컨텍스트가 포함 됩니다."
  syntax:
    content: public System.Threading.ExecutionContext ExecutionContext { get; }
    return:
      type: System.Threading.ExecutionContext
      description: "<xref:System.Threading.ExecutionContext>현재 스레드에 대 한 컨텍스트 정보를 통합 하는 개체입니다.</xref:System.Threading.ExecutionContext>"
  overload: System.Threading.Thread.ExecutionContext*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Finalize
  id: Finalize
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "리소스가 해제 되 고 가비지 수집기가 회수 하는 경우 다른 정리 작업이 수행 되도록는 <xref href=&quot;System.Threading.Thread&quot;> </xref> 개체입니다."
  remarks: "현재 개체가 종료 될 때 가비지 수집기에서 Finalize를 호출 합니다."
  syntax:
    content: ~Thread ();
    parameters: []
  overload: System.Threading.Thread.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  id: FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "이름 및 프로세스의 모든 스레드에 대 한 슬롯 간의 연관이 없앱니다. 성능 향상을 위해 표시 된 필드를 사용 하 여는 <xref:System.ThreadStaticAttribute>특성을 대신 합니다.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 <xref:System.ThreadStaticAttribute>특성) 및 데이터 슬롯.</xref:System.ThreadStaticAttribute> 스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다. TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/add/includes/ajax-current-ext-md.md)합니다.       호출 스레드에서 `FreeNamedDataSlot`를 호출 하는 다른 스레드가 <xref:System.Threading.Thread.GetNamedDataSlot%2A>이름이 같은 이름과 연결 된 새 슬롯을 할당 합니다.</xref:System.Threading.Thread.GetNamedDataSlot%2A> 에 대 한 후속 호출 `GetNamedDataSlot` 스레드에서 새 슬롯을 반환 합니다. 그러나 모든 스레드는 여전히에 <xref:System.LocalDataStoreSlot?displayProperty=fullName>한 이전 호출에서 반환 된 `GetNamedDataSlot` 계속는 이전 슬롯을 사용할 수 있습니다.</xref:System.LocalDataStoreSlot?displayProperty=fullName>       이름에 연결 되어 있는 슬롯 해제 될 경우에만 모든 `LocalDataStoreSlot` 호출 하기 전에 가져온 `FreeNamedDataSlot` 이 해제 되 고 가비지 수집 합니다.       스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다. 공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다. 스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드가 만료 된 후 다시 사용 하기 위해 슬롯을 해제 합니다. 데이터 슬롯은 스레드당 고유 합니다. 다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_9_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_9_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_9_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_9_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_2.vb)]"
  syntax:
    content: public static void FreeNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "해제할 데이터 슬롯의 이름입니다."
  overload: System.Threading.Thread.FreeNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetApartmentState
  id: GetApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "반환 된 <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> 아파트 상태를 나타내는 값입니다."
  remarks: "이 메서드를 함께 <xref:System.Threading.Thread.SetApartmentState%2A>메서드 및 <xref:System.Threading.Thread.TrySetApartmentState%2A>메서드를 대체는 <xref:System.Threading.Thread.ApartmentState%2A>속성.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.TrySetApartmentState%2A> </xref:System.Threading.Thread.SetApartmentState%2A>"
  example:
  - "The following code example demonstrates the GetApartmentState, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, GetApartmentState displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_11_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_11_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_11_1.cs)]"
  syntax:
    content: public System.Threading.ApartmentState GetApartmentState ();
    parameters: []
    return:
      type: System.Threading.ApartmentState
      description: "중 하나는 <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> 관리 되는 스레드의 아파트 상태를 나타내는 값입니다. 기본값은 <xref href=&quot;System.Threading.ApartmentState&quot;> </xref>합니다."
  overload: System.Threading.Thread.GetApartmentState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetCompressedStack
  id: GetCompressedStack
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "반환 된 <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> 현재 스레드 스택을 캡처하는 데 사용할 수 있습니다."
  remarks: "이 메서드는 더 이상 지원 됩니다."
  syntax:
    content: public System.Threading.CompressedStack GetCompressedStack ();
    parameters: []
    return:
      type: System.Threading.CompressedStack
      description: "없음."
  overload: System.Threading.Thread.GetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "모든 경우"
  platform:
  - net462
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  id: GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "현재 스레드의 도메인 내에서 현재 스레드의 지정된 된 슬롯에서 값을 검색 합니다. 성능 향상을 위해 표시 된 필드를 사용 하 여는 <xref:System.ThreadStaticAttribute>특성을 대신 합니다.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 <xref:System.ThreadStaticAttribute>특성) 및 데이터 슬롯.</xref:System.ThreadStaticAttribute> 스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다. TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/add/includes/ajax-current-ext-md.md)합니다.       스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다. 공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다. 스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드가 만료 된 후 다시 사용 하기 위해 슬롯을 해제 합니다. 데이터 슬롯은 스레드당 고유 합니다. 다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다.      > [!NOTE] > GetData는는 `Shared` 항상 다른 스레드를 참조 하는 변수를 사용 하 여 호출 하는 경우에 현재 실행 중인 스레드에 적용 되는 메서드. 혼동을 피하기 위해 사용 하 여 클래스 이름을 호출할 때 `Shared` 메서드: `Dim test As Object = Thread.GetData(testSlot)`합니다."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_27_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_27_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_27_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_27_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_2.vb)]"
  syntax:
    content: public static object GetData (LocalDataStoreSlot slot);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "<xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> 값을 얻을 수 있는 합니다."
    return:
      type: System.Object
      description: "검색 된 값입니다."
  overload: System.Threading.Thread.GetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomain
  id: GetDomain
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "현재 스레드가 실행 되 고 있는 현재 도메인을 반환 합니다."
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_29_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_29_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_29_1.cpp)]"
  syntax:
    content: public static AppDomain GetDomain ();
    parameters: []
    return:
      type: System.AppDomain
      description: "<xref href=&quot;System.AppDomain&quot;> </xref> 실행 중인 스레드의 현재 응용 프로그램 도메인을 나타내는입니다."
  overload: System.Threading.Thread.GetDomain*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomainID
  id: GetDomainID
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "고유한 응용 프로그램 도메인 식별자를 반환합니다."
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_17_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_17_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_17_1.cpp)]"
  syntax:
    content: public static int GetDomainID ();
    parameters: []
    return:
      type: System.Int32
      description: "응용 프로그램 도메인을 고유 하 게 식별 하는 32 비트 부호 있는 정수입니다."
  overload: System.Threading.Thread.GetDomainID*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetHashCode
  id: GetHashCode
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "현재 스레드에 대 한 해시 코드를 반환합니다."
  remarks: "해시 코드는 고유 하 게 보장 되지 않습니다. 사용 하 여는 <xref:System.Threading.Thread.ManagedThreadId%2A>관리 되는 스레드에 대 한 고유 식별자가 필요한 경우 속성을 사용 합니다.</xref:System.Threading.Thread.ManagedThreadId%2A>"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "정수 해시 코드 값입니다."
  overload: System.Threading.Thread.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  id: GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "명명된 된 데이터 슬롯을 찾습니다. 성능 향상을 위해 표시 된 필드를 사용 하 여는 <xref:System.ThreadStaticAttribute>특성을 대신 합니다.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 <xref:System.ThreadStaticAttribute>특성) 및 데이터 슬롯.</xref:System.ThreadStaticAttribute> 스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다. TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/add/includes/ajax-current-ext-md.md)합니다.       스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다. 공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다. 스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드가 만료 된 후 다시 사용 하기 위해 슬롯을 해제 합니다. 데이터 슬롯은 스레드당 고유 합니다. 다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다.       명명 된 슬롯 존재 하지 않는 경우 새 슬롯 할당 됩니다. 명명 된 데이터 슬롯은 공용 이며 다른 사용자에 의해 조작 될 수 있습니다."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_13_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_13_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_13_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_13_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot GetNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "로컬 데이터 슬롯의 이름입니다."
    return:
      type: System.LocalDataStoreSlot
      description: "A <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> 이 스레드에 대해 할당 된 합니다."
  overload: System.Threading.Thread.GetNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Interrupt
  id: Interrupt
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "에 있는 스레드를 중단 된 <xref uid=&quot;langword_csharp_WaitSleepJoin&quot; name=&quot;WaitSleepJoin&quot; href=&quot;&quot;> </xref> 스레드 상태입니다."
  remarks: "이 스레드가 대기, 대기 또는 조인 상태에 현재 차단 되지 않은 경우 차단 하는 다음 시작 될 때 중단 됩니다.       <xref:System.Threading.ThreadInterruptedException>중단된 된 스레드의에서 수행 되지만 해당 스레드는 차단 throw 됩니다.</xref:System.Threading.ThreadInterruptedException> 스레드가 차단 되지 않으면 예외가 throw 되지 및 스레드가 중단 없이 완료할 수 있으므로 합니다."
  example:
  - "The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.  \n  \n [!code-cpp[System.Threading.Thread.Interrupt#1](~/add/codesnippet/cpp/m-system.threading.threa_21_1.cpp)]\n [!code-vb[System.Threading.Thread.Interrupt#1](~/add/codesnippet/visualbasic/m-system.threading.threa_21_1.vb)]\n [!code-cs[System.Threading.Thread.Interrupt#1](~/add/codesnippet/csharp/m-system.threading.threa_21_1.cs)]"
  syntax:
    content: public void Interrupt ();
    parameters: []
  overload: System.Threading.Thread.Interrupt*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 적절 한 없는 <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Threading.Thread.IsAlive
  id: IsAlive
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "현재 스레드의 실행 상태를 나타내는 값을 가져옵니다."
  syntax:
    content: public bool IsAlive { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>이 스레드가 시작 되었는지을 하지 않았으면 정상적으로 종료 또는 중단 되었습니다. 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Threading.Thread.IsAlive*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.IsBackground
  id: IsBackground
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "스레드가 배경 스레드인지 여부를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "스레드는 백그라운드 스레드 이거나 포그라운드 스레드는. 백그라운드 스레드는 백그라운드 스레드 프로세스를 종료 하는 것을 금지 하지 않는 점을 제외 하 고 포그라운드 스레드를 동일 합니다. 프로세스에 속한 모든 포그라운드 스레드가 중단 되 면 공용 언어 런타임에서 프로세스를 끝냅니다. 나머지 모든 백그라운드 스레드 중단 되 고 완료 하지 마세요.       기본적으로 다음 스레드 포그라운드에서 실행 (즉, 해당 IsBackground 속성에서 반환 `false`):-기본 스레드 (또는 주 응용 프로그램 스레드).      -호출 하 여 만든 모든 스레드는 <xref:System.Threading.Thread>클래스 생성자.</xref:System.Threading.Thread>       기본적으로 백그라운드에서 실행 하는 다음 스레드 (즉, 해당 IsBackground 속성에서 반환 `true`):-스레드 풀 스레드는 런타임에서 유지 관리 되는 작업자 스레드의 풀 인 합니다. <xref:System.Threading.ThreadPool>클래스</xref:System.Threading.ThreadPool> 를 사용 하 여 스레드 풀에서 스레드 풀 및 일정 작업을 구성할 수 있습니다.          > [!NOTE] > 작업 기반 비동기 작업을 스레드 풀 스레드에서 자동으로 실행 합니다.      -비관리 코드에서 관리 되는 실행 환경에 들어가는 모든 스레드입니다."
  example:
  - "The following example contrasts the behavior of foreground and background threads. It creates a foreground thread and a background thread. The foreground thread keeps the process running until completes its `for` loop and terminates. However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.  \n  \n [!code-cs[System.Threading.Thread.IsBackground#1](~/add/codesnippet/csharp/p-system.threading.threa_7_1.cs)]\n [!code-cpp[System.Threading.Thread.IsBackground#1](~/add/codesnippet/cpp/p-system.threading.threa_7_1.cpp)]\n [!code-vb[System.Threading.Thread.IsBackground#1](~/add/codesnippet/visualbasic/p-system.threading.threa_7_1.vb)]"
  syntax:
    content: public bool IsBackground { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>이 스레드가 백그라운드 스레드 이거나 백그라운드 스레드가; 될 예정 이면 하는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Threading.Thread.IsBackground*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "스레드가 중지 되었습니다."
  platform:
  - net462
- uid: System.Threading.Thread.IsThreadPoolThread
  id: IsThreadPoolThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "스레드가 관리 되는 스레드 풀에 속하는지를 나타내는 값을 가져옵니다."
  remarks: "자세한 내용은 참조 [스레드 풀 관리](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following code example shows how to determine whether a thread is from the thread pool.  \n  \n [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/cpp/p-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/csharp/p-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_0_1.vb)]"
  syntax:
    content: public bool IsThreadPoolThread { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>이 스레드가 관리 되는 스레드 풀;에 속하는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Threading.Thread.IsThreadPoolThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Join
  id: Join
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "표준 COM 수행 하면서이 인스턴스가 나타내는 스레드가 종료 될 때까지 호출 스레드를 차단 하 고 <xref uid=&quot;langword_csharp_SendMessage&quot; name=&quot;SendMessage&quot; href=&quot;&quot;> </xref> 펌핑 합니다."
  remarks: "공간 연결은 스레드가 해당 조인 메서드는 완료 될 때까지 호출 스레드 (즉, 메서드를 호출 하는 스레드)를 차단 하는 동기화 방법을입니다. 이 메서드를 사용 하 여 스레드가 종료 되었는지 확인 합니다. 스레드가 종료 되지 않는 경우 호출자에 게는 무기한으로 차단 됩니다. 다음 예제에서는 `Thread1` 의 조인 메서드를 호출 하는 스레드 `Thread2`,으로 구독이 `Thread1` 될 때까지 차단 하려면 `Thread2` 완료 되었습니다.       [!code-cs[System.Threading.Thread.Join#1](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)][!code-vb[System.Threading.Thread.Join#1](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb) ] 스레드가 이미 종료 되는 경우 <xref:System.Threading.Thread.Join%2A>메서드가 즉시 반환 호출 됩니다.</xref:System.Threading.Thread.Join%2A>        > [!WARNING] >의 Join 메서드를 호출 하지 말아야는 <xref:System.Threading.Thread>현재 스레드에서 현재 스레드를 나타내는 개체입니다.</xref:System.Threading.Thread> 이렇게 하면 현재 스레드가 자체에 제한이 없음을,이 방법 변경 놓입니다 앱 <xref:System.Threading.ThreadState?displayProperty=fullName>.</xref:System.Threading.ThreadState?displayProperty=fullName> 포함 하도록 호출 스레드의 상태 호출할 수 없습니다 `Join` 중인 스레드에서 <xref:System.Threading.ThreadState?displayProperty=fullName>상태.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  syntax:
    content: public void Join ();
    parameters: []
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "호출자에 있는 스레드는 <xref href=&quot;System.Threading.ThreadState&quot;> </xref> 상태입니다."
  - type: System.Threading.ThreadInterruptedException
    commentId: T:System.Threading.ThreadInterruptedException
    description: "스레드가 대기 하는 동안 중단 되었습니다."
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.Int32)
  id: Join(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "표준 COM 및 SendMessage 펌프 계속 수행 하면서이 인스턴스가 나타내는 스레드가 종료 될 때까지 호출 스레드 되거나 지정 된 시간이 경과할를 차단 합니다."
  remarks: "공간 연결은 스레드 중 하나가 될 때까지 호출 스레드 (즉, 메서드를 호출 하는 스레드)를 차단 하는 동기화 방법을 인 <xref:System.Threading.Thread.Join%2A>메서드는 완료 된 시간 제한 간격이 경과 또는.</xref:System.Threading.Thread.Join%2A> 다음 예제에서는 `Thread1` 호출 스레드는 <xref:System.Threading.Thread.Join>메서드 `Thread2`,으로 구독이 `Thread1` 할 때 까지는 차단 하도록 `Thread2` 완료 2 분이 지난 또는.</xref:System.Threading.Thread.Join>       [!code-cs[System.Threading.Thread.Join#2](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)][!code-vb[System.Threading.Thread.Join#2](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb) ] 경우 <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>에 대해 지정 된는 `millisecondsTimeout` 매개 변수를이 똑같이 동작의 <xref:System.Threading.Thread.Join>반환 값을 제외한 메서드 오버 로드.</xref:System.Threading.Thread.Join> </xref:System.Threading.Timeout.Infinite?displayProperty=fullName>         스레드가 이미 종료 되는 경우 <xref:System.Threading.Thread.Join%2A>메서드가 즉시 반환 호출 됩니다.</xref:System.Threading.Thread.Join%2A>       이 메서드 <xref:System.Threading.ThreadState?displayProperty=fullName>.</xref:System.Threading.ThreadState?displayProperty=fullName> 포함 하도록 호출 스레드의 상태를 변경 합니다. 호출할 수 없습니다 `Join` 중인 스레드에서 <xref:System.Threading.ThreadState?displayProperty=fullName>상태.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  syntax:
    content: public bool Join (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "스레드가 종료 되기를 기다릴 밀리초 수입니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우에 스레드가 종료 됩니다. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 로 지정 된 시간 동안 스레드가 종료 되지 않은 경우는 <code> millisecondsTimeout </code> 경과 된 매개 변수입니다."
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "값 <code> millisecondsTimeout </code> 가 음수이 고 같지 않으면 &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; (밀리초)입니다."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "스레드가 시작 되지 않았습니다."
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.TimeSpan)
  id: Join(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "표준 COM 및 SendMessage 펌프 계속 수행 하면서이 인스턴스가 나타내는 스레드가 종료 될 때까지 호출 스레드 되거나 지정 된 시간이 경과할를 차단 합니다."
  remarks: "공간 연결은 스레드 중 하나가 될 때까지 호출 스레드 (즉, 메서드를 호출 하는 스레드)를 차단 하는 동기화 방법을 인 <xref:System.Threading.Thread.Join%2A>메서드는 완료 된 시간 제한 간격이 경과 또는.</xref:System.Threading.Thread.Join%2A> 다음 예제에서는 `Thread1` 호출 스레드는 <xref:System.Threading.Thread.Join>메서드 `Thread2`,으로 구독이 `Thread1` 할 때 까지는 차단 하도록 `Thread2` 완료 2 분이 지난 또는.</xref:System.Threading.Thread.Join>       [!code-cs[System.Threading.Thread.Join#3](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)][!code-vb[System.Threading.Thread.Join#3](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb) ] 경우 <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>에 대해 지정 된 `timeout`,이 메서드는 동일 하 게 동작의 <xref:System.Threading.Thread.Join>반환 값을 제외한 메서드 오버 로드.</xref:System.Threading.Thread.Join> </xref:System.Threading.Timeout.Infinite?displayProperty=fullName>         스레드가 이미 종료 되는 경우 <xref:System.Threading.Thread.Join%2A>메서드가 즉시 반환 호출 됩니다.</xref:System.Threading.Thread.Join%2A>       이 메서드 <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> 포함 하도록 현재 스레드의 상태를 변경 합니다. 호출할 수 없습니다 `Join` 중인 스레드에서 <xref:System.Threading.ThreadState?displayProperty=fullName>상태.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  example:
  - "The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.  \n  \n [!code-cpp[System.Threading.Thread.Timespan#1](~/add/codesnippet/cpp/m-system.threading.threa_28_2.cpp)]\n [!code-cs[System.Threading.Thread.Timespan#1](~/add/codesnippet/csharp/m-system.threading.threa_28_2.cs)]\n [!code-vb[System.Threading.Thread.Timespan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_28_2.vb)]"
  syntax:
    content: public bool Join (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "A <xref:System.TimeSpan>스레드가 종료 되기를 기다릴 시간으로 설정 합니다.</xref:System.TimeSpan>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우에 스레드가 종료 됩니다. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 로 지정 된 시간 동안 스레드가 종료 되지 않은 경우는 <code> timeout </code> 경과 된 매개 변수입니다."
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "값 <code> timeout </code> 가 음수이 고 같지 않으면 &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; 밀리초에서 보다 큰 &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; 시간 (밀리초)입니다."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "호출자에 있는 스레드는 <xref href=&quot;System.Threading.ThreadState&quot;> </xref> 상태입니다."
  platform:
  - net462
- uid: System.Threading.Thread.ManagedThreadId
  id: ManagedThreadId
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "현재 관리 되는 스레드에 대 한 고유 식별자를 가져옵니다."
  remarks: "해당 스레드는 프로세스 내에서 고유 하 게 식별 하는 스레드의 ManagedThreadId 속성 값이 사용 됩니다.       공용 언어 런타임을 호스트 하는 관리 되지 않는 코드에서 스레드를 파이버를 구현 하는 경우에 ManagedThreadId 속성의 값에서 시간에 따라 달라 지지 않습니다."
  syntax:
    content: public int ManagedThreadId { get; }
    return:
      type: System.Int32
      description: "이 관리 되는 스레드에 대 한 고유 식별자를 나타내는 정수입니다."
  overload: System.Threading.Thread.ManagedThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.MemoryBarrier
  id: MemoryBarrier
  parent: System.Threading.Thread
  langs:
  - csharp
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: '다음과 같이 메모리 액세스를 동기화 합니다: 현재 스레드를 실행 하는 프로세서 등의 지침을 변경할 수 없습니다 MemoryBarrier에 대 한 호출 이후의 메모리 액세스 뒤에 MemoryBarrier에 대 한 호출 이전의 메모리 액세스가 하는 방식으로 실행 합니다.'
  remarks: "MemoryBarrier는 메모리 (예: 여러 Intel Itanium 프로세서를 사용 하는 시스템) 순서가 있는 경우 하나의 다중 프로세서 시스템에만 필요 합니다.       대부분의 용도 C#에 대 한 `lock` 문, Visual Basic `SyncLock` 문, 또는 <xref:System.Threading.Monitor>편리 하 게 데이터를 동기화 할 클래스를 제공 합니다.</xref:System.Threading.Monitor>"
  syntax:
    content: public static void MemoryBarrier ();
    parameters: []
  overload: System.Threading.Thread.MemoryBarrier*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Name
  id: Name
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "스레드의 이름을 가져오거나 설정 합니다."
  remarks: "이 속성은 쓰기-되 면입니다. 스레드 이름 속성의 기본값은 때문에 `null`, 여부 이름을 이미 명시적으로 할당 된 스레드를 사용 하 여 비교 하 여 확인할 수 있습니다 `null`합니다.       Name 속성에 할당 된 문자열 모든 유니코드 문자를 포함할 수 있습니다."
  example:
  - "The following example shows how to name a thread.  \n  \n [!code-cs[System.Threading.Thread.Name#1](~/add/codesnippet/csharp/p-system.threading.threa_4_1.cs)]\n [!code-cpp[System.Threading.Thread.Name#1](~/add/codesnippet/cpp/p-system.threading.threa_4_1.cpp)]\n [!code-vb[System.Threading.Thread.Name#1](~/add/codesnippet/visualbasic/p-system.threading.threa_4_1.vb)]"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "스레드의 이름을 포함 하는 문자열 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 설정 된 이름이 있는 경우."
  overload: System.Threading.Thread.Name*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Set 작업을 요청 했지만, 하지만 <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> 속성이 이미 설정 되었습니다."
  platform:
  - net462
- uid: System.Threading.Thread.Priority
  id: Priority
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "스레드의 예약 우선 순위를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "스레드 중 하나라도 다음과 같은 우선 순위를 할당할 수 있습니다 <xref:System.Threading.ThreadPriority>값:- `Highest`       -    `AboveNormal`       -    `Normal`       -    `BelowNormal`       -    `Lowest` 운영 체제 스레드의 우선 순위를 준수 하지 않아도 됩니다.</xref:System.Threading.ThreadPriority>"
  example:
  - "The following example shows the result of changing the priority of a thread. Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>, and the priority of a second is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>. Each thread increments a variable in a `while` loop and runs for a set time.  \n  \n [!code-cs[System.Threading.ThreadPriority#1](~/add/codesnippet/csharp/p-system.threading.threa_6_1.cs)]\n [!code-vb[System.Threading.ThreadPriority#1](~/add/codesnippet/visualbasic/p-system.threading.threa_6_1.vb)]"
  syntax:
    content: public System.Threading.ThreadPriority Priority { get; set; }
    return:
      type: System.Threading.ThreadPriority
      description: "중 하나는 <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref> 값입니다. 기본값은 <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref>합니다."
  overload: System.Threading.Thread.Priority*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "스레드가 같은 최종 상태에 도달 <xref href=&quot;System.Threading.ThreadState&quot;> </xref>합니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Set 작업은 올바른 아닙니다 변수에 지정한 값이 <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref> 값입니다."
  platform:
  - net462
- uid: System.Threading.Thread.ResetAbort
  id: ResetAbort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "취소는 <xref:System.Threading.Thread.Abort*>현재 스레드에 대 한 요청.</xref:System.Threading.Thread.Abort*>"
  remarks: "이 메서드는 적절 한 사용 권한 가진 코드에서 호출할 수만 있습니다.       호출할 때 `Abort` 시스템 스레드를 종료 하에 <xref:System.Threading.ThreadAbortException>.</xref:System.Threading.ThreadAbortException> 에서 throw `ThreadAbortException`응용 프로그램 코드에서 발견 될 수 있지만 하지 않는 한 catch 블록의 끝에 다시 throw 되는 특별 한 예외는 `ResetAbort` 라고 합니다. `ResetAbort`중단을 요청을 취소 하 고 방지는 `ThreadAbortException` 의 스레드를 종료 합니다.       참조 <xref:System.Threading.ThreadAbortException>호출 방법을 보여 주는 예제는 `ResetAbort` 메서드.</xref:System.Threading.ThreadAbortException>"
  syntax:
    content: public static void ResetAbort ();
    parameters: []
  overload: System.Threading.Thread.ResetAbort*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "<xref uid=&quot;langword_csharp_Abort&quot; name=&quot;Abort&quot; href=&quot;&quot;></xref>현재 스레드에서 호출 되었습니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 현재 스레드에 대 한 필수 보안 사용 권한이 없습니다."
  platform:
  - net462
- uid: System.Threading.Thread.Resume
  id: Resume
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "일시 중단 된 스레드를 다시 시작 합니다."
  remarks: >-
    > [!CAUTION]

    >  Do not use the <xref:System.Threading.Thread.Suspend%2A> and Resume methods to synchronize the activities of threads. You have no way of knowing what code a thread is executing when you suspend it. If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked. If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked. Deadlocks can occur very easily.
  syntax:
    content: public void Resume ();
    parameters: []
  overload: System.Threading.Thread.Resume*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "스레드가 시작 되지 않은, 또는 일시 중단 된 상태가 아닙니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 적절 한 없는 <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  id: SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "시작 하기 전에 스레드의 아파트 상태를 설정 합니다."
  remarks: "새 스레드가 <xref:System.Threading.ApartmentState?displayProperty=fullName>아파트 상태 설정 있지 않은 경우 되어 시작 되기 전에.</xref:System.Threading.ApartmentState?displayProperty=fullName> 스레드가 시작 되기 전에 아파트 상태를 설정 해야 합니다.      > [!NOTE] >에 주 응용 프로그램 초기화 됩니다 <xref:System.Threading.ApartmentState?displayProperty=fullName>기본적으로.</xref:System.Threading.ApartmentState?displayProperty=fullName> 주 응용 프로그램 스레드의 아파트 상태를 설정 하는 유일한 방법은 <xref:System.Threading.ApartmentState?displayProperty=fullName>적용 하는 것은 <xref:System.STAThreadAttribute>진입점 메서드 특성.</xref:System.STAThreadAttribute> </xref:System.Threading.ApartmentState?displayProperty=fullName>       SetApartmentState 메서드와 함께 <xref:System.Threading.Thread.GetApartmentState%2A>메서드 및 <xref:System.Threading.Thread.TrySetApartmentState%2A>메서드를 대체는 <xref:System.Threading.Thread.ApartmentState%2A>속성.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.TrySetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, SetApartmentState, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and SetApartmentState changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with SetApartmentState, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_6_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_6_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_6_1.cs)]"
  syntax:
    content: public void SetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "새 아파트 상태입니다."
  overload: System.Threading.Thread.SetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>가 잘못 된 아파트 상태가 아닙니다."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "스레드가 이미 시작 되었습니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "아파트 상태가 이미 초기화 되었습니다."
  platform:
  - net462
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  id: SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "캡처한 적용 <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> 현재 스레드에 있습니다."
  remarks: "이 메서드는 더 이상 지원 됩니다."
  syntax:
    content: public void SetCompressedStack (System.Threading.CompressedStack stack);
    parameters:
    - id: stack
      type: System.Threading.CompressedStack
      description: "<xref href=&quot;System.Threading.CompressedStack&quot;> </xref> 현재 스레드에 적용할 개체입니다."
  overload: System.Threading.Thread.SetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "모든 경우"
  platform:
  - net462
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  id: SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "해당 스레드의 현재 도메인에 대해 현재 실행 중인 스레드의 지정된 된 슬롯에서 데이터를 설정합니다. 성능 향상을 위해 표시 된 필드를 사용 하 여는 <xref:System.ThreadStaticAttribute>특성을 대신 합니다.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 <xref:System.ThreadStaticAttribute>특성) 및 데이터 슬롯.</xref:System.ThreadStaticAttribute> 스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다. TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/add/includes/ajax-current-ext-md.md)합니다.       스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다. 공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다. 스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드 프로시저 종료 된 후 다시 사용 하기 위해 슬롯을 해제 및 <xref:System.Threading.Thread>가비지 수집에서 회수 된 개체입니다.</xref:System.Threading.Thread> 데이터 슬롯은 스레드당 고유 합니다. 다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다.      > [!NOTE] > SetData는는 `Shared` 항상 다른 스레드를 참조 하는 변수를 사용 하 여 호출 하는 경우에 현재 실행 중인 스레드에 적용 되는 메서드. 혼동을 피하기 위해 사용 하 여 클래스 이름을 호출할 때 `Shared` 메서드: `Thread.SetData(testSlot, &quot;test data&quot;)`합니다."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_4_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_4_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_4_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_4_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_2.vb)]"
  syntax:
    content: public static void SetData (LocalDataStoreSlot slot, object data);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "<xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> 값을 설정 하는 합니다."
    - id: data
      type: System.Object
      description: "값을 설정할 수 있습니다."
  overload: System.Threading.Thread.SetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.Int32)
  id: Sleep(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "지정한 시간 (밀리초) 동안 현재 스레드를 일시 중단합니다."
  remarks: "지정 된 시간 동안 운영 체제에서 스레드를 예약 실행 됩니다. 이 메서드 <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> 의 상태를 변경 합니다.       지정할 수 있습니다 <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>에 대 한는 `millisecondsTimeout` 매개 변수를 무기한으로 스레드를 일시 중단 합니다.</xref:System.Threading.Timeout.Infinite?displayProperty=fullName> 하지만 다른를 사용 하는 권장 <xref:System.Threading?displayProperty=fullName>와 같은 클래스 <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, 또는 <xref:System.Threading.Semaphore>대신 동기화 할 스레드에 또는 리소스 관리.</xref:System.Threading.Semaphore> </xref:System.Threading.EventWaitHandle> </xref:System.Threading.Monitor> </xref:System.Threading.Mutex> </xref:System.Threading?displayProperty=fullName>       특정 속도로 시스템 클록 틱 클록 해상도 호출합니다. 실제 시간 제한은 정확 하 게 지정된 된 제한 시간을 지정된 된 제한 시간 클록 틱 일치 하 게 조정 될 것 이므로 아닐 수 있습니다. 클록의 해상도 대기 시간에 대 한 자세한 내용은 참조는 [함수 절전](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) 항목입니다. 이 메서드를 호출는 [함수 절전](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx) Windows 시스템 Api에서에서 합니다.       이 메서드는 표준 COM 및 SendMessage 펌프를 수행 하지 않습니다.      > [!NOTE] > 있는 스레드를 대기 해야 하는 경우 <xref:System.STAThreadAttribute>, 표준 COM 및 SendMessage 펌프를 수행 하 고 오버 로드 중 하나를 사용 하는 것이 좋습니다. 하지만 <xref:System.Threading.Thread.Join%2A>시간 제한 간격을 지정 하는 메서드.</xref:System.Threading.Thread.Join%2A> </xref:System.STAThreadAttribute>"
  example:
  - "The following example uses the Sleep method to block the application's main thread.  \n  \n [!code-cs[Thread.Sleep#1](~/add/codesnippet/csharp/m-system.threading.threa_2_1.cs)]\n [!code-vb[Thread.Sleep#1](~/add/codesnippet/visualbasic/m-system.threading.threa_2_1.vb)]\n [!code-cpp[Thread.Sleep#1](~/add/codesnippet/cpp/m-system.threading.threa_2_1.cpp)]"
  syntax:
    content: public static void Sleep (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "스레드가 일시 중단 되는 시간 (밀리초)의 수입니다. 하는 경우의 값은 `millisecondsTimeout` 인수가&0; 이면 스레드는 프로세스를 실행할 준비가 된 우선 순위가 같은 스레드에 해당 시간 조각의 나머지입니다. 실행 준비가 된 우선 순위가 같은 다른 스레드가 없으면 현재 스레드의 실행을 일시 중단 되지 않습니다."
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "시간 제한 값이 음수이 고 <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite> 과 같지 않은"
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  id: Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "지정 된 시간 동안 현재 스레드를 일시 중단합니다."
  remarks: "지정 된 시간 동안 운영 체제에서 스레드를 예약 실행 됩니다. 이 메서드 <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> 의 상태를 변경 합니다.       지정할 수 있습니다 <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName>에 대 한는 `timeout` 매개 변수를 무기한으로 스레드를 일시 중단 합니다.</xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName> 하지만 다른를 사용 하는 권장 <xref:System.Threading?displayProperty=fullName>와 같은 클래스 <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, 또는 <xref:System.Threading.Semaphore>대신 동기화 할 스레드에 또는 리소스 관리.</xref:System.Threading.Semaphore> </xref:System.Threading.EventWaitHandle> </xref:System.Threading.Monitor> </xref:System.Threading.Mutex> </xref:System.Threading?displayProperty=fullName>       이 오버 로드의 <xref:System.Threading.Thread.Sleep%2A>에서 정수 밀리초의 총 수를 사용 하 여 `timeout`.</xref:System.Threading.Thread.Sleep%2A> 소수 자릿수 밀리초는 무시 됩니다.       이 메서드는 표준 COM 및 SendMessage 펌프를 수행 하지 않습니다.      > [!NOTE] > 있는 스레드를 대기 해야 하는 경우 <xref:System.STAThreadAttribute>, 표준 COM 및 SendMessage 펌프를 수행 하 고 오버 로드 중 하나를 사용 하는 것이 좋습니다. 하지만 <xref:System.Threading.Thread.Join%2A>시간 제한 간격을 지정 하는 메서드.</xref:System.Threading.Thread.Join%2A> </xref:System.STAThreadAttribute>"
  example:
  - "The following example uses the Sleep method overload to block the application's main thread five times, for two seconds each time.  \n  \n [!code-cpp[Thread.Sleep_TimeSpan#1](~/add/codesnippet/cpp/m-system.threading.threa_31_1.cpp)]\n [!code-cs[Thread.Sleep_TimeSpan#1](~/add/codesnippet/csharp/m-system.threading.threa_31_1.cs)]\n [!code-vb[Thread.Sleep_TimeSpan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_31_1.vb)]"
  syntax:
    content: public static void Sleep (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "스레드가 일시 중단 된 시간의 양입니다. 하는 경우의 값은 `millisecondsTimeout` 인수는 &lt;xref:System.TimeSpan?displayProperty=fullName&gt;, 스레드 프로세스를 실행할 준비가 된 우선 순위가 같은 스레드에 해당 시간 조각의 나머지 합니다. 실행 준비가 된 우선 순위가 같은 다른 스레드가 없으면 현재 스레드의 실행을 일시 중단 되지 않습니다."
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "값 <code> timeout </code> 가 음수이 고 같지 않으면 &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; 밀리초에서 보다 큰 &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; 시간 (밀리초)입니다."
  platform:
  - net462
- uid: System.Threading.Thread.SpinWait(System.Int32)
  id: SpinWait(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "정의 하는 시간 동안 대기 하도록 스레드는 <code> iterations </code> 매개 변수입니다."
  remarks: "SpinWait 메서드는 잠금을 구현 하는 데 유용 합니다. .NET Framework에서와 같은 클래스 <xref:System.Threading.Monitor>및 <xref:System.Threading.ReaderWriterLock>,이 메서드를 내부적으로 사용 합니다.</xref:System.Threading.ReaderWriterLock> </xref:System.Threading.Monitor> SpinWait 기본적으로 넣습니다 프로세서 매우 빽빽한 루프에서 지정한 루프 수로는 `iterations` 매개 변수입니다. 따라서 대기 시간은 프로세서의 속도에 따라 달라 집니다.       이와 반대로와 <xref:System.Threading.Thread.Sleep%2A>메서드.</xref:System.Threading.Thread.Sleep%2A> 호출 하는 스레드 <xref:System.Threading.Thread.Sleep%2A>지정한 간격이&0; 인 경우에 프로세서 시간의 현재 해당 조각의 나머지 부분을 만듭니다.</xref:System.Threading.Thread.Sleep%2A> 에 대 한&0;이 아닌 간격 <xref:System.Threading.Thread.Sleep%2A>시간 간격이 경과할 때까지 스레드가 스레드 스케줄러에서 고려 대상에서 제거 합니다.</xref:System.Threading.Thread.Sleep%2A>       SpinWait 일반적인 응용 프로그램에 일반적으로 유용 하지 않습니다. 대부분의 경우에서.NET Framework; 제공한 동기화 클래스를 사용 해야 예를 들어 호출 <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>또는 래핑하는 문을 <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>(`lock` C#에서 또는 `SyncLock` Visual basic에서).</xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> </xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>      > [!CAUTION] > 피하려면는 상태 변경이 임박을 알고 있는 경우와 같은 컨텍스트 전환 하는 드문 경우 루프에서 SpinWait 메서드 호출을 수행 합니다. SpinWait 실행 코드는 여러 개의 프로세서가 있는 컴퓨터에서 발생할 수 있는 문제를 방지 하도록 설계 되었습니다. 예를 들어, 하이퍼 스레딩 기술 채택 하는 여러 Intel 프로세서가 있는 컴퓨터, SpinWait 특정 상황에서는 프로세서 부족을 방지 합니다."
  syntax:
    content: public static void SpinWait (int iterations);
    parameters:
    - id: iterations
      type: System.Int32
      description: "스레드가 대기 시간을 정의 하는 32 비트 부호 있는 정수입니다."
  overload: System.Threading.Thread.SpinWait*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Start
  id: Start
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "현재 인스턴스의 상태를 변경 하려면 운영 체제 <xref href=&quot;System.Threading.ThreadState&quot;> </xref>합니다."
  remarks: "이 스레드는 <xref:System.Threading.ThreadState?displayProperty=fullName>상태 이면 운영 체제 실행을 예약할 수 있습니다.</xref:System.Threading.ThreadState?displayProperty=fullName> 스레드가 나타내는 메서드의 첫 번째 줄에서 실행이 시작 되는 <xref:System.Threading.ThreadStart>또는 <xref:System.Threading.ParameterizedThreadStart>스레드 생성자에 제공 합니다.</xref:System.Threading.ParameterizedThreadStart> </xref:System.Threading.ThreadStart> 참고 시작에 대 한 호출의 호출 스레드를 차단 하지 않습니다.      > [!NOTE] >이 오버 로드를 사용 하 여 만든 스레드를 사용 하는 경우는 <xref:System.Threading.ParameterizedThreadStart>대리자 `null` 스레드에서 실행 하는 메서드에 전달 됩니다.</xref:System.Threading.ParameterizedThreadStart>       스레드가 종료 되 면 다시 호출 하 여 `Start`합니다."
  example:
  - "The following example creates and starts a thread.  \n  \n [!code-cpp[ThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_25_1.cpp)]\n [!code-cs[ThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_25_1.cs)]\n [!code-vb[ThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_25_1.vb)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "스레드가 이미 시작 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "이 스레드를 시작할 수 있는 메모리가 부족 합니다."
  platform:
  - net462
- uid: System.Threading.Thread.Start(System.Object)
  id: Start(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "현재 인스턴스의 상태를 변경 하려면 운영 체제 <xref href=&quot;System.Threading.ThreadState&quot;> </xref>, 필요에 따라 스레드가 실행 하는 메서드에서 사용할 데이터가 들어 있는 개체를 제공 합니다."
  remarks: "이 스레드는 <xref:System.Threading.ThreadState?displayProperty=fullName>상태 이면 운영 체제 실행을 예약할 수 있습니다.</xref:System.Threading.ThreadState?displayProperty=fullName> 스레드가 나타내는 메서드의 첫 번째 줄에서 실행이 시작 되는 <xref:System.Threading.ThreadStart>또는 <xref:System.Threading.ParameterizedThreadStart>스레드 생성자에 제공 합니다.</xref:System.Threading.ParameterizedThreadStart> </xref:System.Threading.ThreadStart> 참고 시작에 대 한 호출의 호출 스레드를 차단 하지 않습니다.       스레드가 종료 되 면 다시 호출 하 여 `Start`합니다.       이 오버 로드와 <xref:System.Threading.ParameterizedThreadStart>대리자 쉽게 데이터를 전달 하는 스레드 프로시저에 있지만 하는 방법 형식이 안전 하지 않은 모든 개체를이 오버 로드에 전달 될 수 있으므로.</xref:System.Threading.ParameterizedThreadStart> 스레드 프로시저에 데이터를 전달 하는 보다 강력한 방법은 작업자 개체에 데이터 필드와 스레드 프로시저를 넣는 것입니다. 자세한 내용은 참조 [스레드 만들기 및 시작 시 데이터 전달](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_15_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_15_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_15_1.cs)]"
  syntax:
    content: public void Start (object parameter);
    parameters:
    - id: parameter
      type: System.Object
      description: "스레드가 실행 하는 메서드에서 사용할 데이터가 들어 있는 개체입니다."
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "스레드가 이미 시작 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "이 스레드를 시작할 수 있는 메모리가 부족 합니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이 메서드를 사용 하 여 만든는 <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> 대리자 대신는 <xref href=&quot;System.Threading.ParameterizedThreadStart&quot;> </xref> 위임 합니다."
  platform:
  - net462
- uid: System.Threading.Thread.Suspend
  id: Suspend
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "스레드를 일시 중단 하거나 스레드가 이미 일시 중단 된 경우 효과가 없습니다."
  remarks: "스레드가 이미 일시 중단 된 경우이 메서드는 영향을 주지 않습니다.      > [!CAUTION] > 일시 중단을 사용 하지 않는 및 <xref:System.Threading.Thread.Resume%2A>스레드 활동을 동기화 하는 메서드.</xref:System.Threading.Thread.Resume%2A> 일시 중단 하면 스레드 코드 실행 알 방법이 없습니다. 보안 권한 확인 하는 동안 잠금을 유지 하는 동안 스레드를 일시 중단, 기타의 스레드는 <xref:System.AppDomain>차단 될 수 있습니다.</xref:System.AppDomain> 다른 스레드가 클래스 생성자를 실행 하는 동안 스레드 일시 중단 된 <xref:System.AppDomain>클래스는 차단 사용 하려고 하는.</xref:System.AppDomain> 교착 상태는 매우 쉽게 발생할 수 있습니다."
  syntax:
    content: public void Suspend ();
    parameters: []
  overload: System.Threading.Thread.Suspend*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "스레드가 시작 되지 않은 또는 중단 합니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 적절 한 없는 <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "이름 집합을 해당 디스패치 식별자 집합에 매핑합니다."
  remarks: "이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다."
  syntax:
    content: void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "나중에 사용하도록 예약되어 있습니다. IID_NULL 이어야 합니다."
    - id: rgszNames
      type: System.IntPtr
      description: "전달 된 이름의 배열을 매핑할 수 있습니다."
    - id: cNames
      type: System.UInt32
      description: "매핑할 이름의 수입니다."
    - id: lcid
      type: System.UInt32
      description: "이름을 해석할 로캘 컨텍스트."
    - id: rgDispId
      type: System.IntPtr
      description: "이름에 해당 하는 Id를 받는 호출자가 할당 된 배열입니다."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "COM을 사용 하 여 런타임에 바인딩된 액세스 `IDispatch` 인터페이스가 지원 되지 않습니다."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "인터페이스에 대 한 형식 정보를 얻으려면 다음 사용할 수 있는 개체에 대 한 형식 정보를 검색 합니다."
  remarks: "이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다."
  syntax:
    content: void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "반환할 형식 정보입니다."
    - id: lcid
      type: System.UInt32
      description: "형식 정보에 대 한 로캘 식별자입니다."
    - id: ppTInfo
      type: System.IntPtr
      description: "요청 된 형식 정보 개체에 대 한 포인터를 받습니다."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "COM을 사용 하 여 런타임에 바인딩된 액세스 `IDispatch` 인터페이스가 지원 되지 않습니다."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "개체 (0 또는 1)를 제공 하는 형식 정보 인터페이스의 수를 검색 합니다."
  remarks: "이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다."
  syntax:
    content: void _Thread.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "개체에서 제공 하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "COM을 사용 하 여 런타임에 바인딩된 액세스 `IDispatch` 인터페이스가 지원 되지 않습니다."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "개체에서 노출 하는 메서드와 속성에 대 한 액세스를 제공 합니다."
  remarks: "이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다."
  syntax:
    content: void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "멤버를 식별 합니다."
    - id: riid
      type: System.Guid
      description: "나중에 사용하도록 예약되어 있습니다. IID_NULL 이어야 합니다."
    - id: lcid
      type: System.UInt32
      description: "인수를 해석할 로캘 컨텍스트입니다."
    - id: wFlags
      type: System.Int16
      description: "호출의 컨텍스트를 설명 하는 플래그입니다."
    - id: pDispParams
      type: System.IntPtr
      description: "인수의 배열, 명명 된 인수 및 배열에 있는 요소 수에 대 한 수에 대 한 인수 Dispid의 배열에 포함 된 구조체에 대 한 포인터입니다."
    - id: pVarResult
      type: System.IntPtr
      description: "결과 저장 될 위치에 대 한 포인터입니다."
    - id: pExcepInfo
      type: System.IntPtr
      description: "예외 정보가 포함 된 구조에 대 한 포인터입니다."
    - id: puArgErr
      type: System.IntPtr
      description: "오류가 있는 첫 번째 인수의 인덱스입니다."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "COM을 사용 하 여 런타임에 바인딩된 액세스 `IDispatch` 인터페이스가 지원 되지 않습니다."
  platform:
  - net462
- uid: System.Threading.Thread.ThreadState
  id: ThreadState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "현재 스레드의 상태를 포함 하는 값을 가져옵니다."
  remarks: "ThreadState 속성 보다 더 구체적인 정보를 제공는 <xref:System.Threading.Thread.IsAlive%2A>속성.</xref:System.Threading.Thread.IsAlive%2A>      > [!IMPORTANT] > 스레드 상태 디버깅 시나리오에 대 한 관심만 유용 합니다. 코드 스레드 활동을 동기화 할 스레드 상태를 사용해 해야 합니다."
  example:
  - "The following code example demonstrates accessing the `ThreadState` of a thread.  \n  \n [!code-cs[System.Threading.Thread.ThreadState#1](~/add/codesnippet/csharp/p-system.threading.threa_5_1.cs)]\n [!code-vb[System.Threading.Thread.ThreadState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_5_1.vb)]\n [!code-cpp[System.Threading.Thread.ThreadState#1](~/add/codesnippet/cpp/p-system.threading.threa_5_1.cpp)]"
  syntax:
    content: public System.Threading.ThreadState ThreadState { get; }
    return:
      type: System.Threading.ThreadState
      description: "중 하나는 <xref href=&quot;System.Threading.ThreadState&quot;> </xref> 현재 스레드의 상태를 나타내는 값입니다. 초기 값은 <xref uid=&quot;langword_csharp_Unstarted&quot; name=&quot;Unstarted&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Threading.Thread.ThreadState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  id: TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "시작 하기 전에 스레드의 아파트 상태를 설정 합니다."
  remarks: "새 스레드가 <xref:System.Threading.ApartmentState?displayProperty=fullName>아파트 상태 설정 있지 않은 경우 되어 시작 되기 전에.</xref:System.Threading.ApartmentState?displayProperty=fullName> 스레드가 시작 되기 전에 아파트 상태를 설정 해야 합니다.      > [!NOTE] >에 주 응용 프로그램 초기화 됩니다 <xref:System.Threading.ApartmentState?displayProperty=fullName>기본적으로.</xref:System.Threading.ApartmentState?displayProperty=fullName> 주 응용 프로그램 스레드의 아파트 상태를 설정 하는 유일한 방법은 <xref:System.Threading.ApartmentState?displayProperty=fullName>적용 하는 것은 <xref:System.STAThreadAttribute>진입점 메서드 특성.</xref:System.STAThreadAttribute> </xref:System.Threading.ApartmentState?displayProperty=fullName>       TrySetApartmentState 메서드와 함께 <xref:System.Threading.Thread.GetApartmentState%2A>메서드 및 <xref:System.Threading.Thread.SetApartmentState%2A>메서드를 대체는 <xref:System.Threading.Thread.ApartmentState%2A>속성.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.SetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and TrySetApartmentState methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The TrySetApartmentState method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the TrySetApartmentState method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_26_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_26_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_26_1.cs)]"
  syntax:
    content: public bool TrySetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "새 아파트 상태입니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>아파트 상태가 설정 됩니다. 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Threading.Thread.TrySetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>가 잘못 된 아파트 상태가 아닙니다."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "스레드가 이미 시작 되었습니다."
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  id: VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "필드의 값을 읽습니다. 값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다."
  remarks: "VolatileRead 및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 VolatileRead 프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다. 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 VolatileRead 에서도 및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 VolatileRead 나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> 필드에 대 한 모든 액세스 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 VolatileRead <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> 보장"
  syntax:
    content: public static byte VolatileRead (ref byte address);
    parameters:
    - id: address
      type: System.Byte
      description: "읽을 필드입니다."
    return:
      type: System.Byte
      description: "프로세서에서 해당 필드에 쓴 마지막 값입니다."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  id: VolatileRead(System.Double@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "필드의 값을 읽습니다. 값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A>프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.</xref:System.Threading.Thread.VolatileRead%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static double VolatileRead (ref double address);
    parameters:
    - id: address
      type: System.Double
      description: "읽을 필드입니다."
    return:
      type: System.Double
      description: "프로세서에서 해당 필드에 쓴 마지막 값입니다."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  id: VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "필드의 값을 읽습니다. 값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A>프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.</xref:System.Threading.Thread.VolatileRead%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static short VolatileRead (ref short address);
    parameters:
    - id: address
      type: System.Int16
      description: "읽을 필드입니다."
    return:
      type: System.Int16
      description: "프로세서에서 해당 필드에 쓴 마지막 값입니다."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  id: VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "필드의 값을 읽습니다. 값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A>프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.</xref:System.Threading.Thread.VolatileRead%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static int VolatileRead (ref int address);
    parameters:
    - id: address
      type: System.Int32
      description: "읽을 필드입니다."
    return:
      type: System.Int32
      description: "프로세서에서 해당 필드에 쓴 마지막 값입니다."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  id: VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "필드의 값을 읽습니다. 값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A>프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.</xref:System.Threading.Thread.VolatileRead%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static long VolatileRead (ref long address);
    parameters:
    - id: address
      type: System.Int64
      description: "읽을 필드입니다."
    return:
      type: System.Int64
      description: "프로세서에서 해당 필드에 쓴 마지막 값입니다."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  id: VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "필드의 값을 읽습니다. 값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A>프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.</xref:System.Threading.Thread.VolatileRead%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static IntPtr VolatileRead (ref IntPtr address);
    parameters:
    - id: address
      type: System.IntPtr
      description: "읽을 필드입니다."
    return:
      type: System.IntPtr
      description: "프로세서에서 해당 필드에 쓴 마지막 값입니다."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  id: VolatileRead(System.Object@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "필드의 값을 읽습니다. 값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A>프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.</xref:System.Threading.Thread.VolatileRead%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static object VolatileRead (ref object address);
    parameters:
    - id: address
      type: System.Object
      description: "읽을 필드입니다."
    return:
      type: System.Object
      description: "프로세서에서 해당 필드에 쓴 마지막 값입니다."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  id: VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "필드의 값을 읽습니다. 값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A>프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.</xref:System.Threading.Thread.VolatileRead%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static sbyte VolatileRead (ref sbyte address);
    parameters:
    - id: address
      type: System.SByte
      description: "읽을 필드입니다."
    return:
      type: System.SByte
      description: "프로세서에서 해당 필드에 쓴 마지막 값입니다."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  id: VolatileRead(System.Single@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "필드의 값을 읽습니다. 값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A>프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.</xref:System.Threading.Thread.VolatileRead%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static float VolatileRead (ref float address);
    parameters:
    - id: address
      type: System.Single
      description: "읽을 필드입니다."
    return:
      type: System.Single
      description: "프로세서에서 해당 필드에 쓴 마지막 값입니다."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  id: VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "필드의 값을 읽습니다. 값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A>프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.</xref:System.Threading.Thread.VolatileRead%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static ushort VolatileRead (ref ushort address);
    parameters:
    - id: address
      type: System.UInt16
      description: "읽을 필드입니다."
    return:
      type: System.UInt16
      description: "프로세서에서 해당 필드에 쓴 마지막 값입니다."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  id: VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "필드의 값을 읽습니다. 값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A>프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.</xref:System.Threading.Thread.VolatileRead%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static uint VolatileRead (ref uint address);
    parameters:
    - id: address
      type: System.UInt32
      description: "읽을 필드입니다."
    return:
      type: System.UInt32
      description: "프로세서에서 해당 필드에 쓴 마지막 값입니다."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  id: VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "필드의 값을 읽습니다. 값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A>프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.</xref:System.Threading.Thread.VolatileRead%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static ulong VolatileRead (ref ulong address);
    parameters:
    - id: address
      type: System.UInt64
      description: "읽을 필드입니다."
    return:
      type: System.UInt64
      description: "프로세서에서 해당 필드에 쓴 마지막 값입니다."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  id: VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "필드의 값을 읽습니다. 값은 프로세서 수 나 프로세서 캐시의 상태에 관계 없이 컴퓨터의 프로세서에서 마지막 쓴 값입니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A>프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다.</xref:System.Threading.Thread.VolatileRead%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static UIntPtr VolatileRead (ref UIntPtr address);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "읽을 필드입니다."
    return:
      type: System.UIntPtr
      description: "프로세서에서 해당 필드에 쓴 마지막 값입니다."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  id: VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>설정 되며 VolatileWrite 동기화의 특별 한 경우에 있습니다.</xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 VolatileWrite 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다. 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 VolatileWrite 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A>또는 VolatileWrite.</xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A>또는 VolatileWrite.</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref byte address, byte value);
    parameters:
    - id: address
      type: System.Byte
      description: "에 값이 쓰여질 필드입니다."
    - id: value
      type: System.Byte
      description: "쓸 값입니다."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  id: VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A>메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.</xref:System.Threading.Thread.VolatileWrite%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static void VolatileWrite (ref double address, double value);
    parameters:
    - id: address
      type: System.Double
      description: "에 값이 쓰여질 필드입니다."
    - id: value
      type: System.Double
      description: "쓸 값입니다."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  id: VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A>메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.</xref:System.Threading.Thread.VolatileWrite%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static void VolatileWrite (ref short address, short value);
    parameters:
    - id: address
      type: System.Int16
      description: "에 값이 쓰여질 필드입니다."
    - id: value
      type: System.Int16
      description: "쓸 값입니다."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  id: VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A>메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.</xref:System.Threading.Thread.VolatileWrite%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static void VolatileWrite (ref int address, int value);
    parameters:
    - id: address
      type: System.Int32
      description: "에 값이 쓰여질 필드입니다."
    - id: value
      type: System.Int32
      description: "쓸 값입니다."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  id: VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A>메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.</xref:System.Threading.Thread.VolatileWrite%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static void VolatileWrite (ref long address, long value);
    parameters:
    - id: address
      type: System.Int64
      description: "에 값이 쓰여질 필드입니다."
    - id: value
      type: System.Int64
      description: "쓸 값입니다."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  id: VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A>메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.</xref:System.Threading.Thread.VolatileWrite%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static void VolatileWrite (ref IntPtr address, IntPtr value);
    parameters:
    - id: address
      type: System.IntPtr
      description: "에 값이 쓰여질 필드입니다."
    - id: value
      type: System.IntPtr
      description: "쓸 값입니다."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  id: VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A>메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.</xref:System.Threading.Thread.VolatileWrite%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static void VolatileWrite (ref object address, object value);
    parameters:
    - id: address
      type: System.Object
      description: "에 값이 쓰여질 필드입니다."
    - id: value
      type: System.Object
      description: "쓸 값입니다."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  id: VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A>메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.</xref:System.Threading.Thread.VolatileWrite%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static void VolatileWrite (ref sbyte address, sbyte value);
    parameters:
    - id: address
      type: System.SByte
      description: "에 값이 쓰여질 필드입니다."
    - id: value
      type: System.SByte
      description: "쓸 값입니다."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  id: VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A>메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.</xref:System.Threading.Thread.VolatileWrite%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static void VolatileWrite (ref float address, float value);
    parameters:
    - id: address
      type: System.Single
      description: "에 값이 쓰여질 필드입니다."
    - id: value
      type: System.Single
      description: "쓸 값입니다."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  id: VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A>메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.</xref:System.Threading.Thread.VolatileWrite%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static void VolatileWrite (ref ushort address, ushort value);
    parameters:
    - id: address
      type: System.UInt16
      description: "에 값이 쓰여질 필드입니다."
    - id: value
      type: System.UInt16
      description: "쓸 값입니다."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  id: VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A>메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.</xref:System.Threading.Thread.VolatileWrite%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static void VolatileWrite (ref uint address, uint value);
    parameters:
    - id: address
      type: System.UInt32
      description: "에 값이 쓰여질 필드입니다."
    - id: value
      type: System.UInt32
      description: "쓸 값입니다."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  id: VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A>메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.</xref:System.Threading.Thread.VolatileWrite%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static void VolatileWrite (ref ulong address, ulong value);
    parameters:
    - id: address
      type: System.UInt64
      description: "에 값이 쓰여질 필드입니다."
    - id: value
      type: System.UInt64
      description: "쓸 값입니다."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  id: VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "값의 모든 프로세서에서 컴퓨터를 볼 수 있도록 필드에 값을에 즉시 씁니다."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>동기화의 특별 한 경우에는.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor>클래스 보다 쉽게 대안을 제공 합니다.</xref:System.Threading.Monitor>       다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A>메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다.</xref:System.Threading.Thread.VolatileWrite%2A> 프로세서 캐시 플러시 필요할 수 있습니다.       단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A>및 <xref:System.Threading.Thread.VolatileWrite%2A>또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.       이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 <xref:System.Threading.Thread.VolatileRead%2A>나 <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 사용 해야 합니다.      > [!NOTE] > C#에서 사용 하 여 `volatile` 한정자 필드에는 해당 필드에 대 한 모든 액세스 모드를 사용할지 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 보장"
  syntax:
    content: public static void VolatileWrite (ref UIntPtr address, UIntPtr value);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "에 값이 쓰여질 필드입니다."
    - id: value
      type: System.UIntPtr
      description: "쓸 값입니다."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Yield
  id: Yield
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "호출 스레드가 현재 프로세서에서 실행할 준비가 되어 있는 다른 스레드에 실행 명령을 내리도록 합니다 하면 됩니다. 운영 체제 스레드에 양도할 수를 선택 합니다."
  remarks: "이 메서드가 성공 하면 현재 시간 조각에서 스레드의 나머지가 생성 됩니다. 운영 체제의 우선 순위 및 실행할 수 있는 다른 스레드에서의 상태에 따라 다른 시간 조각에 대 한 호출 스레드를 예약 합니다.       잠긴 호출 스레드를 실행 하는 프로세서로 제한 됩니다. 운영 체제 해당 프로세서 유휴 또는 낮은 우선 순위의 스레드를 실행 하는 경우에 다른 프로세서로 실행을 전환 되지 않습니다. 현재 프로세서에서 실행할 준비가 된 다른 스레드가 없는 운영 체제 실행을 생성 하지 않습니다 및이 메서드가 반환 `false`합니다.       이 메서드는 플랫폼 호출을 사용할를 네이티브 Win32 호출 `SwitchToThread` 함수입니다. 호출 해야 플랫폼을 사용 하는 대신 메서드를 호출 하는 수익률 플랫폼 바이패스를 호출 하기 때문에 모든 사용자 지정 스레딩 동작 호스트 요청 했습니다."
  syntax:
    content: public static bool Yield ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>운영 체제; 다른 스레드로 실행을 전환 하는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Threading.Thread.Yield*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  isExternal: false
  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Threading.ThreadStateException
  parent: System.Threading
  isExternal: false
  name: ThreadStateException
  nameWithType: ThreadStateException
  fullName: System.Threading.ThreadStateException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Threading.ThreadInterruptedException
  parent: System.Threading
  isExternal: false
  name: ThreadInterruptedException
  nameWithType: ThreadInterruptedException
  fullName: System.Threading.ThreadInterruptedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
- uid: System.Threading.ParameterizedThreadStart
  parent: System.Threading
  isExternal: false
  name: ParameterizedThreadStart
  nameWithType: ParameterizedThreadStart
  fullName: System.Threading.ParameterizedThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
- uid: System.Threading.ThreadStart
  parent: System.Threading
  isExternal: false
  name: ThreadStart
  nameWithType: ThreadStart
  fullName: System.Threading.ThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
- uid: System.Threading.Thread.Abort
  parent: System.Threading.Thread
  isExternal: false
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
- uid: System.Threading.Thread.Abort(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Threading.Thread.AllocateDataSlot
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
- uid: System.LocalDataStoreSlot
  parent: System
  isExternal: false
  name: LocalDataStoreSlot
  nameWithType: LocalDataStoreSlot
  fullName: System.LocalDataStoreSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Threading.Thread.ApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
- uid: System.Threading.ApartmentState
  parent: System.Threading
  isExternal: false
  name: ApartmentState
  nameWithType: ApartmentState
  fullName: System.Threading.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
- uid: System.Threading.Thread.BeginThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
- uid: System.Threading.Thread.CurrentContext
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
- uid: System.Runtime.Remoting.Contexts.Context
  parent: System.Runtime.Remoting.Contexts
  isExternal: false
  name: Context
  nameWithType: Context
  fullName: System.Runtime.Remoting.Contexts.Context
- uid: System.Threading.Thread.CurrentCulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Threading.Thread.CurrentPrincipal
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.Threading.Thread.CurrentThread
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
- uid: System.Threading.Thread
  parent: System.Threading
  isExternal: false
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
- uid: System.Threading.Thread.CurrentUICulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
- uid: System.Threading.Thread.EndCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
- uid: System.Threading.Thread.EndThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
- uid: System.Threading.Thread.ExecutionContext
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
- uid: System.Threading.ExecutionContext
  parent: System.Threading
  isExternal: true
  name: ExecutionContext
  nameWithType: ExecutionContext
  fullName: System.Threading.ExecutionContext
- uid: System.Threading.Thread.Finalize
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
- uid: System.Threading.Thread.GetApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
- uid: System.Threading.Thread.GetCompressedStack
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
- uid: System.Threading.CompressedStack
  parent: System.Threading
  isExternal: false
  name: CompressedStack
  nameWithType: CompressedStack
  fullName: System.Threading.CompressedStack
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  isExternal: false
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
- uid: System.Threading.Thread.GetDomain
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.Threading.Thread.GetDomainID
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
- uid: System.Threading.Thread.GetHashCode
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
- uid: System.Threading.Thread.Interrupt
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
- uid: System.Threading.Thread.IsAlive
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.Thread.IsBackground
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join
  parent: System.Threading.Thread
  isExternal: false
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
- uid: System.Threading.Thread.Join(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
- uid: System.Threading.Thread.Join(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.Thread.ManagedThreadId
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
- uid: System.Threading.Thread.Name
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
- uid: System.Threading.Thread.Priority
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
- uid: System.Threading.ThreadPriority
  parent: System.Threading
  isExternal: false
  name: ThreadPriority
  nameWithType: ThreadPriority
  fullName: System.Threading.ThreadPriority
- uid: System.Threading.Thread.ResetAbort
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
- uid: System.Threading.Thread.Resume
  parent: System.Threading.Thread
  isExternal: false
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
- uid: System.Threading.Thread.Sleep(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
- uid: System.Threading.Thread.SpinWait(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
- uid: System.Threading.Thread.Start
  parent: System.Threading.Thread
  isExternal: false
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
- uid: System.Threading.Thread.Start(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
- uid: System.Threading.Thread.Suspend
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Threading.Thread.ThreadState
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
- uid: System.Threading.ThreadState
  parent: System.Threading
  isExternal: false
  name: ThreadState
  nameWithType: ThreadState
  fullName: System.Threading.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
- uid: System.SByte
  parent: System
  isExternal: true
  name: SByte
  nameWithType: SByte
  fullName: System.SByte
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
- uid: System.UInt16
  parent: System
  isExternal: true
  name: UInt16
  nameWithType: UInt16
  fullName: System.UInt16
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
- uid: System.UInt64
  parent: System
  isExternal: true
  name: UInt64
  nameWithType: UInt64
  fullName: System.UInt64
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
- uid: System.UIntPtr
  parent: System
  isExternal: true
  name: UIntPtr
  nameWithType: UIntPtr
  fullName: System.UIntPtr
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
- uid: System.Threading.Thread.Yield
  parent: System.Threading.Thread
  isExternal: false
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
- uid: System.Threading.Thread.#ctor*
  parent: System.Threading.Thread
  isExternal: false
  name: Thread
  nameWithType: Thread.Thread
- uid: System.Threading.Thread.Abort*
  parent: System.Threading.Thread
  isExternal: false
  name: Abort
  nameWithType: Thread.Abort
- uid: System.Threading.Thread.AllocateDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot
  nameWithType: Thread.AllocateDataSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot
  nameWithType: Thread.AllocateNamedDataSlot
- uid: System.Threading.Thread.ApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion
  nameWithType: Thread.BeginCriticalRegion
- uid: System.Threading.Thread.BeginThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity
  nameWithType: Thread.BeginThreadAffinity
- uid: System.Threading.Thread.CurrentContext*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
- uid: System.Threading.Thread.CurrentCulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
- uid: System.Threading.Thread.CurrentPrincipal*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
- uid: System.Threading.Thread.CurrentThread*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
- uid: System.Threading.Thread.CurrentUICulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup*
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup
  nameWithType: Thread.DisableComObjectEagerCleanup
- uid: System.Threading.Thread.EndCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion
  nameWithType: Thread.EndCriticalRegion
- uid: System.Threading.Thread.EndThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity
  nameWithType: Thread.EndThreadAffinity
- uid: System.Threading.Thread.ExecutionContext*
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
- uid: System.Threading.Thread.Finalize*
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize
  nameWithType: Thread.Finalize
- uid: System.Threading.Thread.FreeNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot
  nameWithType: Thread.FreeNamedDataSlot
- uid: System.Threading.Thread.GetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState
  nameWithType: Thread.GetApartmentState
- uid: System.Threading.Thread.GetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack
  nameWithType: Thread.GetCompressedStack
- uid: System.Threading.Thread.GetData*
  parent: System.Threading.Thread
  isExternal: false
  name: GetData
  nameWithType: Thread.GetData
- uid: System.Threading.Thread.GetDomain*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain
  nameWithType: Thread.GetDomain
- uid: System.Threading.Thread.GetDomainID*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID
  nameWithType: Thread.GetDomainID
- uid: System.Threading.Thread.GetHashCode*
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode
  nameWithType: Thread.GetHashCode
- uid: System.Threading.Thread.GetNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot
  nameWithType: Thread.GetNamedDataSlot
- uid: System.Threading.Thread.Interrupt*
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt
  nameWithType: Thread.Interrupt
- uid: System.Threading.Thread.IsAlive*
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
- uid: System.Threading.Thread.IsBackground*
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread*
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join*
  parent: System.Threading.Thread
  isExternal: false
  name: Join
  nameWithType: Thread.Join
- uid: System.Threading.Thread.ManagedThreadId*
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier*
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier
  nameWithType: Thread.MemoryBarrier
- uid: System.Threading.Thread.Name*
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
- uid: System.Threading.Thread.Priority*
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
- uid: System.Threading.Thread.ResetAbort*
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort
  nameWithType: Thread.ResetAbort
- uid: System.Threading.Thread.Resume*
  parent: System.Threading.Thread
  isExternal: false
  name: Resume
  nameWithType: Thread.Resume
- uid: System.Threading.Thread.SetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState
  nameWithType: Thread.SetApartmentState
- uid: System.Threading.Thread.SetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack
  nameWithType: Thread.SetCompressedStack
- uid: System.Threading.Thread.SetData*
  parent: System.Threading.Thread
  isExternal: false
  name: SetData
  nameWithType: Thread.SetData
- uid: System.Threading.Thread.Sleep*
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep
  nameWithType: Thread.Sleep
- uid: System.Threading.Thread.SpinWait*
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait
  nameWithType: Thread.SpinWait
- uid: System.Threading.Thread.Start*
  parent: System.Threading.Thread
  isExternal: false
  name: Start
  nameWithType: Thread.Start
- uid: System.Threading.Thread.Suspend*
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend
  nameWithType: Thread.Suspend
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke
- uid: System.Threading.Thread.ThreadState*
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState
  nameWithType: Thread.TrySetApartmentState
- uid: System.Threading.Thread.VolatileRead*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead
  nameWithType: Thread.VolatileRead
- uid: System.Threading.Thread.VolatileWrite*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite
  nameWithType: Thread.VolatileWrite
- uid: System.Threading.Thread.Yield*
  parent: System.Threading.Thread
  isExternal: false
  name: Yield
  nameWithType: Thread.Yield
