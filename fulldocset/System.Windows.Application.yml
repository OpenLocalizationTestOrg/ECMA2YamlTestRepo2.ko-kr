### YamlMime:ManagedReference
items:
- uid: System.Windows.Application
  id: Application
  children:
  - System.Windows.Application.#ctor
  - System.Windows.Application.Activated
  - System.Windows.Application.Current
  - System.Windows.Application.Deactivated
  - System.Windows.Application.DispatcherUnhandledException
  - System.Windows.Application.Exit
  - System.Windows.Application.FindResource(System.Object)
  - System.Windows.Application.FragmentNavigation
  - System.Windows.Application.GetContentStream(System.Uri)
  - System.Windows.Application.GetCookie(System.Uri)
  - System.Windows.Application.GetRemoteStream(System.Uri)
  - System.Windows.Application.GetResourceStream(System.Uri)
  - System.Windows.Application.LoadCompleted
  - System.Windows.Application.LoadComponent(System.Uri)
  - System.Windows.Application.LoadComponent(System.Object,System.Uri)
  - System.Windows.Application.MainWindow
  - System.Windows.Application.Navigated
  - System.Windows.Application.Navigating
  - System.Windows.Application.NavigationFailed
  - System.Windows.Application.NavigationProgress
  - System.Windows.Application.NavigationStopped
  - System.Windows.Application.OnActivated(System.EventArgs)
  - System.Windows.Application.OnDeactivated(System.EventArgs)
  - System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  - System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  - System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  - System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  - System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  - System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  - System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  - System.Windows.Application.Properties
  - System.Windows.Application.ResourceAssembly
  - System.Windows.Application.Resources
  - System.Windows.Application.Run
  - System.Windows.Application.Run(System.Windows.Window)
  - System.Windows.Application.SessionEnding
  - System.Windows.Application.SetCookie(System.Uri,System.String)
  - System.Windows.Application.Shutdown
  - System.Windows.Application.Shutdown(System.Int32)
  - System.Windows.Application.ShutdownMode
  - System.Windows.Application.Startup
  - System.Windows.Application.StartupUri
  - System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.Application.TryFindResource(System.Object)
  - System.Windows.Application.Windows
  langs:
  - csharp
  name: Application
  nameWithType: Application
  fullName: System.Windows.Application
  type: Class
  summary: "캡슐화 된 [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] 응용 프로그램입니다."
  remarks: "응용 프로그램은 캡슐화 하는 클래스 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 을 다음을 비롯 한 응용 프로그램 관련 기능:- **응용 프로그램 수명**: <xref:System.Windows.Application.Activated>, <xref:System.Windows.Application.Current%2A> <xref:System.Windows.Application.Deactivated>, <xref:System.Windows.Application.DispatcherUnhandledException> <xref:System.Windows.Application.Exit>, <xref:System.Windows.Application.Run%2A> <xref:System.Windows.Application.SessionEnding> <xref:System.Windows.Application.Shutdown%2A>, <xref:System.Windows.Application.ShutdownMode%2A> <xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup> </xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.Application.SessionEnding> ,</xref:System.Windows.Application.Run%2A> </xref:System.Windows.Application.Exit> </xref:System.Windows.Application.DispatcherUnhandledException> </xref:System.Windows.Application.Deactivated> </xref:System.Windows.Application.Current%2A> </xref:System.Windows.Application.Activated>      - **응용 프로그램 범위 창, 속성 및 리소스 관리**: <xref:System.Windows.Application.FindResource%2A>, <xref:System.Windows.Application.GetContentStream%2A> <xref:System.Windows.Application.GetResourceStream%2A> <xref:System.Windows.Application.LoadComponent%2A>, <xref:System.Windows.Application.MainWindow%2A> <xref:System.Windows.Application.Properties%2A>, <xref:System.Windows.Application.Resources%2A> <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application.Windows%2A>.</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Application.StartupUri%2A> </xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application.Properties%2A> </xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.LoadComponent%2A> ,</xref:System.Windows.Application.GetResourceStream%2A> </xref:System.Windows.Application.GetContentStream%2A> </xref:System.Windows.Application.FindResource%2A>      - **명령줄 매개 변수 및 종료 코드 처리**: <xref:System.Windows.Application.Startup?displayProperty=fullName>, <xref:System.Windows.Application.Exit?displayProperty=fullName> <xref:System.Windows.Application.Shutdown%2A?displayProperty=fullName>.</xref:System.Windows.Application.Shutdown%2A?displayProperty=fullName> </xref:System.Windows.Application.Exit?displayProperty=fullName> </xref:System.Windows.Application.Startup?displayProperty=fullName>      -   **Navigation**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>, <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>, <xref:System.Windows.Application.NavigationFailed>, <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>.</xref:System.Windows.Application.GetCookie%2A></xref:System.Windows.Application.SetCookie%2A></xref:System.Windows.Application.NavigationFailed></xref:System.Windows.Application.NavigationStopped></xref:System.Windows.Application.NavigationProgress></xref:System.Windows.Application.Navigating></xref:System.Windows.Application.Navigated></xref:System.Windows.Application.LoadCompleted></xref:System.Windows.Application.FragmentNavigation>       응용 프로그램의 창, 속성 및 리소스 범위 서비스에 대 한 공유 액세스를 제공 하는 singleton 패턴을 구현 합니다. 따라서 <xref:System.AppDomain>.</xref:System.AppDomain> 당 응용 프로그램 클래스의 인스턴스 하나만 만들 수 있습니다.       태그, 태그 및 코드 숨김 또는 코드를 사용 하 여 응용 프로그램을 구현할 수 있습니다. 응용 프로그램 구현 하는 경우, 태그와 함께 태그 파일을 구성 해야 태그 또는 태그 및 코드 숨김, 여부는 [!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` 항목입니다.      > [!NOTE] > 독립 실행형 응용 프로그램 응용 프로그램 개체를 필요 하지 않습니다; 사용자 지정 수 `static` 진입점 메서드 (`Main`) 응용 프로그램의 인스턴스를 만들지 않고 창이 열립니다. 그러나 [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)] 응용 프로그램 개체에 필요 합니다."
  example:
  - "The following example shows how a standard application is defined using only markup:  \n  \n [!code-xml[ApplicationSnippets#ApplicationMARKUP](~/add/codesnippet/xaml/ApplicationSnippets.CSharp/AppMarkup.xaml#applicationmarkup)]  \n  \n The following example shows how a standard application is defined using only code:  \n  \n [!code-cs[ApplicationSnippets#ApplicationCODE](~/add/codesnippet/csharp/ApplicationSnippets.CSharp/AppCode.cs#applicationcode)]\n [!code-vb[ApplicationSnippets#ApplicationCODE](~/add/codesnippet/visualbasic/applicationsnippets/appcode.vb#applicationcode)]  \n  \n The following example shows how a standard application is defined using a combination of markup and code-behind.  \n  \n [!code-xml[ApplicationSnippets#ApplicationXAML](~/add/codesnippet/xaml/ApplicationSnippets.CSharp/App.xaml#applicationxaml)]  \n  \n [!code-cs[ApplicationSnippets#ApplicationCODEBEHIND](~/add/codesnippet/csharp/ApplicationSnippets.CSharp/App.xaml.cs#applicationcodebehind)]\n [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/add/codesnippet/visualbasic/applicationsnippets/application.xaml.vb#applicationcodebehind)]"
  syntax:
    content: 'public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient'
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  implements:
  - System.Windows.Markup.IQueryAmbient
  inheritedMembers:
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.Application.#ctor
  id: '#ctor'
  parent: System.Windows.Application
  langs:
  - csharp
  name: Application()
  nameWithType: Application.Application()
  fullName: System.Windows.Application.Application()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Windows.Application&quot;> </xref> 클래스입니다."
  remarks: "인스턴스가 하나만 <xref:System.Windows.Application>당 클래스를 만들 수 있습니다 <xref:System.AppDomain>, 응용 프로그램 범위 창, 속성 및 리소스 데이터의 단일 집합에 대 한 공유 액세스 되도록 합니다.</xref:System.AppDomain> </xref:System.Windows.Application> 따라서의 기본 생성자는 <xref:System.Windows.Application>클래스 초기화 되 고 인스턴스가에서 첫 번째 인스턴스가 있는지 여부를 검색 한 <xref:System.AppDomain>정상이 아닌 경우는 <xref:System.InvalidOperationException>throw 됩니다.</xref:System.InvalidOperationException> </xref:System.AppDomain> </xref:System.Windows.Application>       <xref:System.Windows.Application>현재에 대 한 개체 <xref:System.AppDomain>정적에서 노출 <xref:System.Windows.Application.Current%2A>속성.</xref:System.Windows.Application.Current%2A> </xref:System.AppDomain> </xref:System.Windows.Application>"
  syntax:
    content: public Application ();
    parameters: []
  overload: System.Windows.Application.#ctor*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "인스턴스가 둘 이상는 <xref href=&quot;System.Windows.Application&quot;> </xref> 당 클래스를 만들 <xref href=&quot;System.AppDomain&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Windows.Application.Activated
  id: Activated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Activated
  nameWithType: Application.Activated
  fullName: System.Windows.Application.Activated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "응용 프로그램은 전경 응용 프로그램이 됩니다 때 발생 합니다."
  remarks: "A [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] 하나 이상의 열려 있는 창이 응용 프로그램을 활성화 (포그라운드로 됨) 창 중 하나는 활성화 된 경우 처음으로 응용 프로그램이 시작 된 이후 또는 창이 활성화 될 때 응용 프로그램이 활성 상태인 동안: 프로그램이 경우:-응용 프로그램의 첫 번째 창을 엽니다.      -사용자가 ALT + TAB을 사용 하 여 또는 작업 관리자를 사용 하 여 응용 프로그램으로 전환 합니다.      -사용자가 응용 프로그램의 창 중 하나에 대 한 작업 표시줄 단추를 클릭 합니다.       활성화 되는 시기를 검색 하는 응용 프로그램 Activated 이벤트를 처리할 수 있습니다.       응용 프로그램 처음 활성화 된 후 비활성화 하 고 해당 수명 동안 여러 번 다시 활성화 될 수 있습니다. 응용 프로그램의 동작 또는 상태는 정품 인증 상태에 따라 달라 지, Activated 및 <xref:System.Windows.Application.Deactivated>를 정품 인증을 확인 하는 이벤트의 기능 상태</xref:System.Windows.Application.Deactivated> 를 모두 처리할 수 있습니다.       응용 프로그램 활성화 되 면 Activated 응용 프로그램이 활성 상태인 동안 응용 프로그램 내에서 개수 창이 활성화 될에 관계 없이 응용 프로그램이 비활성화 될 때까지 다시 발생 하지 않습니다.       활성화 발생 하지 않습니다 [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]합니다."
  example:
  - "The following example shows how to detect when a standalone application activates and deactivates.  \n  \n [!code-xml[ApplicationActivationSnippets#DetectActivationStateXAML](~/add/codesnippet/xaml/ApplicationActivationSnippets.CSharp/App.xaml#detectactivationstatexaml)]  \n  \n [!code-cs[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/csharp/ApplicationActivationSnippets.CSharp/App.xaml.cs#detectactivationstatecodebehind)]\n [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/visualbasic/applicationactivationsnippets/application.xaml.vb#detectactivationstatecodebehind)]"
  syntax:
    content: public event EventHandler Activated;
    return:
      type: System.EventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Current
  id: Current
  parent: System.Windows.Application
  langs:
  - csharp
  name: Current
  nameWithType: Application.Current
  fullName: System.Windows.Application.Current
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "가져옵니다는 <xref href=&quot;System.Windows.Application&quot;> </xref> 현재에 대 한 개체 <xref href=&quot;System.AppDomain&quot;> </xref>합니다."
  remarks: "<xref:System.Windows.Application>이 당-<xref:System.AppDomain> <xref:System.Windows.Application>현재 <xref:System.AppDomain>.</xref:System.AppDomain> 에 대 한 인스턴스</xref:System.Windows.Application> 를 공유 액세스를 제공 하도록 현재 정적 속성을 구현 하는 단일 유형</xref:System.AppDomain></xref:System.Windows.Application> 이 디자인 하 여 관리 되는 상태에서는 <xref:System.Windows.Application>, 공유 리소스 및 상태를 포함 하 여, 하나의 공유 위치에서 제공 됩니다.</xref:System.Windows.Application>       이 속성은 스레드로부터 안전 하 고 모든 스레드에서 사용할 수 있습니다."
  syntax:
    content: public static System.Windows.Application Current { get; }
    return:
      type: System.Windows.Application
      description: "<xref href=&quot;System.Windows.Application&quot;> </xref> 현재에 대 한 개체 <xref href=&quot;System.AppDomain&quot;> </xref>합니다."
  overload: System.Windows.Application.Current*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Deactivated
  id: Deactivated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Deactivated
  nameWithType: Application.Deactivated
  fullName: System.Windows.Application.Deactivated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "응용 프로그램 포그라운드 응용 프로그램이 중지 될 때 발생 합니다."
  remarks: "A [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] (포그라운드 응용 프로그램이 중지 됨)를 비활성화 하는 하나 이상의 열려 있는 창이 응용 프로그램 사용자가 다음을 수행 하는 경우:-ALT + TAB을 사용 하 여 또는 작업 관리자를 사용 하 여 다른 응용 프로그램으로 전환 합니다.      -다른 응용 프로그램의 창에 대 한 작업 표시줄 단추를 클릭합니다.       비활성화를 검색 하는 응용 프로그램 Deactivated 이벤트를 처리할 수 있습니다.       응용 프로그램 처음 활성화 된 후 비활성화 하 고 해당 수명 동안 여러 번 다시 활성화 될 수 있습니다. 두 Deactivated를 처리할 수 있는 응용 프로그램의 동작 또는 상태는 정품 인증 상태에 따라 달라 지, 및 <xref:System.Windows.Application.Activated>는 상태를 확인할 수 인치</xref:System.Windows.Application.Activated>       비활성화에 대 한 끝나면 [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]합니다."
  example:
  - "The following example shows how to detect when a standalone application deactivates and activates.  \n  \n [!code-xml[ApplicationActivationSnippets#DetectActivationStateXAML](~/add/codesnippet/xaml/ApplicationActivationSnippets.CSharp/App.xaml#detectactivationstatexaml)]  \n  \n [!code-cs[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/csharp/ApplicationActivationSnippets.CSharp/App.xaml.cs#detectactivationstatecodebehind)]\n [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/visualbasic/applicationactivationsnippets/application.xaml.vb#detectactivationstatecodebehind)]"
  syntax:
    content: public event EventHandler Deactivated;
    return:
      type: System.EventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.DispatcherUnhandledException
  id: DispatcherUnhandledException
  parent: System.Windows.Application
  langs:
  - csharp
  name: DispatcherUnhandledException
  nameWithType: Application.DispatcherUnhandledException
  fullName: System.Windows.Application.DispatcherUnhandledException
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "예외는 응용 프로그램에서 throw 되었지만 처리 되지 않은 경우 발생 합니다."
  remarks: "기본적으로 [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] 처리 되지 않은 예외를 catch 하 고 예외 (올은 예외를 보고할 수) 대화 상자에서 사용자에 게 알려줍니다 자동으로 응용 프로그램을 종료 합니다.       그러나 응용 프로그램을 사용자 지정 되지 않은 예외를 중앙된 위치에서 처리를 수행 하는 경우 DispatcherUnhandledException를 처리 해야 합니다.       DispatcherUnhandledException는에 의해 발생 한 <xref:System.Windows.Application>주 UI 스레드에서 실행 되는 코드에서 처리 되지 않은 각 예외에 대 한.</xref:System.Windows.Application>       예외가 처리 되지 않은 경우에 배경 [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] 스레드 (자체로 스레드 <xref:System.Windows.Threading.Dispatcher>) 또는 백그라운드 작업자 스레드 (없는 스레드는 <xref:System.Windows.Threading.Dispatcher>), 예외 주에 게 전달 되지 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] 스레드.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> 따라서 DispatcherUnhandledException 발생 하지 않습니다. 이러한 경우에는 다음을 수행 하는 코드를 작성 해야 합니다. 1.  백그라운드 스레드에서 예외를 처리 합니다.      2.  이러한 예외를 주 디스패치 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] 스레드입니다.      3.  주 다시 throw 할 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] 스레드를 거듭제곱할 DispatcherUnhandledException을 허용 하도록 처리 하지 않고 있습니다.       자세한 내용은 참조는 [스레딩 모델](~/add/includes/ajax-current-ext-md.md) 개요입니다.       DispatcherUnhandledException 이벤트 처리기에 전달 되는 <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs>인수는 예외에 대 한 컨텍스트 정보를 포함 하는 포함 하 여:-예외 (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>).</xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A> </xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs>      - <xref:System.Windows.Threading.Dispatcher>예외가 시작 된 (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>).</xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A> </xref:System.Windows.Threading.Dispatcher>       예외를 복구할 수 있는지 여부를 확인 하려면이 정보를 사용할 수 있습니다. 복구 가능한 예외는 <xref:System.IO.FileNotFoundException>, 예를 들어 복구할 수 없는 예외 수 있지만 한 <xref:System.StackOverflowException>, 예를 들어.</xref:System.StackOverflowException> </xref:System.IO.FileNotFoundException>       DispatcherUnhandledException에서 처리 되지 않은 예외를 처리 하지 않으려면 시점과 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 설정 해야 처리를 계속 하려면는 <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A>속성을 `true`.</xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A>       다른 이벤트와 달리는 <xref:System.Windows.Application>DispatcherUnhandledException 발생 시키고 일치 하는 보호 된 가상 구현 (OnDispatcherUnhandledException)가 없습니다.</xref:System.Windows.Application> 따라서 클래스에서 파생 되는 <xref:System.Windows.Application>DispatcherUnhandledException 처리 되지 않은 예외를 처리 하는 이벤트 처리기 등록 항상 해야 합니다.</xref:System.Windows.Application>"
  example:
  - "The following example shows how to process unhandled exceptions by handling the DispatcherUnhandledException event.  \n  \n [!code-cs[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/add/codesnippet/csharp/ApplicationDispatcherUnhandledExceptionSnippets.CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind1)]\n [!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/add/codesnippet/visualbasic/applicationdispatcherunhandledexceptionsnippets/application.xaml.vb#handledispatcherunhandledexceptioncodebehind1)]  \n[!code-cs[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/add/codesnippet/csharp/ApplicationDispatcherUnhandledExceptionSnippets.CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind2)]\n[!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/add/codesnippet/visualbasic/applicationdispatcherunhandledexceptionsnippets/application.xaml.vb#handledispatcherunhandledexceptioncodebehind2)]"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Exit
  id: Exit
  parent: System.Windows.Application
  langs:
  - csharp
  name: Exit
  nameWithType: Application.Exit
  fullName: System.Windows.Application.Exit
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "응용 프로그램을 종료 하 고 취소할 수 없습니다 직전에 발생 합니다."
  remarks: "다음 이유 중 하나에 대 한 응용 프로그램이 종료 수:- <xref:System.Windows.Application.Shutdown%2A>의 메서드는 <xref:System.Windows.Application>의해 명시적으로 또는 결정 된 대로 개체 호출 됩니다는 <xref:System.Windows.Application.ShutdownMode%2A>속성.</xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application> </xref:System.Windows.Application.Shutdown%2A>      -사용자 로그 오프 하거나 종료 하는 세션을 종료 합니다.       종료 이벤트를 처리 하 여 응용 프로그램이 종료 하는 경우이 감지할 수 있으며 필요에 따라 추가 처리를 수행할 수 있습니다.       검사 하거나를 호출할 필요 하지 않을 때 응용 프로그램 종료 코드를 변경 하려면 종료를 처리할 수도 있습니다 <xref:System.Windows.Application.Shutdown%2A>명시적으로.</xref:System.Windows.Application.Shutdown%2A> 종료 코드에서 노출 되는 <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>속성은 <xref:System.Windows.ExitEventArgs>종료 이벤트 처리기에 전달 되는 인수.</xref:System.Windows.ExitEventArgs> </xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> 응용 프로그램 실행을 중지, 종료 코드 후속 처리에 대 한 운영 체제에 전달 됩니다.       응용 프로그램에서 처리 하는 경우는 <xref:System.Windows.Application.SessionEnding>이벤트 이후에, 종료는 발생 하지 않습니다 취소 및 응용 프로그램에서에서 계속 실행 종료 모드에 따라 및.</xref:System.Windows.Application.SessionEnding>       종료 코드에서 설정할 수 있습니다는 [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]있지만 값이 무시 됩니다.       에 대 한 [!INCLUDE[TLA2#tla_xbap#plural](~/add/includes/tla2sharptla-xbapsharpplural-md.md)], 다음과 같은 상황에서 발생 하는 종료:- [!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)] 에서 멀리 이동 하 게 됩니다.      -에 [!INCLUDE[TLA2#tla_ie7](~/add/includes/tla2sharptla-ie7-md.md)]때 호스팅하는 탭은 [!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)] 닫힙니다.      -브라우저 닫혀 있습니다.       모든 경우의 값에는 <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>속성은 무시 됩니다.</xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>"
  example:
  - "The following example demonstrates how to:  \n  \n-   Handle the Exit event.  \n  \n-   Inspect and update the <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> property of the <xref:System.Windows.ExitEventArgs>.  \n  \n-   Write an entry to an application log in isolated storage.  \n  \n-   Persist the application state to isolated storage.  \n  \n [!code-xml[ApplicationExitSnippets#HandleExitXAML](~/add/codesnippet/xaml/ApplicationExitSnippets.CSharp/App.xaml#handleexitxaml)]  \n  \n [!code-cs[ApplicationExitSnippets#HandleExitCODEBEHIND](~/add/codesnippet/csharp/ApplicationExitSnippets.CSharp/App.xaml.cs#handleexitcodebehind)]\n [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/add/codesnippet/visualbasic/applicationexitsnippets/application.xaml.vb#handleexitcodebehind)]"
  syntax:
    content: public event System.Windows.ExitEventHandler Exit;
    return:
      type: System.Windows.ExitEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.FindResource(System.Object)
  id: FindResource(System.Object)
  parent: System.Windows.Application
  langs:
  - csharp
  name: FindResource(Object)
  nameWithType: Application.FindResource(Object)
  fullName: System.Windows.Application.FindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "검색 한 [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] 리소스와 같은 <xref href=&quot;System.Windows.Style&quot;> </xref> 또는 <xref href=&quot;System.Windows.Media.Brush&quot;> </xref>, 지정 된 키와 throw 요청 된 리소스가 없는 경우 예외 (참조 [XAML 리소스](~/add/includes/ajax-current-ext-md.md))."
  remarks: "지정된 된 리소스에 대 한 응용 프로그램 범위 리소스에서 FindResource 먼저 보입니다. 응용 프로그램 범위 리소스 관리 <xref:System.Windows.Application>에서 노출 하 고는 <xref:System.Windows.Application.Resources%2A>속성.</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application> 지정된 된 리소스는 응용 프로그램 범위 리소스 집합에 없는 경우 FindResource 그런 다음 다음 검색 시스템 리소스입니다. 시스템 리소스는 사용자가 정의한 shell 리소스 있으며 색, 글꼴 및 셸 구성을 포함 합니다. 노출 된 <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, 및 <xref:System.Windows.SystemParameters>형식을 각각 정적 속성으로.</xref:System.Windows.SystemParameters> </xref:System.Windows.SystemFonts> </xref:System.Windows.SystemColors> FindResource을 얻으려고를 사용 하려면 이러한 형식은 속성을 노출 리소스 키 FindResource;를 전달 하도록 디자인 된 예를 들어 <xref:System.Windows.SystemParameters.IconWidthKey%2A>.</xref:System.Windows.SystemParameters.IconWidthKey%2A>       FindResource 개체를 반환 하므로 리소스를 찾을 경우 적절 한 형식으로 반환된 된 값을 캐스팅 해야 합니다.      > [!IMPORTANT] >를 찾을 수 없는 키에 대 한이 메서드를 호출 하면 예외가 throw 됩니다. 호출 FindResource 여에서 발생 하는 예외를 처리 하지 않을 경우 <xref:System.Windows.Application.TryFindResource%2A>대신 호출 합니다. <xref:System.Windows.Application.TryFindResource%2A>반환는 `null` 참조할 때 요청 된 리소스를 찾을 수 없으면 예외를 throw 하지 않습니다.</xref:System.Windows.Application.TryFindResource%2A> </xref:System.Windows.Application.TryFindResource%2A>       이 메서드는 스레드로부터 안전 하 고 모든 스레드에서 호출할 수 있습니다."
  example:
  - "The following example shows how to use FindResource to find a resource, and to handle <xref:System.Windows.ResourceReferenceKeyNotFoundException> if the resource is not found.  \n  \n [!code-cs[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/add/codesnippet/csharp/ApplicationFindResourceSnippets/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]\n [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/add/codesnippet/visualbasic/applicationfindresourcesnippets/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]"
  syntax:
    content: public object FindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "찾을 리소스의 이름입니다."
    return:
      type: System.Object
      description: "요청 된 리소스 개체입니다. 현재 요청의 없으면는 <xref href=&quot;System.Windows.ResourceReferenceKeyNotFoundException&quot;> </xref> throw 됩니다."
  overload: System.Windows.Application.FindResource*
  exceptions:
  - type: System.Windows.ResourceReferenceKeyNotFoundException
    commentId: T:System.Windows.ResourceReferenceKeyNotFoundException
    description: "리소스를 찾을 수 없습니다."
  platform:
  - net462
- uid: System.Windows.Application.FragmentNavigation
  id: FragmentNavigation
  parent: System.Windows.Application
  langs:
  - csharp
  name: FragmentNavigation
  nameWithType: Application.FragmentNavigation
  fullName: System.Windows.Application.FragmentNavigation
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "응용 프로그램의 탐색기 콘텐츠 조각 탐색을 시작할 때 발생 원하는 조각이 되었거나 현재 콘텐츠에 원본 뒤 탐색 즉시 발생 [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] 다른 콘텐츠에 있으면 경우 콘텐츠가 로드 됨."
  remarks: "탐색기 중 하나는 <xref:System.Windows.Navigation.NavigationWindow>나 <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow> 는       <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=fullName> 를 참조 하십시오."
  syntax:
    content: public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;
    return:
      type: System.Windows.Navigation.FragmentNavigationEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.GetContentStream(System.Uri)
  id: GetContentStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetContentStream(Uri)
  nameWithType: Application.GetContentStream(Uri)
  fullName: System.Windows.Application.GetContentStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "지정 된에 있는 콘텐츠 데이터 파일에 대 한 리소스 스트림을 반환 <xref:System.Uri>(참조 [WPF 응용 프로그램 리소스, 내용 및 데이터 파일](~/add/includes/ajax-current-ext-md.md)).</xref:System.Uri>"
  remarks: "이 메서드는 스레드로부터 안전 하지 않습니다."
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);
    parameters:
    - id: uriContent
      type: System.Uri
      description: "상대 <xref:System.Uri>느슨한 리소스에 매핑되는.</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "A <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref> 지정된 <xref:System.Uri>.</xref:System.Uri> 에 있는 콘텐츠 데이터 파일이 들어 있는 느슨한 리소스가 없는 경우 null이 반환 됩니다."
  overload: System.Windows.Application.GetContentStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref:System.Uri>에 전달 되는 GetContentStream null입니다.</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref:System.Uri>즉 GetContentStream에 전달 된가 절대 <xref:System.Uri>.</xref:System.Uri> </xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.GetCookie(System.Uri)
  id: GetCookie(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetCookie(Uri)
  nameWithType: Application.GetCookie(Uri)
  fullName: System.Windows.Application.GetCookie(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "에 <xref:System.Uri>.</xref:System.Uri> 로 지정 된 위치에 대 한 쿠키를 검색 합니다."
  remarks: "GetCookie <xref:System.Uri>.</xref:System.Uri> 지정된에 대 한 쿠키를 검색합니다. 쿠키를 검색할 수 없는 경우는 <xref:System.ComponentModel.Win32Exception>throw 됩니다.</xref:System.ComponentModel.Win32Exception> 이름/값 쌍의 목록 쿠키 문자열 구문 분석 하는 코드를 작성 해야 합니다.       쿠키에 대 한 개요 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)], 참조 [탐색 개요](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public static string GetCookie (Uri uri);
    parameters:
    - id: uri
      type: System.Uri
      description: "<xref:System.Uri>쿠키가 만들어진 위치를 지정 하는.</xref:System.Uri>"
    return:
      type: System.String
      description: "A <xref:System.String>값을 쿠키가 있으면; 그렇지 않으면는 <xref href=&quot;System.ComponentModel.Win32Exception&quot;> </xref> throw 됩니다.</xref:System.String>"
  overload: System.Windows.Application.GetCookie*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "A [!INCLUDE[TLA#tla_win32](~/add/includes/tlasharptla-win32-md.md)] 에서 오류가 발생 한는 <xref uid=&quot;langword_csharp_InternetGetCookie&quot; name=&quot;InternetGetCookie&quot; href=&quot;&quot;> </xref> 함수 (GetCookie 라고 함)를 지정된 된 쿠키를 검색할 때 문제가 발생 한 경우."
  platform:
  - net462
- uid: System.Windows.Application.GetRemoteStream(System.Uri)
  id: GetRemoteStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetRemoteStream(Uri)
  nameWithType: Application.GetRemoteStream(Uri)
  fullName: System.Windows.Application.GetRemoteStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "원본 사이트의 데이터 파일에 지정 된 위치에 대 한 리소스 스트림을 반환 <xref:System.Uri>(참조 [WPF 응용 프로그램 리소스, 내용 및 데이터 파일](~/add/includes/ajax-current-ext-md.md)).</xref:System.Uri>"
  remarks: "이 메서드는 스레드로부터 안전 하지 않습니다."
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);
    parameters:
    - id: uriRemote
      type: System.Uri
      description: "<xref:System.Uri>느슨한 원본 사이트에 리소스에 매핑되는.</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "A <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref> 지정된 <xref:System.Uri>.</xref:System.Uri> 에 있는 원본 사이트의 데이터 파일에 대 한 리소스 스트림이 포함 된 느슨한 리소스가 없으면 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 반환 됩니다."
  overload: System.Windows.Application.GetRemoteStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref:System.Uri>에 전달 되는 GetRemoteStream null입니다.</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref:System.Uri>에 전달 되는 GetRemoteStream는 상대적이 지 않고이 아니라 절대 주소 또는 `pack://siteoforigin:,,,/` 양식.</xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.GetResourceStream(System.Uri)
  id: GetResourceStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetResourceStream(Uri)
  nameWithType: Application.GetResourceStream(Uri)
  fullName: System.Windows.Application.GetResourceStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "지정 된 위치에서 있는 리소스 데이터 파일에 대 한 리소스 스트림을 반환 <xref:System.Uri>(참조 [WPF 응용 프로그램 리소스, 내용 및 데이터 파일](~/add/includes/ajax-current-ext-md.md)).</xref:System.Uri>"
  remarks: "이 메서드는 스레드로부터 안전 하지 않습니다."
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);
    parameters:
    - id: uriResource
      type: System.Uri
      description: "<xref:System.Uri>포함된 된 리소스에 매핑되는.</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "A <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref> 지정된 <xref:System.Uri>.</xref:System.Uri> 에 있는 리소스 데이터 파일에 대 한 리소스 스트림이 포함 된"
  overload: System.Windows.Application.GetResourceStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref:System.Uri>에 전달 되는 GetResourceStream null입니다.</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref:System.Uri>에 전달 되는 GetResourceStream는 상대적이 지 않고이 아니라 절대 주소 또는 `pack://application:,,,/` 양식.</xref:System.Uri>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<xref:System.Uri>에 전달 되는 GetResourceStream를 찾을 수 없습니다.</xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.LoadCompleted
  id: LoadCompleted
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadCompleted
  nameWithType: Application.LoadCompleted
  fullName: System.Windows.Application.LoadCompleted
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "응용 프로그램의 탐색기에서 탐색 된 콘텐츠 로드 된 구문 분석 및 렌더링 되기 시작할 때 발생 합니다."
  remarks: "탐색기 중 하나는 <xref:System.Windows.Navigation.NavigationWindow>나 <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow> 는       <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=fullName> 를 참조 하십시오.      > [!NOTE] >와 같은 이벤트 탐색된 된 콘텐츠를 수신 대기는 <xref:System.Windows.FrameworkElement.Loaded>에 이벤트 <xref:System.Windows.Controls.Page>탐색된 된 콘텐츠의 속성에 액세스 하기 전에.</xref:System.Windows.Controls.Page> </xref:System.Windows.FrameworkElement.Loaded>"
  syntax:
    content: public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;
    return:
      type: System.Windows.Navigation.LoadCompletedEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.LoadComponent(System.Uri)
  id: LoadComponent(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadComponent(Uri)
  nameWithType: Application.LoadComponent(Uri)
  fullName: System.Windows.Application.LoadComponent(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "로드는 [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] 있는 지정 된 파일에 [!INCLUDE[TLA#tla_uri](~/add/includes/tlasharptla-uri-md.md)]의 루트 요소에 지정 된 개체의 인스턴스로 변환 하 고는 [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] 파일입니다."
  remarks: "반환 값의 루트 요소와 동일한 형식으로 명시적으로 변환 해야 합니다는 [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] 파일입니다.       [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] 파일에는 응용 프로그램 코드 파일 일 수 있습니다 (로 구성 된는 [!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)] 페이지 항목) 또는 응용 프로그램 데이터 파일 (리소스 파일, 콘텐츠 파일 또는의 원본 사이트 파일; 참조 [WPF 응용 프로그램 리소스, 내용 및 데이터 파일](~/add/includes/ajax-current-ext-md.md)).      > [!NOTE] >이 메서드는 스레드로부터 안전 하지 않습니다."
  syntax:
    content: public static object LoadComponent (Uri resourceLocator);
    parameters:
    - id: resourceLocator
      type: System.Uri
      description: "A <xref:System.Uri>상대에 매핑되는 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 파일.</xref:System.Uri>"
    return:
      type: System.Object
      description: "XAML 파일에 지정 된 루트 요소는 인스턴스를 로드 합니다."
  overload: System.Windows.Application.LoadComponent*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceLocator</code>null입니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>resourceLocator</code> is an absolute [!INCLUDE[TLA2#tla_uri](~/add/includes/tla2sharptla-uri-md.md)]."
  - type: System.Exception
    commentId: T:System.Exception
    description: "파일이 아닙니다는 [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] 파일입니다."
  platform:
  - net462
- uid: System.Windows.Application.LoadComponent(System.Object,System.Uri)
  id: LoadComponent(System.Object,System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadComponent(Object,Uri)
  nameWithType: Application.LoadComponent(Object,Uri)
  fullName: System.Windows.Application.LoadComponent(Object,Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "로드 한 [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] 있는 지정 된 파일에 [!INCLUDE[TLA#tla_uri](~/add/includes/tlasharptla-uri-md.md)] 의 루트 요소에 지정 된 개체의 인스턴스로 변환 하 고는 [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] 파일입니다."
  remarks: "[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] 파일에는 응용 프로그램 코드 파일 일 수 있습니다 (로 구성 된는 [!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)] 페이지 항목) 또는 응용 프로그램 데이터 파일 (리소스 파일, 콘텐츠 파일 또는의 원본 사이트 파일; 참조 [WPF 응용 프로그램 리소스, 내용 및 데이터 파일](~/add/includes/ajax-current-ext-md.md)).      > [!NOTE] >이 메서드는 스레드로부터 안전 하지 않습니다."
  syntax:
    content: public static void LoadComponent (object component, Uri resourceLocator);
    parameters:
    - id: component
      type: System.Object
      description: "루트 요소와 동일한 형식의 개체는 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 파일입니다."
    - id: resourceLocator
      type: System.Uri
      description: "A <xref:System.Uri>상대에 매핑되는 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 파일.</xref:System.Uri>"
  overload: System.Windows.Application.LoadComponent*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceLocator</code>null입니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>resourceLocator</code> is an absolute [!INCLUDE[TLA2#tla_uri](~/add/includes/tla2sharptla-uri-md.md)]."
  - type: System.Exception
    commentId: T:System.Exception
    description: "<code>component</code>루트 요소와 일치 하지 않는 형식의 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 파일입니다."
  platform:
  - net462
- uid: System.Windows.Application.MainWindow
  id: MainWindow
  parent: System.Windows.Application
  langs:
  - csharp
  name: MainWindow
  nameWithType: Application.MainWindow
  fullName: System.Windows.Application.MainWindow
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "응용 프로그램의 주 창을 가져오거나 설정 합니다."
  remarks: "MainWindow는 자동으로 첫 번째 <xref:System.Windows.Window> <xref:System.AppDomain>.</xref:System.AppDomain> 에서 인스턴스화할 수 있는 개체</xref:System.Windows.Window> 에 대 한 참조 설정       다른 주 창을 다른 할당 MainWindow를 설정 하 여 지정할 수 있습니다 <xref:System.Windows.Application.Windows%2A>MainWindow 속성에는 개체입니다.</xref:System.Windows.Application.Windows%2A>       경우는 <xref:System.Windows.Application.ShutdownMode%2A>속성의는 <xref:System.Windows.Application>개체로 설정 되어 <xref:System.Windows.ShutdownMode>, 주 창을 닫으면 응용 프로그램을 종료 합니다.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application> </xref:System.Windows.Application.ShutdownMode%2A>       MainWindow 속성을 설정 하는 것이 불가능 [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]응용 프로그램의 주 창 설정 하 여 생성 되는 창이 아닌 경우, 고 <xref:System.Windows.Application.StartupUri%2A>에서 속성 [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)].</xref:System.Windows.Application.StartupUri%2A> 두 가지 제한 된 [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] 접근 방식이 됩니다:-하나만 지정할 수 있습니다는 [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]-만 <xref:System.Windows.Window>또는 [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]-만 <xref:System.Windows.Navigation.NavigationWindow>주 창으로.</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Window>      -설정 해야 합니다는 <xref:System.Windows.UIElement.Visibility%2A>지정할 속성 창, 그렇지 않으면 표시 되지 않게 합니다.</xref:System.Windows.UIElement.Visibility%2A>       첫 번째에 대 한 참조 <xref:System.Windows.Window>개체를 인스턴스화할 수에 첫 번째 항목으로 추가 됩니다는 <xref:System.Windows.Application.Windows%2A>컬렉션.</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Window> MainWindow 다른에 대 한 참조도 설정한 경우 <xref:System.Windows.Window>에 있는 항목의 순서는 동안 주 창에 대 한 참조 항목의 위치가 변경 됩니다 <xref:System.Windows.Application.Windows%2A>그대로 유지 됩니다.</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Window> 따라서 항상 사용 하 여 MainWindow <xref:System.Windows.Application.Windows%2A>.</xref:System.Windows.Application.Windows%2A> 첫 번째 항목 대신 주 창 참조      > [!NOTE] > 주 창이 없으면는 <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Navigation.NavigationWindow>조정 <xref:System.Windows.Navigation.NavigationWindow>.</xref:System.Windows.Navigation.NavigationWindow> 으로 값을 캐스팅 해야 합니다 멤버에</xref:System.Windows.Navigation.NavigationWindow> 대 한 특정 액세스 해야 하 고</xref:System.Windows.Navigation.NavigationWindow>   >>이 속성은 작성 된 스레드에서 에서만 사용할 수는 <xref:System.Windows.Application>개체입니다.</xref:System.Windows.Application>"
  example:
  - "The following example shows how to find the main application window.  \n  \n [!code-cs[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/add/codesnippet/csharp/ApplicationMainWindowSnippets.CSharp/App.xaml.cs#getapplicationmainwindowcode)]\n [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/add/codesnippet/visualbasic/applicationmainwindowsnippets/application.xaml.vb#getapplicationmainwindowcode)]  \n  \n The following example shows how to set MainWindow using [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)].  \n  \n [!code-xml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/add/codesnippet/xaml/ApplicationMainWindowSnippets.XAML/App.xaml#setapplicationmainwindowxaml)]  \n  \n The following example shows how to instantiate the MainWindow in code during application startup.  \n  \n [!code-cs[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/add/codesnippet/csharp/HOWTOWindowManagementSnippets/App.xaml.cs#firstwindowusingcodecodebehind)]\n [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/add/codesnippet/visualbasic/howtowindowmanagementsnippets/application.xaml.vb#firstwindowusingcodecodebehind)]"
  syntax:
    content: public System.Windows.Window MainWindow { get; set; }
    return:
      type: System.Windows.Window
      description: "A <xref href=&quot;System.Windows.Window&quot;> </xref> 주 응용 프로그램 창으로 지정 된 합니다."
  overload: System.Windows.Application.MainWindow*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "와 같은 브라우저에서 호스팅되는 응용 프로그램에서 MainWindow 설정 되어 있는 [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]합니다."
  platform:
  - net462
- uid: System.Windows.Application.Navigated
  id: Navigated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Navigated
  nameWithType: Application.Navigated
  fullName: System.Windows.Application.Navigated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "아직 완전히 로드 되지 않았지만 응용 프로그램의 탐색기에서 탐색 중인 콘텐츠를 찾으면 때 발생 합니다."
  remarks: "탐색기 중 하나는 <xref:System.Windows.Navigation.NavigationWindow>나 <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow> 는       <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName> 를 참조 하십시오."
  syntax:
    content: public event System.Windows.Navigation.NavigatedEventHandler Navigated;
    return:
      type: System.Windows.Navigation.NavigatedEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Navigating
  id: Navigating
  parent: System.Windows.Application
  langs:
  - csharp
  name: Navigating
  nameWithType: Application.Navigating
  fullName: System.Windows.Application.Navigating
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "새 탐색 탐색기 응용 프로그램에서 요청 될 때 발생 합니다."
  remarks: "탐색기 중 하나는 <xref:System.Windows.Navigation.NavigationWindow>나 <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow> 는       <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=fullName> 를 참조 하십시오."
  syntax:
    content: public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;
    return:
      type: System.Windows.Navigation.NavigatingCancelEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationFailed
  id: NavigationFailed
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationFailed
  nameWithType: Application.NavigationFailed
  fullName: System.Windows.Application.NavigationFailed
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "응용 프로그램의 탐색기는 요청한 콘텐츠를 탐색 하는 동안 오류가 발생 하는 경우 발생 합니다."
  remarks: "탐색기 중 하나는 <xref:System.Windows.Navigation.NavigationWindow>나 <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow> 는       <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName> 를 참조 하십시오."
  syntax:
    content: public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;
    return:
      type: System.Windows.Navigation.NavigationFailedEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationProgress
  id: NavigationProgress
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationProgress
  nameWithType: Application.NavigationProgress
  fullName: System.Windows.Application.NavigationProgress
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "탐색기 탐색 진행 정보를 제공 하도록 응용 프로그램에서 관리 되는 다운로드 하는 동안에 주기적으로 발생 합니다."
  remarks: "탐색기 중 하나는 <xref:System.Windows.Navigation.NavigationWindow>나 <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow> 는       <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=fullName> 를 참조 하십시오."
  syntax:
    content: public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;
    return:
      type: System.Windows.Navigation.NavigationProgressEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationStopped
  id: NavigationStopped
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationStopped
  nameWithType: Application.NavigationStopped
  fullName: System.Windows.Application.NavigationStopped
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 경우는 <xref uid=&quot;langword_csharp_StopLoading&quot; name=&quot;StopLoading&quot; href=&quot;&quot;> </xref> 새 탐색 요청 될 경우에 탐색기가 현재 탐색 진행 중인 동안 또는 응용 프로그램의 탐색기의 메서드를 호출 합니다."
  remarks: "탐색기 중 하나는 <xref:System.Windows.Navigation.NavigationWindow>나 <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow> 는       <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=fullName> 를 참조 하십시오."
  syntax:
    content: public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;
    return:
      type: System.Windows.Navigation.NavigationStoppedEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnActivated(System.EventArgs)
  id: OnActivated(System.EventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnActivated(EventArgs)
  nameWithType: Application.OnActivated(EventArgs)
  fullName: System.Windows.Application.OnActivated(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Application.Activated&quot;> </xref> 이벤트입니다."
  remarks: "OnActivated 발생는 <xref:System.Windows.Application.Activated>이벤트.</xref:System.Windows.Application.Activated>       파생 되는 형식을 <xref:System.Windows.Application>OnActivated를 재정의할 수 있습니다.</xref:System.Windows.Application> 재정의 된 메서드를 호출 해야 OnActivated 기본 클래스에 <xref:System.Windows.Application.Activated>발생 해야 합니다.</xref:System.Windows.Application.Activated>"
  syntax:
    content: protected virtual void OnActivated (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>이벤트 데이터를 포함 하는.</xref:System.EventArgs>"
  overload: System.Windows.Application.OnActivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnDeactivated(System.EventArgs)
  id: OnDeactivated(System.EventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnDeactivated(EventArgs)
  nameWithType: Application.OnDeactivated(EventArgs)
  fullName: System.Windows.Application.OnDeactivated(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Application.Deactivated&quot;> </xref> 이벤트입니다."
  remarks: "OnDeactivated 발생는 <xref:System.Windows.Application.Deactivated>이벤트.</xref:System.Windows.Application.Deactivated>       파생 되는 형식을 <xref:System.Windows.Application>OnDeactivated를 재정의할 수 있습니다.</xref:System.Windows.Application> 재정의 된 메서드를 호출 해야 OnDeactivated 기본 클래스에 <xref:System.Windows.Application.Deactivated>발생 해야 합니다.</xref:System.Windows.Application.Deactivated>"
  syntax:
    content: protected virtual void OnDeactivated (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>이벤트 데이터를 포함 하는.</xref:System.EventArgs>"
  overload: System.Windows.Application.OnDeactivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  id: OnExit(System.Windows.ExitEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnExit(ExitEventArgs)
  nameWithType: Application.OnExit(ExitEventArgs)
  fullName: System.Windows.Application.OnExit(ExitEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Application.Exit&quot;> </xref> 이벤트입니다."
  remarks: "OnExit 발생는 <xref:System.Windows.Application.Exit>이벤트.</xref:System.Windows.Application.Exit>       파생 되는 형식을 <xref:System.Windows.Application>OnExit 메서드를 재정의할 수 있습니다.</xref:System.Windows.Application> 재정의 된 메서드를 호출 해야 OnExit 기본 클래스에 <xref:System.Windows.Application.Exit>발생 해야 합니다.</xref:System.Windows.Application.Exit>"
  syntax:
    content: protected virtual void OnExit (System.Windows.ExitEventArgs e);
    parameters:
    - id: e
      type: System.Windows.ExitEventArgs
      description: "<xref href=&quot;System.Windows.ExitEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Windows.Application.OnExit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  id: OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnFragmentNavigation(FragmentNavigationEventArgs)
  nameWithType: Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  fullName: System.Windows.Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Application.FragmentNavigation&quot;> </xref> 이벤트입니다."
  remarks: "OnFragmentNavigation 발생는 <xref:System.Windows.Application.FragmentNavigation>이벤트.</xref:System.Windows.Application.FragmentNavigation>       파생 되는 형식을 <xref:System.Windows.Application>OnFragmentNavigation를 재정의할 수 있습니다.</xref:System.Windows.Application> 재정의 된 메서드를 호출 해야 OnFragmentNavigation 기본 클래스에 <xref:System.Windows.Application.FragmentNavigation>발생 해야 합니다.</xref:System.Windows.Application.FragmentNavigation>"
  syntax:
    content: protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.FragmentNavigationEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.FragmentNavigationEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Windows.Application.OnFragmentNavigation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  id: OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnLoadCompleted(NavigationEventArgs)
  nameWithType: Application.OnLoadCompleted(NavigationEventArgs)
  fullName: System.Windows.Application.OnLoadCompleted(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Application.LoadCompleted&quot;> </xref> 이벤트입니다."
  remarks: "OnLoadCompleted 발생는 <xref:System.Windows.Application.LoadCompleted>이벤트.</xref:System.Windows.Application.LoadCompleted>       파생 되는 형식을 <xref:System.Windows.Application>OnLoadCompleted를 재정의할 수 있습니다.</xref:System.Windows.Application> 재정의 된 메서드를 호출 해야 OnLoadCompleted 기본 클래스에 <xref:System.Windows.Application.LoadCompleted>발생 해야 합니다.</xref:System.Windows.Application.LoadCompleted>"
  syntax:
    content: protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Windows.Application.OnLoadCompleted*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  id: OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigated(NavigationEventArgs)
  nameWithType: Application.OnNavigated(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigated(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Application.Navigated&quot;> </xref> 이벤트입니다."
  remarks: "OnNavigated 발생는 <xref:System.Windows.Application.Navigated>이벤트.</xref:System.Windows.Application.Navigated>       파생 되는 형식을 <xref:System.Windows.Application>OnNavigated를 재정의할 수 있습니다.</xref:System.Windows.Application> 재정의 된 메서드를 호출 해야 OnNavigated 기본 클래스에 <xref:System.Windows.Application.Navigated>발생 해야 합니다.</xref:System.Windows.Application.Navigated>"
  syntax:
    content: protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Windows.Application.OnNavigated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  id: OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigating(NavigatingCancelEventArgs)
  nameWithType: Application.OnNavigating(NavigatingCancelEventArgs)
  fullName: System.Windows.Application.OnNavigating(NavigatingCancelEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Application.Navigating&quot;> </xref> 이벤트입니다."
  remarks: "OnNavigating 발생는 <xref:System.Windows.Application.Navigating>이벤트.</xref:System.Windows.Application.Navigating>       파생 되는 형식을 <xref:System.Windows.Application>OnNavigating를 재정의할 수 있습니다.</xref:System.Windows.Application> 재정의 된 메서드를 호출 해야 OnNavigating 기본 클래스에 <xref:System.Windows.Application.Navigating>발생 해야 합니다.</xref:System.Windows.Application.Navigating>"
  syntax:
    content: protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigatingCancelEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigatingCancelEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Windows.Application.OnNavigating*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  id: OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationFailed(NavigationFailedEventArgs)
  nameWithType: Application.OnNavigationFailed(NavigationFailedEventArgs)
  fullName: System.Windows.Application.OnNavigationFailed(NavigationFailedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Application.NavigationFailed&quot;> </xref> 이벤트입니다."
  remarks: "OnNavigationFailed 발생는 <xref:System.Windows.Application.NavigationFailed>이벤트.</xref:System.Windows.Application.NavigationFailed>       파생 되는 형식을 <xref:System.Windows.Application>OnNavigationFailed를 재정의할 수 있습니다.</xref:System.Windows.Application> 재정의 된 메서드를 호출 해야 OnNavigationFailed 기본 클래스에 <xref:System.Windows.Application.NavigationFailed>발생 해야 합니다.</xref:System.Windows.Application.NavigationFailed>"
  example:
  - "<xref:System.Windows.Application.OnFragmentNavigation%2A>  \n  \n <xref:System.Windows.Application.OnLoadCompleted%2A>  \n  \n <xref:System.Windows.Application.OnNavigating%2A>  \n  \n <xref:System.Windows.Application.OnNavigated%2A>  \n  \n <xref:System.Windows.Application.OnNavigationProgress%2A>  \n  \n <xref:System.Windows.Application.OnNavigationStopped%2A>"
  syntax:
    content: protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationFailedEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationFailedEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Windows.Application.OnNavigationFailed*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  id: OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationProgress(NavigationProgressEventArgs)
  nameWithType: Application.OnNavigationProgress(NavigationProgressEventArgs)
  fullName: System.Windows.Application.OnNavigationProgress(NavigationProgressEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Application.NavigationProgress&quot;> </xref> 이벤트입니다."
  remarks: "OnNavigationProgress 발생는 <xref:System.Windows.Application.NavigationProgress>이벤트.</xref:System.Windows.Application.NavigationProgress>       파생 되는 형식을 <xref:System.Windows.Application>OnNavigationProgress를 재정의할 수 있습니다.</xref:System.Windows.Application> 경우 재정의 된 메서드가 기본 클래스에 명시적으로 OnNavigationProgress 호출 해야 <xref:System.Windows.Application.NavigationProgress>발생 해야 합니다.</xref:System.Windows.Application.NavigationProgress>"
  syntax:
    content: protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationProgressEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationProgressEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Windows.Application.OnNavigationProgress*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  id: OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationStopped(NavigationEventArgs)
  nameWithType: Application.OnNavigationStopped(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigationStopped(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Application.NavigationStopped&quot;> </xref> 이벤트입니다."
  remarks: "OnNavigationStopped 발생는 <xref:System.Windows.Application.NavigationStopped>이벤트.</xref:System.Windows.Application.NavigationStopped>       파생 되는 형식을 <xref:System.Windows.Application>OnNavigationStopped를 재정의할 수 있습니다.</xref:System.Windows.Application> 재정의 된 메서드를 호출 해야 OnNavigationStopped 기본 클래스에 <xref:System.Windows.Application.NavigationStopped>발생 해야 합니다.</xref:System.Windows.Application.NavigationStopped>"
  syntax:
    content: protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Windows.Application.OnNavigationStopped*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  id: OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnSessionEnding(SessionEndingCancelEventArgs)
  nameWithType: Application.OnSessionEnding(SessionEndingCancelEventArgs)
  fullName: System.Windows.Application.OnSessionEnding(SessionEndingCancelEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Application.SessionEnding&quot;> </xref> 이벤트입니다."
  remarks: "OnSessionEnding 발생는 <xref:System.Windows.Application.SessionEnding>이벤트.</xref:System.Windows.Application.SessionEnding>       파생 되는 형식을 <xref:System.Windows.Application>OnSessionEnding를 재정의할 수 있습니다.</xref:System.Windows.Application> 재정의 된 메서드를 호출 해야 OnSessionEnding 기본 클래스에 <xref:System.Windows.Application.SessionEnding>발생 해야 합니다.</xref:System.Windows.Application.SessionEnding>"
  syntax:
    content: protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);
    parameters:
    - id: e
      type: System.Windows.SessionEndingCancelEventArgs
      description: "A <xref href=&quot;System.Windows.SessionEndingCancelEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Windows.Application.OnSessionEnding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  id: OnStartup(System.Windows.StartupEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnStartup(StartupEventArgs)
  nameWithType: Application.OnStartup(StartupEventArgs)
  fullName: System.Windows.Application.OnStartup(StartupEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Application.Startup&quot;> </xref> 이벤트입니다."
  remarks: "OnStartup 발생는 <xref:System.Windows.Application.Startup>이벤트.</xref:System.Windows.Application.Startup>       파생 되는 형식을 <xref:System.Windows.Application>OnStartup를 재정의할 수 있습니다.</xref:System.Windows.Application> 재정의 된 메서드를 호출 해야 OnStartup 기본 클래스에는 <xref:System.Windows.Application.Startup>이벤트 발생 해야 합니다.</xref:System.Windows.Application.Startup>"
  syntax:
    content: protected virtual void OnStartup (System.Windows.StartupEventArgs e);
    parameters:
    - id: e
      type: System.Windows.StartupEventArgs
      description: "A <xref href=&quot;System.Windows.StartupEventArgs&quot;> </xref> 하는 이벤트 데이터를 포함 합니다."
  overload: System.Windows.Application.OnStartup*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Properties
  id: Properties
  parent: System.Windows.Application
  langs:
  - csharp
  name: Properties
  nameWithType: Application.Properties
  fullName: System.Windows.Application.Properties
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "응용 프로그램 범위의 속성 컬렉션을 가져옵니다."
  remarks: "<xref:System.Windows.Application>응용 프로그램 범위의 속성을 저장 하는 데 사용할 수 있는 속성을 통해 사전을 노출 합니다.</xref:System.Windows.Application> 모든 코드에서 상태를 공유할 수 있습니다는 <xref:System.AppDomain>고유한 상태 코드를 작성할 필요 없이 스레드로부터 안전한 방식입니다.</xref:System.AppDomain>       속성에 저장 된 속성을 반환 하는 적절 한 형식으로 변환 해야 합니다.       TheProperties 속성은 스레드로부터 안전 하 고 모든 스레드에서 사용할 수 있습니다."
  example:
  - "The following example shows how create and use an application-scope property using Properties.  \n  \n [!code-xml[ApplicationPropertiesSnippets#HandleStartupXAML](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/App.xaml#handlestartupxaml)]  \n  \n [!code-cs[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/csharp/ApplicationPropertiesSnippets.CSharp/App.xaml.cs#handlestartupcodebehind)]\n [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/visualbasic/applicationpropertiessnippets/application.xaml.vb#handlestartupcodebehind)]  \n  \n [!code-xml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  \n[!code-xml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  \n  \n [!code-cs[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/add/codesnippet/csharp/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]\n [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/add/codesnippet/visualbasic/applicationpropertiessnippets/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]"
  syntax:
    content: public System.Collections.IDictionary Properties { get; }
    return:
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>응용 프로그램 범위의 속성을 포함 하는.</xref:System.Collections.IDictionary>"
  overload: System.Windows.Application.Properties*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.ResourceAssembly
  id: ResourceAssembly
  parent: System.Windows.Application
  langs:
  - csharp
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
  fullName: System.Windows.Application.ResourceAssembly
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "가져오거나는 <xref:System.Reflection.Assembly>에서 팩을 제공 하는 [!INCLUDE[TLA#tla_uri#plural](~/add/includes/tlasharptla-urisharpplural-md.md)] 의 리소스에 대 한는 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 응용 프로그램.</xref:System.Reflection.Assembly>"
  remarks: "기본적으로 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 리소스가 반환 되는 값으로 식별 되는 항목 어셈블리와 관련 하 여 실행 시 확인 되는 <xref:System.Reflection.Assembly.GetEntryAssembly%2A>메서드.</xref:System.Reflection.Assembly.GetEntryAssembly%2A>       진입 어셈블리에서 반환 되는 어셈블리는 <xref:System.Reflection.Assembly.GetEntryAssembly%2A>다음 될 수 있습니다.-기본 응용 프로그램 도메인에서 실행 가능한 어셈블리.</xref:System.Reflection.Assembly.GetEntryAssembly%2A>      - <xref:System.AppDomain.ExecuteAssembly%2A>.</xref:System.AppDomain.ExecuteAssembly%2A> 를 호출 하 여 실행할 첫 번째 어셈블리       그러나 다음과 같은 경우에는 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 어셈블리 항목 어셈블리에 대 한 참조를 가져올 수 없습니다:-는 (네이티브) 응용 프로그램에서 호스트를 관리 되지 않는 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 어셈블리입니다.      -관리 되는 응용 프로그램 호스트는 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 이외의 메서드를 사용 하 여 새 응용 프로그램 도메인 <xref:System.AppDomain.ExecuteAssembly%2A>.</xref:System.AppDomain.ExecuteAssembly%2A> 에 로드 하 여 어셈블리       이러한 경우 모두 <xref:System.Reflection.Assembly.GetEntryAssembly%2A>반환 `null`, 및 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 어셈블리의 리소스를 확인할 수 없습니다.</xref:System.Reflection.Assembly.GetEntryAssembly%2A> 이러한 경우 ResourceAssembly 설정할 수 있습니다, 한 번만 리소스를 확인 하는 데 사용 해야 하는 어셈블리에 대 한 참조입니다.       ResourceAssembly 시키면 한 번의 리소스 어셈블리가 후 변경 될 가능성이 없기 때문에 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 어셈블리는 로드 됩니다.      > [!NOTE] > ResourceAssembly을 설정할 수 없습니다는 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 어셈블리 항목 어셈블리를 검색할 수 있습니다-즉, <xref:System.Reflection.Assembly.GetEntryAssembly%2A>어셈블리에 대 한 참조를 반환 하지 않고 `null`.</xref:System.Reflection.Assembly.GetEntryAssembly%2A>       이 속성은 스레드로부터 안전 하 고 모든 스레드에서 사용할 수 있습니다.       ResourceAssembly는.NET Framework 버전 3.5에서에서 도입 되었습니다.  자세한 내용은 참조 [버전 및 종속성](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public static System.Reflection.Assembly ResourceAssembly { get; set; }
    return:
      type: System.Reflection.Assembly
      description: "에 대 한 참조는 <xref:System.Reflection.Assembly>에서 팩을 제공 하는 [!INCLUDE[TLA#tla_uri#plural](~/add/includes/tlasharptla-urisharpplural-md.md)] 의 리소스에 대 한는 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 응용 프로그램.</xref:System.Reflection.Assembly>"
  overload: System.Windows.Application.ResourceAssembly*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 응용 프로그램에는 입력 어셈블리 또는 ResourceAssembly 이미 설정 되었습니다."
  platform:
  - net462
- uid: System.Windows.Application.Resources
  id: Resources
  parent: System.Windows.Application
  langs:
  - csharp
  name: Resources
  nameWithType: Application.Resources
  fullName: System.Windows.Application.Resources
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "스타일 및 브러시 등의 응용 프로그램 범위 리소스의 컬렉션을 가져오거나 설정 합니다."
  remarks: "Windows 및 응용 프로그램의 요소 간에 리소스를 공유 하려면 리소스 속성을 사용할 수 있습니다. 또한 리소스 속성은 다음과 같은 순서로 트래버스 리소스 조회 경로에 포함: 1입니다.  요소 2입니다.  Windows 3입니다.  4 리소스가 없습니다.  시스템 따라서 [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] 요소는 응용 프로그램 범위 리소스에 바인딩될 수 있습니다. 또한, 리소스 변경, 리소스 시스템 해당 요소 되도록 해당 리소스에 바인딩되는 속성의 변경 내용을 반영 하도록 자동으로 업데이트 됩니다.       응용 프로그램 범위 리소스 응용 프로그램 전체에서 일관 된 테마를 지원 하는 간단한 방법을 제공 합니다. 에 테마를 쉽게 만들 수 있습니다 [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] 를 사용 하 여는 `Application.Resources` 태그입니다. 그러나 응용 프로그램이 많은 테마 요소를 포함할 수도 있는 여러 테마를 지원 하기 쉬울 수 있습니다 하나를 사용 하 여 관리 <xref:System.Windows.ResourceDictionary>각 테마에 대 한 인스턴스.</xref:System.Windows.ResourceDictionary> 이러한 방식으로 새 테마에 적절 한 <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> 리소스 속성을 설정 하 여 적용할 수 있습니다.       리소스를 사용 하 여 때 두 가지 고려 사항이 있습니다. 먼저, 사전 *키* 은 개체를 설정 하 고 (참고는 문자열을 사용 하는 경우 키가 대/소문자 구분) 속성 값을 가져올 경우 정확히 동일한 개체 인스턴스를 사용 해야 합니다. 두 번째, 사전 *값* 개체 이므로 속성 값을 가져올 때 값을 원하는 형식으로 변환 해야 합니다.       리소스는 스레드로부터 안전 하며 모든 스레드에서 사용할 수 있습니다."
  example:
  - "This example illustrates how to use [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] together with application-scope resources to create a consistent visual appearance.  \n  \n [!code-xml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/App.xaml#resourcespropertyxaml)]  \n  \n [!code-xml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/MainWindow.xaml#windowbackgroundpropertyxaml1)]  \n[!code-xml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML2](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/MainWindow.xaml#windowbackgroundpropertyxaml2)]  \n  \n The following example shows how to set an application resource in code and XAML.  \n  \n [!code-vb[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/add/codesnippet/visualbasic/howtoapplicationmodelsnippets/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]\n [!code-cs[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/add/codesnippet/csharp/HOWTOApplicationModelSnippets/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]  \n  \n [!code-xml[HOWTOApplicationModelSnippets#SetApplicationScopeResourceXAML](~/add/codesnippet/xaml/HOWTOApplicationModelSnippets/App.xaml#setapplicationscoperesourcexaml)]  \n  \n The following example shows how to get an application resource in code.  \n  \n [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/add/codesnippet/visualbasic/howtoapplicationmodelsnippets/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]\n [!code-cs[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/add/codesnippet/csharp/HOWTOApplicationModelSnippets/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]"
  syntax:
    content: public System.Windows.ResourceDictionary Resources { get; set; }
    return:
      type: System.Windows.ResourceDictionary
      description: "A <xref href=&quot;System.Windows.ResourceDictionary&quot;> </xref>&0; 개 이상의 응용 프로그램 범위 리소스를 포함 하는 개체입니다."
  overload: System.Windows.Application.Resources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Run
  id: Run
  parent: System.Windows.Application
  langs:
  - csharp
  name: Run()
  nameWithType: Application.Run()
  fullName: System.Windows.Application.Run()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "시작 된 [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] 응용 프로그램입니다."
  remarks: "<xref:System.Windows.Application.Run%2A>시작 하기 위해 호출 됩니다는 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 응용 프로그램입니다.</xref:System.Windows.Application.Run%2A> 정의 하는 경우 프로그램 <xref:System.Windows.Application>태그 또는 태그 및 코드 숨김을 사용 하 여 <xref:System.Windows.Application.Run%2A>암시적으로 호출 됩니다.</xref:System.Windows.Application.Run%2A> </xref:System.Windows.Application> 그러나 <xref:System.Windows.Application>코드를 사용 하는 명시적으로 호출 해야 <xref:System.Windows.Application.Run%2A>.</xref:System.Windows.Application.Run%2A> </xref:System.Windows.Application> 정의 하는 경우       때 <xref:System.Windows.Application.Run%2A>를 호출할 <xref:System.Windows.Application>새 연결 <xref:System.Windows.Threading.Dispatcher>인스턴스는 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] 스레드.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Application> </xref:System.Windows.Application.Run%2A> 다음으로 <xref:System.Windows.Threading.Dispatcher>개체의 <xref:System.Windows.Threading.Dispatcher.Run%2A>windows 메시지를 처리 하는 메시지 펌프를 시작 하는 메서드 호출 됩니다.</xref:System.Windows.Threading.Dispatcher.Run%2A> </xref:System.Windows.Threading.Dispatcher> 마지막으로 <xref:System.Windows.Threading.Dispatcher>호출 개체는 <xref:System.Windows.Application>개체의는 <xref:System.Windows.Application.OnStartup%2A>를 발생 시키는 메서드는 <xref:System.Windows.Application.Startup>이벤트.</xref:System.Windows.Application.Startup> </xref:System.Windows.Application.OnStartup%2A> </xref:System.Windows.Application> </xref:System.Windows.Threading.Dispatcher> 따라서 응용 프로그램 실행 모델 이미 처리할 때 설정 되었으며 <xref:System.Windows.Application.Startup>, 이때 응용 프로그램에 실행 되 고 간주 됩니다.</xref:System.Windows.Application.Startup>       응용 프로그램의 경우 실행이 중지 <xref:System.Windows.Application.Shutdown%2A>버전이 호출 됩니다; 값은 <xref:System.Windows.Application.ShutdownMode%2A>속성 시기를 결정 합니다. <xref:System.Windows.Application.Shutdown%2A>호출 되 고 호출 합니다. 자동으로 수행 됨 또는 명시적으로 해야 하는지 여부</xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application.Shutdown%2A>       <xref:System.Windows.Application.Run%2A>만들어진 스레드에서만에서 호출할 수는 <xref:System.Windows.Application>개체입니다.</xref:System.Windows.Application></xref:System.Windows.Application.Run%2A> 또한 <xref:System.Windows.Application.Run%2A>에서 호출할 수 없습니다는 [!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)].</xref:System.Windows.Application.Run%2A>"
  example:
  - "The following example shows an application that uses a custom <xref:System.Windows.Application> and must therefore explicitly call <xref:System.Windows.Application.Run%2A>.  \n  \n [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/add/codesnippet/visualbasic/applicationrunsnippets/app.vb#customentrypointandruncode)]\n [!code-cs[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/add/codesnippet/csharp/ApplicationRunSnippets.CSharp/App.cs#customentrypointandruncode)]"
  syntax:
    content: public int Run ();
    parameters: []
    return:
      type: System.Int32
      description: "<xref:System.Int32>응용 프로그램이 종료 될 때 운영 체제에 반환 되는 응용 프로그램 종료 코드.</xref:System.Int32> 기본적으로 종료 코드 값은 0입니다."
  overload: System.Windows.Application.Run*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "실행 브라우저에서 호스팅되는 응용 프로그램에서 호출 됩니다 (예를 들어 한 [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)])."
  platform:
  - net462
- uid: System.Windows.Application.Run(System.Windows.Window)
  id: Run(System.Windows.Window)
  parent: System.Windows.Application
  langs:
  - csharp
  name: Run(Window)
  nameWithType: Application.Run(Window)
  fullName: System.Windows.Application.Run(Window)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "시작 된 [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] 응용 프로그램 지정 된 창이 열립니다."
  remarks: "이 오버 로드 확장는 <xref:System.Windows.Application.Run%2A>메서드를 실행 중인 응용 프로그램이 시작 된 후 지정 된 창을 엽니다.</xref:System.Windows.Application.Run%2A>       코드를 정의 하는 경우 <xref:System.Windows.Application>하는 창을 엽니다.이 실행을 시작한 경우, 실행을 명시적으로 호출 합니다.</xref:System.Windows.Application>       만들면 사용자 <xref:System.Windows.Application>태그 또는 태그 및 관련 코드를 사용 하 여 자동으로 창을 열 수 있습니다는 다음 방법 중 하나를 사용 하는 동안:- <xref:System.Windows.Application.StartupUri%2A>.</xref:System.Windows.Application.StartupUri%2A> 를 설정 하 여 선언적</xref:System.Windows.Application>      -프로그래밍 방식으로 <xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup> 처리"
  example:
  - "The following example shows an application with a manually-created static entry point method that instantiates <xref:System.Windows.Application>, before calling <xref:System.Windows.Application.Run%2A>.  \n  \n [!code-cs[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/add/codesnippet/csharp/ApplicationRunOL1Snippets.CSharp/App.cs#customentrypointandrunol1code)]\n [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/add/codesnippet/visualbasic/applicationrunol1snippets/app.vb#customentrypointandrunol1code)]"
  syntax:
    content: public int Run (System.Windows.Window window);
    parameters:
    - id: window
      type: System.Windows.Window
      description: "A <xref href=&quot;System.Windows.Window&quot;> </xref> 응용 프로그램이 시작 될 때 자동으로 열립니다."
    return:
      type: System.Int32
      description: "<xref:System.Int32>응용 프로그램이 종료 될 때 운영 체제에 반환 되는 응용 프로그램 종료 코드.</xref:System.Int32> 기본적으로 종료 코드 값은 0입니다."
  overload: System.Windows.Application.Run*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Windows.Application.Run*>브라우저에서 호스팅되는 응용 프로그램에서 호출 됩니다 (예를 들어 한 [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]).</xref:System.Windows.Application.Run*>"
  platform:
  - net462
- uid: System.Windows.Application.SessionEnding
  id: SessionEnding
  parent: System.Windows.Application
  langs:
  - csharp
  name: SessionEnding
  nameWithType: Application.SessionEnding
  fullName: System.Windows.Application.SessionEnding
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "사용자가 종료 될 때 발생는 [!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)] 세션 로그 오프 하거나 운영 체제를 종료 합니다."
  remarks: "기본적으로 응용 프로그램이 종료 될 때는 [!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)] 세션을 끝낼은 사용자가 로그 오프 하거나 종료 하는 경우에 발생 합니다. 이 경우 [!INCLUDE[TLA2#tla_mswin](~/add/includes/tla2sharptla-mswin-md.md)] 를 종료 하려면 각 열려 있는 응용 프로그램을 요청 합니다. 그러나 있기 응용 프로그램이 발생 하는 때를 종료할 준비가 되어 있지 않을 수 있습니다. 예를 들어 응용 프로그램 또는 장기 실행 작업 중에 일관성이 없는 상태에 있는 데이터가 있을 수 있습니다. 이러한 상황에서 세션 종료를 방지 하는 것이 바람직 수 있으며 사용자가 세션을 종료 여부를 결정 하는 옵션을 허용 하는 것이 더 효율적일 수 있습니다.       SessionEnding 이벤트를 처리 하 여 세션이 끝날 때를 감지할 수 있습니다. 응용 프로그램 세션 종료 하지 못하도록 해야 하는 경우는 <xref:System.Windows.SessionEndingCancelEventArgs>노출 하는 이벤트 처리기에 전달 되는 인수는 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A>로 설정 하는 `true` (기본값은 `false`).</xref:System.ComponentModel.CancelEventArgs.Cancel%2A> </xref:System.Windows.SessionEndingCancelEventArgs>       SessionEnding 처리 되지 않은 또는 취소 하지 않고 처리 되는 경우 <xref:System.Windows.Application.Shutdown%2A>호출 되 고 <xref:System.Windows.Application.Exit>이벤트가 발생 합니다.</xref:System.Windows.Application.Exit> </xref:System.Windows.Application.Shutdown%2A>       세션이 종료 되는 이유는 방법에 대 한 자세한 정보를 얻으려면 응용 프로그램을 검사할 수 <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>, 중 하나인는 <xref:System.Windows.ReasonSessionEnding>값 (<xref:System.Windows.ReasonSessionEnding> 및 <xref:System.Windows.ReasonSessionEnding>).</xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>       SessionEnding 콘솔 응용 프로그램에서 발생 하지 않습니다.       만드는 스레드는에 발생 하는 SessionEnding는 <xref:System.Windows.Application>개체입니다.</xref:System.Windows.Application>       에 대 한 끝나면 SessionEnding [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]합니다."
  example:
  - "The following example demonstrates how to handle the SessionEnding event and allow the user to cancel it.  \n  \n [!code-xml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/add/codesnippet/xaml/ApplicationSessionEndingSnippets.CSharp/App.xaml#handlingsessionendingxaml)]  \n  \n [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/add/codesnippet/visualbasic/applicationsessionendingsnippets/application.xaml.vb#handlingsessionendingcodebehind)]\n [!code-cs[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/add/codesnippet/csharp/ApplicationSessionEndingSnippets.CSharp/App.xaml.cs#handlingsessionendingcodebehind)]"
  syntax:
    content: public event System.Windows.SessionEndingCancelEventHandler SessionEnding;
    return:
      type: System.Windows.SessionEndingCancelEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.SetCookie(System.Uri,System.String)
  id: SetCookie(System.Uri,System.String)
  parent: System.Windows.Application
  langs:
  - csharp
  name: SetCookie(Uri,String)
  nameWithType: Application.SetCookie(Uri,String)
  fullName: System.Windows.Application.SetCookie(Uri,String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "에 <xref:System.Uri>.</xref:System.Uri> 로 지정 된 위치에 대 한 쿠키를 만듭니다."
  remarks: "쿠키는 응용 프로그램에서 클라이언트 컴퓨터에 응용 프로그램 세션 (세션 쿠키) 중 또는 응용 프로그램 세션 (영구 쿠키) 간에 저장 될 수 있는 데이터의 일부를 임의로. SetCookie를 호출 하 여 두 종류의 쿠키를 만들 수 있습니다.       쿠키 데이터 형식에서 이름/값 쌍 형식의 일반적으로 가집니다: `Name=Value` SetCookie,이 형식의 문자열와 함께 전달는 <xref:System.Uri>쿠키를 설정 해야 하는 위치 (일반적으로 응용 프로그램 도메인).</xref:System.Uri>       쿠키는 세션 쿠키 또는 영구 쿠키 인지 SetCookie로 전달 하는 쿠키 문자열이 만료 날짜를 포함 하는 여부에 따라 달라 집니다. 세션 쿠키에 대 한 문자열에서 한 만료 날짜를 포함 하지 않습니다. 영구 쿠키의 문자열에는 다음과 같은 형식 이어야 합니다: `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT` 영구 쿠키는 현재에서 저장 된 [!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)] 설치의 임시 인터넷 파일 폴더 만료 될 때까지,이 경우 삭제 됩니다. 만료 날짜가 과거 날짜/시간 값으로 설정 하 여 응용 프로그램에서 영구 쿠키를 삭제할 수 있습니다.       쿠키에 대 한 개요 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)], 참조 [탐색 개요](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public static void SetCookie (Uri uri, string value);
    parameters:
    - id: uri
      type: System.Uri
      description: "<xref:System.Uri>쿠키를 생성 해야 하는 위치를 지정 하는.</xref:System.Uri>"
    - id: value
      type: System.String
      description: "<xref:System.String>쿠키 데이터를 포함 하.</xref:System.String>"
  overload: System.Windows.Application.SetCookie*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "A [!INCLUDE[TLA#tla_win32](~/add/includes/tlasharptla-win32-md.md)] 에서 오류가 발생 한는 <xref uid=&quot;langword_csharp_InternetSetCookie&quot; name=&quot;InternetSetCookie&quot; href=&quot;&quot;> </xref> 함수 (SetCookie 라고 함) 지정된 된 쿠키를 만들려고 할 때 문제가 발생 한 경우."
  platform:
  - net462
- uid: System.Windows.Application.Shutdown
  id: Shutdown
  parent: System.Windows.Application
  langs:
  - csharp
  name: Shutdown()
  nameWithType: Application.Shutdown()
  fullName: System.Windows.Application.Shutdown()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "응용 프로그램을 종료합니다."
  remarks: "시스템 종료를 호출할 때 응용 프로그램 실행을 중지 합니다. 처리할 수는 <xref:System.Windows.Application.Exit>응용 프로그램은 적절 한 처리를 수행 하 고, 실행이 중지 시기를 감지 하는 이벤트입니다.</xref:System.Windows.Application.Exit>       종료 암시적으로 호출한 [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] 다음과 같은 경우:- <xref:System.Windows.Application.ShutdownMode%2A>를 <xref:System.Windows.ShutdownMode>.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      - <xref:System.Windows.Application.ShutdownMode%2A>를 <xref:System.Windows.ShutdownMode>.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      사용자 세션을 종료 하는-및 <xref:System.Windows.Application.SessionEnding>이벤트, 처리 되지 않은 또는 취소 없이 처리 된.</xref:System.Windows.Application.SessionEnding>       시스템 종료를 명시적으로 호출 하면 종료 될 경우에 응용 프로그램에 관계 없이 <xref:System.Windows.Application.ShutdownMode%2A>설정.</xref:System.Windows.Application.ShutdownMode%2A> 그러나 경우 <xref:System.Windows.Application.ShutdownMode%2A>로 설정 된 <xref:System.Windows.ShutdownMode>, 응용 프로그램을 종료 하기 위해 종료를 호출 해야 합니다.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      > [!IMPORTANT] > 때 종료 호출 되 면 여부에 관계 없이 응용 프로그램이 종료 됩니다는 <xref:System.Windows.Window.Closing>이벤트의 열려 있는 창 모두 취소 됩니다.</xref:System.Windows.Window.Closing>       이 메서드를 만든 스레드가 에서만 호출할 수 있습니다는 <xref:System.Windows.Application>개체입니다.</xref:System.Windows.Application>"
  syntax:
    content: public void Shutdown ();
    parameters: []
  overload: System.Windows.Application.Shutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Shutdown(System.Int32)
  id: Shutdown(System.Int32)
  parent: System.Windows.Application
  langs:
  - csharp
  name: Shutdown(Int32)
  nameWithType: Application.Shutdown(Int32)
  fullName: System.Windows.Application.Shutdown(Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "운영 체제에 지정된 된 종료 코드를 반환 하는 응용 프로그램을 종료 합니다."
  remarks: "처리할 수는 <xref:System.Windows.Application.Exit>이벤트가 종료 코드를 설정 합니다.</xref:System.Windows.Application.Exit> 그러나 명시적으로 호출 <xref:System.Windows.Application.Shutdown%2A>, 처리할 <xref:System.Windows.Application.Exit>설정에서 종료 코드를 호출 하면 종료 대신만.</xref:System.Windows.Application.Exit> </xref:System.Windows.Application.Shutdown%2A>       이 메서드를 만든 스레드가 에서만 호출할 수 있습니다는 <xref:System.Windows.Application>개체입니다.</xref:System.Windows.Application>"
  syntax:
    content: public void Shutdown (int exitCode);
    parameters:
    - id: exitCode
      type: System.Int32
      description: "응용 프로그램에 대 한 정수 종료 코드입니다. 기본 종료 코드가 0입니다."
  overload: System.Windows.Application.Shutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.ShutdownMode
  id: ShutdownMode
  parent: System.Windows.Application
  langs:
  - csharp
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
  fullName: System.Windows.Application.ShutdownMode
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "원인이 되는 조건을 가져오거나 설정 합니다.는 <xref:System.Windows.Application.Shutdown*>호출 될 메서드입니다.</xref:System.Windows.Application.Shutdown*>"
  remarks: "응용 프로그램의 경우에만 실행이 중지 된 <xref:System.Windows.Application.Shutdown%2A>응용 프로그램의 메서드가 호출 됩니다.</xref:System.Windows.Application.Shutdown%2A> 시스템 종료 되었으면 ShutdownMode 속성의 값에 지정 된 대로 명시적으로 또는 암시적으로 발생할 수 있습니다.       되었으면 ShutdownMode를 설정한 경우 <xref:System.Windows.ShutdownMode>, [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] 암시적으로 호출 <xref:System.Windows.Application.Shutdown%2A>응용 프로그램의 마지막 창의 닫을 때, 현재 인스턴스화된 창이 주 창으로 설정 된 경우에 (참조 <xref:System.Windows.Application.MainWindow%2A>).</xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode>       되었으면 ShutdownMode <xref:System.Windows.ShutdownMode>하면 [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]암시적으로 호출 하려면 <xref:System.Windows.Application.Shutdown%2A>때는 <xref:System.Windows.Application.MainWindow%2A>다른 창이 현재 열려 있는 경우에 닫힙니다.</xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode>       일부 응용 프로그램의 수명 때 주 창 또는 마지막 창이 닫혀 또는 데이터에 종속 되지 않을 수 있습니다 windows에 종속 전혀 아닐 수도 있습니다. 이러한 시나리오에 대 한 되었으면 ShutdownMode 속성을 설정 해야 <xref:System.Windows.ShutdownMode>, 명시적 필요 <xref:System.Windows.Application.Shutdown%2A>메서드를 호출 하는 응용 프로그램을 중지 합니다.</xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode> 그렇지 않으면 응용 프로그램이 백그라운드에서 실행을 계속 합니다.       되었으면 ShutdownMode를 선언적으로 구성할 수 있습니다 [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] 또는 코드에서 프로그래밍 방식으로 합니다.       이 속성은 작성 된 스레드에서 에서만 사용할 수는 <xref:System.Windows.Application>개체입니다.</xref:System.Windows.Application>"
  example:
  - "The following example shows how to configure ShutdownMode to specify that an application must be closed explicitly.  \n  \n [!code-xml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/add/codesnippet/xaml/ApplicationShutdownModeSnippets.XAML/App.xaml#setshutdownmodexaml)]"
  syntax:
    content: public System.Windows.ShutdownMode ShutdownMode { get; set; }
    return:
      type: System.Windows.ShutdownMode
      description: "A <xref href=&quot;System.Windows.ShutdownMode&quot;> </xref> 열거형 값입니다. 기본값은 <xref href=&quot;System.Windows.ShutdownMode&quot;> </xref>합니다."
  overload: System.Windows.Application.ShutdownMode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Startup
  id: Startup
  parent: System.Windows.Application
  langs:
  - csharp
  name: Startup
  nameWithType: Application.Startup
  fullName: System.Windows.Application.Startup
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 경우는 <xref:System.Windows.Application.Run*>의 메서드는 <xref href=&quot;System.Windows.Application&quot;> </xref> 개체를 호출 합니다.</xref:System.Windows.Application.Run*>"
  remarks: "일반적인 [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] 응용 프로그램은 시작 시를 포함 하 여 다양 한 초기화 작업을 수행할 수 있습니다.-명령줄 매개 변수를 처리 합니다.      -주 창 열기      응용 프로그램 범위 리소스를 초기화 합니다.      -응용 프로그램 범위의 속성을 초기화 합니다.       주 창 및 사용 하 여 응용 프로그램 범위 리소스를 선언적으로 지정할 수 있습니다 [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] (<xref:System.Windows.Application.StartupUri%2A> 및 <xref:System.Windows.Application.Resources%2A>각각).</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application.StartupUri%2A> 그러나 경우에 따라 리소스 또는 응용 프로그램의 주 창 수만 결정 되는 프로그래밍 방식으로 런타임에 합니다. 또한 응용 프로그램 범위의 속성 및 명령줄 매개 변수 에서만 사용할 수 있습니다 프로그래밍 방식으로. 다음을 포함 한 시작 이벤트를 처리 하 여 프로그래밍 방식으로 초기화를 수행할 수:-가져오고에서 사용할 수 있는 명령줄 매개 변수를 처리는 <xref:System.Windows.StartupEventArgs.Args%2A>의 속성은 <xref:System.Windows.StartupEventArgs>Startup 이벤트 처리기에 전달 되는 클래스입니다.</xref:System.Windows.StartupEventArgs> </xref:System.Windows.StartupEventArgs.Args%2A>      -사용 하 여 응용 프로그램 범위 리소스를 초기화 합니다.는 <xref:System.Windows.Application.Resources%2A>속성.</xref:System.Windows.Application.Resources%2A>      -를 사용 하 여 응용 프로그램 범위의 속성을 초기화 합니다.는 <xref:System.Windows.Application.Properties%2A>속성.</xref:System.Windows.Application.Properties%2A>      -인스턴스화하고 (일부) 창을 표시 합니다.      > [!NOTE] > 정적을 호출 하 여 명령줄 매개 변수를 가져올 수도 있습니다 <xref:System.Environment.GetCommandLineArgs%2A>의 메서드는 <xref:System.Environment>개체입니다.</xref:System.Environment> </xref:System.Environment.GetCommandLineArgs%2A> 그러나 <xref:System.Environment.GetCommandLineArgs%2A>실행 되려면 완전 신뢰가 필요 합니다.</xref:System.Environment.GetCommandLineArgs%2A>       설정 하는 경우 <xref:System.Windows.Application.StartupUri%2A>를 사용 하 여 [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)], 만든 주 창에서 사용할 수 없는 <xref:System.Windows.Application.MainWindow%2A>속성 또는 <xref:System.Windows.Application.Windows%2A>속성의는 <xref:System.Windows.Application>시작 이벤트를 처리 한 후 될 때까지 개체.</xref:System.Windows.Application> </xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.StartupUri%2A> 시작 하는 동안 주 창에 대 한 액세스를 해야 할 경우 Startup 이벤트 처리기에서 새 창 개체를 수동으로 만들 해야 합니다.      > [!NOTE] > 응용 프로그램을 사용 하는 경우 <xref:System.Net.AuthenticationManager.CredentialPolicy%2A>자격 증명 정책을 지정 하려면 설정 해야 <xref:System.Net.AuthenticationManager.CredentialPolicy%2A>시작이 고, 그렇지 않으면 발생 한 후 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 설정 된 기본 내부 정책에 직접 시작 이벤트가 발생 한 후.</xref:System.Net.AuthenticationManager.CredentialPolicy%2A> </xref:System.Net.AuthenticationManager.CredentialPolicy%2A>       Startup 이벤트 처리기에 전달 되는 명령줄 인수가와 동일 하지 않습니다는 [!INCLUDE[TLA#tla_url](~/add/includes/tlasharptla-url-md.md)] 쿼리에 전달 되는 문자열 매개 변수는 [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]합니다."
  example:
  - "The following example shows how to acquire and process command-line options from a standalone application. If the **/StartMinimized** command-line parameter was provided, the application opens the main window in a minimized state.  \n  \n [!code-xml[ApplicationStartupSnippets#HandleStartupXAML](~/add/codesnippet/xaml/ApplicationStartupSnippets.CSharp/App.xaml#handlestartupxaml)]  \n  \n [!code-cs[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/csharp/ApplicationStartupSnippets.CSharp/App.xaml.cs#handlestartupcodebehind)]\n [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/visualbasic/applicationstartupsnippets/application.xaml.vb#handlestartupcodebehind)]  \n  \n [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)] cannot retrieve and process command-line arguments because they are launched with [!INCLUDE[TLA#tla_clickonce](~/add/includes/tlasharptla-clickonce-md.md)] deployment (see [Deploying a WPF Application (WPF)](~/add/includes/ajax-current-ext-md.md)). However, they can retrieve and process query string parameters from the URLs that are used to launch them."
  syntax:
    content: public event System.Windows.StartupEventHandler Startup;
    return:
      type: System.Windows.StartupEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.StartupUri
  id: StartupUri
  parent: System.Windows.Application
  langs:
  - csharp
  name: StartupUri
  nameWithType: Application.StartupUri
  fullName: System.Windows.Application.StartupUri
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "가져오거나는 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] 응용 프로그램이 시작 될 때 자동으로 표시 되는 합니다."
  remarks: "StartupUri을 사용 하 여 자동으로 로드 한 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] 리소스 응용 프로그램이 시작 합니다.       다음 표에서 유형의 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] 로드할 수 있는 리소스, 열리는 창 유형 및 이러한 리소스 StartupUri로 설정할 수 있는 응용 프로그램 종류입니다.      | 형식 | 창 | 응용 프로그램 종류 |   |----------|------------|----------------------|   | <xref:System.Windows.Window>| <xref:System.Windows.Window>| 독립 실행형만 |   | <xref:System.Windows.Navigation.NavigationWindow>| <xref:System.Windows.Navigation.NavigationWindow>| 독립 실행형만 |   | <xref:System.Windows.Controls.Page>| <xref:System.Windows.Navigation.NavigationWindow>| 독립 실행형/브라우저에서 호스팅되 |   | <xref:System.Windows.Controls.UserControl>| <xref:System.Windows.Navigation.NavigationWindow>| 독립 실행형/브라우저에서 호스팅되 |   | <xref:System.Windows.Documents.FlowDocument>| <xref:System.Windows.Navigation.NavigationWindow>| 독립 실행형/브라우저에서 호스팅되 |   | <xref:System.Windows.Navigation.PageFunction%601>| <xref:System.Windows.Navigation.NavigationWindow>| 독립 실행형/브라우저에서 호스팅되 |       일반적으로 속성을 설정 하면 StartupUri에 선언적으로 [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)].</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.PageFunction%601> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Documents.FlowDocument> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Controls.UserControl> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Controls.Page> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Window> </xref:System.Windows.Window> 그러나 StartupUri를 프로그래밍 방식으로 설정할 수으로 <xref:System.Windows.Application.Startup>필요한을 로드 하는 응용 프로그램에 있는 경우에 이벤트 처리기 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] 런타임 시 리소스.</xref:System.Windows.Application.Startup> 예를 들어 응용 프로그램 수를 기다릴 경우 해당 리소스를 로드 하의 이름을 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] 리소스 구성 파일에 저장 됩니다.       StartupUri를 선언적으로 설정 하는지 여부 또는 해당 프로그래밍 방식으로 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] 될 때까지 리소스 로드 되지 않은 후는 <xref:System.Windows.Application.Startup>이벤트를 처리 합니다.</xref:System.Windows.Application.Startup> 따라서 액세스할 수 없습니다 결과 창에 중 하 나와는 <xref:System.Windows.Application.Windows%2A>속성 또는 <xref:System.Windows.Application.MainWindow%2A>속성 <xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup> 를 처리 하는 경우</xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Windows%2A>"
  syntax:
    content: public Uri StartupUri { get; set; }
    return:
      type: System.Uri
      description: "A <xref:System.Uri>참조 하는 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] 응용 프로그램이 시작 될 때 자동으로 열립니다.</xref:System.Uri>"
  overload: System.Windows.Application.StartupUri*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "StartupUri는 null 값으로 설정 됩니다."
  platform:
  - net462
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  id: System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  isEii: true
  parent: System.Windows.Application
  langs:
  - csharp
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "현재 범위에서 지정된 된 앰비언트 속성을 사용할 수 있는지 여부에 대 한 쿼리 합니다."
  remarks: "이 멤버는 명시적 인터페이스 멤버 구현 이며 사용할 수 있습니다 경우에만 <xref:System.Windows.Application>인스턴스로 캐스팅 되는 <xref:System.Windows.Markup.IQueryAmbient>인터페이스.</xref:System.Windows.Markup.IQueryAmbient> </xref:System.Windows.Application>"
  syntax:
    content: bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);
    parameters:
    - id: propertyName
      type: System.String
      description: "요청된 된 앰비언트 속성의 이름입니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>요청 된 앰비언트 속성을 사용할 수 있습니다. 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.TryFindResource(System.Object)
  id: TryFindResource(System.Object)
  parent: System.Windows.Application
  langs:
  - csharp
  name: TryFindResource(Object)
  nameWithType: Application.TryFindResource(Object)
  fullName: System.Windows.Application.TryFindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "지정된 된 리소스를 검색 합니다."
  remarks: "지정된 된 리소스에 대 한 응용 프로그램 범위 리소스에서 TryFindResource 먼저 보입니다. 응용 프로그램 범위 리소스 관리 <xref:System.Windows.Application>에서 노출 하 고는 <xref:System.Windows.Application.Resources%2A>속성.</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application> 지정된 된 리소스는 응용 프로그램 범위 리소스 집합에 없는 경우 TryFindResource 그런 다음 다음 검색 시스템 리소스입니다. 시스템 리소스는 사용자가 정의한 shell 리소스 있으며 색, 글꼴 및 셸 구성을 포함 합니다. 노출 된 <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, 및 <xref:System.Windows.SystemParameters>형식을 각각 정적 속성으로.</xref:System.Windows.SystemParameters> </xref:System.Windows.SystemFonts> </xref:System.Windows.SystemColors> TryFindResource을 얻으려고를 사용 하려면 이러한 형식은 속성을 노출 리소스 키 TryFindResource;를 전달 하도록 디자인 된 예를 들어 <xref:System.Windows.SystemParameters.IconWidthKey%2A>.</xref:System.Windows.SystemParameters.IconWidthKey%2A>       TryFindResource 개체를 반환 하므로 리소스를 찾을 경우 적절 한 형식으로 반환된 된 값을 캐스팅 해야 합니다.       이 메서드는 스레드로부터 안전 하 고 모든 스레드에서 호출할 수 있습니다."
  example:
  - "The following example shows how to use TryFindResource to acquire a resource.  \n  \n [!code-xml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/add/codesnippet/xaml/ApplicationTryFindResourceSnippets/App.xaml#applicationcalltryfindresourcexaml)]  \n  \n [!code-cs[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/add/codesnippet/csharp/ApplicationTryFindResourceSnippets/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]\n [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/add/codesnippet/visualbasic/applicationtryfindresourcesnippets/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  \n[!code-cs[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/add/codesnippet/csharp/ApplicationTryFindResourceSnippets/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]\n[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/add/codesnippet/visualbasic/applicationtryfindresourcesnippets/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]"
  syntax:
    content: public object TryFindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "찾을 리소스의 이름입니다."
    return:
      type: System.Object
      description: "요청 된 리소스 개체입니다. 요청된 된 항목이 없을 경우 null 참조가 반환 됩니다."
  overload: System.Windows.Application.TryFindResource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Windows
  id: Windows
  parent: System.Windows.Application
  langs:
  - csharp
  name: Windows
  nameWithType: Application.Windows
  fullName: System.Windows.Application.Windows
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "응용 프로그램의 인스턴스화된 창을 가져옵니다."
  remarks: "A <xref:System.Windows.Window>참조가 창이 인스턴스화됩니다 되는 즉시 자동으로 Windows에 추가 됩니다는 [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] 스레드; windows 스레드는 추가 작업자에 의해 만들어진.</xref:System.Windows.Window> A <xref:System.Windows.Window>참조 한 후 자동으로 제거 됩니다 해당 <xref:System.Windows.Window.Closing>이벤트를 처리 하기 전에 해당 <xref:System.Windows.Window.Closed>이벤트가 발생 합니다.</xref:System.Windows.Window.Closed> </xref:System.Windows.Window.Closing> </xref:System.Windows.Window>       기본적으로 Windows 속성에 추가 된 첫 번째 항목이 됩니다 <xref:System.Windows.Application.MainWindow%2A>.</xref:System.Windows.Application.MainWindow%2A>       이 속성은 작성 된 스레드에서 에서만 사용할 수는 <xref:System.Windows.Application>개체입니다.</xref:System.Windows.Application>"
  example:
  - "The following example demonstrates how to enumerate the Windows property to build a top-level Windows menu, which is common to [!INCLUDE[TLA#tla_mdi](~/add/includes/tlasharptla-mdi-md.md)] applications like [!INCLUDE[TLA#tla_xl](~/add/includes/tlasharptla-xl-md.md)], or multiple-instance Single Document Interface (SDI) applications like [!INCLUDE[TLA#tla_word](~/add/includes/tlasharptla-word-md.md)].  \n  \n [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/add/codesnippet/visualbasic/applicationwindowssnippets/windowmenuitem.vb#windowmenuitemcode)]\n [!code-cs[ApplicationWindowsSnippets#WindowMenuItemCODE](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/WindowMenuItem.cs#windowmenuitemcode)]  \n  \n [!code-xml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/add/codesnippet/xaml/ApplicationWindowsSnippets.CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  \n  \n [!code-cs[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]\n [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/add/codesnippet/visualbasic/applicationwindowssnippets/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  \n[!code-cs[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]\n[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/add/codesnippet/visualbasic/applicationwindowssnippets/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]"
  syntax:
    content: public System.Windows.WindowCollection Windows { get; }
    return:
      type: System.Windows.WindowCollection
      description: "A <xref href=&quot;System.Windows.WindowCollection&quot;> </xref> 현재의 모든 창 개체에 대 한 참조를 포함 하는 <xref href=&quot;System.AppDomain&quot;> </xref>합니다."
  overload: System.Windows.Application.Windows*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Threading.DispatcherObject
  isExternal: false
  name: System.Windows.Threading.DispatcherObject
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.ResourceReferenceKeyNotFoundException
  parent: System.Windows
  isExternal: false
  name: ResourceReferenceKeyNotFoundException
  nameWithType: ResourceReferenceKeyNotFoundException
  fullName: System.Windows.ResourceReferenceKeyNotFoundException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Exception
  isExternal: true
  name: System.Exception
- uid: System.Windows.Application.#ctor
  parent: System.Windows.Application
  isExternal: false
  name: Application()
  nameWithType: Application.Application()
  fullName: System.Windows.Application.Application()
- uid: System.Windows.Application.Activated
  parent: System.Windows.Application
  isExternal: false
  name: Activated
  nameWithType: Application.Activated
  fullName: System.Windows.Application.Activated
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.Application.Current
  parent: System.Windows.Application
  isExternal: false
  name: Current
  nameWithType: Application.Current
  fullName: System.Windows.Application.Current
- uid: System.Windows.Application
  parent: System.Windows
  isExternal: false
  name: Application
  nameWithType: Application
  fullName: System.Windows.Application
- uid: System.Windows.Application.Deactivated
  parent: System.Windows.Application
  isExternal: false
  name: Deactivated
  nameWithType: Application.Deactivated
  fullName: System.Windows.Application.Deactivated
- uid: System.Windows.Application.DispatcherUnhandledException
  parent: System.Windows.Application
  isExternal: false
  name: DispatcherUnhandledException
  nameWithType: Application.DispatcherUnhandledException
  fullName: System.Windows.Application.DispatcherUnhandledException
- uid: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionEventHandler
  nameWithType: DispatcherUnhandledExceptionEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
- uid: System.Windows.Application.Exit
  parent: System.Windows.Application
  isExternal: false
  name: Exit
  nameWithType: Application.Exit
  fullName: System.Windows.Application.Exit
- uid: System.Windows.ExitEventHandler
  parent: System.Windows
  isExternal: false
  name: ExitEventHandler
  nameWithType: ExitEventHandler
  fullName: System.Windows.ExitEventHandler
- uid: System.Windows.Application.FindResource(System.Object)
  parent: System.Windows.Application
  isExternal: false
  name: FindResource(Object)
  nameWithType: Application.FindResource(Object)
  fullName: System.Windows.Application.FindResource(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.Application.FragmentNavigation
  parent: System.Windows.Application
  isExternal: false
  name: FragmentNavigation
  nameWithType: Application.FragmentNavigation
  fullName: System.Windows.Application.FragmentNavigation
- uid: System.Windows.Navigation.FragmentNavigationEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: FragmentNavigationEventHandler
  nameWithType: FragmentNavigationEventHandler
  fullName: System.Windows.Navigation.FragmentNavigationEventHandler
- uid: System.Windows.Application.GetContentStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetContentStream(Uri)
  nameWithType: Application.GetContentStream(Uri)
  fullName: System.Windows.Application.GetContentStream(Uri)
- uid: System.Windows.Resources.StreamResourceInfo
  parent: System.Windows.Resources
  isExternal: false
  name: StreamResourceInfo
  nameWithType: StreamResourceInfo
  fullName: System.Windows.Resources.StreamResourceInfo
- uid: System.Uri
  parent: System
  isExternal: true
  name: Uri
  nameWithType: Uri
  fullName: System.Uri
- uid: System.Windows.Application.GetCookie(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetCookie(Uri)
  nameWithType: Application.GetCookie(Uri)
  fullName: System.Windows.Application.GetCookie(Uri)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Application.GetRemoteStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetRemoteStream(Uri)
  nameWithType: Application.GetRemoteStream(Uri)
  fullName: System.Windows.Application.GetRemoteStream(Uri)
- uid: System.Windows.Application.GetResourceStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetResourceStream(Uri)
  nameWithType: Application.GetResourceStream(Uri)
  fullName: System.Windows.Application.GetResourceStream(Uri)
- uid: System.Windows.Application.LoadCompleted
  parent: System.Windows.Application
  isExternal: false
  name: LoadCompleted
  nameWithType: Application.LoadCompleted
  fullName: System.Windows.Application.LoadCompleted
- uid: System.Windows.Navigation.LoadCompletedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: LoadCompletedEventHandler
  nameWithType: LoadCompletedEventHandler
  fullName: System.Windows.Navigation.LoadCompletedEventHandler
- uid: System.Windows.Application.LoadComponent(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent(Uri)
  nameWithType: Application.LoadComponent(Uri)
  fullName: System.Windows.Application.LoadComponent(Uri)
- uid: System.Windows.Application.LoadComponent(System.Object,System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent(Object,Uri)
  nameWithType: Application.LoadComponent(Object,Uri)
  fullName: System.Windows.Application.LoadComponent(Object,Uri)
- uid: System.Windows.Application.MainWindow
  parent: System.Windows.Application
  isExternal: false
  name: MainWindow
  nameWithType: Application.MainWindow
  fullName: System.Windows.Application.MainWindow
- uid: System.Windows.Window
  parent: System.Windows
  isExternal: false
  name: Window
  nameWithType: Window
  fullName: System.Windows.Window
- uid: System.Windows.Application.Navigated
  parent: System.Windows.Application
  isExternal: false
  name: Navigated
  nameWithType: Application.Navigated
  fullName: System.Windows.Application.Navigated
- uid: System.Windows.Navigation.NavigatedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatedEventHandler
  nameWithType: NavigatedEventHandler
  fullName: System.Windows.Navigation.NavigatedEventHandler
- uid: System.Windows.Application.Navigating
  parent: System.Windows.Application
  isExternal: false
  name: Navigating
  nameWithType: Application.Navigating
  fullName: System.Windows.Application.Navigating
- uid: System.Windows.Navigation.NavigatingCancelEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatingCancelEventHandler
  nameWithType: NavigatingCancelEventHandler
  fullName: System.Windows.Navigation.NavigatingCancelEventHandler
- uid: System.Windows.Application.NavigationFailed
  parent: System.Windows.Application
  isExternal: false
  name: NavigationFailed
  nameWithType: Application.NavigationFailed
  fullName: System.Windows.Application.NavigationFailed
- uid: System.Windows.Navigation.NavigationFailedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationFailedEventHandler
  nameWithType: NavigationFailedEventHandler
  fullName: System.Windows.Navigation.NavigationFailedEventHandler
- uid: System.Windows.Application.NavigationProgress
  parent: System.Windows.Application
  isExternal: false
  name: NavigationProgress
  nameWithType: Application.NavigationProgress
  fullName: System.Windows.Application.NavigationProgress
- uid: System.Windows.Navigation.NavigationProgressEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationProgressEventHandler
  nameWithType: NavigationProgressEventHandler
  fullName: System.Windows.Navigation.NavigationProgressEventHandler
- uid: System.Windows.Application.NavigationStopped
  parent: System.Windows.Application
  isExternal: false
  name: NavigationStopped
  nameWithType: Application.NavigationStopped
  fullName: System.Windows.Application.NavigationStopped
- uid: System.Windows.Navigation.NavigationStoppedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationStoppedEventHandler
  nameWithType: NavigationStoppedEventHandler
  fullName: System.Windows.Navigation.NavigationStoppedEventHandler
- uid: System.Windows.Application.OnActivated(System.EventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnActivated(EventArgs)
  nameWithType: Application.OnActivated(EventArgs)
  fullName: System.Windows.Application.OnActivated(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.Application.OnDeactivated(System.EventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnDeactivated(EventArgs)
  nameWithType: Application.OnDeactivated(EventArgs)
  fullName: System.Windows.Application.OnDeactivated(EventArgs)
- uid: System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnExit(ExitEventArgs)
  nameWithType: Application.OnExit(ExitEventArgs)
  fullName: System.Windows.Application.OnExit(ExitEventArgs)
- uid: System.Windows.ExitEventArgs
  parent: System.Windows
  isExternal: false
  name: ExitEventArgs
  nameWithType: ExitEventArgs
  fullName: System.Windows.ExitEventArgs
- uid: System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnFragmentNavigation(FragmentNavigationEventArgs)
  nameWithType: Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  fullName: System.Windows.Application.OnFragmentNavigation(FragmentNavigationEventArgs)
- uid: System.Windows.Navigation.FragmentNavigationEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: FragmentNavigationEventArgs
  nameWithType: FragmentNavigationEventArgs
  fullName: System.Windows.Navigation.FragmentNavigationEventArgs
- uid: System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnLoadCompleted(NavigationEventArgs)
  nameWithType: Application.OnLoadCompleted(NavigationEventArgs)
  fullName: System.Windows.Application.OnLoadCompleted(NavigationEventArgs)
- uid: System.Windows.Navigation.NavigationEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationEventArgs
  nameWithType: NavigationEventArgs
  fullName: System.Windows.Navigation.NavigationEventArgs
- uid: System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigated(NavigationEventArgs)
  nameWithType: Application.OnNavigated(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigated(NavigationEventArgs)
- uid: System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigating(NavigatingCancelEventArgs)
  nameWithType: Application.OnNavigating(NavigatingCancelEventArgs)
  fullName: System.Windows.Application.OnNavigating(NavigatingCancelEventArgs)
- uid: System.Windows.Navigation.NavigatingCancelEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatingCancelEventArgs
  nameWithType: NavigatingCancelEventArgs
  fullName: System.Windows.Navigation.NavigatingCancelEventArgs
- uid: System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationFailed(NavigationFailedEventArgs)
  nameWithType: Application.OnNavigationFailed(NavigationFailedEventArgs)
  fullName: System.Windows.Application.OnNavigationFailed(NavigationFailedEventArgs)
- uid: System.Windows.Navigation.NavigationFailedEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationFailedEventArgs
  nameWithType: NavigationFailedEventArgs
  fullName: System.Windows.Navigation.NavigationFailedEventArgs
- uid: System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationProgress(NavigationProgressEventArgs)
  nameWithType: Application.OnNavigationProgress(NavigationProgressEventArgs)
  fullName: System.Windows.Application.OnNavigationProgress(NavigationProgressEventArgs)
- uid: System.Windows.Navigation.NavigationProgressEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationProgressEventArgs
  nameWithType: NavigationProgressEventArgs
  fullName: System.Windows.Navigation.NavigationProgressEventArgs
- uid: System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationStopped(NavigationEventArgs)
  nameWithType: Application.OnNavigationStopped(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigationStopped(NavigationEventArgs)
- uid: System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnSessionEnding(SessionEndingCancelEventArgs)
  nameWithType: Application.OnSessionEnding(SessionEndingCancelEventArgs)
  fullName: System.Windows.Application.OnSessionEnding(SessionEndingCancelEventArgs)
- uid: System.Windows.SessionEndingCancelEventArgs
  parent: System.Windows
  isExternal: false
  name: SessionEndingCancelEventArgs
  nameWithType: SessionEndingCancelEventArgs
  fullName: System.Windows.SessionEndingCancelEventArgs
- uid: System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnStartup(StartupEventArgs)
  nameWithType: Application.OnStartup(StartupEventArgs)
  fullName: System.Windows.Application.OnStartup(StartupEventArgs)
- uid: System.Windows.StartupEventArgs
  parent: System.Windows
  isExternal: false
  name: StartupEventArgs
  nameWithType: StartupEventArgs
  fullName: System.Windows.StartupEventArgs
- uid: System.Windows.Application.Properties
  parent: System.Windows.Application
  isExternal: false
  name: Properties
  nameWithType: Application.Properties
  fullName: System.Windows.Application.Properties
- uid: System.Collections.IDictionary
  parent: System.Collections
  isExternal: true
  name: IDictionary
  nameWithType: IDictionary
  fullName: System.Collections.IDictionary
- uid: System.Windows.Application.ResourceAssembly
  parent: System.Windows.Application
  isExternal: false
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
  fullName: System.Windows.Application.ResourceAssembly
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.Windows.Application.Resources
  parent: System.Windows.Application
  isExternal: false
  name: Resources
  nameWithType: Application.Resources
  fullName: System.Windows.Application.Resources
- uid: System.Windows.ResourceDictionary
  parent: System.Windows
  isExternal: false
  name: ResourceDictionary
  nameWithType: ResourceDictionary
  fullName: System.Windows.ResourceDictionary
- uid: System.Windows.Application.Run
  parent: System.Windows.Application
  isExternal: false
  name: Run()
  nameWithType: Application.Run()
  fullName: System.Windows.Application.Run()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Application.Run(System.Windows.Window)
  parent: System.Windows.Application
  isExternal: false
  name: Run(Window)
  nameWithType: Application.Run(Window)
  fullName: System.Windows.Application.Run(Window)
- uid: System.Windows.Application.SessionEnding
  parent: System.Windows.Application
  isExternal: false
  name: SessionEnding
  nameWithType: Application.SessionEnding
  fullName: System.Windows.Application.SessionEnding
- uid: System.Windows.SessionEndingCancelEventHandler
  parent: System.Windows
  isExternal: false
  name: SessionEndingCancelEventHandler
  nameWithType: SessionEndingCancelEventHandler
  fullName: System.Windows.SessionEndingCancelEventHandler
- uid: System.Windows.Application.SetCookie(System.Uri,System.String)
  parent: System.Windows.Application
  isExternal: false
  name: SetCookie(Uri,String)
  nameWithType: Application.SetCookie(Uri,String)
  fullName: System.Windows.Application.SetCookie(Uri,String)
- uid: System.Windows.Application.Shutdown
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown()
  nameWithType: Application.Shutdown()
  fullName: System.Windows.Application.Shutdown()
- uid: System.Windows.Application.Shutdown(System.Int32)
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown(Int32)
  nameWithType: Application.Shutdown(Int32)
  fullName: System.Windows.Application.Shutdown(Int32)
- uid: System.Windows.Application.ShutdownMode
  parent: System.Windows.Application
  isExternal: false
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
  fullName: System.Windows.Application.ShutdownMode
- uid: System.Windows.ShutdownMode
  parent: System.Windows
  isExternal: false
  name: ShutdownMode
  nameWithType: ShutdownMode
  fullName: System.Windows.ShutdownMode
- uid: System.Windows.Application.Startup
  parent: System.Windows.Application
  isExternal: false
  name: Startup
  nameWithType: Application.Startup
  fullName: System.Windows.Application.Startup
- uid: System.Windows.StartupEventHandler
  parent: System.Windows
  isExternal: false
  name: StartupEventHandler
  nameWithType: StartupEventHandler
  fullName: System.Windows.StartupEventHandler
- uid: System.Windows.Application.StartupUri
  parent: System.Windows.Application
  isExternal: false
  name: StartupUri
  nameWithType: Application.StartupUri
  fullName: System.Windows.Application.StartupUri
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  parent: System.Windows.Application
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Application.TryFindResource(System.Object)
  parent: System.Windows.Application
  isExternal: false
  name: TryFindResource(Object)
  nameWithType: Application.TryFindResource(Object)
  fullName: System.Windows.Application.TryFindResource(Object)
- uid: System.Windows.Application.Windows
  parent: System.Windows.Application
  isExternal: false
  name: Windows
  nameWithType: Application.Windows
  fullName: System.Windows.Application.Windows
- uid: System.Windows.WindowCollection
  parent: System.Windows
  isExternal: false
  name: WindowCollection
  nameWithType: WindowCollection
  fullName: System.Windows.WindowCollection
- uid: System.Windows.Application.#ctor*
  parent: System.Windows.Application
  isExternal: false
  name: Application
  nameWithType: Application.Application
- uid: System.Windows.Application.Current*
  parent: System.Windows.Application
  isExternal: false
  name: Current
  nameWithType: Application.Current
- uid: System.Windows.Application.FindResource*
  parent: System.Windows.Application
  isExternal: false
  name: FindResource
  nameWithType: Application.FindResource
- uid: System.Windows.Application.GetContentStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetContentStream
  nameWithType: Application.GetContentStream
- uid: System.Windows.Application.GetCookie*
  parent: System.Windows.Application
  isExternal: false
  name: GetCookie
  nameWithType: Application.GetCookie
- uid: System.Windows.Application.GetRemoteStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetRemoteStream
  nameWithType: Application.GetRemoteStream
- uid: System.Windows.Application.GetResourceStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetResourceStream
  nameWithType: Application.GetResourceStream
- uid: System.Windows.Application.LoadComponent*
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent
  nameWithType: Application.LoadComponent
- uid: System.Windows.Application.MainWindow*
  parent: System.Windows.Application
  isExternal: false
  name: MainWindow
  nameWithType: Application.MainWindow
- uid: System.Windows.Application.OnActivated*
  parent: System.Windows.Application
  isExternal: false
  name: OnActivated
  nameWithType: Application.OnActivated
- uid: System.Windows.Application.OnDeactivated*
  parent: System.Windows.Application
  isExternal: false
  name: OnDeactivated
  nameWithType: Application.OnDeactivated
- uid: System.Windows.Application.OnExit*
  parent: System.Windows.Application
  isExternal: false
  name: OnExit
  nameWithType: Application.OnExit
- uid: System.Windows.Application.OnFragmentNavigation*
  parent: System.Windows.Application
  isExternal: false
  name: OnFragmentNavigation
  nameWithType: Application.OnFragmentNavigation
- uid: System.Windows.Application.OnLoadCompleted*
  parent: System.Windows.Application
  isExternal: false
  name: OnLoadCompleted
  nameWithType: Application.OnLoadCompleted
- uid: System.Windows.Application.OnNavigated*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigated
  nameWithType: Application.OnNavigated
- uid: System.Windows.Application.OnNavigating*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigating
  nameWithType: Application.OnNavigating
- uid: System.Windows.Application.OnNavigationFailed*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationFailed
  nameWithType: Application.OnNavigationFailed
- uid: System.Windows.Application.OnNavigationProgress*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationProgress
  nameWithType: Application.OnNavigationProgress
- uid: System.Windows.Application.OnNavigationStopped*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationStopped
  nameWithType: Application.OnNavigationStopped
- uid: System.Windows.Application.OnSessionEnding*
  parent: System.Windows.Application
  isExternal: false
  name: OnSessionEnding
  nameWithType: Application.OnSessionEnding
- uid: System.Windows.Application.OnStartup*
  parent: System.Windows.Application
  isExternal: false
  name: OnStartup
  nameWithType: Application.OnStartup
- uid: System.Windows.Application.Properties*
  parent: System.Windows.Application
  isExternal: false
  name: Properties
  nameWithType: Application.Properties
- uid: System.Windows.Application.ResourceAssembly*
  parent: System.Windows.Application
  isExternal: false
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
- uid: System.Windows.Application.Resources*
  parent: System.Windows.Application
  isExternal: false
  name: Resources
  nameWithType: Application.Resources
- uid: System.Windows.Application.Run*
  parent: System.Windows.Application
  isExternal: false
  name: Run
  nameWithType: Application.Run
- uid: System.Windows.Application.SetCookie*
  parent: System.Windows.Application
  isExternal: false
  name: SetCookie
  nameWithType: Application.SetCookie
- uid: System.Windows.Application.Shutdown*
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown
  nameWithType: Application.Shutdown
- uid: System.Windows.Application.ShutdownMode*
  parent: System.Windows.Application
  isExternal: false
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
- uid: System.Windows.Application.StartupUri*
  parent: System.Windows.Application
  isExternal: false
  name: StartupUri
  nameWithType: Application.StartupUri
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  parent: System.Windows.Application
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
- uid: System.Windows.Application.TryFindResource*
  parent: System.Windows.Application
  isExternal: false
  name: TryFindResource
  nameWithType: Application.TryFindResource
- uid: System.Windows.Application.Windows*
  parent: System.Windows.Application
  isExternal: false
  name: Windows
  nameWithType: Application.Windows
