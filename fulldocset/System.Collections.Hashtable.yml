### YamlMime:ManagedReference
items:
- uid: System.Collections.Hashtable
  id: Hashtable
  children:
  - System.Collections.Hashtable.#ctor
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary)
  - System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Int32)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)
  - System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Single)
  - System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.Add(System.Object,System.Object)
  - System.Collections.Hashtable.Clear
  - System.Collections.Hashtable.Clone
  - System.Collections.Hashtable.comparer
  - System.Collections.Hashtable.Contains(System.Object)
  - System.Collections.Hashtable.ContainsKey(System.Object)
  - System.Collections.Hashtable.ContainsValue(System.Object)
  - System.Collections.Hashtable.CopyTo(System.Array,System.Int32)
  - System.Collections.Hashtable.Count
  - System.Collections.Hashtable.EqualityComparer
  - System.Collections.Hashtable.GetEnumerator
  - System.Collections.Hashtable.GetHash(System.Object)
  - System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Collections.Hashtable.hcp
  - System.Collections.Hashtable.IsFixedSize
  - System.Collections.Hashtable.IsReadOnly
  - System.Collections.Hashtable.IsSynchronized
  - System.Collections.Hashtable.Item(System.Object)
  - System.Collections.Hashtable.KeyEquals(System.Object,System.Object)
  - System.Collections.Hashtable.Keys
  - System.Collections.Hashtable.OnDeserialization(System.Object)
  - System.Collections.Hashtable.Remove(System.Object)
  - System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)
  - System.Collections.Hashtable.SyncRoot
  - System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator
  - System.Collections.Hashtable.Values
  langs:
  - csharp
  name: Hashtable
  nameWithType: Hashtable
  fullName: System.Collections.Hashtable
  type: Class
  summary: "키의 해시 코드에 따라 구성 된 키/값 쌍의 컬렉션을 나타냅니다.       이 형식에 대 한.NET Framework 소스 코드를 찾아보려면 참조는 [참조 소스](http://referencesource.microsoft.com/#mscorlib/system/collections/hashtable.cs#10fefb6e0ae510dd)합니다."
  remarks: "> [!NOTE]>이 형식에 대 한.NET Framework 소스 코드를 보려면를 참조 하십시오.는 [참조 소스](http://referencesource.microsoft.com/#mscorlib/system/collections/hashtable.cs#10fefb6e0ae510dd)합니다. 소스 코드를 온라인, 오프 라인에서 살펴보고에 대 한 참조를 다운로드 및; 디버그 시 소스 (패치 및 업데이트 포함)를 단계별로 실행 참조 [지침](http://referencesource.microsoft.com/)합니다.       각 요소에 저장 된 키/값 쌍은는 <xref:System.Collections.DictionaryEntry>개체입니다.</xref:System.Collections.DictionaryEntry> 키 일 수 없습니다 `null`, 하지만 값이 될 수 있습니다.       해시 테이블에서 키를 재정의 하는 데 필요한 사용 되는 개체는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>메서드 (또는 <xref:System.Collections.IHashCodeProvider>인터페이스) 및 <xref:System.Object.Equals%2A?displayProperty=fullName>메서드 (또는 <xref:System.Collections.IComparer>인터페이스).</xref:System.Collections.IComparer> </xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Collections.IHashCodeProvider> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> 두 메서드 및 인터페이스의 구현을 대/소문자 구분; 같은 방식으로 처리 해야 합니다. 그렇지 않으면 해시 테이블 수 제대로 동작 하지 합니다. 예를 들어, 해시 테이블을 만들 때 사용 해야는 <xref:System.Collections.CaseInsensitiveHashCodeProvider>클래스 (모든 대/소문자 구분 또는 <xref:System.Collections.IHashCodeProvider>구현)와 <xref:System.Collections.CaseInsensitiveComparer>클래스 (또는 어떤 대/소문자 구분 <xref:System.Collections.IComparer>구현).</xref:System.Collections.IComparer> </xref:System.Collections.CaseInsensitiveComparer> </xref:System.Collections.IHashCodeProvider> </xref:System.Collections.CaseInsensitiveHashCodeProvider>       또한 이러한 메서드는 해시 테이블에 키가 있는 동안에 동일한 매개 변수를 사용 하 여 호출 될 때 동일한 결과 생성 해야 합니다. 대신 사용 하 여 해시 테이블 생성자를 사용 하는 프로그램 <xref:System.Collections.IEqualityComparer>매개 변수.</xref:System.Collections.IEqualityComparer> 키가 같은지 여부 단순히 참조 일치의 상속 된 구현 된 경우 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>및 <xref:System.Object.Equals%2A?displayProperty=fullName>충분 합니다.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName>       해시 테이블의 키로 사용 하는 상태로 키 개체의 변경 하지 않아야 합니다.       요소가 해시 테이블에 추가 되 면 요소 키의 해시 코드에 따라 버킷에 배치 됩니다. 요소를 찾는 데 필요한 키 비교 수가 상당히 감소 하나만 특정 버킷에 검색 하려면 키의 해시 코드를 사용 하는 키의 후속 조회 합니다.       해시 테이블의 로드 비율 버킷과 요소의 최대 비율을 결정합니다. 더 작은 부하 요인으로 인해 메모리 소모량이 증가 하면 더 빠르게 평균 조회 시간입니다. 일반적으로 1.0의 기본 로드 비율 적절 한 속도와 크기를 제공합니다. 서로 다른 로드 비율 Hashtable를 만들 때 지정할 수 있습니다.       요소가 해시 테이블에 추가 되 면 해시 테이블의 실제 로드 비율이 증가 합니다. 실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 Hashtable 버킷 수가 두 번 보다 큰 가장 작은 소수로 해시 테이블에서 버킷 수가 자동으로 증가 합니다.       해시 테이블의 각 키 개체 <xref:System.Collections.Hashtable.GetHash%2A>.</xref:System.Collections.Hashtable.GetHash%2A> 를 호출 하 여 액세스할 수 있는 자체 해시 함수를 제공 해야 합니다. 그러나 구현 하는 개체 <xref:System.Collections.IHashCodeProvider>해시 가능한 생성자에 전달 될 수 있고 해당 해시 함수는 테이블의 모든 개체에 사용 됩니다.</xref:System.Collections.IHashCodeProvider>       해시 테이블의 용량은는 해시 테이블에 저장할 수 있는 요소의 수입니다. 요소가 해시 테이블에 추가 되 면 자동으로 용량 증가 하면 재할당을 통해 필요에 따라 합니다.       매우 큰 해시 테이블 개체에 대 한 설정 하 여 64 비트 시스템의 2 십억 요소에 최대 용량을 늘릴 수는 `enabled` 에 구성 요소의 특성 `true` 런타임 환경에서 합니다.       `foreach` C# 언어의 (`For Each` Visual basic에서) 컬렉션의 요소 형식의 개체를 반환 합니다. 해시 테이블의 각 요소는 키/값 쌍에 요소 유형 키의 형식 또는 값의 형식입니다. 대신, 요소 형식이 <xref:System.Collections.DictionaryEntry>.</xref:System.Collections.DictionaryEntry> 예를 들어: [!code-cpp [System.Collections.Hashtable_ClassExample#01](~/add/codesnippet/cpp/t-system.collections.has_1.cpp)][!code-cs[System.Collections.Hashtable_ClassExample#01](~/add/codesnippet/csharp/t-system.collections.has_1.cs)][!code-vb[System.Collections.Hashtable_ClassExample#01](~/add/codesnippet/visualbasic/t-system.collections.has_1.vb) ] 는 `foreach` 문에 열거자를 컬렉션에 쓰는 것부터 읽기 가능 주변 래퍼입니다.           되기 때문에 직렬화 및 다시 정렬 될 요소 하면이 해시 테이블에 대 한 열거자를 역직렬화, 없습니다 호출 하지 않고 열거를 계속 진행할 수는 <xref:System.Collections.IEnumerator.Reset%2A>메서드.</xref:System.Collections.IEnumerator.Reset%2A>      > [!NOTE] > 키를 상속할 수의 동작을 변경할의 절대 변경할 수 비교를 사용 하 여 하기 때문에 <xref:System.Type.Equals%2A>메서드.</xref:System.Type.Equals%2A>"
  example:
  - "The following example shows how to create, initialize and perform various functions to a Hashtable and how to print out its keys and values.  \n  \n [!code-cpp[System.Collections.Hashtable_ClassExample#00](~/add/codesnippet/cpp/t-system.collections.has_2.cpp)]\n [!code-cs[System.Collections.Hashtable_ClassExample#00](~/add/codesnippet/csharp/t-system.collections.has_2.cs)]\n [!code-vb[System.Collections.Hashtable_ClassExample#00](~/add/codesnippet/visualbasic/t-system.collections.has_2.vb)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Hashtable/HashtableDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Hashtable : ICloneable, System.Collections.IDictionary, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
  inheritance:
  - System.Object
  implements:
  - System.Collections.IDictionary
  - System.ICloneable
  - System.Runtime.Serialization.IDeserializationCallback
  - System.Runtime.Serialization.ISerializable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor
  id: '#ctor'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable()
  nameWithType: Hashtable.Hashtable()
  fullName: System.Collections.Hashtable.Hashtable()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새로 만든 빈 인스턴스를 초기화는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 기본 초기 용량을 사용 하 여 클래스, 인수, 해시 코드 공급자 및 비교자를 로드 합니다."
  remarks: "해시 테이블의 용량은 최적의 로드 비율에 따라 해시 테이블 버킷 수를 계산 하는 데 사용 됩니다. 용량 자동으로 증가 해야 하는 경우.       로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.       실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.       키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <xref:System.Collections.Hashtable>개체입니다.</xref:System.Collections.Hashtable> 기본 해시 코드 공급자는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> 키의 구현       비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable>고유 해야 합니다.</xref:System.Collections.Hashtable> 기본 비교자는 <xref:System.Object.Equals%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.Equals%2A?displayProperty=fullName> 키의 구현       이 생성자는 o (1) 연산입니다."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctor#1](~/add/codesnippet/cpp/m-system.collections.has_4_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctor#1](~/add/codesnippet/csharp/m-system.collections.has_4_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctor#1](~/add/codesnippet/visualbasic/m-system.collections.has_4_1.vb)]"
  syntax:
    content: public Hashtable ();
    parameters: []
  overload: System.Collections.Hashtable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary)
  id: '#ctor(System.Collections.IDictionary)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary)
  nameWithType: Hashtable.Hashtable(IDictionary)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 지정된 된 사전에서 새 요소를 복사 하 여 클래스 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체입니다. 새 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체 초기 용량이 복사 된 요소 수와 동일 하 고 기본 로드 비율, 해시 코드 공급자 및 비교자를 사용 합니다."
  remarks: "초기 용량 원본 사전의 요소 수로 설정 됩니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.       로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.       실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.       키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <xref:System.Collections.Hashtable>개체입니다.</xref:System.Collections.Hashtable> 기본 해시 코드 공급자는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> 키의 구현       비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable>고유 해야 합니다.</xref:System.Collections.Hashtable> 기본 비교자는 <xref:System.Object.Equals%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.Equals%2A?displayProperty=fullName> 키의 구현       새 요소의 <xref:System.Collections.Hashtable>정렬 되는 열거자를 통해 반복 하는 순서는 <xref:System.Collections.IDictionary>개체입니다.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       이 생성자는는 O (`n`) 작업을 여기서 `n` 에 있는 요소의 수는 `d` 매개 변수입니다."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/cpp/m-system.collections.has_1_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/csharp/m-system.collections.has_1_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/visualbasic/m-system.collections.has_1_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>새 복사할 개체 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체입니다.</xref:System.Collections.IDictionary>"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)
  id: '#ctor(System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새로 만든 빈 인스턴스를 초기화는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 클래스에서 기본 초기 용량을 사용 하 고 요소와 지정 된 로드 <xref:System.Collections.IEqualityComparer>개체입니다.</xref:System.Collections.IEqualityComparer>"
  remarks: "해시 테이블의 용량은 최적의 로드 비율에 따라 해시 테이블 버킷 수를 계산 하는 데 사용 됩니다. 용량 자동으로 증가 해야 하는 경우.       로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.       실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.       <xref:System.Collections.IEqualityComparer>해시 코드 공급자와 비교자 개체를 포함 합니다.</xref:System.Collections.IEqualityComparer> 경우는 <xref:System.Collections.IEqualityComparer>에 사용 되는 <xref:System.Collections.Hashtable>생성자에서 키로 사용 되는 개체는 <xref:System.Collections.Hashtable>개체는 재정의 하지 않아도 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>및 <xref:System.Object.Equals%2A?displayProperty=fullName>메서드.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       해시 코드 공급자 <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> 키에 대 한 해시 코드를 분배합니다. 기본 해시 코드 공급자는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> 키의 구현       비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable>고유 해야 합니다.</xref:System.Collections.Hashtable> 기본 비교자는 <xref:System.Object.Equals%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.Equals%2A?displayProperty=fullName> 키의 구현       <xref:System.Collections.IEqualityComparer>조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.</xref:System.Collections.IEqualityComparer>       이 생성자는 o (1) 연산입니다."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctor#1](~/add/codesnippet/cpp/m-system.collections.has_5_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctor#1](~/add/codesnippet/csharp/m-system.collections.has_5_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctor#1](~/add/codesnippet/visualbasic/m-system.collections.has_5_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>해시 코드 공급자와 비교자를 사용 하면 정의 하는 개체는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체입니다.</xref:System.Collections.IEqualityComparer>       -또는- <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 기본 해시 코드 공급자와 기본 비교자를 사용 합니다. 기본 해시 코드 공급자는 각 키의 구현의 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 기본 비교자는 각 키의 구현 및 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;합니다."
  overload: System.Collections.Hashtable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32)
  nameWithType: Hashtable.Hashtable(Int32)
  fullName: System.Collections.Hashtable.Hashtable(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새로 만든 빈 인스턴스를 초기화는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 클래스 지정된 된 초기 용량을 기본 로드 비율, 해시 코드 공급자 및 비교자를 사용 합니다."
  remarks: "초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <xref:System.Collections.Hashtable>개체입니다.</xref:System.Collections.Hashtable> 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.       로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.       실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.       해시 코드 공급자 <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> 키에 대 한 해시 코드를 분배합니다. 기본 해시 코드 공급자는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> 키의 구현       비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable>고유 해야 합니다.</xref:System.Collections.Hashtable> 기본 비교자는 <xref:System.Object.Equals%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.Equals%2A?displayProperty=fullName> 키의 구현       이 생성자는는 O (`n`) 작업, 여기서 `n` 은 `capacity`합니다."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/cpp/m-system.collections.has_2_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/csharp/m-system.collections.has_2_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/visualbasic/m-system.collections.has_2_1.vb)]"
  syntax:
    content: public Hashtable (int capacity);
    parameters:
    - id: capacity
      type: System.Int32
      description: "대략적인 개수의 요소를는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체 처음 포함 될 수 있습니다."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>가&0; 보다 작습니다."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)
  id: '#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 지정된 된 사전에서 새 요소를 복사 하 여 클래스 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체입니다. 새 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체 초기 용량이 복사 된 요소 수와 동일 하며 기본 로드 비율와 지정 된 사용 <xref:System.Collections.IEqualityComparer>개체입니다.</xref:System.Collections.IEqualityComparer>"
  remarks: "초기 용량 원본 사전의 요소 수로 설정 됩니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.       로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.       실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.       <xref:System.Collections.IEqualityComparer>해시 코드 공급자와 비교자 개체를 포함 합니다.</xref:System.Collections.IEqualityComparer> 경우는 <xref:System.Collections.IEqualityComparer>에 사용 되는 <xref:System.Collections.Hashtable>생성자에서 키로 사용 되는 개체는 <xref:System.Collections.Hashtable>개체는 재정의 하지 않아도 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>및 <xref:System.Object.Equals%2A?displayProperty=fullName>메서드.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       해시 코드 공급자 <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> 키에 대 한 해시 코드를 분배합니다. 기본 해시 코드 공급자는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> 키의 구현       비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable>고유 해야 합니다.</xref:System.Collections.Hashtable> 기본 비교자는 <xref:System.Object.Equals%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.Equals%2A?displayProperty=fullName> 키의 구현       <xref:System.Collections.IEqualityComparer>조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.</xref:System.Collections.IEqualityComparer>       새 요소의 <xref:System.Collections.Hashtable>정렬 되는 열거자를 통해 반복 하는 순서는 <xref:System.Collections.IDictionary>개체입니다.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       이 생성자는는 O (`n`) 작업을 여기서 `n` 에 있는 요소의 수는 `d` 매개 변수입니다."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/cpp/81cd87de-02b7-42cc-8fdd-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/csharp/81cd87de-02b7-42cc-8fdd-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/visualbasic/81cd87de-02b7-42cc-8fdd-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>새 복사할 개체 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체입니다.</xref:System.Collections.IDictionary>"
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>해시 코드 공급자와 비교자를 사용 하면 정의 하는 개체는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>       -또는- <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 기본 해시 코드 공급자와 기본 비교자를 사용 합니다. 기본 해시 코드 공급자는 각 키의 구현의 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 기본 비교자는 각 키의 구현 및 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;합니다."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)
  id: '#ctor(System.Collections.IDictionary,System.Single)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,Single)
  nameWithType: Hashtable.Hashtable(IDictionary,Single)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 지정된 된 사전에서 새 요소를 복사 하 여 클래스 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체입니다. 새 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체 초기 용량이 복사 된 요소 수와 동일 하 고 지정된 된 로드 비율, 기본 해시 코드 공급자 및 비교자를 사용 하 여 합니다."
  remarks: "초기 용량 원본 사전의 요소 수로 설정 됩니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.       로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다. 1.0의 로드 비율은 속도와 크기 적절 합니다.       실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.       키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <xref:System.Collections.Hashtable>개체입니다.</xref:System.Collections.Hashtable> 기본 해시 코드 공급자는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> 키의 구현       비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable>고유 해야 합니다.</xref:System.Collections.Hashtable> 기본 비교자는 <xref:System.Object.Equals%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.Equals%2A?displayProperty=fullName> 키의 구현       새 요소의 <xref:System.Collections.Hashtable>정렬 되는 열거자를 통해 반복 하는 순서는 <xref:System.Collections.IDictionary>개체입니다.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       이 생성자는는 O (`n`) 작업을 여기서 `n` 에 있는 요소의 수는 `d` 매개 변수입니다."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cs[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/csharp/fb1cfbc8-7454-4619-a6e7-_1.cs)]\n [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/cpp/fb1cfbc8-7454-4619-a6e7-_1.cpp)]\n [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/visualbasic/fb1cfbc8-7454-4619-a6e7-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, float loadFactor);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>새 복사할 개체 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체입니다.</xref:System.Collections.IDictionary>"
    - id: loadFactor
      type: System.Single
      description: "0.1에서 최상의 성능을 제공 하는 기본 값에 곱합니다 1.0 사이의 범위에 속하는 숫자입니다. 결과 버킷과 요소의 최대 비율입니다."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>loadFactor</code>0.1 보다 작습니다.       -또는- <code>loadFactor</code> 1.0 보다 큽니다."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새로 만든 빈 인스턴스를 초기화는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 클래스에서 기본 초기 용량을 사용 하 고 인수를 지정 된 해시 코드 공급자 및 비교자를 로드 합니다."
  remarks: "해시 테이블의 용량은 최적의 로드 비율에 따라 해시 테이블 버킷 수를 계산 하는 데 사용 됩니다. 용량 자동으로 증가 해야 하는 경우.       로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.       실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.       키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <xref:System.Collections.Hashtable>개체입니다.</xref:System.Collections.Hashtable> 기본 해시 코드 공급자는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> 키의 구현       비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable>고유 해야 합니다.</xref:System.Collections.Hashtable> 기본 비교자는 <xref:System.Object.Equals%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.Equals%2A?displayProperty=fullName> 키의 구현       사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.       이 생성자는 o (1) 연산입니다."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctor#1](~/add/codesnippet/cpp/1ff65986-0234-4702-94b7-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctor#1](~/add/codesnippet/csharp/1ff65986-0234-4702-94b7-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctor#1](~/add/codesnippet/visualbasic/1ff65986-0234-4702-94b7-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> 해시를 제공 하는 개체에 있는 모든 키에 대 한 코드는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체입니다.       -또는- <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 기본 해시 코드 공급자를 사용 하려면 각 키의 구현인 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;합니다."
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>두 키가 같은지 여부를 확인 하는 데 사용할 개체입니다.</xref:System.Collections.IComparer>       -또는- <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 기본 비교자를 사용 하려면 각 키의 구현인 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;합니다."
  overload: System.Collections.Hashtable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)
  id: '#ctor(System.Int32,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새로 만든 빈 인스턴스를 초기화는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 지정된 된 초기 용량을 사용 하 여 클래스 및 <xref:System.Collections.IEqualityComparer>, 및 기본 로드 비율.</xref:System.Collections.IEqualityComparer>"
  remarks: "초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <xref:System.Collections.Hashtable>개체입니다.</xref:System.Collections.Hashtable> 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.       로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.       실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.       <xref:System.Collections.IEqualityComparer>해시 코드 공급자와 비교자 개체를 포함 합니다.</xref:System.Collections.IEqualityComparer> 경우는 <xref:System.Collections.IEqualityComparer>에 사용 되는 <xref:System.Collections.Hashtable>생성자에서 키로 사용 되는 개체는 <xref:System.Collections.Hashtable>재정의 하지 않아도 되는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>및 <xref:System.Object.Equals%2A?displayProperty=fullName>메서드.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       해시 코드 공급자 <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> 키에 대 한 해시 코드를 분배합니다. 기본 해시 코드 공급자는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> 키의 구현       비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable>고유 해야 합니다.</xref:System.Collections.Hashtable> 기본 비교자는 <xref:System.Object.Equals%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.Equals%2A?displayProperty=fullName> 키의 구현       <xref:System.Collections.IEqualityComparer>조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.</xref:System.Collections.IEqualityComparer>       이 생성자는는 O (`n`) 작업, 여기서 `n` 는 `capacity` 매개 변수입니다."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/cpp/5067e9ac-cd98-4da8-9418-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/csharp/5067e9ac-cd98-4da8-9418-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/visualbasic/5067e9ac-cd98-4da8-9418-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "대략적인 개수의 요소를는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체 처음 포함 될 수 있습니다."
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>해시 코드 공급자와 비교자를 사용 하면 정의 하는 개체는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>       -또는- <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 기본 해시 코드 공급자와 기본 비교자를 사용 합니다. 기본 해시 코드 공급자는 각 키의 구현의 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 기본 비교자는 각 키의 구현 및 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;합니다."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>가&0; 보다 작습니다."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single)
  id: '#ctor(System.Int32,System.Single)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,Single)
  nameWithType: Hashtable.Hashtable(Int32,Single)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새로 만든 빈 인스턴스를 초기화는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 지정된 된 초기 용량을 사용 하 여 클래스 및 비율과 기본 해시 코드 공급자 및 비교자를 로드 합니다."
  remarks: "초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <xref:System.Collections.Hashtable>개체입니다.</xref:System.Collections.Hashtable> 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.       로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다. 1.0의 로드 비율은 속도와 크기 적절 합니다.       실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.       해시 코드 공급자 <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> 키에 대 한 해시 코드를 분배합니다. 기본 해시 코드 공급자는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> 키의 구현       비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable>고유 해야 합니다.</xref:System.Collections.Hashtable> 기본 비교자는 <xref:System.Object.Equals%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.Equals%2A?displayProperty=fullName> 키의 구현       이 생성자는는 O (`n`) 작업, 여기서 `n` 는 `capacity` 매개 변수입니다."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/cpp/m-system.collections.has_8_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/csharp/m-system.collections.has_8_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/visualbasic/m-system.collections.has_8_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, float loadFactor);
    parameters:
    - id: capacity
      type: System.Int32
      description: "대략적인 개수의 요소를는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체 처음 포함 될 수 있습니다."
    - id: loadFactor
      type: System.Single
      description: "0.1에서 최상의 성능을 제공 하는 기본 값에 곱합니다 1.0 사이의 범위에 속하는 숫자입니다. 결과 버킷과 요소의 최대 비율입니다."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>가&0; 보다 작습니다.       -또는- <code>loadFactor</code> 0.1 보다 작습니다.       -또는- <code>loadFactor</code> 1.0 보다 큽니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>capacity</code>오버플로가 발생 했습니다."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: '#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.Hashtable(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.Hashtable(SerializationInfo,StreamingContext)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새로 만든 빈 인스턴스를 초기화는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 클래스를 사용 하 여 지정 된 직렬화 가능 <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> 및 <xref:System.Runtime.Serialization.StreamingContext>개체입니다.</xref:System.Runtime.Serialization.StreamingContext>"
  remarks: "해시 테이블의 용량은 최적의 로드 비율에 따라 해시 테이블 버킷 수를 계산 하는 데 사용 됩니다. 용량 자동으로 증가 해야 하는 경우.       로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.       실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.       키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <xref:System.Collections.Hashtable>개체입니다.</xref:System.Collections.Hashtable> 기본 해시 코드 공급자는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> 키의 구현       비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable>고유 해야 합니다.</xref:System.Collections.Hashtable> 기본 비교자는 <xref:System.Object.Equals%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.Equals%2A?displayProperty=fullName> 키의 구현       이 생성자는는 O (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>       직렬화 및 역직렬화에 대 한 열거자 때문에 <xref:System.Collections.Hashtable>다시 정렬 될 요소를 발생할 수 있습니다, 호출 하지 않고 열거를 계속 불가능는 <xref:System.Collections.IEnumerator.Reset%2A>메서드.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.Hashtable>"
  syntax:
    content: protected Hashtable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "A <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> 개체를 serialize 하는 데 필요한 정보를 포함 하는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체입니다."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "A <xref:System.Runtime.Serialization.StreamingContext>소스와 연결 된 직렬화 된 스트림의 대상이 들어 있는 개체는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Runtime.Serialization.StreamingContext>"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>info</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 지정된 된 사전에서 새 요소를 복사 하 여 클래스 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체입니다. 새 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체 초기 용량이 복사 된 요소 수와 동일 하 고 지정 된 해시 코드 공급자 기본 로드 비율 및 비교자를 사용 하 여 합니다. 이 API는 사용 되지 않습니다. 참조 하십시오. &lt;xref:System.Collections.Hashtable.%23ctor%2A&gt;합니다."
  remarks: "초기 용량 원본 사전의 요소 수로 설정 됩니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.       로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.       실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.       키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <xref:System.Collections.Hashtable>개체입니다.</xref:System.Collections.Hashtable> 기본 해시 코드 공급자는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> 키의 구현       비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable>고유 해야 합니다.</xref:System.Collections.Hashtable> 기본 비교자는 <xref:System.Object.Equals%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.Equals%2A?displayProperty=fullName> 키의 구현       사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.       새 요소의 <xref:System.Collections.Hashtable>정렬 되는 열거자를 통해 반복 하는 순서는 <xref:System.Collections.IDictionary>개체입니다.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       이 생성자는는 O (`n`) 작업을 여기서 `n` 에 있는 요소의 수는 `d` 매개 변수입니다."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/cpp/9a30e378-7c34-4854-b12f-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/csharp/9a30e378-7c34-4854-b12f-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/visualbasic/9a30e378-7c34-4854-b12f-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>새 복사할 개체 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체입니다.</xref:System.Collections.IDictionary>"
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> 해시를 제공 하는 개체에 있는 모든 키에 대 한 코드는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다.       -또는- <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 기본 해시 코드 공급자를 사용 하려면 각 키의 구현인 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;합니다."
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>두 키가 같은지 여부를 확인 하는 데 사용할 개체입니다.</xref:System.Collections.IComparer>       -또는- <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 기본 비교자를 사용 하려면 각 키의 구현인 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;합니다."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)
  id: '#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 지정된 된 사전에서 새 요소를 복사 하 여 클래스 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체입니다. 새 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체 초기 용량이 복사 된 요소 수와 동일 하 고 지정된 된 로드 비율을 사용 하 여 및 <xref:System.Collections.IEqualityComparer>개체입니다.</xref:System.Collections.IEqualityComparer>"
  remarks: "초기 용량 원본 사전의 요소 수로 설정 됩니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.       로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다. 1.0의 로드 비율은 속도와 크기 적절 합니다.       실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.       <xref:System.Collections.IEqualityComparer>해시 코드 공급자와 비교자 개체를 포함 합니다.</xref:System.Collections.IEqualityComparer> 경우는 <xref:System.Collections.IEqualityComparer>에 사용 되는 <xref:System.Collections.Hashtable>생성자에서 키로 사용 되는 개체는 <xref:System.Collections.Hashtable>개체는 재정의 하지 않아도 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>및 <xref:System.Object.Equals%2A?displayProperty=fullName>메서드.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       해시 코드 공급자 <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> 키에 대 한 해시 코드를 분배합니다. 기본 해시 코드 공급자는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> 키의 구현       비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable>고유 해야 합니다.</xref:System.Collections.Hashtable> 기본 비교자는 <xref:System.Object.Equals%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.Equals%2A?displayProperty=fullName> 키의 구현       <xref:System.Collections.IEqualityComparer>조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.</xref:System.Collections.IEqualityComparer>       새 요소의 <xref:System.Collections.Hashtable>정렬 되는 열거자를 통해 반복 하는 순서는 <xref:System.Collections.IDictionary>개체입니다.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       이 생성자는는 O (`n`) 작업을 여기서 `n` 에 있는 요소의 수는 `d` 매개 변수입니다."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cs[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/csharp/a92f83be-9de4-470a-8cbb-_1.cs)]\n [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/cpp/a92f83be-9de4-470a-8cbb-_1.cpp)]\n [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/visualbasic/a92f83be-9de4-470a-8cbb-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>새 복사할 개체 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체입니다.</xref:System.Collections.IDictionary>"
    - id: loadFactor
      type: System.Single
      description: "0.1에서 최상의 성능을 제공 하는 기본 값에 곱합니다 1.0 사이의 범위에 속하는 숫자입니다. 결과 버킷과 요소의 최대 비율입니다."
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>해시 코드 공급자와 비교자를 사용 하면 정의 하는 개체는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>       -또는- <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 기본 해시 코드 공급자와 기본 비교자를 사용 합니다. 기본 해시 코드 공급자는 각 키의 구현의 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 기본 비교자는 각 키의 구현 및 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;합니다."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>loadFactor</code>0.1 보다 작습니다.       -또는- <code>loadFactor</code> 1.0 보다 큽니다."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새로 만든 빈 인스턴스를 초기화는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 클래스 지정된 된 초기 용량, 해시 코드 공급자, 비교자 및 기본 로드 비율을 사용 합니다."
  remarks: "초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <xref:System.Collections.Hashtable>개체입니다.</xref:System.Collections.Hashtable> 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.       로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.       실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.       해시 코드 공급자 <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> 키에 대 한 해시 코드를 분배합니다. 기본 해시 코드 공급자는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> 키의 구현       비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable>고유 해야 합니다.</xref:System.Collections.Hashtable> 기본 비교자는 <xref:System.Object.Equals%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.Equals%2A?displayProperty=fullName> 키의 구현       사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.       이 생성자는는 O (`n`) 작업, 여기서 `n` 는 `capacity` 매개 변수입니다."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/cpp/2154dba0-3cc6-41f7-aa9b-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/csharp/2154dba0-3cc6-41f7-aa9b-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/visualbasic/2154dba0-3cc6-41f7-aa9b-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "대략적인 개수의 요소를는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체 처음 포함 될 수 있습니다."
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> 해시를 제공 하는 개체에 있는 모든 키에 대 한 코드는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다.       -또는- <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 기본 해시 코드 공급자를 사용 하려면 각 키의 구현인 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;합니다."
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>두 키가 같은지 여부를 확인 하는 데 사용할 개체입니다.</xref:System.Collections.IComparer>       -또는- <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 기본 비교자를 사용 하려면 각 키의 구현인 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;합니다."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>가&0; 보다 작습니다."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)
  id: '#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새로 만든 빈 인스턴스를 초기화는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 지정 된 초기 용량, 로드 비율을 사용 하 여 클래스 및 <xref:System.Collections.IEqualityComparer>개체입니다.</xref:System.Collections.IEqualityComparer>"
  remarks: "초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <xref:System.Collections.Hashtable>개체입니다.</xref:System.Collections.Hashtable> 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.       로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다. 1.0의 로드 비율은 속도와 크기 적절 합니다.       실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.       <xref:System.Collections.IEqualityComparer>해시 코드 공급자와 비교자 개체를 포함 합니다.</xref:System.Collections.IEqualityComparer> 경우는 <xref:System.Collections.IEqualityComparer>에 사용 되는 <xref:System.Collections.Hashtable>생성자에서 키로 사용 되는 개체는 <xref:System.Collections.Hashtable>재정의 하지 않아도 되는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>및 <xref:System.Object.Equals%2A?displayProperty=fullName>메서드.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       해시 코드 공급자 <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> 키에 대 한 해시 코드를 분배합니다. 기본 해시 코드 공급자는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> 키의 구현       비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable>고유 해야 합니다.</xref:System.Collections.Hashtable> 기본 비교자는 <xref:System.Object.Equals%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.Equals%2A?displayProperty=fullName> 키의 구현       <xref:System.Collections.IEqualityComparer>조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.</xref:System.Collections.IEqualityComparer>       이 생성자는는 O (`n`) 작업, 여기서 `n` 는 `capacity` 매개 변수입니다."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/cpp/30b60c47-7bce-44a2-8d17-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/csharp/30b60c47-7bce-44a2-8d17-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/visualbasic/30b60c47-7bce-44a2-8d17-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, float loadFactor, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "대략적인 개수의 요소를는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체 처음 포함 될 수 있습니다."
    - id: loadFactor
      type: System.Single
      description: "0.1에서 최상의 성능을 제공 하는 기본 값에 곱합니다 1.0 사이의 범위에 속하는 숫자입니다. 결과 버킷과 요소의 최대 비율입니다."
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>해시 코드 공급자와 비교자를 사용 하면 정의 하는 개체는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>       -또는- <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 기본 해시 코드 공급자와 기본 비교자를 사용 합니다. 기본 해시 코드 공급자는 각 키의 구현의 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; 기본 비교자는 각 키의 구현 및 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;합니다."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>가&0; 보다 작습니다.       -또는- <code>loadFactor</code> 0.1 보다 작습니다.       -또는- <code>loadFactor</code> 1.0 보다 큽니다."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 지정된 된 사전에서 새 요소를 복사 하 여 클래스 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체입니다. 새 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체 초기 용량이 복사 된 요소 수와 동일 하 고 지정된 로드 비율, 해시 코드 공급자 및 비교자를 사용 합니다."
  remarks: "초기 용량 원본 사전의 요소 수로 설정 됩니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.       로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다. 1.0의 로드 비율은 속도와 크기 적절 합니다.       실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.       키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <xref:System.Collections.Hashtable>개체입니다.</xref:System.Collections.Hashtable> 기본 해시 코드 공급자는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> 키의 구현       비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable>고유 해야 합니다.</xref:System.Collections.Hashtable> 기본 비교자는 <xref:System.Object.Equals%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.Equals%2A?displayProperty=fullName> 키의 구현       사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.       새 요소의 <xref:System.Collections.Hashtable>정렬 되는 열거자를 통해 반복 하는 순서는 <xref:System.Collections.IDictionary>개체입니다.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       이 생성자는는 O (`n`) 작업을 여기서 `n` 에 있는 요소의 수는 `d` 매개 변수입니다."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cs[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/csharp/c67b166f-bc6a-49e5-9bd7-_1.cs)]\n [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/cpp/c67b166f-bc6a-49e5-9bd7-_1.cpp)]\n [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/visualbasic/c67b166f-bc6a-49e5-9bd7-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>새 복사할 개체 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체입니다.</xref:System.Collections.IDictionary>"
    - id: loadFactor
      type: System.Single
      description: "0.1에서 최상의 성능을 제공 하는 기본 값에 곱합니다 1.0 사이의 범위에 속하는 숫자입니다. 결과 버킷과 요소의 최대 비율입니다."
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> 해시를 제공 하는 개체에 있는 모든 키에 대 한 코드는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다.       -또는- <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 기본 해시 코드 공급자를 사용 하려면 각 키의 구현인 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;합니다."
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>두 키가 같은지 여부를 확인 하는 데 사용할 개체입니다.</xref:System.Collections.IComparer>       -또는- <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 기본 비교자를 사용 하려면 각 키의 구현인 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;합니다."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>loadFactor</code>0.1 보다 작습니다.       -또는- <code>loadFactor</code> 1.0 보다 큽니다."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "새로 만든 빈 인스턴스를 초기화는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 지정된 된 초기 용량을 사용 하 여 클래스, 인수, 해시 코드 공급자 및 비교자를 로드 합니다."
  remarks: "초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <xref:System.Collections.Hashtable>개체입니다.</xref:System.Collections.Hashtable> 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.       로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다. 1.0의 로드 비율은 속도와 크기 적절 합니다.       실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.       해시 코드 공급자 <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> 키에 대 한 해시 코드를 분배합니다. 기본 해시 코드 공급자는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> 키의 구현       비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable>고유 해야 합니다.</xref:System.Collections.Hashtable> 기본 비교자는 <xref:System.Object.Equals%2A?displayProperty=fullName>안내 하십시오.</xref:System.Object.Equals%2A?displayProperty=fullName> 키의 구현       사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.       이 생성자는는 O (`n`) 작업, 여기서 `n` 는 `capacity` 매개 변수입니다."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/cpp/86ed2545-c9ee-4654-a1a4-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/csharp/86ed2545-c9ee-4654-a1a4-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/visualbasic/86ed2545-c9ee-4654-a1a4-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "대략적인 개수의 요소를는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 개체 처음 포함 될 수 있습니다."
    - id: loadFactor
      type: System.Single
      description: "0.1에서 최상의 성능을 제공 하는 기본 값에 곱합니다 1.0 사이의 범위에 속하는 숫자입니다. 결과 버킷과 요소의 최대 비율입니다."
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> 해시를 제공 하는 개체에 있는 모든 키에 대 한 코드는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다.       -또는- <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 기본 해시 코드 공급자를 사용 하려면 각 키의 구현인 &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;합니다."
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>두 키가 같은지 여부를 확인 하는 데 사용할 개체입니다.</xref:System.Collections.IComparer>       -또는- <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 기본 비교자를 사용 하려면 각 키의 구현인 &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;합니다."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>가&0; 보다 작습니다.       -또는- <code>loadFactor</code> 0.1 보다 작습니다.       -또는- <code>loadFactor</code> 1.0 보다 큽니다."
  platform:
  - net462
- uid: System.Collections.Hashtable.Add(System.Object,System.Object)
  id: Add(System.Object,System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Add(Object,Object)
  nameWithType: Hashtable.Add(Object,Object)
  fullName: System.Collections.Hashtable.Add(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "지정한 키와 값을 가진 요소에 추가 된 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다."
  remarks: "키 일 수 없습니다 `null`, 하지만 값이 될 수 있습니다.       개체의 상태와 해시 코드 값 간에 상관 관계가 있는 일반적으로 쓰일 수 없습니다 키로 합니다. 예를 들어 문자열 개체는 키로 사용 하기 위해 StringBuilder 개체 보다 더 나은입니다.       사용할 수도 있습니다는 <xref:System.Collections.Hashtable.Item%2A>에 속성 키의 값을 설정 하 여 새 요소를 추가할 수 없습니다.는 <xref:System.Collections.Hashtable>; 예를 들어 `myCollection[&quot;myNonexistentKey&quot;] = myValue`.</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable.Item%2A> 그러나 지정된 된 키에 이미 있는 경우는 <xref:System.Collections.Hashtable>설정는 <xref:System.Collections.Hashtable.Item%2A>속성 이전 값을 덮어씁니다.</xref:System.Collections.Hashtable.Item%2A> </xref:System.Collections.Hashtable> 반면, Add 메서드는 기존 요소를 수정 하지 않습니다.       경우 <xref:System.Collections.Hashtable.Count%2A>의 용량 보다 작은 <xref:System.Collections.Hashtable>,이 메서드는 o (1) 작업.</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable.Count%2A> 이 메서드는 O 됩니다 용량을 새 요소로 적용로 늘려야 하는 경우 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable.Add Example#1](~/add/codesnippet/cpp/m-system.collections.has_6_1.cpp)]\n [!code-cs[Classic Hashtable.Add Example#1](~/add/codesnippet/csharp/m-system.collections.has_6_1.cs)]\n [!code-vb[Classic Hashtable.Add Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_6_1.vb)]"
  syntax:
    content: public virtual void Add (object key, object value);
    parameters:
    - id: key
      type: System.Object
      description: "추가할 요소의 키입니다."
    - id: value
      type: System.Object
      description: "추가할 요소의 값입니다. 값일 수 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Collections.Hashtable.Add*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "같은 키를 가진 요소가 이미는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.Hashtable&quot;> </xref> 읽기 전용입니다.       -또는- <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 크기가 고정된 되어 있습니다."
  platform:
  - net462
- uid: System.Collections.Hashtable.Clear
  id: Clear
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Clear()
  nameWithType: Hashtable.Clear()
  fullName: System.Collections.Hashtable.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "모든 요소를 제거는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다."
  remarks: "<xref:System.Collections.Hashtable.Count%2A>가&0;으로 설정 하 고 컬렉션의 요소에 다른 개체에 대 한 참조도 해제 됩니다.</xref:System.Collections.Hashtable.Count%2A> 용량 변경 되지 않습니다.       이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.has_10_1.cpp)]\n [!code-vb[Classic Hashtable.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_10_1.vb)]\n [!code-cs[Classic Hashtable.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.has_10_1.cs)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Hashtable.Clear*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.Hashtable&quot;> </xref> 읽기 전용입니다."
  platform:
  - net462
- uid: System.Collections.Hashtable.Clone
  id: Clone
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Clone()
  nameWithType: Hashtable.Clone()
  fullName: System.Collections.Hashtable.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "단순 복사본을 만듭니다는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다."
  remarks: "컬렉션의 단순 복사본은 참조 형식 또는 값 형식 참조에서 참조 하는 개체를 복사 하지 않습니다 여부는 컬렉션의 요소에만 복사 합니다. 새 컬렉션에 대 한 참조는 원본 컬렉션에 대 한 참조를 가리키는 동일한 개체를 가리킵니다.       반면, 요소를 복사 하는 컬렉션의 전체 복사본 및 뿐만 아니라 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목입니다.       <xref:System.Collections.Hashtable>복사본은 동일한 개수, 같은 용량, 동일한 <xref:System.Collections.IHashCodeProvider>구현과 같은 <xref:System.Collections.IComparer>원래 <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> 구현</xref:System.Collections.IComparer> </xref:System.Collections.IHashCodeProvider> </xref:System.Collections.Hashtable>       이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "단순 복사는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다."
  overload: System.Collections.Hashtable.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.comparer
  id: comparer
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: comparer
  nameWithType: Hashtable.comparer
  fullName: System.Collections.Hashtable.comparer
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "가져오거나는 <xref:System.Collections.IComparer>에 사용할는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IComparer>"
  remarks: "이 속성의 값을 검색 하는 것은 o (1) 작업입니다."
  syntax:
    content: protected System.Collections.IComparer comparer { get; set; }
    return:
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>에 사용할는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IComparer>"
  overload: System.Collections.Hashtable.comparer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "속성 값으로 설정 되어 있지만 <xref:System.Collections.IEqualityComparer>.</xref:System.Collections.IEqualityComparer> 를 사용 하 여 해시 테이블을 만든"
  platform:
  - net462
- uid: System.Collections.Hashtable.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Hashtable.Contains(Object)
  fullName: System.Collections.Hashtable.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "결정 여부는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 특정 키가 들어 있습니다."
  remarks: "구현 <xref:System.Collections.IDictionary.Contains%2A?displayProperty=fullName>.</xref:System.Collections.IDictionary.Contains%2A?displayProperty=fullName> 포함 <xref:System.Collections.Hashtable.ContainsKey%2A>.</xref:System.Collections.Hashtable.ContainsKey%2A> 과 동일 하 게 작동       이 메서드는 o (1) 작업.       컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 <xref:System.Object.Equals%2A>및 <xref:System.IComparable.CompareTo%2A>에 대 한 메서드 `item` 항목이 있는지 여부를 확인 합니다.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> .NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <xref:System.Object.Equals%2A>및 <xref:System.IComparable.CompareTo%2A>의 메서드는 `item` 컬렉션의 개체에 대 한 매개 변수.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following example shows how to determine whether the <xref:System.Collections.Hashtable> contains a specific element.  \n  \n [!code-cpp[Classic Hashtable.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.has_12_1.cpp)]\n [!code-cs[Classic Hashtable.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.has_12_1.cs)]\n [!code-vb[Classic Hashtable.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_12_1.vb)]"
  syntax:
    content: public virtual bool Contains (object key);
    parameters:
    - id: key
      type: System.Object
      description: "찾을 수 있는 키의 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 지정 된 요소가 포함 되어 고, 그렇지 않으면 키 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Collections.Hashtable.Contains*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.ContainsKey(System.Object)
  id: ContainsKey(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: ContainsKey(Object)
  nameWithType: Hashtable.ContainsKey(Object)
  fullName: System.Collections.Hashtable.ContainsKey(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "결정 여부는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 특정 키가 들어 있습니다."
  remarks: "이 메서드는 <xref:System.Collections.Hashtable.Contains%2A>.</xref:System.Collections.Hashtable.Contains%2A> 과 동일 하 게 동작       이 메서드는 o (1) 작업.       컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 <xref:System.Object.Equals%2A>및 <xref:System.IComparable.CompareTo%2A>에 대 한 메서드 `item` 항목이 있는지 여부를 확인 합니다.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> .NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <xref:System.Object.Equals%2A>및 <xref:System.IComparable.CompareTo%2A>의 메서드는 `item` 컬렉션의 개체에 대 한 매개 변수.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following example shows how to determine whether the <xref:System.Collections.Hashtable> contains a specific element.  \n  \n [!code-cpp[Classic Hashtable.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.has_7_1.cpp)]\n [!code-cs[Classic Hashtable.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.has_7_1.cs)]\n [!code-vb[Classic Hashtable.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_7_1.vb)]"
  syntax:
    content: public virtual bool ContainsKey (object key);
    parameters:
    - id: key
      type: System.Object
      description: "찾을 수 있는 키의 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 지정 된 요소가 포함 되어 고, 그렇지 않으면 키 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Collections.Hashtable.ContainsKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.ContainsValue(System.Object)
  id: ContainsValue(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: ContainsValue(Object)
  nameWithType: Hashtable.ContainsValue(Object)
  fullName: System.Collections.Hashtable.ContainsValue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "결정 여부는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 특정 값을 포함 합니다."
  remarks: "요소는 <xref:System.Collections.Hashtable>사용 하 여 지정 된 값이 비교는 <xref:System.Object.Equals%2A?displayProperty=fullName>메서드.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Collections.Hashtable>       이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>       컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 <xref:System.Object.Equals%2A>및 <xref:System.IComparable.CompareTo%2A>에 대 한 메서드 `item` 항목이 있는지 여부를 확인 합니다.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> .NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <xref:System.Object.Equals%2A>및 <xref:System.IComparable.CompareTo%2A>의 메서드는 `item` 컬렉션의 개체에 대 한 매개 변수.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following example shows how to determine whether the <xref:System.Collections.Hashtable> contains a specific element.  \n  \n [!code-cpp[Classic Hashtable.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.has_9_1.cpp)]\n [!code-cs[Classic Hashtable.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.has_9_1.cs)]\n [!code-vb[Classic Hashtable.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_9_1.vb)]"
  syntax:
    content: public virtual bool ContainsValue (object value);
    parameters:
    - id: value
      type: System.Object
      description: "찾을 값은 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다. 값일 수 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 지정 된 요소가 포함 되어 <code> value </code>, 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Collections.Hashtable.ContainsValue*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Hashtable.CopyTo(Array,Int32)
  fullName: System.Collections.Hashtable.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "복사본의 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 요소를 사용 하는&1; 차원 <xref:System.Array>지정된 된 인덱스에 있는 인스턴스에.</xref:System.Array>"
  remarks: "<xref:System.Array>열거자 <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> 을 반복 하는 같은 순서로</xref:System.Array> 요소가 복사 되       에 있는 키를 복사 하는 <xref:System.Collections.Hashtable>를 사용 하 여 `Hashtable.Keys.CopyTo`.</xref:System.Collections.Hashtable>       값만 복사 하는 <xref:System.Collections.Hashtable>를 사용 하 여 `Hashtable.Values.CopyTo`.</xref:System.Collections.Hashtable>       이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>"
  example:
  - "The following example shows how to copy the list of keys or the list of values in a <xref:System.Collections.Hashtable> into a one-dimensional <xref:System.Array>.  \n  \n [!code-cs[Classic Hashtable.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.has_0_1.cs)]\n [!code-vb[Classic Hashtable.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_0_1.vb)]\n [!code-cpp[Classic Hashtable.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.has_0_1.cpp)]"
  syntax:
    content: public virtual void CopyTo (Array array, int arrayIndex);
    parameters:
    - id: array
      type: System.Array
      description: "1 차원 <xref:System.Array>의 대상인은 <xref:System.Collections.DictionaryEntry>에서 복사한 개체 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.DictionaryEntry> </xref:System.Array> <xref:System.Array>0부터 시작 하는 인덱스가 있어야 합니다.</xref:System.Array>"
    - id: arrayIndex
      type: System.Int32
      description: "인덱스는&0;부터 시작 `array` 복사가 시작 되는 합니다."
  overload: System.Collections.Hashtable.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>arrayIndex</code>가&0; 보다 작습니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>가 다차원 배열인 경우       -또는-소스에 있는 요소의 수 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 에서 사용 가능한 공간 보다 큰 <code>arrayIndex</code> 대상의 끝에 <code>array</code>합니다."
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "소스의 형식을 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 대상의 형식으로 자동 캐스팅할 수 없는 <code> array </code>합니다."
  platform:
  - net462
- uid: System.Collections.Hashtable.Count
  id: Count
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Count
  nameWithType: Hashtable.Count
  fullName: System.Collections.Hashtable.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "에 포함 된 키/값 쌍의 수를 가져옵니다는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다."
  remarks: "이 속성의 값을 검색 하는 것은 o (1) 작업입니다."
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "에 포함 된 키/값 쌍의 수는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다."
  overload: System.Collections.Hashtable.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.EqualityComparer
  id: EqualityComparer
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: EqualityComparer
  nameWithType: Hashtable.EqualityComparer
  fullName: System.Collections.Hashtable.EqualityComparer
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "가져옵니다는 <xref:System.Collections.IEqualityComparer>에 사용할는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>"
  remarks: "<xref:System.Collections.IEqualityComparer>비교자 및 해시 코드 공급자를 모두 포함 합니다.</xref:System.Collections.IEqualityComparer> 경우는 <xref:System.Collections.IEqualityComparer>에 사용 되는 <xref:System.Collections.Hashtable>생성자에서 키로 사용 되는 개체는 <xref:System.Collections.Hashtable>재정의 하지 않아도 되는 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>및 <xref:System.Object.Equals%2A?displayProperty=fullName>메서드.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       이 속성의 값을 검색 하는 것은 o (1) 작업입니다."
  syntax:
    content: protected System.Collections.IEqualityComparer EqualityComparer { get; }
    return:
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>에 사용할는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>"
  overload: System.Collections.Hashtable.EqualityComparer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "속성 값으로 설정 되어 있지만 해시 테이블을 사용 하 여 만들어진는 <xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> 및 <xref:System.Collections.IComparer>.</xref:System.Collections.IComparer>"
  platform:
  - net462
- uid: System.Collections.Hashtable.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Hashtable.GetEnumerator()
  fullName: System.Collections.Hashtable.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "반환 된 <xref:System.Collections.IDictionaryEnumerator>반복 하는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IDictionaryEnumerator>"
  remarks: "[Visual Basic, C#]       `foreach` C# 언어의 (`for each` Visual basic에서)은 열거자의 복잡성을 숨깁니다.  따라서 사용 하 여 `foreach` 열거자를 직접 조작 하는 대신이 좋습니다.       열거자는 컬렉션의에서 데이터를 읽는 데 사용할 수 있지만 기본 컬렉션을 수정 하는 사용할 수 없습니다.       처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치 됩니다. <xref:System.Collections.IEnumerator.Reset%2A>또한이 위치로 복원 열거자를 가져옵니다.</xref:System.Collections.IEnumerator.Reset%2A>  이 위치에서 <xref:System.Collections.IEnumerator.Current%2A>정의 되지 않습니다.</xref:System.Collections.IEnumerator.Current%2A> 따라서 <xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> 의 값을 읽기 전에 컬렉션의 첫 번째 요소로 열거자를</xref:System.Collections.IEnumerator.MoveNext%2A> 호출 해야 합니다.       <xref:System.Collections.IEnumerator.Current%2A>될 때까지 동일한 개체를 반환 <xref:System.Collections.IEnumerator.MoveNext%2A>또는 <xref:System.Collections.IEnumerator.Reset%2A>호출 됩니다.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>설정 <xref:System.Collections.IEnumerator.Current%2A>를 다음 요소로.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       경우 <xref:System.Collections.IEnumerator.MoveNext%2A>전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <xref:System.Collections.IEnumerator.MoveNext%2A>반환 `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 열거자가 있는 경우이 위치에 대 한 후속 호출에서 <xref:System.Collections.IEnumerator.MoveNext%2A>반환할 수도 `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A>반환 `false`, <xref:System.Collections.IEnumerator.Current%2A>정의 되지 않습니다.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Current%2A>다시, 컬렉션의 첫 번째 요소를 호출할 수 있습니다 <xref:System.Collections.IEnumerator.Reset%2A>그 뒤 <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A> 설정 하려면       열거자는 컬렉션이 변경 되지으로 유효한 상태를 유지 합니다. 컬렉션 변경 되 면 추가, 수정 또는 요소를 삭제와 같은 열거자는 무효화 하 고 해당 동작은 정의 되지 않습니다.       열거자는 컬렉션에 배타적으로 액세스가 없습니다. 따라서 컬렉션을 열거지 않습니다 본질적으로 스레드로부터 안전한 프로시저가 합니다.  을 열거 하는 동안 스레드로부터 안전을 보장 하려면 전체 열거 동안 컬렉션을 잠글 수 있습니다.  컬렉션에 여러 스레드에서 읽기 및 쓰기에 대 한 액세스를 허용 하려면 사용자 지정 동기화를 구현 해야 합니다.       이 메서드는 o (1) 작업.       직렬화 및 역직렬화에 대 한 열거자 때문에 <xref:System.Collections.Hashtable>다시 정렬 될 요소를 발생할 수 있습니다, 호출 하지 않고 열거를 계속 불가능는 <xref:System.Collections.IEnumerator.Reset%2A>메서드.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.Hashtable>"
  example:
  - "The following example compares the use of GetEnumerator and `foreach` to enumerate the contents of a <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable Example#2](~/add/codesnippet/cpp/m-system.collections.has_3_1.cpp)]\n [!code-cs[Classic Hashtable Example#2](~/add/codesnippet/csharp/m-system.collections.has_3_1.cs)]\n [!code-vb[Classic Hashtable Example#2](~/add/codesnippet/visualbasic/m-system.collections.has_3_1.vb)]"
  syntax:
    content: public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IDictionaryEnumerator
      description: "An <xref:System.Collections.IDictionaryEnumerator> for the <xref href=&quot;System.Collections.Hashtable&quot;></xref>.</xref:System.Collections.IDictionaryEnumerator>"
  overload: System.Collections.Hashtable.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.GetHash(System.Object)
  id: GetHash(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: GetHash(Object)
  nameWithType: Hashtable.GetHash(Object)
  fullName: System.Collections.Hashtable.GetHash(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "지정된 된 키에 대 한 해시 코드를 반환합니다."
  remarks: "특정 해시 테이블을 만든 경우 <xref:System.Collections.IHashCodeProvider>구현에서이 메서드는 해당 해시 코드 공급자를 사용 합니다; 하 고 사용은 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>구현의 `key`.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.IHashCodeProvider>       이 메서드는 o (1) 작업."
  syntax:
    content: protected virtual int GetHash (object key);
    parameters:
    - id: key
      type: System.Object
      description: "<xref:System.Object>해시 코드는 반환 될에 대 한.</xref:System.Object>"
    return:
      type: System.Int32
      description: "에 대 한 해시 코드 <code> key </code>합니다."
  overload: System.Collections.Hashtable.GetHash*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.GetObjectData(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "구현 된 <xref href=&quot;System.Runtime.Serialization.ISerializable&quot;> </xref> 인터페이스를 serialize 하는 데 필요한 데이터를 반환 된 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다."
  remarks: "이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>"
  syntax:
    content: public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "A <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> 개체를 serialize 하는 데 필요한 정보를 포함 하는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "A <xref:System.Runtime.Serialization.StreamingContext>소스와 연결 된 직렬화 된 스트림의 대상이 들어 있는 개체는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Runtime.Serialization.StreamingContext>"
  overload: System.Collections.Hashtable.GetObjectData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>info</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "컬렉션이 수정 되었습니다."
  platform:
  - net462
- uid: System.Collections.Hashtable.hcp
  id: hcp
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: hcp
  nameWithType: Hashtable.hcp
  fullName: System.Collections.Hashtable.hcp
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "해시 코드를 분배할 수 있는 개체를 가져오거나 설정 합니다."
  remarks: "이 속성의 값을 검색 하는 것은 o (1) 작업입니다."
  syntax:
    content: protected System.Collections.IHashCodeProvider hcp { get; set; }
    return:
      type: System.Collections.IHashCodeProvider
      description: "해시 코드를 분배할 수 있는 개체입니다."
  overload: System.Collections.Hashtable.hcp*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "속성 값으로 설정 되어 있지만 <xref:System.Collections.IEqualityComparer>.</xref:System.Collections.IEqualityComparer> 를 사용 하 여 해시 테이블을 만든"
  platform:
  - net462
- uid: System.Collections.Hashtable.IsFixedSize
  id: IsFixedSize
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: IsFixedSize
  nameWithType: Hashtable.IsFixedSize
  fullName: System.Collections.Hashtable.IsFixedSize
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "나타내는 값을 가져옵니다 여부는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 크기가 고정된 되어 있습니다."
  remarks: "컬렉션 크기가 고정된 된 컬렉션을 만든 후 기존 요소를 수정할 수 있습니다에 추가 하거나 제거할 요소의 수 없습니다.       크기가 고정된 된 컬렉션은 지정 된 추가 및 요소를 제거 하지 못하도록 하는 래퍼 컬렉션 따라서를 추가 하거나 제거할 요소를 포함 하 여 내부 컬렉션을 변경 하는 경우 고정 크기 컬렉션에 해당 변경 내용을 반영 합니다.       이 속성의 값을 검색 하는 것은 o (1) 작업입니다."
  syntax:
    content: public virtual bool IsFixedSize { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 고정 되어 고, 그렇지 않으면 크기가 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Collections.Hashtable.IsFixedSize*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.IsReadOnly
  id: IsReadOnly
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: IsReadOnly
  nameWithType: Hashtable.IsReadOnly
  fullName: System.Collections.Hashtable.IsReadOnly
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "나타내는 값을 가져옵니다 여부는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 읽기 전용입니다."
  remarks: "읽기 전용 컬렉션에서는 컬렉션을 만든 후에 추가, 제거 또는 요소를 수정할 수 없습니다.       읽기 전용 컬렉션은 지정 된 컬렉션을 수정 하지 못하도록 하는 래퍼 컬렉션 따라서 기본 컬렉션이 변경 될 경우 읽기 전용 컬렉션 해당 변경 내용을 반영 합니다.       이 속성의 값을 검색 하는 것은 o (1) 작업입니다."
  syntax:
    content: public virtual bool IsReadOnly { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 읽기 전용, 되지 않았으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Collections.Hashtable.IsReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Hashtable.IsSynchronized
  fullName: System.Collections.Hashtable.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "에 대 한 액세스 여부를 나타내는 값을 가져옵니다는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 이 동기화 되었으면 (스레드로부터 안전 하 게 보호)."
  remarks: "A <xref:System.Collections.Hashtable>동시 지원할 수 있습니다 하나 기록기 및 다중 판독기.</xref:System.Collections.Hashtable> 반환 되는 래퍼를 통해 수행 해야 모든 작업을 지원 하기 위해 여러 작성기는 <xref:System.Collections.Hashtable.Synchronized%2A>메서드.</xref:System.Collections.Hashtable.Synchronized%2A>       컬렉션을 열거 하는 스레드로부터 안전한 프로시저가 아닙니다 기본적으로 합니다. 컬렉션이 동기화 되어 있을 때 다른 스레드에서 수 수정할 열거자에서 예외가 발생 하는 컬렉션입니다. 열거 동안 스레드 보안을 보장 하려면 전체 열거 동안 컬렉션을 잠글 하거나 다른 스레드에서 변경 된 내용으로 인해 발생 한 예외를 catch 합니다.       다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <xref:System.Collections.Hashtable.SyncRoot%2A>열거 하는 동안: [!code-cpp [클래식 Hashtable.IsSynchronized 예제&#2;](~/add/codesnippet/cpp/p-system.collections.has_1_1.cpp)][!code-vb[클래식 Hashtable.IsSynchronized 예제&#2;](~/add/codesnippet/visualbasic/p-system.collections.has_1_1.vb)][!code-cs[클래식 Hashtable.IsSynchronized 예제&#2;](~/add/codesnippet/csharp/p-system.collections.has_1_1.cs) ]     </xref:System.Collections.Hashtable.SyncRoot%2A>"
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Hashtable>, determine if a <xref:System.Collections.Hashtable> is synchronized, and use a synchronized <xref:System.Collections.Hashtable>.  \n  \n [!code-cs[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.has_1_2.cs)]\n [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.has_1_2.cpp)]\n [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.has_1_2.vb)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우에 대 한 액세스는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 은 동기화 (스레드로부터 안전함); 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Collections.Hashtable.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.Item(System.Object)
  id: Item(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Item(Object)
  nameWithType: Hashtable.Item(Object)
  fullName: System.Collections.Hashtable.Item(Object)
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "지정된 된 키와 연결 된 값을 가져오거나 설정 합니다."
  remarks: "이 속성은 다음 구문을 사용 하 여 컬렉션의 특정 요소를 액세스 하는 기능 제공: `myCollection[key]`합니다.       에 존재 하지 않는 키의 값을 설정 하 여 새 요소를 추가 하는 항목 속성을 사용할 수도 있습니다는 <xref:System.Collections.Hashtable>; 예를 들어 `myCollection[&quot;myNonexistentKey&quot;] = myValue`.</xref:System.Collections.Hashtable> 그러나 지정된 된 키에 이미 있는 경우는 <xref:System.Collections.Hashtable>, 이전 값을 덮어씁니다 항목 속성을 설정 합니다.</xref:System.Collections.Hashtable> 반면,는 <xref:System.Collections.Hashtable.Add%2A>메서드는 기존 요소를 수정 하지 않습니다.</xref:System.Collections.Hashtable.Add%2A>       키 일 수 없습니다 `null`, 하지만 값이 될 수 있습니다. 구분 하기 위해 `null` 지정된 된 키를 찾을 수 없으므로 반환 되는 및 `null` 지정된 된 키의 값은 반환 되는 `null`를 사용 하 여는 <xref:System.Collections.Hashtable.Contains%2A>메서드 또는 <xref:System.Collections.Hashtable.ContainsKey%2A>목록에 키가 있는지 확인 하는 메서드.</xref:System.Collections.Hashtable.ContainsKey%2A> </xref:System.Collections.Hashtable.Contains%2A>       이 속성의 값을 검색 하 하는 것은 o (1) 연산입니다. o (1) 작업 이기도 속성을 설정 합니다.       C# 언어의 키워드를 사용 하 여 구현 하는 대신 인덱서를 정의 하는 <xref:System.Collections.IList.Item%2A>속성.</xref:System.Collections.IList.Item%2A> Visual Basic에서는 동일한 인덱싱 기능을 기본 속성으로 항목을 구현 합니다."
  syntax:
    content: public virtual object this[object key] { get; set; }
    parameters:
    - id: key
      type: System.Object
      description: "키 값을 가져오거나 설정 합니다."
    return:
      type: System.Object
      description: "지정된 된 키와 연결 된 값입니다. 지정된 된 키가 없으면 get 반환 하려고 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>가 지정된 된 키를 사용 하 여 새 요소를 만들어 설정 하려고 시도 합니다."
  overload: System.Collections.Hashtable.Item*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "속성을 설정 및 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 읽기 전용입니다.       -또는-속성이 설정 되어, <code> key </code> 컬렉션에 존재 하지 않는 및 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 크기가 고정된 되어 있습니다."
  platform:
  - net462
- uid: System.Collections.Hashtable.KeyEquals(System.Object,System.Object)
  id: KeyEquals(System.Object,System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: KeyEquals(Object,Object)
  nameWithType: Hashtable.KeyEquals(Object,Object)
  fullName: System.Collections.Hashtable.KeyEquals(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "특정 비교 <xref:System.Object>에 특정 키가 있는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Object>"
  remarks: "특정 해시 테이블을 만든 경우 <xref:System.Collections.IComparer>구현이이 메서드는 사용 되는 비교자; <xref:System.Collections.IComparer.Compare%2A>(`item`, `key`).</xref:System.Collections.IComparer.Compare%2A> </xref:System.Collections.IComparer> 그렇지 않으면 사용 `item.Equals(key)`합니다.       이 메서드는 o (1) 작업."
  syntax:
    content: protected virtual bool KeyEquals (object item, object key);
    parameters:
    - id: item
      type: System.Object
      description: "<xref:System.Object>와 비교할 `key`.</xref:System.Object>"
    - id: key
      type: System.Object
      description: "에 있는 키의 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 와 비교할 `item`합니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>if <code>item</code> and <code>key</code> are equal; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Hashtable.KeyEquals*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>item</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>key</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.Keys
  id: Keys
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Keys
  nameWithType: Hashtable.Keys
  fullName: System.Collections.Hashtable.Keys
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "가져옵니다는 <xref:System.Collections.ICollection>키를 포함 하는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.ICollection>"
  remarks: "에 있는 키의 순서는 <xref:System.Collections.ICollection>지정 되어 있지에 연결 된 값과 순서가 동일 하지만 <xref:System.Collections.ICollection>에서 반환 되는 <xref:System.Collections.Hashtable.Values%2A>메서드.</xref:System.Collections.Hashtable.Values%2A> </xref:System.Collections.ICollection> </xref:System.Collections.ICollection>       반환 된 <xref:System.Collections.ICollection>정적 복사 하지 않습니다; 대신 <xref:System.Collections.ICollection>원래 <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> 의 키를 다시 참조할</xref:System.Collections.ICollection> </xref:System.Collections.ICollection> 따라서 <xref:System.Collections.Hashtable>계속 <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> 반영</xref:System.Collections.Hashtable> 변경       이 속성의 값을 검색 하는 것은 o (1) 작업입니다."
  syntax:
    content: public virtual System.Collections.ICollection Keys { get; }
    return:
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>키를 포함 하는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.ICollection>"
  overload: System.Collections.Hashtable.Keys*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.OnDeserialization(System.Object)
  id: OnDeserialization(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: OnDeserialization(Object)
  nameWithType: Hashtable.OnDeserialization(Object)
  fullName: System.Collections.Hashtable.OnDeserialization(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "구현 된 <xref href=&quot;System.Runtime.Serialization.ISerializable&quot;> </xref> 인터페이스와 deserialization이 완료 되 면 deserialization 이벤트를 발생 시킵니다."
  remarks: "이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>       직렬화 및 역직렬화에 대 한 열거자 때문에 <xref:System.Collections.Hashtable>다시 정렬 될 요소를 발생할 수 있습니다, 호출 하지 않고 열거를 계속 불가능는 <xref:System.Collections.IEnumerator.Reset%2A>메서드.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.Hashtable>"
  syntax:
    content: public virtual void OnDeserialization (object sender);
    parameters:
    - id: sender
      type: System.Object
      description: "Deserialization 이벤트의 소스입니다."
  overload: System.Collections.Hashtable.OnDeserialization*
  exceptions:
  - type: System.Runtime.Serialization.SerializationException
    commentId: T:System.Runtime.Serialization.SerializationException
    description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> 개체와 현재 연결 된 <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 올바르지 않습니다."
  platform:
  - net462
- uid: System.Collections.Hashtable.Remove(System.Object)
  id: Remove(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Remove(Object)
  nameWithType: Hashtable.Remove(Object)
  fullName: System.Collections.Hashtable.Remove(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "지정된 된 키를 가진 요소를 제거는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다."
  remarks: "경우는 <xref:System.Collections.Hashtable>지정된 키를 가진 요소가 포함 되지 않습니다는 <xref:System.Collections.Hashtable>변경 되지 않습니다.</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> 예외가 throw 되지 않습니다.       이 메서드는 o (1) 작업."
  example:
  - "The following example shows how to remove elements from the <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable.Remove Example#1](~/add/codesnippet/cpp/m-system.collections.has_13_1.cpp)]\n [!code-cs[Classic Hashtable.Remove Example#1](~/add/codesnippet/csharp/m-system.collections.has_13_1.cs)]\n [!code-vb[Classic Hashtable.Remove Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_13_1.vb)]"
  syntax:
    content: public virtual void Remove (object key);
    parameters:
    - id: key
      type: System.Object
      description: "제거할 요소의 키입니다."
  overload: System.Collections.Hashtable.Remove*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.Hashtable&quot;> </xref> 읽기 전용입니다.       -또는- <xref href=&quot;System.Collections.Hashtable&quot;> </xref> 크기가 고정된 되어 있습니다."
  platform:
  - net462
- uid: System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)
  id: Synchronized(System.Collections.Hashtable)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Synchronized(Hashtable)
  nameWithType: Hashtable.Synchronized(Hashtable)
  fullName: System.Collections.Hashtable.Synchronized(Hashtable)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "에 대 한 동기화 (스레드로부터 안전한 지) 래퍼를 반환 합니다.는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다."
  remarks: "Synchronized 메서드는 스레드로부터 안전 하 게 여러 판독기와 작성기에 대 한 보호 합니다. 또한 동기화 된 래퍼 한 작성기만 한 번에 작성 되는지 확인 합니다.       컬렉션을 열거 본질적으로 스레드로부터 안전한 프로시저가 아닙니다. 컬렉션이 동기화 되어 있을 때 다른 스레드에서 수 수정할 열거자에서 예외가 발생 하는 컬렉션입니다. 열거 동안 스레드 보안을 보장 하려면 전체 열거 동안 컬렉션을 잠글 하거나 다른 스레드에서 변경 된 내용으로 인해 발생 한 예외를 catch 합니다.       다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <xref:System.Collections.Hashtable.SyncRoot%2A>열거 하는 동안: [!code-cpp [클래식 Hashtable.IsSynchronized 예제&#2;](~/add/codesnippet/cpp/m-system.collections.has_11_1.cpp)][!code-vb[클래식 Hashtable.IsSynchronized 예제&#2;](~/add/codesnippet/visualbasic/m-system.collections.has_11_1.vb)][!code-cs[클래식 Hashtable.IsSynchronized 예제&#2;](~/add/codesnippet/csharp/m-system.collections.has_11_1.cs) ] 이 메서드는 o (1) 작업.    </xref:System.Collections.Hashtable.SyncRoot%2A>"
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Hashtable>, determine if a <xref:System.Collections.Hashtable> is synchronized, and use a synchronized <xref:System.Collections.Hashtable>.  \n  \n [!code-cs[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.has_11_2.cs)]\n [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.has_11_2.cpp)]\n [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_11_2.vb)]"
  syntax:
    content: public static System.Collections.Hashtable Synchronized (System.Collections.Hashtable table);
    parameters:
    - id: table
      type: System.Collections.Hashtable
      description: "<xref href=&quot;System.Collections.Hashtable&quot;> </xref> 동기화 합니다."
    return:
      type: System.Collections.Hashtable
      description: "A (스레드로부터 안전한 지) 래퍼에 대 한 동기화는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다."
  overload: System.Collections.Hashtable.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>table</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.SyncRoot
  id: SyncRoot
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Hashtable.SyncRoot
  fullName: System.Collections.Hashtable.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "에 대 한 액세스를 동기화 하는 데 사용할 수 있는 개체를 가져옵니다는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다."
  remarks: "동기화 된 버전을 만들려면는 <xref:System.Collections.Hashtable>를 사용 하 여는 <xref:System.Collections.Hashtable.Synchronized%2A>메서드.</xref:System.Collections.Hashtable.Synchronized%2A> </xref:System.Collections.Hashtable> 하지만 파생된 클래스의 동기화 된 버전을 제공할 수 있습니다는 <xref:System.Collections.Hashtable>SyncRoot 속성을 사용 하 여.</xref:System.Collections.Hashtable> 동기화 하는 코드의 SyncRoot에 대 한 작업을 수행 해야는 <xref:System.Collections.Hashtable>, <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> 으로 만들어지므로</xref:System.Collections.Hashtable> 이렇게 하면 다른 개체에서 파생 된 컬렉션의 적절 한 작업입니다. 특히, 동시에 수정할 수 있는 다른 스레드와 적절 한 동기화를 유지 관리는 <xref:System.Collections.Hashtable>개체입니다.</xref:System.Collections.Hashtable>       컬렉션을 열거 하는 스레드로부터 안전한 프로시저가 아닙니다 기본적으로 합니다. 컬렉션이 동기화 되어 있을 때 다른 스레드에서 수 수정할 열거자에서 예외가 발생 하는 컬렉션입니다. 열거 동안 스레드 보안을 보장 하려면 전체 열거 동안 컬렉션을 잠글 하거나 다른 스레드에서 변경 된 내용으로 인해 발생 한 예외를 catch 합니다.       다음 코드 예제에는 SyncRoot를 사용 하 여 전체 열거 동안 컬렉션을 잠그는 방법을 보여 줍니다: [!code-cpp [클래식 Hashtable.IsSynchronized 예제&#2;](~/add/codesnippet/cpp/p-system.collections.has_0_1.cpp)][!code-vb[클래식 Hashtable.IsSynchronized 예제&#2;](~/add/codesnippet/visualbasic/p-system.collections.has_0_1.vb)][!code-cs[클래식 Hashtable.IsSynchronized 예제&#2;    ](~/add/codesnippet/csharp/p-system.collections.has_0_1.cs)]"
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "에 대 한 액세스를 동기화 하는 데 사용할 수 있는 개체는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>합니다."
  overload: System.Collections.Hashtable.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator
  id: System#Collections#IEnumerable#GetEnumerator
  isEii: true
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: Hashtable.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.Collections.Hashtable.System.Collections.IEnumerable.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "컬렉션을 반복 하는 열거자를 반환 합니다."
  remarks: "[Visual Basic, C#]       `foreach` C# 언어의 (`for each` Visual basic에서)은 열거자의 복잡성을 숨깁니다.  따라서 사용 하 여 `foreach` 열거자를 직접 조작 하는 대신이 좋습니다.       열거자는 컬렉션의에서 데이터를 읽는 데 사용할 수 있지만 기본 컬렉션을 수정 하는 사용할 수 없습니다.       처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치 됩니다. <xref:System.Collections.IEnumerator.Reset%2A>또한이 위치로 복원 열거자를 가져옵니다.</xref:System.Collections.IEnumerator.Reset%2A> 이 위치에서, 호출 <xref:System.Collections.IEnumerator.Current%2A>예외를 throw 합니다.</xref:System.Collections.IEnumerator.Current%2A> 따라서 <xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> 의 값을 읽기 전에 컬렉션의 첫 번째 요소로 열거자를</xref:System.Collections.IEnumerator.MoveNext%2A> 호출 해야 합니다.       <xref:System.Collections.IEnumerator.Current%2A>될 때까지 동일한 개체를 반환 <xref:System.Collections.IEnumerator.MoveNext%2A>또는 <xref:System.Collections.IEnumerator.Reset%2A>호출 됩니다.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>설정 <xref:System.Collections.IEnumerator.Current%2A>를 다음 요소로.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       경우 <xref:System.Collections.IEnumerator.MoveNext%2A>전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <xref:System.Collections.IEnumerator.MoveNext%2A>반환 `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 열거자가 있는 경우이 위치에 대 한 후속 호출에서 <xref:System.Collections.IEnumerator.MoveNext%2A>반환할 수도 `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A>반환 `false`호출, <xref:System.Collections.IEnumerator.Current%2A>예외를 throw 합니다.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Current%2A>다시, 컬렉션의 첫 번째 요소를 호출할 수 있습니다 <xref:System.Collections.IEnumerator.Reset%2A>그 뒤 <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A> 설정 하려면       열거자는 컬렉션이 변경 되지으로 유효한 상태를 유지 합니다. 컬렉션 변경 되 면 추가, 수정 또는 요소를 삭제와 같은 열거자를 무효화 될 수 있습니다 및을 <xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Reset%2A> <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException> throw</xref:System.Collections.IEnumerator.Reset%2A> 하거나</xref:System.Collections.IEnumerator.MoveNext%2A> 다음에 호출 사이 컬렉션이 수정 되는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A>및 <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A>열거자가 이미 무효로 되 었 하는 경우에 설정 하는 요소를 반환 합니다.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       열거자는 컬렉션에 배타적으로 액세스가 없습니다. 따라서 컬렉션을 열거지 않습니다 본질적으로 스레드로부터 안전한 프로시저가 합니다. 컬렉션이 동기화 되어 있을 때 다른 스레드에서 수 수정할 열거자에서 예외가 발생 하는 컬렉션입니다. 열거 동안 스레드 보안을 보장 하려면 전체 열거 동안 컬렉션을 잠글 하거나 다른 스레드에서 변경 된 내용으로 인해 발생 한 예외를 catch 합니다.       이 메서드는 o (1) 작업."
  syntax:
    content: System.Collections.IEnumerator IEnumerable.GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "<xref:System.Collections.IEnumerator>컬렉션을 반복에 사용할 수 있는.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.Values
  id: Values
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Values
  nameWithType: Hashtable.Values
  fullName: System.Collections.Hashtable.Values
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "가져옵니다는 <xref:System.Collections.ICollection>값을 포함 하는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.ICollection>"
  remarks: "에 있는 값의 순서는 <xref:System.Collections.ICollection>지정 되어 있지는 연결 된 키와 순서가 동일 하지만 <xref:System.Collections.ICollection>에서 반환 되는 <xref:System.Collections.Hashtable.Keys%2A>메서드.</xref:System.Collections.Hashtable.Keys%2A> </xref:System.Collections.ICollection> </xref:System.Collections.ICollection>       반환 된 <xref:System.Collections.ICollection>정적 복사 하지 않습니다; 대신 <xref:System.Collections.ICollection> <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> 원래에서 값을 다시 참조</xref:System.Collections.ICollection> </xref:System.Collections.ICollection> 따라서 <xref:System.Collections.Hashtable>계속 <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> 반영</xref:System.Collections.Hashtable> 변경       이 속성의 값을 검색 하는 것은 o (1) 작업입니다."
  syntax:
    content: public virtual System.Collections.ICollection Values { get; }
    return:
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>값을 포함 하는 <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.ICollection>"
  overload: System.Collections.Hashtable.Values*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Runtime.Serialization.SerializationException
  isExternal: true
  name: System.Runtime.Serialization.SerializationException
- uid: System.Collections.Hashtable.#ctor
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable()
  nameWithType: Hashtable.Hashtable()
  fullName: System.Collections.Hashtable.Hashtable()
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary)
  nameWithType: Hashtable.Hashtable(IDictionary)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary)
- uid: System.Collections.IDictionary
  parent: System.Collections
  isExternal: true
  name: IDictionary
  nameWithType: IDictionary
  fullName: System.Collections.IDictionary
- uid: System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IEqualityComparer)
- uid: System.Collections.IEqualityComparer
  parent: System.Collections
  isExternal: true
  name: IEqualityComparer
  nameWithType: IEqualityComparer
  fullName: System.Collections.IEqualityComparer
- uid: System.Collections.Hashtable.#ctor(System.Int32)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32)
  nameWithType: Hashtable.Hashtable(Int32)
  fullName: System.Collections.Hashtable.Hashtable(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,Single)
  nameWithType: Hashtable.Hashtable(IDictionary,Single)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IHashCodeProvider,IComparer)
- uid: System.Collections.IHashCodeProvider
  parent: System.Collections
  isExternal: false
  name: IHashCodeProvider
  nameWithType: IHashCodeProvider
  fullName: System.Collections.IHashCodeProvider
- uid: System.Collections.IComparer
  parent: System.Collections
  isExternal: true
  name: IComparer
  nameWithType: IComparer
  fullName: System.Collections.IComparer
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,Single)
  nameWithType: Hashtable.Hashtable(Int32,Single)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single)
- uid: System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.Hashtable(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.Hashtable(SerializationInfo,StreamingContext)
- uid: System.Runtime.Serialization.SerializationInfo
  parent: System.Runtime.Serialization
  isExternal: false
  name: SerializationInfo
  nameWithType: SerializationInfo
  fullName: System.Runtime.Serialization.SerializationInfo
- uid: System.Runtime.Serialization.StreamingContext
  parent: System.Runtime.Serialization
  isExternal: true
  name: StreamingContext
  nameWithType: StreamingContext
  fullName: System.Runtime.Serialization.StreamingContext
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.Add(System.Object,System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Add(Object,Object)
  nameWithType: Hashtable.Add(Object,Object)
  fullName: System.Collections.Hashtable.Add(Object,Object)
- uid: System.Collections.Hashtable.Clear
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clear()
  nameWithType: Hashtable.Clear()
  fullName: System.Collections.Hashtable.Clear()
- uid: System.Collections.Hashtable.Clone
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clone()
  nameWithType: Hashtable.Clone()
  fullName: System.Collections.Hashtable.Clone()
- uid: System.Collections.Hashtable.comparer
  parent: System.Collections.Hashtable
  isExternal: false
  name: comparer
  nameWithType: Hashtable.comparer
  fullName: System.Collections.Hashtable.comparer
- uid: System.Collections.Hashtable.Contains(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Contains(Object)
  nameWithType: Hashtable.Contains(Object)
  fullName: System.Collections.Hashtable.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Hashtable.ContainsKey(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsKey(Object)
  nameWithType: Hashtable.ContainsKey(Object)
  fullName: System.Collections.Hashtable.ContainsKey(Object)
- uid: System.Collections.Hashtable.ContainsValue(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsValue(Object)
  nameWithType: Hashtable.ContainsValue(Object)
  fullName: System.Collections.Hashtable.ContainsValue(Object)
- uid: System.Collections.Hashtable.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Hashtable
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Hashtable.CopyTo(Array,Int32)
  fullName: System.Collections.Hashtable.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Hashtable.Count
  parent: System.Collections.Hashtable
  isExternal: false
  name: Count
  nameWithType: Hashtable.Count
  fullName: System.Collections.Hashtable.Count
- uid: System.Collections.Hashtable.EqualityComparer
  parent: System.Collections.Hashtable
  isExternal: false
  name: EqualityComparer
  nameWithType: Hashtable.EqualityComparer
  fullName: System.Collections.Hashtable.EqualityComparer
- uid: System.Collections.Hashtable.GetEnumerator
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetEnumerator()
  nameWithType: Hashtable.GetEnumerator()
  fullName: System.Collections.Hashtable.GetEnumerator()
- uid: System.Collections.IDictionaryEnumerator
  parent: System.Collections
  isExternal: true
  name: IDictionaryEnumerator
  nameWithType: IDictionaryEnumerator
  fullName: System.Collections.IDictionaryEnumerator
- uid: System.Collections.Hashtable.GetHash(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetHash(Object)
  nameWithType: Hashtable.GetHash(Object)
  fullName: System.Collections.Hashtable.GetHash(Object)
- uid: System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.GetObjectData(SerializationInfo,StreamingContext)
- uid: System.Collections.Hashtable.hcp
  parent: System.Collections.Hashtable
  isExternal: false
  name: hcp
  nameWithType: Hashtable.hcp
  fullName: System.Collections.Hashtable.hcp
- uid: System.Collections.Hashtable.IsFixedSize
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsFixedSize
  nameWithType: Hashtable.IsFixedSize
  fullName: System.Collections.Hashtable.IsFixedSize
- uid: System.Collections.Hashtable.IsReadOnly
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsReadOnly
  nameWithType: Hashtable.IsReadOnly
  fullName: System.Collections.Hashtable.IsReadOnly
- uid: System.Collections.Hashtable.IsSynchronized
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsSynchronized
  nameWithType: Hashtable.IsSynchronized
  fullName: System.Collections.Hashtable.IsSynchronized
- uid: System.Collections.Hashtable.Item(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Item(Object)
  nameWithType: Hashtable.Item(Object)
  fullName: System.Collections.Hashtable.Item(Object)
- uid: System.Collections.Hashtable.KeyEquals(System.Object,System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: KeyEquals(Object,Object)
  nameWithType: Hashtable.KeyEquals(Object,Object)
  fullName: System.Collections.Hashtable.KeyEquals(Object,Object)
- uid: System.Collections.Hashtable.Keys
  parent: System.Collections.Hashtable
  isExternal: false
  name: Keys
  nameWithType: Hashtable.Keys
  fullName: System.Collections.Hashtable.Keys
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Hashtable.OnDeserialization(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: OnDeserialization(Object)
  nameWithType: Hashtable.OnDeserialization(Object)
  fullName: System.Collections.Hashtable.OnDeserialization(Object)
- uid: System.Collections.Hashtable.Remove(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Remove(Object)
  nameWithType: Hashtable.Remove(Object)
  fullName: System.Collections.Hashtable.Remove(Object)
- uid: System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Synchronized(Hashtable)
  nameWithType: Hashtable.Synchronized(Hashtable)
  fullName: System.Collections.Hashtable.Synchronized(Hashtable)
- uid: System.Collections.Hashtable
  parent: System.Collections
  isExternal: false
  name: Hashtable
  nameWithType: Hashtable
  fullName: System.Collections.Hashtable
- uid: System.Collections.Hashtable.SyncRoot
  parent: System.Collections.Hashtable
  isExternal: false
  name: SyncRoot
  nameWithType: Hashtable.SyncRoot
  fullName: System.Collections.Hashtable.SyncRoot
- uid: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator
  parent: System.Collections.Hashtable
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: Hashtable.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.Collections.Hashtable.System.Collections.IEnumerable.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Hashtable.Values
  parent: System.Collections.Hashtable
  isExternal: false
  name: Values
  nameWithType: Hashtable.Values
  fullName: System.Collections.Hashtable.Values
- uid: System.Collections.Hashtable.#ctor*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable
  nameWithType: Hashtable.Hashtable
- uid: System.Collections.Hashtable.Add*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Add
  nameWithType: Hashtable.Add
- uid: System.Collections.Hashtable.Clear*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clear
  nameWithType: Hashtable.Clear
- uid: System.Collections.Hashtable.Clone*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clone
  nameWithType: Hashtable.Clone
- uid: System.Collections.Hashtable.comparer*
  parent: System.Collections.Hashtable
  isExternal: false
  name: comparer
  nameWithType: Hashtable.comparer
- uid: System.Collections.Hashtable.Contains*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Contains
  nameWithType: Hashtable.Contains
- uid: System.Collections.Hashtable.ContainsKey*
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsKey
  nameWithType: Hashtable.ContainsKey
- uid: System.Collections.Hashtable.ContainsValue*
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsValue
  nameWithType: Hashtable.ContainsValue
- uid: System.Collections.Hashtable.CopyTo*
  parent: System.Collections.Hashtable
  isExternal: false
  name: CopyTo
  nameWithType: Hashtable.CopyTo
- uid: System.Collections.Hashtable.Count*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Count
  nameWithType: Hashtable.Count
- uid: System.Collections.Hashtable.EqualityComparer*
  parent: System.Collections.Hashtable
  isExternal: false
  name: EqualityComparer
  nameWithType: Hashtable.EqualityComparer
- uid: System.Collections.Hashtable.GetEnumerator*
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetEnumerator
  nameWithType: Hashtable.GetEnumerator
- uid: System.Collections.Hashtable.GetHash*
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetHash
  nameWithType: Hashtable.GetHash
- uid: System.Collections.Hashtable.GetObjectData*
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetObjectData
  nameWithType: Hashtable.GetObjectData
- uid: System.Collections.Hashtable.hcp*
  parent: System.Collections.Hashtable
  isExternal: false
  name: hcp
  nameWithType: Hashtable.hcp
- uid: System.Collections.Hashtable.IsFixedSize*
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsFixedSize
  nameWithType: Hashtable.IsFixedSize
- uid: System.Collections.Hashtable.IsReadOnly*
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsReadOnly
  nameWithType: Hashtable.IsReadOnly
- uid: System.Collections.Hashtable.IsSynchronized*
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsSynchronized
  nameWithType: Hashtable.IsSynchronized
- uid: System.Collections.Hashtable.Item*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Item
  nameWithType: Hashtable.Item
- uid: System.Collections.Hashtable.KeyEquals*
  parent: System.Collections.Hashtable
  isExternal: false
  name: KeyEquals
  nameWithType: Hashtable.KeyEquals
- uid: System.Collections.Hashtable.Keys*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Keys
  nameWithType: Hashtable.Keys
- uid: System.Collections.Hashtable.OnDeserialization*
  parent: System.Collections.Hashtable
  isExternal: false
  name: OnDeserialization
  nameWithType: Hashtable.OnDeserialization
- uid: System.Collections.Hashtable.Remove*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Remove
  nameWithType: Hashtable.Remove
- uid: System.Collections.Hashtable.Synchronized*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Synchronized
  nameWithType: Hashtable.Synchronized
- uid: System.Collections.Hashtable.SyncRoot*
  parent: System.Collections.Hashtable
  isExternal: false
  name: SyncRoot
  nameWithType: Hashtable.SyncRoot
- uid: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator*
  parent: System.Collections.Hashtable
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator
  nameWithType: Hashtable.System.Collections.IEnumerable.GetEnumerator
- uid: System.Collections.Hashtable.Values*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Values
  nameWithType: Hashtable.Values
