### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.EventLog
  id: EventLog
  children:
  - System.Diagnostics.EventLog.#ctor
  - System.Diagnostics.EventLog.#ctor(System.String)
  - System.Diagnostics.EventLog.#ctor(System.String,System.String)
  - System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  - System.Diagnostics.EventLog.BeginInit
  - System.Diagnostics.EventLog.Clear
  - System.Diagnostics.EventLog.Close
  - System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  - System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  - System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  - System.Diagnostics.EventLog.Delete(System.String)
  - System.Diagnostics.EventLog.Delete(System.String,System.String)
  - System.Diagnostics.EventLog.DeleteEventSource(System.String)
  - System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  - System.Diagnostics.EventLog.Dispose(System.Boolean)
  - System.Diagnostics.EventLog.EnableRaisingEvents
  - System.Diagnostics.EventLog.EndInit
  - System.Diagnostics.EventLog.Entries
  - System.Diagnostics.EventLog.EntryWritten
  - System.Diagnostics.EventLog.Exists(System.String)
  - System.Diagnostics.EventLog.Exists(System.String,System.String)
  - System.Diagnostics.EventLog.GetEventLogs
  - System.Diagnostics.EventLog.GetEventLogs(System.String)
  - System.Diagnostics.EventLog.Log
  - System.Diagnostics.EventLog.LogDisplayName
  - System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  - System.Diagnostics.EventLog.MachineName
  - System.Diagnostics.EventLog.MaximumKilobytes
  - System.Diagnostics.EventLog.MinimumRetentionDays
  - System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  - System.Diagnostics.EventLog.OverflowAction
  - System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  - System.Diagnostics.EventLog.Source
  - System.Diagnostics.EventLog.SourceExists(System.String)
  - System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  - System.Diagnostics.EventLog.SynchronizingObject
  - System.Diagnostics.EventLog.WriteEntry(System.String)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  - System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  langs:
  - csharp
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog
  type: Class
  summary: "Windows 이벤트 로그와의 상호 작용을 제공합니다."
  remarks: "이벤트 로그에 액세스 하거나 중요 한 소프트웨어 또는 하드웨어 이벤트에 대 한 정보를 기록 하는 Windows 이벤트 로그를 사용자 지정할 수 있습니다. 이벤트 로그를 사용 하 여 기존 로그에서 읽은, 로그에 항목을 기록, 만들기 또는 이벤트 소스를 삭제, 로그를 삭제 고 응답할 수 있습니다 항목을 기록 하려면. 이벤트 소스를 만들 때 새 로그를 만들 수도 있습니다.      > [!IMPORTANT] >이 형식이 구현 하는 <xref:System.IDisposable>인터페이스.</xref:System.IDisposable> 형식을 사용 하 여 마쳤으면는 삭제 해야의 직접 또는 간접적으로 합니다. 직접 형식의 삭제 하려면 해당 <xref:System.IDisposable.Dispose%2A>에서 메서드는 `try` / `catch` 블록.</xref:System.IDisposable.Dispose%2A> 작업을 삭제할 하지 직접,를 사용 하 여 언어 구문와 같은 `using` (C#에서) 또는 `Using` (Visual Basic)에서는 합니다. 자세한 내용은의 &quot;를 사용 하는 개체는 구현 IDisposable&quot; 섹션을 참조 하십시오.는 <xref:System.IDisposable>인터페이스 항목.</xref:System.IDisposable>       개별 이벤트 로그 및 해당 항목에 대 한 액세스를 제공할 뿐만 아니라 EventLog 클래스의 모든 이벤트 로그 컬렉션에 액세스할 수 있습니다. 사용할 수는 `static` 로그를 삭제 하는 이벤트 로그의 멤버 로그 목록을 가져오고, 만들기 또는 소스, 삭제 또는 컴퓨터는 특정 원본이 이미 들어 있는지 확인 합니다.       세 가지 기본 이벤트 로그가: 응용 프로그램, 시스템 및 보안 합니다. 보안 로그에는 읽기 전용입니다. 다른 응용 프로그램과 서비스를 설치 하면 Active Directory와 같은 추가 이벤트 로그에 있을 수 있습니다.       EventLog 클래스를 사용 하는 경우 보안 고려 사항이 있습니다. EventLog 필요 <xref:System.Diagnostics.EventLogPermission>.NET Framework 2.0 및 이상 버전에서 특정 작업 또는.NET Framework 1.0 및 1.1에서 완전 신뢰에 대 한 권한을.</xref:System.Diagnostics.EventLogPermission> 좋습니다 <xref:System.Diagnostics.EventLogPermission>부분적으로 신뢰할 수 있는 코드에 부여할 수 없습니다.</xref:System.Diagnostics.EventLogPermission>  직접 전달 하면 안 이벤트 로그 개체를 포함 하 여 <xref:System.Diagnostics.EventLogEntryCollection>및 <xref:System.Diagnostics.EventLogEntry>개체 덜 신뢰할 수 있는 코드를.</xref:System.Diagnostics.EventLogEntry> </xref:System.Diagnostics.EventLogEntryCollection> 예를 들어 EventLog 개체를 만들고, 엔트리를 쓴 다음 이벤트 로그를 전달 이벤트 로그를 읽고 쓸 수는 다른 응용 프로그램의 이름 이벤트 로그 메시지를 보내는 등의 작업을 수행 하는 코드를 허용 하기 때문에 개체 부분적으로 신뢰할 수 있는 코드를 보안 문제를 만들 수 있습니다.       Windows Vista 이상에서는 사용자 계정 컨트롤 (UAC)는 사용자의 자격 증명을 결정 합니다. 두 개의 런타임 액세스 토큰에 할당 된 기본 제공 Administrators 그룹의 구성원 인 경우: 표준 사용자 액세스 토큰 및 관리자 액세스 토큰입니다. 기본적으로 표준 사용자 역할에 속합니다. 보안 로그에 액세스 하는 코드를 실행 하려면 먼저 자격 증명에서 높여야 표준 사용자 관리자에 게 있습니다. 응용 프로그램에 대 한 바로 가기 메뉴를 열고 응용 프로그램을 시작 하는 경우 이렇게 할 수 있습니다 (마우스를 사용 하는 단추로 클릭 하 고 응용 프로그램 아이콘)를 관리자 권한으로 실행 하 고 있습니다.       서버의 이벤트 뷰어를 통해 볼 수 있는 사용자 지정 이벤트 로그를 만들 이벤트 로그를 사용할 수 있습니다. 사용 하 여는 <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>메서드를 이벤트 뷰어의 이벤트 로그에 대 한 지역화 된 이름을 표시 합니다.</xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> 사용 하 여는 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>최대 로그 크기에 도달 하면 이벤트 로그의 동작을 구성할 수 있는 방법은.</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>       이벤트 로그를 읽으려면 로그 이름을 지정 합니다 (<xref:System.Diagnostics.EventLog.Log%2A> 속성) 및 서버 컴퓨터 이름 (<xref:System.Diagnostics.EventLog.MachineName%2A> 이벤트 로그에 대 한 속성</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> 로컬 컴퓨터의 서버 컴퓨터 이름을 지정 하지 않으면 &quot;.&quot;를 가정 합니다. 이벤트 소스를 지정할 필요는 없습니다 (<xref:System.Diagnostics.EventLog.Source%2A> 속성)는 원본 로그에 쓰기에 대해서만 필요 하기 때문에,.</xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.Entries%2A>속성은 항목의 이벤트 로그의 목록을 자동으로 채워집니다.</xref:System.Diagnostics.EventLog.Entries%2A>       이벤트 로그를 작성 하려면를 지정 하거나 이벤트 소스를 만듭니다 (<xref:System.Diagnostics.EventLog.Source%2A> 속성).</xref:System.Diagnostics.EventLog.Source%2A> 새 이벤트 원본을 만들 수 있도록 컴퓨터에 관리 자격 증명이 있어야 합니다. 이벤트 소스 항목의 유효한 소스로 이벤트 로그와 응용 프로그램을 등록합니다. 한 번에 하나의 로그에 기록할 이벤트 소스를 사용할 수 있습니다. <xref:System.Diagnostics.EventLog.Source%2A>속성 모든 임의의 문자열일 수 있지만 이름을 컴퓨터의 다른 원본을 구별 되어야 합니다.</xref:System.Diagnostics.EventLog.Source%2A> 이벤트 소스는 일반적으로 응용 프로그램 또는 다른 식별 문자열 이름입니다. 중복을 만들려고 <xref:System.Diagnostics.EventLog.Source%2A>값 예외를 throw 합니다.</xref:System.Diagnostics.EventLog.Source%2A> 그러나 하나의 이벤트 로그는 여러 원본과 연결할 수 있습니다.       EventLog 인스턴스와 연결 된 이벤트 로그에 대 한 이벤트 소스가 존재 하지 않는 새 이벤트 소스 생성 됩니다. 이벤트 소스 Windows Vista 이상 또는 Windows Server 2003을 만들려면 관리 자격 증명이 있어야 합니다.       이 요구 사항은 되므로 이벤트 소스 고유한 지 확인 하려면 보안 로그를 포함 하 여 모든 이벤트 로그를 검색 해야 합니다. Windows Vista 이상에서는 사용자가 권한이 없습니다; 보안 로그에 액세스할 수 따라서 한 <xref:System.Security.SecurityException>throw 됩니다.</xref:System.Security.SecurityException>      > [!IMPORTANT] > 만들기 또는 이벤트 소스를 삭제 합니다. 명명된 된 뮤텍스를 사용 하 여 기본 코드의 동기화가 필요 합니다. 높은 권한이 필요한 응용 프로그램에서 명명 된 뮤텍스를 잠그는 하는 경우에 잠금이 해제 될 때까지 응답을 중지 하도록 응용을 프로그램이 만들거나 이벤트 소스를 삭제 하려고 합니다. 이 문제를 방지 하려면 부여 안 <xref:System.Security.Permissions.SecurityPermissionFlag>신뢰할 수 없는 코드 권한을.</xref:System.Security.Permissions.SecurityPermissionFlag> 또한 <xref:System.Security.Permissions.SecurityPermissionFlag>권한 잠재적으로 기타 사용 권한을 무시할 수 및 신뢰할 수 있는 코드에만 부여 해야 합니다.</xref:System.Security.Permissions.SecurityPermissionFlag>       응용 프로그램 및 서비스 응용 프로그램 로그 나 사용자 지정 로그를 작성 해야 합니다. 장치 드라이버 시스템 로그에 써야 합니다. <xref:System.Diagnostics.EventLog.Log%2A>응용 프로그램 로그에 이벤트 로그 기본값 속성을</xref:System.Diagnostics.EventLog.Log%2A> 명시적으로 설정 하지      > [!NOTE] > 등록 된 소스로 쓰기에서 응용 프로그램을 보호 항목이 없습니다.  응용 프로그램에 부여 하는 경우 <xref:System.Diagnostics.EventLogPermissionAccess>권한, 컴퓨터에 등록 된 유효한 소스에 대 한 이벤트 작성할 수 있습니다.</xref:System.Diagnostics.EventLogPermissionAccess>       사용 <xref:System.Diagnostics.EventLog.WriteEvent%2A>및 <xref:System.Diagnostics.EventLog.WriteEntry%2A>이벤트 로그에 이벤트를 쓰는 메서드</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.WriteEvent%2A> 이벤트를 작성 하는 이벤트 소스를 지정 해야 합니다. 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다.       응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에는 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>개체 또는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>메서드.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 새 이벤트 원본을 만들 수 있도록 컴퓨터에 관리 자격 증명이 있어야 합니다.       각 소스; 한 번에 하나의 이벤트 로그에 쓸 수 있습니다. 그러나 응용 프로그램 여러 이벤트 로그에 쓸 수 여러 소스를 사용할 수 있습니다. 예를 들어 응용 프로그램에 다른 이벤트 로그 또는 서로 다른 리소스 파일에 대해 구성 된 여러 소스가 필요할 수 있습니다. 기존 소스 구성 세부 정보를 변경 하려면 소스를 삭제 하 고 새 구성으로 만듭니다. 다른 응용 프로그램이 나 구성 요소는 기존 소스를 사용 하는 경우 기존 소스를 삭제 하는 대신 업데이트 된 구성을 사용 하 여 새 원본을 만듭니다.       이벤트 범주, 메시지 문자열에 대 한 지역화 된 리소스가 포함 된 이벤트 소스를 등록할 수 있습니다. 응용 프로그램 실제 문자열 값을 지정 하는 대신 리소스 식별자를 사용 하 여 이벤트 로그 항목을 쓸 수 있습니다. 참조는 <xref:System.Diagnostics.EventLogInstaller>및 <xref:System.Diagnostics.EventSourceCreationData>클래스 리소스 파일을 사용 하 여 소스를 구성 하는 방법에 대 한 자세한 내용은.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       응용 프로그램 이벤트 로그에 직접 문자열 값을 쓰는, 리소스 원본에 대 한 파일 속성을 설정할 필요가 없습니다. 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 해당 소스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>이벤트 로그에 대 한 리소스 식별자를 사용 하 여 항목을 작성 하는 메서드</xref:System.Diagnostics.EventLog.WriteEvent%2A> 를 사용 하 여 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       이벤트를 쓸 때 메시지 문자열에 대 한 리소스 식별자 또는 메시지 문자열 중 하나 이상 지정 해야 합니다. 다른 이벤트 속성은 선택 사항입니다. 선택적 이벤트 설정의 예는 다음과 같습니다:-설정할 수 있습니다는 <xref:System.Diagnostics.EventLogEntryType>이벤트 뷰어에서 항목에 대해 표시 되는 아이콘을 지정할 수 있습니다.</xref:System.Diagnostics.EventLogEntryType>      -응용 프로그램 범주를 사용 하 여 이벤트를 필터링 하는 경우 이벤트에 대 한 범주 식별자를 지정할 수 있습니다.      -지정된 된 이벤트와 추가 정보를 연결 하려는 경우 이진 데이터 이벤트 항목에 첨부할 수 있습니다.      > [!IMPORTANT] > 이벤트 로그에 쓰는 경우 디스크 공간, 프로세서 시간 및 기타 시스템 리소스입니다. 중요 한 정보만 기록 하는 것이 유용 합니다. 이벤트 로그 호출 오류 경로에 배치 되지 않고을 주 코드 경로에 있으므로 하지 성능이 저하 될 것이 좋습니다.       이벤트 로그의 인스턴스에 대 한 초기 속성 값의 목록에 대 한 참조는 <xref:System.Diagnostics.EventLog.%23ctor%2A>생성자.</xref:System.Diagnostics.EventLog.%23ctor%2A>"
  example:
  - "The following example creates the event source `MySource` if it doesn't already exist, and writes an entry to the event log `MyNewLog`.  \n  \n> [!NOTE]\n>  Starting with Windows Vista, you must run this application as an administrator.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/t-system.diagnostics.eve_0_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/t-system.diagnostics.eve_0_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/t-system.diagnostics.eve_0_1.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("EntryWritten")]

      [System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("EventLogDesc")]

      public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements:
  - System.ComponentModel.ISupportInitialize
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor
  id: '#ctor'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog()
  nameWithType: EventLog.EventLog()
  fullName: System.Diagnostics.EventLog.EventLog()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> 클래스입니다. 인스턴스를 로그와 연결 하지 않습니다."
  remarks: "호출 하기 전에 <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 지정 된 <xref:System.Diagnostics.EventLog.Source%2A>속성은 <xref:System.Diagnostics.EventLog>인스턴스.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> 만 읽는 경우 <xref:System.Diagnostics.EventLog.Entries%2A>로그에서 지정할 수 있습니다만 <xref:System.Diagnostics.EventLog.Log%2A>및 <xref:System.Diagnostics.EventLog.MachineName%2A>속성.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] > 지정 하지 않는 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A>, 로컬 컴퓨터 (&quot;.&quot;)으로 간주 됩니다.</xref:System.Diagnostics.EventLog.MachineName%2A>       다음 표에서 <xref:System.Diagnostics.EventLog>안내 하십시오.</xref:System.Diagnostics.EventLog> 인스턴스에 대 한 초기 속성 값을 보여 줍니다.      | 속성 | 초기 값 |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| 빈 문자열 (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.Log%2A>| 빈 문자열 (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.MachineName%2A>| 로컬 컴퓨터 (&quot;.&quot;). |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_9_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_9_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_9_1.vb)]"
  syntax:
    content: public EventLog ();
    parameters: []
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String)
  nameWithType: EventLog.EventLog(String)
  fullName: System.Diagnostics.EventLog.EventLog(String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> 클래스입니다. 로컬 컴퓨터에서 로그 인스턴스를 연결 합니다."
  remarks: "설정 하는이 오버 로드는 <xref:System.Diagnostics.EventLog.Log%2A>속성을는 `logName` 매개 변수.</xref:System.Diagnostics.EventLog.Log%2A> 호출 하기 전에 <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 지정 된 <xref:System.Diagnostics.EventLog.Source%2A>속성은 <xref:System.Diagnostics.EventLog>인스턴스.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> 만 읽는 경우 <xref:System.Diagnostics.EventLog.Entries%2A>로그에서 지정할 수 있습니다만 <xref:System.Diagnostics.EventLog.Log%2A>및 <xref:System.Diagnostics.EventLog.MachineName%2A>속성.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] > 지정 하지 않는 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A>, 로컬 컴퓨터 (&quot;.&quot;)으로 간주 됩니다.</xref:System.Diagnostics.EventLog.MachineName%2A> 이 오버 로드 생성자의 지정 된 <xref:System.Diagnostics.EventLog.Log%2A>속성 되지만 변경할 수 있습니다이 읽기 전에 <xref:System.Diagnostics.EventLog.Entries%2A>속성.</xref:System.Diagnostics.EventLog.Entries%2A> </xref:System.Diagnostics.EventLog.Log%2A>       에 지정 된 소스는 <xref:System.Diagnostics.EventLog.Source%2A>한 후속 호출에는 컴퓨터에 있는 다른 원본의 속성은 고유 <xref:System.Diagnostics.EventLog.WriteEntry%2A>아직 없는 경우 지정 된 이름의 한 로그를 만듭니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>       다음 표에서 <xref:System.Diagnostics.EventLog>안내 하십시오.</xref:System.Diagnostics.EventLog> 인스턴스에 대 한 초기 속성 값을 보여 줍니다.      | 속성 | 초기 값 |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| 빈 문자열 (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.Log%2A>| `logName` 매개 변수입니다. |   | <xref:System.Diagnostics.EventLog.MachineName%2A>| 로컬 컴퓨터 (&quot;.&quot;). |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example reads entries in the event log, \"myNewLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_13_1.cpp)]\n [!code-cs[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_13_1.cs)]\n [!code-vb[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_13_1.vb)]"
  syntax:
    content: public EventLog (string logName);
    parameters:
    - id: logName
      type: System.String
      description: "로컬 컴퓨터에 있는 로그의 이름입니다."
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "로그 이름은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "로그 이름이 올바르지 않습니다."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String,String)
  nameWithType: EventLog.EventLog(String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> 클래스입니다. 지정된 된 컴퓨터에서 로그 인스턴스를 연결 합니다."
  remarks: "설정 하는이 오버 로드는 <xref:System.Diagnostics.EventLog.Log%2A>속성을는 `logName` 매개 변수 및 <xref:System.Diagnostics.EventLog.MachineName%2A>속성을는 `machineName` 매개 변수.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog> 속성</xref:System.Diagnostics.EventLog.Source%2A> 지정을</xref:System.Diagnostics.EventLog.WriteEntry%2A> 호출 하기 전에 만 읽는 경우 <xref:System.Diagnostics.EventLog.Entries%2A>로그에서 지정할 수 있습니다만 <xref:System.Diagnostics.EventLog.Log%2A>및 <xref:System.Diagnostics.EventLog.MachineName%2A>속성.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] >이 오버 로드 생성자의 지정 된 <xref:System.Diagnostics.EventLog.Log%2A>및 <xref:System.Diagnostics.EventLog.MachineName%2A>있지만 속성을 읽기 전에 해당 변경할 수는 <xref:System.Diagnostics.EventLog.Entries%2A>속성.</xref:System.Diagnostics.EventLog.Entries%2A> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A>       다음 표에서 <xref:System.Diagnostics.EventLog>안내 하십시오.</xref:System.Diagnostics.EventLog> 인스턴스에 대 한 초기 속성 값을 보여 줍니다.      | 속성 | 초기 값 |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| 빈 문자열 (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.Log%2A>| `logName` 매개 변수입니다. |   | <xref:System.Diagnostics.EventLog.MachineName%2A>| `machineName` 매개 변수입니다. |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example reads entries in the event log, \"myNewLog\", on the computer \"myServer\".  \n  \n [!code-cs[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_0_1.cs)]\n [!code-cpp[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_0_1.cpp)]\n [!code-vb[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_0_1.vb)]"
  syntax:
    content: public EventLog (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: "지정된 된 컴퓨터에서 로그의 이름입니다."
    - id: machineName
      type: System.String
      description: "로그가 있는 컴퓨터입니다."
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "로그 이름은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "로그 이름이 올바르지 않습니다.       -또는-컴퓨터 이름이 올바르지 않습니다."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  id: '#ctor(System.String,System.String,System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String,String,String)
  nameWithType: EventLog.EventLog(String,String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> 클래스입니다. 지정된 된 컴퓨터에 있는 로그 인스턴스 연결 만들거나 할당에 지정된 된 소스는 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>합니다."
  remarks: "이 생성자는 설정의 <xref:System.Diagnostics.EventLog.Log%2A>속성을는 `logName` 매개 변수는 <xref:System.Diagnostics.EventLog.MachineName%2A>속성을는 `machineName` 매개 변수를 및 <xref:System.Diagnostics.EventLog.Source%2A>속성을는 `source` 매개 변수.</xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog.Source%2A>속성은 이벤트 로그에 쓸 때 필요</xref:System.Diagnostics.EventLog.Source%2A> 그러나만 이벤트 로그에서 읽기만 하는 경우는 <xref:System.Diagnostics.EventLog.Log%2A>및 <xref:System.Diagnostics.EventLog.MachineName%2A>(으로 서버에서 이벤트 로그에 이미 연결 된 원본이) 속성은 필수입니다.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> 이벤트 로그에서 읽기만 하는, 다른 오버 로드 생성자의 충분히 사용할 수 있습니다.       다음 표에서 <xref:System.Diagnostics.EventLog>안내 하십시오.</xref:System.Diagnostics.EventLog> 인스턴스에 대 한 초기 속성 값을 보여 줍니다.      | 속성 | 초기 값 |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| `source` 매개 변수입니다. |   | <xref:System.Diagnostics.EventLog.Log%2A>| `logName` 매개 변수입니다. |   | <xref:System.Diagnostics.EventLog.MachineName%2A>| `machineName` 매개 변수입니다. |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example writes an entry to an event log, \"MyNewLog\", on the local computer, using the source \"MySource\".  \n  \n [!code-cs[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/csharp/fd99d44e-2d79-45f8-97e3-_1.cs)]\n [!code-cpp[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/cpp/fd99d44e-2d79-45f8-97e3-_1.cpp)]\n [!code-vb[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/visualbasic/fd99d44e-2d79-45f8-97e3-_1.vb)]"
  syntax:
    content: public EventLog (string logName, string machineName, string source);
    parameters:
    - id: logName
      type: System.String
      description: "지정된 된 컴퓨터에서 로그의 이름"
    - id: machineName
      type: System.String
      description: "로그가 있는 컴퓨터입니다."
    - id: source
      type: System.String
      description: "이벤트 로그 항목의 소스입니다."
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "로그 이름은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "로그 이름이 올바르지 않습니다.       -또는-컴퓨터 이름이 올바르지 않습니다."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.BeginInit
  id: BeginInit
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: BeginInit()
  nameWithType: EventLog.BeginInit()
  fullName: System.Diagnostics.EventLog.BeginInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "초기화를 시작 프로그램 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> 폼에 사용 되거나 다른 구성 요소에서 사용 합니다. 초기화는 런타임에 발생합니다."
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] 디자인 환경에서이 메서드를 사용 하 여 폼에 또는 다른 구성 요소를 사용 하는 구성 초기화를 시작 합니다. <xref:System.Diagnostics.EventLog.EndInit%2A>메서드 초기화를 끝냅니다.</xref:System.Diagnostics.EventLog.EndInit%2A> BeginInit를 사용 하 여 및 <xref:System.Diagnostics.EventLog.EndInit%2A>메서드 컨트롤을 완전히 초기화 되기 전에 사용 되지 않도록 합니다.</xref:System.Diagnostics.EventLog.EndInit%2A>"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Diagnostics.EventLog.BeginInit*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>이미 초기화 되었습니다."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Clear
  id: Clear
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Clear()
  nameWithType: EventLog.Clear()
  fullName: System.Diagnostics.EventLog.Clear()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "이벤트 로그에서 모든 항목을 제거합니다."
  remarks: "이벤트 로그 항목의 개수를 포함할 수를 결정 하는 최대 크기가 설정 됩니다. 이벤트 로그가 꽉 차면 새 이벤트 정보 기록을 중지 하거나 시작 이전 엔트리를 덮어쓰게 합니다. 이벤트 기록을 중지 한 경우 기존 항목에 대 한 로그를 지우고 이벤트 기록을 다시 시작할 수 있도록 허용 하려면이 메서드를 사용할 수 있습니다. 이벤트 로그 항목의 선택을 취소 하는 로그 상주 하는 컴퓨터에 대 한 관리자 권한이 있어야 합니다.       선택을 취소 이벤트 로그, 이벤트 핸들을 새 검색 읽기 및 쓰기 핸들을 해제 닫았다가 이벤트 로그입니다. 기존 이벤트와 함께 메서드를 호출한 후 받은 이벤트 지워지지 않습니다."
  example:
  - "The following example clears an event log.  \n  \n> [!CAUTION]\n>  Because Application, System, Security, and other non-custom logs can contain crucial information; be sure to specify a custom log before executing this example code. This example deletes the custom log `myNewLog`.  \n  \n [!code-cs[Classic EventLog.Clear Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_11_1.cs)]\n [!code-vb[Classic EventLog.Clear Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_11_1.vb)]\n [!code-cpp[Classic EventLog.Clear Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_11_1.cpp)]"
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.Diagnostics.EventLog.Clear*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "이벤트 로그에 지워지지 않은 합니다.       -또는-로그를 열 수 없습니다. Windows 오류 코드를 사용할 수 없는 경우"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "에 대 한 값을 지정 하지 않으면는 <xref:System.Diagnostics.EventLog.Log*>속성.</xref:System.Diagnostics.EventLog.Log*> 로그 이름은 빈 문자열이 아닌지 확인 합니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "로그 존재 하지 않습니다."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Close
  id: Close
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Close()
  nameWithType: EventLog.Close()
  fullName: System.Diagnostics.EventLog.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "이벤트 로그 및 릴리스 읽기 및 쓰기 핸들을 닫습니다."
  remarks: "Close 메서드가 호출 되는 보호 된 여 <xref:System.ComponentModel.Component.Dispose%2A>메서드.</xref:System.ComponentModel.Component.Dispose%2A> <xref:System.ComponentModel.Component.Dispose%2A>.</xref:System.ComponentModel.Component.Dispose%2A> 를 호출 하기 전에 Close를 호출할 필요가 없습니다."
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.EventLog.Close*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "이벤트 로그의 읽기 또는 쓰기 핸들을 해제 하지 못한 합니다."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  id: CreateEventSource(System.Diagnostics.EventSourceCreationData)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(EventSourceCreationData)
  nameWithType: EventLog.CreateEventSource(EventSourceCreationData)
  fullName: System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "지역화 된 이벤트를 작성 하기 위한 올바른 이벤트 소스를 설정 합니다. 지정된 된 구성 속성을 사용 하 여 이벤트 소스와 해당 이벤트 로그에 대 한 메시지입니다."
  remarks: "Use this overload to configure a new source for writing entries to an event log on the local computer or a remote computer. It is not necessary to use this method to read from an event log.  \n  \n The CreateEventSource method uses the input `sourceData`<xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> and <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> properties to create registry values on the target computer for the new source and its associated event log. A new source name cannot match an existing source name or an existing event log name on the target computer. If the <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> property is not set, the source is registered for the Application event log. If the <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> is not set, the source is registered on the local computer.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. Starting with Windows Vista, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  Starting with Windows Vista, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n Each source can only write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n You can register the event source with localized resource file(s) for your event category and message strings. Your application can write event log entries using resource identifiers, rather than specifying the actual string. The Event Viewer uses the resource identifier to find and display the corresponding string from the localized resource file based on current language settings. You can register a separate file for event categories, messages and parameter insertion strings, or you can register the same resource file for all three types of strings. Use the <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, and <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> properties to configure the source to write localized entries to the event log. If your application writes strings values directly to the event log, you do not need to set these properties.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source is configured for an event log, and you reconfigure it for another event log, you must restart the computer for the changes to take effect."
  example:
  - "The following example determines whether the event source named `SampleApplicationSource` is registered on the local computer. If the event source does not exist, the example sets the message resource file for the source and creates the new event source. Finally, the example sets the localized display name for the event log, using the resource identifier value in `DisplayNameMsgId` and the resource file path in `messageFile`.  \n  \n [!code-cpp[EventLog_WriteEvent#6](~/add/codesnippet/cpp/4fd418fb-73e7-42a9-9ba2-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#6](~/add/codesnippet/visualbasic/4fd418fb-73e7-42a9-9ba2-_1.vb)]\n [!code-cs[EventLog_WriteEvent#6](~/add/codesnippet/csharp/4fd418fb-73e7-42a9-9ba2-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings. Specifically, resource identifier 5001 is defined for the localized name of the event log.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);
    parameters:
    - id: sourceData
      type: System.Diagnostics.EventSourceCreationData
      description: "이벤트 소스와 대상 이벤트 로그에 대 한 구성 속성입니다."
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The computer name specified in <code>sourceData</code> is not valid.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The log name specified in <code>sourceData</code> is not valid. Event log names must consist of printable characters and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n The log name specified in <code>sourceData</code> is not valid for user log creation. The Event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of the log name specified in <code>sourceData</code> are not unique.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> is already registered.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> matches an existing event log name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이벤트 로그에 대 한 레지스트리 키를 열 수 없습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>sourceData</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  id: CreateEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(String,String)
  nameWithType: EventLog.CreateEventSource(String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "로컬 컴퓨터에는 로그에 엔트리를 쓰는 유효한 이벤트 소스로 지정된 된 소스 이름을 설정 합니다. 이 메서드는 로컬 컴퓨터에 새 사용자 지정 로그를 만들 수도 있습니다."
  remarks: "Use this overload to create a custom log or to create and register a <xref:System.Diagnostics.EventLog.Source%2A> to an existing log on the local computer.  \n  \n If `logName` is `null` or an empty string (\"\") when you call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, the log defaults to the Application log. If the log does not exist on the local computer, the system creates a custom log and registers your application as a <xref:System.Diagnostics.EventLog.Source%2A> for that log.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. Starting with Windows Vista, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  In Windows Vista and later, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n You only need to create an event source if you are writing to the event log. Before writing an entry to an event log, you must register the event source with the event log as a valid source of events. When you write a log entry, the system uses the <xref:System.Diagnostics.EventLog.Source%2A> to find the appropriate log in which to place your entry. If you are reading the event log, you can either specify the <xref:System.Diagnostics.EventLog.Source%2A>, or a <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A>.  \n  \n> [!NOTE]\n>  You are not required to specify the <xref:System.Diagnostics.EventLog.MachineName%2A> if you are connecting to a log on the local computer. If you do not specify the <xref:System.Diagnostics.EventLog.MachineName%2A> when reading from a log, the local computer (\".\") is assumed.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n The source must be unique on the local computer; a new source name cannot match an existing source name or an existing event log name. Each source can write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source has already been mapped to a log and you remap it to a new log, you must restart the computer for the changes to take effect."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_15_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_15_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_15_1.vb)]"
  syntax:
    content: public static void CreateEventSource (string source, string logName);
    parameters:
    - id: source
      type: System.String
      description: "응용 프로그램이 로컬 컴퓨터에 등록 되는 원본 이름입니다."
    - id: logName
      type: System.String
      description: "소스의 엔트리를 쓸 로그의 이름입니다. 가능한 값에 응용 프로그램, 시스템 또는 사용자 지정 이벤트 로그를 포함 합니다."
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>source</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>logName</code> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n <code>logName</code> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of <code>logName</code> match the first 8 characters of an existing event log name.  \n  \n \\- or -  \n  \n The source cannot be registered because it already exists on the local computer.  \n  \n \\- or -  \n  \n The source name matches an existing event log name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "로컬 컴퓨터에서 이벤트 로그에 대 한 레지스트리 키를 열 수 없습니다."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  id: CreateEventSource(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(String,String,String)
  nameWithType: EventLog.CreateEventSource(String,String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "지정된 된 컴퓨터에서 로그에 엔트리를 쓰는 유효한 이벤트 소스로 지정된 된 소스 이름을 설정 합니다. 또한이 메서드 지정된 된 컴퓨터에 새로운 사용자 지정 로그를 만드는 데 사용할 수 있습니다."
  remarks: "Use this overload to create a custom log or to create and register a <xref:System.Diagnostics.EventLog.Source%2A> to an existing log on the specified computer.  \n  \n If `logName` is `null` or an empty string (\"\") when you call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, the log defaults to the Application log. If the log does not exist on the specified computer, the system creates a custom log and registers your application as a <xref:System.Diagnostics.EventLog.Source%2A> for that log.  \n  \n You only need to create an event source if you are writing to the event log. Before writing an entry to an event log, you must register the event source with the event log as a valid source of events. When you write a log entry, the system uses the <xref:System.Diagnostics.EventLog.Source%2A> to find the appropriate log in which to place your entry. If you are reading the event log, you can either specify the <xref:System.Diagnostics.EventLog.Source%2A>, or a <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A>.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. In Windows Vista and later, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  In Windows Vista and later, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n The source must be unique on the local computer; a new source name cannot match an existing source name or an existing event log name. Each source can write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source has already been mapped to a log and you remap it to a new log, you must restart the computer for the changes to take effect."
  example:
  - "The following example creates the source `MySource` on the computer `MyServer`, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/cpp/86732307-05e6-4c1a-b98e-_1.cpp)]\n [!code-cs[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/csharp/86732307-05e6-4c1a-b98e-_1.cs)]\n [!code-vb[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/visualbasic/86732307-05e6-4c1a-b98e-_1.vb)]"
  syntax:
    content: public static void CreateEventSource (string source, string logName, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "지정된 된 컴퓨터에 등록 되는 응용 프로그램의 소스입니다."
    - id: logName
      type: System.String
      description: "소스의 엔트리를 쓸 로그의 이름입니다. 가능한 값에 응용 프로그램, 시스템 또는 사용자 지정 이벤트 로그를 포함 합니다. 값을 지정 하지 않으면 `logName` 응용 프로그램에 대 한 기본값입니다."
    - id: machineName
      type: System.String
      description: "이 이벤트 소스를 등록 하는 컴퓨터의 이름 또는 &quot;.&quot; 로컬 컴퓨터에 대 한 합니다."
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>machineName</code> is not a valid computer name.  \n  \n \\- or -  \n  \n <code>source</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>logName</code> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n <code>logName</code> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of <code>logName</code> match the first 8 characters of an existing event log name on the specified computer.  \n  \n \\- or -  \n  \n The source cannot be registered because it already exists on the specified computer.  \n  \n \\- or -  \n  \n The source name matches an existing event source name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "지정된 된 컴퓨터에서 이벤트 로그에 대 한 레지스트리 키를 열 수 없습니다."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Delete(System.String)
  id: Delete(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Delete(String)
  nameWithType: EventLog.Delete(String)
  fullName: System.Diagnostics.EventLog.Delete(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "로컬 컴퓨터에서 이벤트 로그를 제거합니다."
  remarks: "삭제 하려는 로그는 로컬 컴퓨터에 있으면이 메서드를 사용 합니다. 적절 한 레지스트리 사용 권한이 있는 경우에 컴퓨터에 있는 모든 로그를 삭제할 수 있습니다.       지정 된 로그를 제거 하는 delete `logName` 로컬 컴퓨터에서 합니다. 로그에 등록 된 소스에만 삭제 하려면 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 호출 로그 항목 삭제 하려는 경우 <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> 호출 삭제 및 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>는 `static` 메서드 이므로 클래스 자체에 호출할 수 있습니다.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 새 인스턴스를 만들 필요는 없습니다 <xref:System.Diagnostics.EventLog>메서드 중 하나를 호출 합니다.</xref:System.Diagnostics.EventLog>       Delete 메서드는 먼저 로그의 내용을 포함 하는 파일을 삭제 합니다. 그런 다음 레지스트리에 액세스 하 고 해당 로그에 대해 등록 된 모든 이벤트 소스를 제거 합니다. 나중에 로그를 다시 만드는 경우 등록 이벤트 소스 마찬가지로 다시 사용 하려는 경우. 이벤트 소스를 등록 하지 않으면 로그 이름을 지정 하지 않고 이벤트 소스에 다른 사용자가 작성 하는 경우 응용 프로그램 이벤트 로그에서 이벤트 소스가 만들어질 수 있습니다. 따라서 응용 프로그램 삭제 하 고 다시 로그에 엔트리를 쓸 수 있었던는 쓰지 응용 프로그램 로그에 대신 이제 이벤트 소스를 포함 하기 때문에 합니다.      > [!NOTE] > 이벤트 로그를 다시 만드는 과정은 어려울 수 있습니다. 응용 프로그램 로그와 같은 시스템에서 만든 이벤트 로그를 삭제 하지 마십시오.       삭제에 대 한 호출을 통해 로그를 자동으로 삭제 하 여 로그에 등록 된 소스 삭제 됩니다. 이 작동 하 여 로그를 사용 하 여 다른 응용 프로그램 해질 수 있습니다."
  example:
  - "The following example deletes a log from the local computer. The example determines the log from its source.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_12_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_12_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_12_1.cs)]"
  syntax:
    content: public static void Delete (string logName);
    parameters:
    - id: logName
      type: System.String
      description: '삭제할 로그의 이름입니다. 가능한 값: 응용 프로그램, 보안, 시스템, 그리고 컴퓨터에서 모든 사용자 지정 이벤트 로그입니다.'
  overload: System.Diagnostics.EventLog.Delete*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logName</code>빈 문자열 (&quot;&quot;) 또는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The registry key for the event log could not be opened on the local computer.  \n  \n \\- or -  \n  \n The log does not exist on the local computer."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "이벤트 로그에 지워지지 않은 합니다.       -또는-로그를 열 수 없습니다. Windows 오류 코드를 사용할 수 없는 경우"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Delete(System.String,System.String)
  id: Delete(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Delete(String,String)
  nameWithType: EventLog.Delete(String,String)
  fullName: System.Diagnostics.EventLog.Delete(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "지정된 된 컴퓨터에서 이벤트 로그를 제거합니다."
  remarks: "삭제 하려는 로그는 원격 컴퓨터에 있으면이 메서드를 사용 합니다. 적절 한 레지스트리 사용 권한이 있는 경우에 컴퓨터에 있는 모든 로그를 삭제할 수 있습니다.       <xref:System.Diagnostics.EventLog.Delete%2A>지정 된 로그 제거 `logName` 에 지정 된 컴퓨터에서 `machineName`합니다.</xref:System.Diagnostics.EventLog.Delete%2A> 로그에 등록 된 소스에만 삭제 하려면 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 호출 로그 항목 삭제 하려는 경우 <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> 호출 <xref:System.Diagnostics.EventLog.Delete%2A>및 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>는 `static` 메서드 이므로 클래스 자체에 호출할 수 있습니다.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A></xref:System.Diagnostics.EventLog.Delete%2A> 인스턴스를 만들 필요는 없습니다 <xref:System.Diagnostics.EventLog>메서드 중 하나를 호출 합니다.</xref:System.Diagnostics.EventLog>       이 메서드는 먼저 로그의 내용을 포함 하는 파일을 삭제 합니다. 그런 다음 레지스트리에 액세스 하 고 해당 로그에 대해 등록 된 모든 이벤트 소스를 제거 합니다. 나중에 로그를 다시 만드는 경우 등록 이벤트 소스 마찬가지로 다시 사용 하려는 경우. 이벤트 소스를 등록 하지 않으면 로그 이름을 지정 하지 않고 이벤트 소스에 다른 사용자가 작성 하는 경우 응용 프로그램 이벤트 로그에서 이벤트 소스가 만들어질 수 있습니다. 따라서 응용 프로그램 삭제 하 고 다시 로그에 엔트리를 쓸 수 있었던는 쓰지 응용 프로그램 로그에 대신 이제 이벤트 소스를 포함 하기 때문에 합니다.      > [!NOTE] > 이벤트 로그를 다시 만드는 과정은 어려울 수 있습니다. 응용 프로그램 로그와 같은 시스템에서 만든 이벤트 로그를 삭제 하지 마십시오.       <xref:System.Diagnostics.EventLog.Delete%2A>해당 로그에 등록 된 소스를 자동으로 삭제</xref:System.Diagnostics.EventLog.Delete%2A> 에 대 한 호출을 통해 로그를 삭제합니다. 이 작동 하 여 로그를 사용 하 여 다른 응용 프로그램 해질 수 있습니다."
  example:
  - "The following example deletes a log from the specified computer. The example determines the log from its source.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cs[Classic EventLog.Delete1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_17_1.cs)]\n [!code-cpp[Classic EventLog.Delete1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_17_1.cpp)]\n [!code-vb[Classic EventLog.Delete1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_17_1.vb)]"
  syntax:
    content: public static void Delete (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: '삭제할 로그의 이름입니다. 가능한 값: 응용 프로그램, 보안, 시스템, 그리고 지정된 된 컴퓨터에서 모든 사용자 지정 이벤트 로그입니다.'
    - id: machineName
      type: System.String
      description: "로그를 삭제 하는 컴퓨터의 이름 또는 &quot;.&quot; 로컬 컴퓨터에 대 한 합니다."
  overload: System.Diagnostics.EventLog.Delete*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logName</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>machineName</code> is not a valid computer name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The registry key for the event log could not be opened on the specified computer.  \n  \n \\- or -  \n  \n The log does not exist on the specified computer."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "이벤트 로그에 지워지지 않은 합니다.       -또는-로그를 열 수 없습니다. Windows 오류 코드를 사용할 수 없는 경우"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String)
  id: DeleteEventSource(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: DeleteEventSource(String)
  nameWithType: EventLog.DeleteEventSource(String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "로컬 컴퓨터의 이벤트 로그에서 이벤트 소스 등록을 제거합니다."
  remarks: "이 메서드를 사용 하 여의 등록을 제거 하는 <xref:System.Diagnostics.EventLog.Source%2A>로컬 컴퓨터에서.</xref:System.Diagnostics.EventLog.Source%2A> DeleteEventSource 로컬 컴퓨터에서 레지스트리에 액세스 하 고 유효한 이벤트 소스로 응용 프로그램의 등록을 제거 합니다.       해당 로그에 엔트리를 쓸 더 이상 필요할 경우 유효한 이벤트 소스로 구성 요소를 제거할 수 없습니다. 예를 들어 하나의 로그에서 다른 구성 요소를 변경 해야 할 경우이 작업을 수행 될 수 있습니다. 소스 한 번에 하나의 로그만 등록할 수 있습니다, 때문에 로그를 변경 하려면 현재 등록을 제거 합니다.       DeleteEventSource 로그에 등록 하는 소스만 제거 합니다. 로그 자체를 제거 하려는 경우 <xref:System.Diagnostics.EventLog.Delete%2A>.</xref:System.Diagnostics.EventLog.Delete%2A> 호출 로그 항목 삭제 하려는 경우 <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> 호출 <xref:System.Diagnostics.EventLog.Delete%2A>DeleteEventSource 되며 `static` 메서드 이므로 클래스 자체에 호출할 수 있습니다.</xref:System.Diagnostics.EventLog.Delete%2A> 인스턴스를 만들 필요는 없습니다 <xref:System.Diagnostics.EventLog>메서드 중 하나를 호출 합니다.</xref:System.Diagnostics.EventLog>       <xref:System.Diagnostics.EventLog.Delete%2A>해당 로그에 등록 된 소스를 자동으로 삭제</xref:System.Diagnostics.EventLog.Delete%2A> 에 대 한 호출을 통해 로그를 삭제합니다. 이 작동 하 여 로그를 사용 하 여 다른 응용 프로그램 해질 수 있습니다.      > [!NOTE] > 변경 내용 적용 하려면 컴퓨터를 다시 시작 해야 합니다는 원본 로그에 이미 매핑 되었습니다. 새 로그에 다시 매핑하려면을 합니다."
  example:
  - "The following example deletes a source from the local computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_8_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_8_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_8_1.cs)]"
  syntax:
    content: public static void DeleteEventSource (string source);
    parameters:
    - id: source
      type: System.String
      description: "응용 프로그램 이벤트 로그 시스템에 등록 된 이름입니다."
  overload: System.Diagnostics.EventLog.DeleteEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> parameter does not exist in the registry of the local computer.  \n  \n \\- or -  \n  \n You do not have write access on the registry key for the event log."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  id: DeleteEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: DeleteEventSource(String,String)
  nameWithType: EventLog.DeleteEventSource(String,String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "지정된 된 컴퓨터에서 응용 프로그램의 이벤트 소스 등록을 제거합니다."
  remarks: "이 오버 로드를 사용 하 여의 등록을 제거 하는 <xref:System.Diagnostics.EventLog.Source%2A>원격 컴퓨터에서.</xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>에 지정 된 컴퓨터의 레지스트리에 액세스 `machineName` 유효한 이벤트 소스로 응용 프로그램의 등록을 제거 합니다.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A>       해당 로그에 엔트리를 쓸 더 이상 필요할 경우 유효한 이벤트 소스로 구성 요소를 제거할 수 없습니다. 예를 들어 하나의 로그에서 다른 구성 요소를 변경 해야 할 경우이 작업을 수행 될 수 있습니다. 소스 한 번에 하나의 로그만 등록할 수 있습니다, 때문에 로그를 변경 하려면 현재 등록을 제거 합니다.       <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>로그에 등록 하는 소스만 제거 합니다.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 로그 자체를 제거 하려는 경우 <xref:System.Diagnostics.EventLog.Delete%2A>.</xref:System.Diagnostics.EventLog.Delete%2A> 호출 로그 항목 삭제 하려는 경우 <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> 호출 <xref:System.Diagnostics.EventLog.Delete%2A>및 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>는 `static` 메서드 이므로 클래스 자체에 호출할 수 있습니다.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A></xref:System.Diagnostics.EventLog.Delete%2A> 인스턴스를 만들 필요는 없습니다 <xref:System.Diagnostics.EventLog>메서드 중 하나를 호출 합니다.</xref:System.Diagnostics.EventLog>       <xref:System.Diagnostics.EventLog.Delete%2A>해당 로그에 등록 된 소스를 자동으로 삭제</xref:System.Diagnostics.EventLog.Delete%2A> 에 대 한 호출을 통해 로그를 삭제합니다. 이 작동 하 여 로그를 사용 하 여 다른 응용 프로그램 해질 수 있습니다.      > [!NOTE] > 변경 내용 적용 하려면 컴퓨터를 다시 시작 해야 합니다는 원본 로그에 이미 매핑 되었습니다. 새 로그에 다시 매핑하려면을 합니다."
  example:
  - "The following example deletes a source from the specified computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cs[Classic EventLog.Delete1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_6_1.cs)]\n [!code-cpp[Classic EventLog.Delete1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_6_1.cpp)]\n [!code-vb[Classic EventLog.Delete1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_6_1.vb)]"
  syntax:
    content: public static void DeleteEventSource (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "응용 프로그램 이벤트 로그 시스템에 등록 된 이름입니다."
    - id: machineName
      type: System.String
      description: "등록을 제거 하는 컴퓨터의 이름 또는 &quot;.&quot; 로컬 컴퓨터에 대 한 합니다."
  overload: System.Diagnostics.EventLog.DeleteEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>machineName</code> parameter is invalid.  \n  \n \\- or -  \n  \n The <code>source</code> parameter does not exist in the registry of the specified computer.  \n  \n \\- or -  \n  \n You do not have write access on the registry key for the event log."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>source</code>때문에 삭제할 수 없습니다 부모 레지스트리 키에 레지스트리에 <code>source</code> 동일한 이름 가진 하위 키를 포함 하지 않습니다."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: EventLog.Dispose(Boolean)
  fullName: System.Diagnostics.EventLog.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "사용 하는 관리 되지 않는 리소스를 해제는 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>, 관리 되는 리소스를 선택적으로 해제 합니다."
  remarks: "이 메서드는 public `Dispose()`메서드 및 <xref:System.Object.Finalize%2A>메서드.</xref:System.Object.Finalize%2A> `Dispose()`보호 된 호출 `Dispose(Boolean)` 메서드는 `disposing` 매개 변수 설정 `true`합니다. <xref:System.Object.Finalize%2A>호출 `Dispose` 와 `disposing` 로 설정 `false`합니다.</xref:System.Object.Finalize%2A>       경우는 `disposing` 매개 변수가 true 이면이 메서드는 관리 개체가 보유 하는 모든 리소스를 해제 합니다.이 <xref:System.Diagnostics.EventLog>참조.</xref:System.Diagnostics.EventLog> 이 메서드 호출에서 `Dispose()` 각 참조 된 개체의 메서드."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>관리 되는 관리 되지 않는 리소스만 해제 하려면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 만 관리 되지 않는 리소스를 해제 합니다."
  overload: System.Diagnostics.EventLog.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
  fullName: System.Diagnostics.EventLog.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "나타내는 값을 가져오거나 여부는 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> 받는 <xref href=&quot;System.Diagnostics.EventLog.EntryWritten&quot;> </xref> 이벤트 알림."
  remarks: "EnableRaisingEvents 속성 결정 여부 <xref:System.Diagnostics.EventLog>항목이 로그에 기록 되 면 이벤트를 발생</xref:System.Diagnostics.EventLog> 속성이 `true`를 수신 하는 구성 요소는 <xref:System.Diagnostics.EventLog.EntryWritten>이벤트 알림이 언제 든 지 항목에 지정 된 로그에 기록 됩니다는 <xref:System.Diagnostics.EventLog.Log%2A>속성.</xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.EntryWritten> EnableRaisingEvents 이면 `false`, 이벤트가 발생 합니다.      > [!NOTE] > 항목은 로컬 컴퓨터에 기록 되는 경우에 이벤트 알림을 받을 수 있습니다. 원격 컴퓨터에서 기록 된 항목에 대 한 알림을 받을 수 없습니다."
  example:
  - "The following example handles an <xref:System.Diagnostics.EventLog.EntryWritten> event.  \n  \n [!code-cs[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_32_1.cs)]\n [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_32_1.vb)]\n [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_32_1.cpp)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우는 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> 해야 하는 항목이 고, 그렇지 않으면 로그에 쓰면 때 알림을 받을 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Diagnostics.EventLog.EnableRaisingEvents*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이벤트 로그 원격 컴퓨터에 있는 경우"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EndInit
  id: EndInit
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EndInit()
  nameWithType: EventLog.EndInit()
  fullName: System.Diagnostics.EventLog.EndInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "초기화를 종료 한 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> 또는 다른 구성 요소는 폼에 사용 합니다. 초기화는 런타임에 발생합니다."
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] 디자인 환경에서이 메서드를 사용 하 여 폼에 또는 다른 구성 요소를 사용 하는 구성 초기화를 끝냅니다. <xref:System.Diagnostics.EventLog.BeginInit%2A>메서드 초기화를 시작 합니다.</xref:System.Diagnostics.EventLog.BeginInit%2A> 사용 하 여 <xref:System.Diagnostics.EventLog.BeginInit%2A>하 고 컨트롤을 완전히 초기화 되기 전에 사용 되지 않도록 하 EndInit 메서드.</xref:System.Diagnostics.EventLog.BeginInit%2A>"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Diagnostics.EventLog.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Entries
  id: Entries
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Entries
  nameWithType: EventLog.Entries
  fullName: System.Diagnostics.EventLog.Entries
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "이벤트 로그의 내용을 가져옵니다."
  remarks: "이벤트 로그에서 읽을 때 항목 멤버를 사용 합니다.       속성이 읽기 전용 이므로 항목을 수정 하거나 항목을 사용 하 여 로그에 쓸 수 없습니다. 대신, 지정는 <xref:System.Diagnostics.EventLog.Source%2A>호출 <xref:System.Diagnostics.EventLog.WriteEntry%2A>새 로그 엔트리를 씁니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A> 항목을 사용 하 여 이벤트 로그에 있는 항목의 수를 계산 하 고 각 볼 수 있습니다 <xref:System.Diagnostics.EventLogEntry>컬렉션에.</xref:System.Diagnostics.EventLogEntry> 사용 하 여 인덱싱된 <xref:System.Diagnostics.EventLogEntryCollection.Item%2A>같은 특정 항목에 대 한 정보를 검색 하려면 멤버 <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, 또는 <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.</xref:System.Diagnostics.EventLogEntry.EntryType%2A> </xref:System.Diagnostics.EventLogEntry.TimeWritten%2A> </xref:System.Diagnostics.EventLogEntry.Category%2A> </xref:System.Diagnostics.EventLogEntry.Message%2A> </xref:System.Diagnostics.EventLogEntryCollection.Item%2A>       를 지정 하는 <xref:System.Diagnostics.EventLog.Source%2A>는 로그에서 읽을 때</xref:System.Diagnostics.EventLog.Source%2A> 필요는 없습니다. 만 지정할 수는 <xref:System.Diagnostics.EventLog.Log%2A>이름 및 <xref:System.Diagnostics.EventLog.MachineName%2A>에 대 한 속성 (서버 컴퓨터 이름)는 <xref:System.Diagnostics.EventLog>인스턴스.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> 두 경우 모두 항목 멤버는 자동 항목의 이벤트 로그의 목록으로 채워집니다. 개별 항목을 읽을 수는이 목록의 항목에 대 한 적절 한 인덱스를 선택할 수 있습니다.       중요 한 차이 읽기 및 쓰기 로그 항목 읽기 메서드를 명시적으로 호출 하는 데 필요한 된다는 점입니다. 후의 <xref:System.Diagnostics.EventLog.Log%2A>및 <xref:System.Diagnostics.EventLog.MachineName%2A>지정, 항목 속성은 자동으로 채워집니다.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> 값 <xref:System.Diagnostics.EventLog.Log%2A>또는 <xref:System.Diagnostics.EventLog.MachineName%2A>속성을 속성 다시 채워야 합니다. 읽기 다음에 항목을</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> 변경 하는 경우      > [!NOTE] > <xref:System.Diagnostics.EventLog.MachineName%2A>는 로그에 연결 하는 경우</xref:System.Diagnostics.EventLog.MachineName%2A> 을 지정할 필요가 없습니다 지정 하지 않는 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A>, 로컬 컴퓨터를 &quot;.&quot;, 것으로 간주 됩니다.</xref:System.Diagnostics.EventLog.MachineName%2A>"
  example:
  - "The following example reads entries in the event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cs[Classic EventLog.Entries Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_23_1.cs)]\n [!code-cpp[Classic EventLog.Entries Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_23_1.cpp)]\n [!code-vb[Classic EventLog.Entries Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_23_1.vb)]"
  syntax:
    content: public System.Diagnostics.EventLogEntryCollection Entries { get; }
    return:
      type: System.Diagnostics.EventLogEntryCollection
      description: "<xref href=&quot;System.Diagnostics.EventLogEntryCollection&quot;> </xref> 이벤트 로그에 항목을 유지 합니다. 인스턴스와 연결 된 각 항목은 <xref href=&quot;System.Diagnostics.EventLogEntry&quot;> </xref> 클래스입니다."
  overload: System.Diagnostics.EventLog.Entries*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EntryWritten
  id: EntryWritten
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EntryWritten
  nameWithType: EventLog.EntryWritten
  fullName: System.Diagnostics.EventLog.EntryWritten
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "로컬 컴퓨터에서 이벤트 로그에 항목이 기록 될 때 발생 합니다."
  remarks: "이벤트 알림을 하려면 설정 해야 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>를 `true`.</xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> 로컬 컴퓨터에 엔트리를 쓸 경우에 이벤트 알림을 받을 수 있습니다. 원격 컴퓨터에서 기록 된 항목에 대 한 알림을 받을 수 없습니다.       EntryWritten 대리자를 만들 때 이벤트를 처리 하는 메서드를 식별 합니다. 이벤트를 이벤트 처리기를 연결 하려면 대리자의 인스턴스 이벤트에 추가 합니다. 대리자를 제거 하기 전 까지는 이벤트가 발생할 때마다 이벤트 처리기가 호출 됩니다. 대리자와 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트](~/add/includes/ajax-current-ext-md.md)합니다.       시스템에 응답 <xref:System.Diagnostics.EventLog.WriteEntry%2A>마지막 쓰기 이벤트&6; 초 이상 이전에 발생 한 경우에.</xref:System.Diagnostics.EventLog.WriteEntry%2A> 이 의미&6; 초 간격 내에서 한 EntryWritten 이벤트 알림을 받습니다, 둘 이상의 이벤트 로그에서 변경 하는 경우에 발생 합니다. 호출 하는 사이 충분히 긴 대기 간격 (약 10 초)을 삽입 하면 <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 이벤트 손실이 할 가능성이 줄어들기.</xref:System.Diagnostics.EventLog.WriteEntry%2A> 그러나 쓰기 이벤트가 더 자주 발생 이벤트 알림이 다음 간격까지 표시 되지 않을 수도 있습니다. 일반적으로 누락 된 이벤트 알림은 되지 손실, 하지만 지연 합니다."
  example:
  - "The following example handles an entry written event.  \n  \n [!code-cs[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/csharp/e-system.diagnostics.eve_1.cs)]\n [!code-cpp[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/cpp/e-system.diagnostics.eve_1.cpp)]\n [!code-vb[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/visualbasic/e-system.diagnostics.eve_1.vb)]"
  syntax:
    content: public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;
    return:
      type: System.Diagnostics.EntryWrittenEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Exists(System.String)
  id: Exists(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Exists(String)
  nameWithType: EventLog.Exists(String)
  fullName: System.Diagnostics.EventLog.Exists(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "로컬 컴퓨터에 로그가 있는지를 결정 합니다."
  remarks: "로컬 컴퓨터에 로그가 있는지를 확인 하려면이 메서드를 사용 합니다. <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A> 를 사용 하 여 로컬 컴퓨터에 있는지 여부를 확인.       이 메서드는 레지스트리를 액세스, 하므로 적절 한 레지스트리 사용 권한을 로컬 컴퓨터에 있어야 그렇지 않은 경우 쿼리에서 반환 `false`합니다.       동일한 컴퓨터에 새 로그에 기존 로그의 이름을 지정할 수 없습니다, 때문에이 메서드를 만들기 전에 사용 새 로그를 확인 하는 경우 지정 된 `logName` 로컬 컴퓨터에 이미 있습니다. `logName` 매개 변수는 대/소문자 구분 하지 않습니다.       존재는 `static` 메서드, 클래스 자체에 호출할 수 있습니다. 인스턴스를 만들 필요는 없습니다 <xref:System.Diagnostics.EventLog>Exists 호출할.</xref:System.Diagnostics.EventLog>"
  example:
  - >-
    [!code-cpp[EventLog_Exists_1#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_4_1.cpp)]
     [!code-vb[EventLog_Exists_1#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_4_1.vb)]
     [!code-cs[EventLog_Exists_1#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_4_1.cs)]
  syntax:
    content: public static bool Exists (string logName);
    parameters:
    - id: logName
      type: System.String
      description: '검색할 로그의 이름입니다. 가능한 값: 응용 프로그램, 보안, 시스템, 기타 응용 프로그램 관련 로그 (예: Active Directory와 연결 된), 또는 컴퓨터에 있는 모든 사용자 지정 로그입니다.'
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>로컬 컴퓨터에 로그가 있는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Diagnostics.EventLog.Exists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "LogName은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 또는 값이 비어 있습니다."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Exists(System.String,System.String)
  id: Exists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Exists(String,String)
  nameWithType: EventLog.Exists(String,String)
  fullName: System.Diagnostics.EventLog.Exists(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "지정된 된 컴퓨터에 로그가 있는지를 결정 합니다."
  remarks: "이 메서드를 사용 하 여 원격 컴퓨터에 로그가 있는지를 확인 합니다. <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A> 를 사용 하 여 원본 원격 컴퓨터에 있는지 여부를 확인.       이 메서드는 레지스트리를 액세스, 하므로 적절 한 레지스트리 사용 권한을 지정한 컴퓨터에 있어야 그렇지 않은 경우 쿼리에서 반환 `false`합니다.       동일한 컴퓨터에 새 로그에 기존 로그의 이름을 지정할 수 없습니다, 때문에이 메서드를 만들기 전에 사용 새 로그를 확인 한 경우 지정 된 `logName` 에서 지정한 서버에 이미는 `machineName` 매개 변수입니다. `logName` 및 `machineName` 매개 변수는 대/소문자 구분 하지 않습니다.       <xref:System.Diagnostics.EventLog.Exists%2A>이 `static` 메서드, 클래스 자체에 호출할 수 있습니다.</xref:System.Diagnostics.EventLog.Exists%2A> <xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A> 를 호출 하</xref:System.Diagnostics.EventLog> 의 새 인스턴스를 만들 필요는 없습니다."
  syntax:
    content: public static bool Exists (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: '검색할 로그입니다. 가능한 값: 응용 프로그램, 보안, 시스템, 기타 응용 프로그램 관련 로그 (예: Active Directory와 연결 된), 또는 컴퓨터에 있는 모든 사용자 지정 로그입니다.'
    - id: machineName
      type: System.String
      description: "로그에 대 한 검색할 컴퓨터의 이름 또는 &quot;.&quot; 로컬 컴퓨터에 대 한 합니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>지정 된 컴퓨터에 로그가 있는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Diagnostics.EventLog.Exists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> machineName </code> 매개 변수는 형식이 잘못 되었습니다. 검색 중인 컴퓨터에 대 한 적절 한 구문을 사용 했습니다 있는지 확인 합니다.       -또는- <code> logName </code> 은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 또는 값이 비어 있습니다."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.GetEventLogs
  id: GetEventLogs
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: GetEventLogs()
  nameWithType: EventLog.GetEventLogs()
  fullName: System.Diagnostics.EventLog.GetEventLogs()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "로컬 컴퓨터에서 모든 이벤트 로그를 검색 하 고 이루어진 배열을 만들어 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> 목록을 포함 하는 개체입니다."
  remarks: "배열 <xref:System.Diagnostics.EventLog>GetEventLogs 호출 하는 경우 개체는 로컬 컴퓨터에서 모든 이벤트 로그의 스냅숏을.</xref:System.Diagnostics.EventLog> 이 아니므로 동적 컬렉션을 삭제 나 로그를 실시간으로 생성은 반영 하지 않습니다. 배열에 있는 로그를 읽거나 쓰려고 전에 존재 하는지 확인 해야 합니다. 배열에는 일반적으로 로그를&3; 개 이상 포함: 응용 프로그램, 시스템 및 보안 합니다. 로컬 컴퓨터에 사용자 지정 로그를 만든 경우의 배열에도 표시 됩니다.       이벤트 로그의 목록을 검색 하려면 적절 한 레지스트리 사용 권한이 있어야 합니다. 이러한 권한은 동일 하 게 <xref:System.Diagnostics.EventLog.Exists%2A>및 <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A> </xref:System.Diagnostics.EventLog.Exists%2A> 를 호출 하는 데 필요한"
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_10_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/m-system.diagnostics.eve_10_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/m-system.diagnostics.eve_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.EventLog[] GetEventLogs ();
    parameters: []
    return:
      type: System.Diagnostics.EventLog[]
      description: "형식의 배열 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> 로컬 컴퓨터의 로그를 나타내는입니다."
  overload: System.Diagnostics.EventLog.GetEventLogs*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "레지스트리에 대 한 읽기 권한이 없습니다.       -또는-컴퓨터에서 이벤트 로그 서비스가 없는 합니다."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.GetEventLogs(System.String)
  id: GetEventLogs(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: GetEventLogs(String)
  nameWithType: EventLog.GetEventLogs(String)
  fullName: System.Diagnostics.EventLog.GetEventLogs(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "지정한 컴퓨터에 모든 이벤트 로그를 검색 하 고 이루어진 배열을 만들어 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> 목록을 포함 하는 개체입니다."
  remarks: "배열 <xref:System.Diagnostics.EventLog>개체는에 지정 된 컴퓨터에서 모든 이벤트 로그의 스냅숏을 `machineName` 매개 변수는 경우에 대 한 호출 <xref:System.Diagnostics.EventLog.GetEventLogs%2A>이루어집니다.</xref:System.Diagnostics.EventLog.GetEventLogs%2A> </xref:System.Diagnostics.EventLog> 이 아니므로 동적 컬렉션을 삭제 나 로그를 실시간으로 생성은 반영 하지 않습니다. 배열에 있는 로그를 읽거나 쓰려고 전에 존재 하는지 확인 해야 합니다. 배열에는 일반적으로 로그를&3; 개 이상 포함: 응용 프로그램, 시스템 및 보안 합니다. 지정된 된 컴퓨터에서 사용자 지정 로그를 만든 경우의 배열에도 표시 됩니다.       <xref:System.Diagnostics.EventLog.GetEventLogs%2A>이 `static` 메서드를 호출 될 수는 <xref:System.Diagnostics.EventLog>클래스 자체.</xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog.GetEventLogs%2A> 인스턴스를 만들 필요는 없습니다는 <xref:System.Diagnostics.EventLog>메서드를 호출 하는 개체입니다.</xref:System.Diagnostics.EventLog>       이벤트 로그의 목록을 검색 하려면 적절 한 레지스트리 사용 권한이 있어야 합니다. 이러한 권한은 동일 하 게 <xref:System.Diagnostics.EventLog.Exists%2A>및 <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A> </xref:System.Diagnostics.EventLog.Exists%2A> 를 호출 하는 데 필요한"
  example:
  - "The following example gets a list of logs on the computer \"myServer\". It then outputs the name of each log.  \n  \n [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_18_1.cpp)]\n [!code-cs[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_18_1.cs)]\n [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_18_1.vb)]"
  syntax:
    content: public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "이벤트 로그에 대 한 검색할 컴퓨터입니다."
    return:
      type: System.Diagnostics.EventLog[]
      description: "형식의 배열 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> 지정한 컴퓨터에 대 한 로그를 나타내는입니다."
  overload: System.Diagnostics.EventLog.GetEventLogs*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> machineName </code> 매개 변수는 잘못 된 컴퓨터 이름입니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "레지스트리에 대 한 읽기 권한이 없습니다.       -또는-컴퓨터에서 이벤트 로그 서비스가 없는 합니다."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Log
  id: Log
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Log
  nameWithType: EventLog.Log
  fullName: System.Diagnostics.EventLog.Log
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "읽거나 쓸 로그의 이름을 가져오거나 설정 합니다."
  remarks: "Three log files exist by default on the server: Application, System, and Security. Applications and services use the Application log file. Device drivers use the System log file. The system generates success and failure audit events in the Security log when auditing is turned on. If you have other applications installed, like Active Directory on Windows servers, there might be other default log files. In addition, you can create custom log files on a local or remote computer. Custom logs help organize your entries in a more detailed way than is allowed when your components write events to the default Application log.  \n  \n> [!NOTE]\n>  Log names are limited to eight characters. According to the system, MyLogSample1 and MyLogSample2 are the same log.  \n  \n If you write to an event log, it is not enough to specify the Log property. You must associate a <xref:System.Diagnostics.EventLog.Source%2A> property with your event log resource to connect it to a particular log. It is not necessary to specify a <xref:System.Diagnostics.EventLog.Source%2A> when only reading from a log, but an event source must be associated with the event log resource in the server's registry. You can specify only the Log name and <xref:System.Diagnostics.EventLog.MachineName%2A> (server computer name) to read from it.  \n  \n> [!NOTE]\n>  You are not required to specify the <xref:System.Diagnostics.EventLog.MachineName%2A> if you are connecting to a log. If you do not specify the <xref:System.Diagnostics.EventLog.MachineName%2A>, the local computer (\".\") is assumed.  \n  \n If the <xref:System.Diagnostics.EventLog.Source%2A> property has not been specified, a call to Log returns an empty string if Log has not been explicitly set (by setting the Log property, or through the constructor). If the <xref:System.Diagnostics.EventLog.Source%2A> has been specified, Log returns the name of the log to which that source was registered.  \n  \n A source can only be registered to one log at a time. If the <xref:System.Diagnostics.EventLog.Source%2A> property was set for an instance of <xref:System.Diagnostics.EventLog>, you cannot change the Log property for that <xref:System.Diagnostics.EventLog> without changing the value of <xref:System.Diagnostics.EventLog.Source%2A> or calling <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> first. If you change the Log property after the <xref:System.Diagnostics.EventLog.Source%2A> property has been set, writing a log entry throws an exception.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the Log property with the \".evt\" file name extension.  \n  \n You cannot create a new log using the Log property alone (without specifying a source for the log). You can call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, passing in a new log name as a parameter, and then call <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. However, the intent is usually either to create (and write entries to) new application-specific logs, or to read from existing logs.  \n  \n If the Log value changes, the event log is closed and all event handles are released.  \n  \n> [!CAUTION]\n>  If you set the Log property to the name of a log that does not exist, the system attaches the <xref:System.Diagnostics.EventLog> to the Application log, but does not warn you that it is using a log other than the one you specified."
  example:
  - "The following example reads entries in the event log, \"NewEventLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.Log Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_17_1.cpp)]\n [!code-cs[Classic EventLog.Log Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_17_1.cs)]\n [!code-vb[Classic EventLog.Log Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_17_1.vb)]"
  syntax:
    content: public string Log { get; set; }
    return:
      type: System.String
      description: "로그의 이름입니다. 이 응용 프로그램, 시스템, 보안 또는 사용자 지정 로그 이름을 수 있습니다. 기본값은 빈 문자열 (&quot;&quot;)."
  overload: System.Diagnostics.EventLog.Log*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.LogDisplayName
  id: LogDisplayName
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
  fullName: System.Diagnostics.EventLog.LogDisplayName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "이벤트 로그의 이름을 가져옵니다."
  remarks: "> [!NOTE]> Windows Vista 이상에서는 사용자가 보안 로그에 액세스할 수 있는 권한이 없는 합니다. Windows Vista를 실행 하는 경우 또는 나중에 사용자를 받아볼 수는 <xref:System.Security.SecurityException>보안 로그의 이벤트에 대 한 표시 이름에 액세스 하려고 할 때</xref:System.Security.SecurityException>   >> Windows Vista 이상에서 사용자 계정 컨트롤 (UAC)가 사용자 권한을 결정합니다. 두 개의 런타임 액세스 토큰에 할당 된 기본 제공 Administrators 그룹의 구성원 인 경우: 표준 사용자 액세스 토큰 및 관리자 액세스 토큰입니다. 기본적으로 표준 사용자 역할에 속합니다. 보안 로그에 액세스 하는 코드를 실행 하려면 먼저 높여야 귀하의 권한을 표준 사용자에서 관리자에 게 있습니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭 하 고 관리자 권한으로 실행 되도록 지정 하 여 응용 프로그램을 시작 하는 경우이 수행할 수 있습니다."
  example:
  - "The following example enumerates the event logs defined on the local computer and displays the LogDisplayName for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_29_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_29_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_29_1.cs)]"
  syntax:
    content: public string LogDisplayName { get; }
    return:
      type: System.String
      description: "시스템의 이벤트 뷰어에서 이벤트 로그를 나타내는 이름입니다."
  overload: System.Diagnostics.EventLog.LogDisplayName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "지정 된 <xref:System.Diagnostics.EventLog.Log*>이 컴퓨터에 대 한 레지스트리에 존재 하지 않습니다.</xref:System.Diagnostics.EventLog.Log*>"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  id: LogNameFromSourceName(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: LogNameFromSourceName(String,String)
  nameWithType: EventLog.LogNameFromSourceName(String,String)
  fullName: System.Diagnostics.EventLog.LogNameFromSourceName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "지정된 된 소스가 등록 되는 로그의 이름을 가져옵니다."
  remarks: "이벤트 소스는 이벤트 로그를 나타냅니다. 것이 응용 프로그램의 이름 또는 하위 구성 요소는 응용 프로그램의 이름을 응용 프로그램이 큰 경우. 응용 프로그램 및 서비스 응용 프로그램 로그 나 사용자 지정 로그에 써야 합니다. 장치 드라이버 시스템 로그에 써야 합니다.       수만 로그에 작성 한 한 번에 새 소스를 만들면 시스템 이벤트 로그와 응용 프로그램 유효한 항목 소스로 등록 합니다. <xref:System.Diagnostics.EventLog.Source%2A>속성에는 모든 문자열을 지정할 수 있지만 다른 소스에서 컴퓨터 이름을 사용할 수 없습니다.</xref:System.Diagnostics.EventLog.Source%2A> 중복 된 경우 만들려는 시도가 <xref:System.Diagnostics.EventLog.Source%2A>값 예외를 throw 합니다.</xref:System.Diagnostics.EventLog.Source%2A> 그러나 하나의 이벤트 로그에 쓰기를 여러 소스 있을 수 있습니다."
  example:
  - "The following example deletes a source from the local computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_2_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_2_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_2_1.cs)]"
  syntax:
    content: public static string LogNameFromSourceName (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "이벤트 원본의 이름입니다."
    - id: machineName
      type: System.String
      description: "검색할에 컴퓨터의 이름 또는 &quot;.&quot; 로컬 컴퓨터에 대 한 합니다."
    return:
      type: System.String
      description: "레지스트리에 지정된 된 소스와 연결 된 로그의 이름입니다."
  overload: System.Diagnostics.EventLog.LogNameFromSourceName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MachineName
  id: MachineName
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MachineName
  nameWithType: EventLog.MachineName
  fullName: System.Diagnostics.EventLog.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "읽기 또는 쓰기 이벤트를 컴퓨터의 이름을 가져오거나 설정 합니다."
  remarks: "이벤트 로그에 작성 하는 경우 연결 해야는 <xref:System.Diagnostics.EventLog.Source%2A>특정 로그에 연결할 개체를 이벤트 로그</xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.Source%2A>로그에서 읽기만 하는 경우이 속성</xref:System.Diagnostics.EventLog.Source%2A> 을 지정할 필요는 없습니다. 만 지정할 수는 <xref:System.Diagnostics.EventLog.Log%2A>이름 및 MachineName (서버 컴퓨터 이름).</xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > 로그에 연결 하는 경우는 MachineName을 지정 하지 않아도 됩니다. MachineName, 로컬 컴퓨터를 지정 하지 않는 경우 (&quot;.&quot;)으로 간주 됩니다.       만 소스는 한 번에 하나의 로그 등록할 수 있습니다. 경우는 <xref:System.Diagnostics.EventLog.Source%2A>의 인스턴스에 대 한 속성이 설정 된 <xref:System.Diagnostics.EventLog>, MachineName 속성을 변경할 수 없습니다 <xref:System.Diagnostics.EventLog>의 값을 변경 하지 않고 <xref:System.Diagnostics.EventLog.Source%2A>호출 또는 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>첫 번째.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> MachineName 속성을 변경 하는 경우는 <xref:System.Diagnostics.EventLog>모든 핸들을 닫고 로그 및 새 컴퓨터에는 소스에 다시 연결 합니다.</xref:System.Diagnostics.EventLog>       MachineName 값에는 빈 문자열일 수 없습니다. 명시적으로 설정 하지 않으면 기본값은 로컬 컴퓨터 (&quot;.&quot;)."
  example:
  - "The following example reads entries in the event log, \"NewEventLog\", on a specified computer.  \n  \n [!code-cs[Classic EventLog.MachineName Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_6_1.cs)]\n [!code-vb[Classic EventLog.MachineName Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_6_1.vb)]\n [!code-cpp[Classic EventLog.MachineName Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_6_1.cpp)]"
  syntax:
    content: public string MachineName { get; set; }
    return:
      type: System.String
      description: "이벤트 로그가 있는 서버의 이름입니다. 기본값은 로컬 컴퓨터 (&quot;.&quot;)."
  overload: System.Diagnostics.EventLog.MachineName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "컴퓨터 이름이 올바르지 않습니다."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MaximumKilobytes
  id: MaximumKilobytes
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
  fullName: System.Diagnostics.EventLog.MaximumKilobytes
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "최대 이벤트 로그 크기 (킬로바이트)를 가져오거나 설정 합니다."
  remarks: "MaximumKilobytes 속성은 이벤트 로그 파일의 크기 제한을 나타냅니다. 이벤트 로그에서 구성된 된 크기 제한에 도달 하면 때 <xref:System.Diagnostics.EventLog.OverflowAction%2A>값과 새 항목을 삭제 하는지 여부 또는 이전 항목 덮어쓰는지 여부를 결정 합니다.</xref:System.Diagnostics.EventLog.OverflowAction%2A>      > [!NOTE] >이 속성은이 인스턴스가 나타내는 이벤트 로그에 대 한 구성 설정을 나타냅니다. 이벤트 로그의 최대 크기에 도달 하면이 속성이 운영 체제 이벤트 로그에 대해 등록 된 모든 이벤트 소스가 작성 하는 새 항목을 처리 하는 방법을 지정 합니다."
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_15_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_15_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_15_1.cs)]"
  syntax:
    content: public long MaximumKilobytes { get; set; }
    return:
      type: System.Int64
      description: "최대 이벤트 로그 크기 (킬로바이트)입니다. 기본값은 512, 512kb 최대 파일 크기를 나타내는입니다."
  overload: System.Diagnostics.EventLog.MaximumKilobytes*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "지정된 된 값은 64 보다 작거나 4194240 64의 짝수 배수가 아닌 보다 큰 합니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MinimumRetentionDays
  id: MinimumRetentionDays
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
  fullName: System.Diagnostics.EventLog.MinimumRetentionDays
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "이벤트 로그에 엔트리를 유지할 일 수를 가져옵니다."
  remarks: "MinimumRetentionDays 속성을 사용 하 여 이벤트 로그에 대 한 현재 설정을 검사 합니다. 사용 하 여 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>이벤트 로그의 각 항목을 유지 해야 하는 일의 최소 수를 변경 합니다.</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>       MinimumRetentionDays 값은 이벤트 로그의 구성된 된 오버플로 동작에 따라 달라 집니다. 경우는 <xref:System.Diagnostics.OverflowAction>이벤트 로그에 대 한 속성이로 설정 되어 <xref:System.Diagnostics.OverflowAction>, MinimumRetentionDays 값은 0입니다.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction> 경우는 <xref:System.Diagnostics.OverflowAction>이벤트 로그에 대 한 속성이로 설정 되어 <xref:System.Diagnostics.OverflowAction>, MinimumRetentionDays 값은-1.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction> 경우는 <xref:System.Diagnostics.OverflowAction>이벤트 로그에 대 한 속성이로 설정 되어 <xref:System.Diagnostics.OverflowAction>, MinimumRetentionDays 값이&0; 보다 크면 하 고 이벤트 로그가 가득 찼을 때 이벤트 로그 항목을 보존할 일 수를 나타냅니다.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction>       이벤트 로그 크기 제한에 도달 하는 경우에 오버플로 동작 발생 합니다. 경우는 <xref:System.Diagnostics.EventLog>가 해당 <xref:System.Diagnostics.EventLog.OverflowAction%2A>로 설정 <xref:System.Diagnostics.OverflowAction>, 이벤트 로그의 최대 크기에 도달 하 고 다음 MinimumRetentionDays 기간을 초과 하는 오래 된 항목을 대체할 수 있는 경우 새 항목이 기록 합니다.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.EventLog.OverflowAction%2A> </xref:System.Diagnostics.EventLog> 이벤트 로그를 정기적으로 보관 하는 경우 최소 기간에 대 한 이벤트 항목을 유지 하는 것은 적합 합니다. 그렇지 않으면 이벤트 로그의 제한에 도달할 때 새 항목을 손실 위험이 있습니다. 새 이벤트 정보가 손실 되지 않도록, 특정 이벤트 로그에 대 한 보관 일정에 따라 이벤트에 대 한 최소 보존 (일)을 설정 합니다."
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_12_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_12_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_12_1.cs)]"
  syntax:
    content: public int MinimumRetentionDays { get; }
    return:
      type: System.Int32
      description: "이벤트 로그에 항목이 유지 되는 일 수입니다. 기본값은 7입니다."
  overload: System.Diagnostics.EventLog.MinimumRetentionDays*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  id: ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: ModifyOverflowPolicy(OverflowAction,Int32)
  nameWithType: EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  fullName: System.Diagnostics.EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "이벤트 로그에는 최대 파일 크기에 도달할 때 새 엔트리를 쓰기 위해 구성된 된 동작을 변경 합니다."
  remarks: "새 항목은 최대 파일 크기에 도달 하는 로그에 기록 되도록 하는 경우 지정 하는 이벤트 로그에 대 한 오버플로 동작 합니다.      > [!NOTE] > 오버플로 동작은 이벤트 로그가 최대 파일 크기에 도달 하는 경우에 적용 됩니다. 오버플로 동작 추가 이벤트 로그 항목을 사용할 수 있는 로그에 새 항목을 쓰는 적용 되지 않습니다.       ModifyOverflowPolicy 메서드 이벤트 로그의 오버플로 동작을 구성합니다. <xref:System.Diagnostics.EventLog>인스턴스입니다.</xref:System.Diagnostics.EventLog> 지정 된 이벤트 로그에 대 한이 메서드를 호출한 후는 <xref:System.Diagnostics.EventLog.Log%2A>속성에는 <xref:System.Diagnostics.EventLog.OverflowAction%2A>및 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>새로 구성된 된 오버플로 동작을 반영 하는 속성 값.</xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> </xref:System.Diagnostics.EventLog.OverflowAction%2A> </xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] >이 속성은이 인스턴스가 나타내는 이벤트 로그에 대 한 구성 설정을 나타냅니다. 이벤트 로그의 최대 크기에 도달 하면이 속성이 운영 체제 이벤트 로그에 대해 등록 된 모든 이벤트 소스가 작성 하는 새 항목을 처리 하는 방법을 지정 합니다.       설정의 `action` 매개 변수를 <xref:System.Diagnostics.OverflowAction>새 항목이 가장 오래 된 항목을 덮어씁니다를 나타내기 위해 때는 <xref:System.Diagnostics.EventLog>최대 크기에 도달 합니다.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.OverflowAction> 경우는 `action` 로 설정 된 <xref:System.Diagnostics.OverflowAction>, `retentionDays` 매개 변수 값은 무시 됩니다.</xref:System.Diagnostics.OverflowAction>       설정의 `action` 매개 변수를 <xref:System.Diagnostics.OverflowAction>를 각각의 새 항목이 덮어씁니다 이전 항목을 나타내기 위해 때는 <xref:System.Diagnostics.EventLog>최대 크기에 도달 합니다.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.OverflowAction> 사용 하 여 로그에 이벤트를 유지 해야 하는 일 수를 지정 된 `retentionDays` 매개 변수입니다. 보존 범위 내에 기록 되는 이벤트는 새 항목으로 덮어쓰지 않습니다.       설정의 `action` 매개 변수를 <xref:System.Diagnostics.OverflowAction>최대 로그 크기에 도달 하면 새 이벤트 삭제를.</xref:System.Diagnostics.OverflowAction> 경우는 `action` 로 설정 된 <xref:System.Diagnostics.OverflowAction>, `retentionDays` 매개 변수 값은 무시 됩니다.</xref:System.Diagnostics.OverflowAction>      > [!CAUTION] >는 오버플로 정책 설정을 <xref:System.Diagnostics.OverflowAction>지정 이벤트 로그가 꽉 찬 경우 새 항목이 삭제 됩니다.</xref:System.Diagnostics.OverflowAction> 이 설정을 사용 하는 경우 이벤트 로그는 정기적으로 보관 되 고 최대 크기 한도 도달 하지 않도록 하려면 삭제를 확인 합니다."
  example:
  - "The following example displays the configured overflow policy for a specified event log, and allows the user to select a new overflow policy setting for the event log.  \n  \n [!code-vb[EventLogProperties#3](~/add/codesnippet/visualbasic/0b0fc273-a638-4af9-ae99-_1.vb)]\n [!code-cpp[EventLogProperties#3](~/add/codesnippet/cpp/0b0fc273-a638-4af9-ae99-_1.cpp)]\n [!code-cs[EventLogProperties#3](~/add/codesnippet/csharp/0b0fc273-a638-4af9-ae99-_1.cs)]"
  syntax:
    content: public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);
    parameters:
    - id: action
      type: System.Diagnostics.OverflowAction
      description: "새 항목 이벤트 로그에 쓰기 위한 오버플로 동작입니다."
    - id: retentionDays
      type: System.Int32
      description: "최소 각 이벤트 로그 항목이 유지 되는 일 수 있습니다. 경우에이 매개 변수는 `action` 로 설정 된 <xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref>합니다."
  overload: System.Diagnostics.EventLog.ModifyOverflowPolicy*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>action</code>유효 하지 않거나 <xref:System.Diagnostics.EventLog.OverflowAction*> 값입니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>retentionDays</code>가 1 보다 작거나 365 보다 큰 경우"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.OverflowAction
  id: OverflowAction
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
  fullName: System.Diagnostics.EventLog.OverflowAction
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "이벤트 로그에는 최대 로그 파일 크기에 도달할 때 새 엔트리를 저장 하는 것에 대 한 구성된 된 동작을 가져옵니다."
  remarks: "새 이벤트 기록 될 때 이벤트 로그의 크기가 증가 합니다. 각 이벤트 로그에 구성 된 최대 크기 제한이 있습니다. <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>속성 (킬로바이트) 이벤트 로그 파일 크기에 허용 된 최대 수를 정의 합니다.</xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>       최대 크기는 이벤트 로그에 대해 구성된 된 오버플로 동작을 검사 하의 OverflowAction 속성 값을 사용 합니다. <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>이벤트 로그에 대 한 오버플로 동작을 변경 하려면 메서드</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> 를 사용 하 여      > [!NOTE] > 오버플로 동작은 이벤트 로그가 최대 파일 크기에 도달 하는 경우에 적용 됩니다. 오버플로 동작 추가 이벤트 로그 항목을 사용할 수 있는 로그에 새 항목을 쓰는 적용 되지 않습니다."
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_28_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_28_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_28_1.cs)]"
  syntax:
    content: public System.Diagnostics.OverflowAction OverflowAction { get; }
    return:
      type: System.Diagnostics.OverflowAction
      description: "<xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref> 이벤트 로그에는 최대 로그 크기에 도달할 때 새 엔트리를 저장 하기 위한 구성된 동작을 지정 하는 값입니다. 기본값은 <xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref>합니다."
  overload: System.Diagnostics.EventLog.OverflowAction*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  id: RegisterDisplayName(System.String,System.Int64)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: RegisterDisplayName(String,Int64)
  nameWithType: EventLog.RegisterDisplayName(String,Int64)
  fullName: System.Diagnostics.EventLog.RegisterDisplayName(String,Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "서버 이벤트 뷰어에에 표시 되는 이벤트 로그의 지역화 된 이름을 지정 합니다."
  remarks: "RegisterDisplayName를 사용 하 여 등록 하 고 이벤트 뷰어의 사용자 지정 이벤트 로그에 대 한 지역화 된 이름을 표시 합니다.       지정 된 리소스 식별자는 리소스 파일에 정의 된 지역화 된 문자열 일치 해야 합니다. 이벤트 뷰어는 지역화 된 문자열 및 현재 문화권 설정을 사용 하 여 사용자 지정 이벤트 로그 이름이 표시 됩니다. 예를 들어 리소스 파일에 서로 다른 문화권에 맞게 지역화 하는 여러 이벤트 로그 이름을 정의할 수 있습니다. 이벤트 뷰어에서 현재 사용자의 문화권 설정에 해당 하는 지역화 된 문자열을 표시 합니다.       이벤트 뷰어 리소스 파일에서 지역화 된 문자열을 로드할 수 없는 경우 또는 이벤트 로그에 대해 등록 된 표시 이름이 없는 경우 다음 이벤트 뷰어에서 표시 <xref:System.Diagnostics.EventLog.Log%2A>.</xref:System.Diagnostics.EventLog.Log%2A> 에 정의 된 이벤트 로그 이름      > [!NOTE] > 미리 정의 된 이벤트 로그에 대 한 표시 이름을 등록할 필요가 없습니다. 운영 체제는 응용 프로그램, 시스템 및 보안 이벤트 로그에 대 한 지역화 된 표시 이름을 등록합니다."
  example:
  - "The following example determines whether the event source named `SampleApplicationSource` is registered on the local computer. If the event source does not exist, the example sets the message resource file for the source and creates the new event source. Finally, the example sets the localized display name for the event log, using the resource identifier value in `DisplayNameMsgId` and the resource file path in `messageFile`.  \n  \n [!code-cpp[EventLog_WriteEvent#6](~/add/codesnippet/cpp/m-system.diagnostics.eve_1_1.cpp)]\n [!code-vb[EventLog_WriteEvent#6](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_1_1.vb)]\n [!code-cs[EventLog_WriteEvent#6](~/add/codesnippet/csharp/m-system.diagnostics.eve_1_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings. Specifically, resource identifier 5001 is defined for the localized name of the event log.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void RegisterDisplayName (string resourceFile, long resourceId);
    parameters:
    - id: resourceFile
      type: System.String
      description: "지역화 된 리소스 파일을 완전히 지정 된 경로입니다."
    - id: resourceId
      type: System.Int64
      description: "리소스 파일 내에서 지역화 된 문자열을 인덱싱하는 리소스 식별자입니다."
  overload: System.Diagnostics.EventLog.RegisterDisplayName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceFile </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Source
  id: Source
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Source
  nameWithType: EventLog.Source
  fullName: System.Diagnostics.EventLog.Source
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "등록 하 고 이벤트 로그에 쓸 때 사용할 소스 이름을 가져오거나 설정 합니다."
  remarks: "이벤트 소스는 이벤트 로그를 나타냅니다. 것이 응용 프로그램의 이름 또는 하위 구성 요소는 응용 프로그램의 이름을 응용 프로그램이 큰 경우. 응용 프로그램 및 서비스 응용 프로그램 로그 나 사용자 지정 로그에 써야 합니다. 장치 드라이버 시스템 로그에 써야 합니다.       이벤트 로그에 작성 하는 경우 이벤트 소스를 지정 하기만 하면 됩니다. 이벤트 로그에 엔트리를 쓰기 전에 유효한 이벤트 소스로 이벤트 로그와 이벤트 소스를 등록 해야 있습니다. 로그 항목을 작성 하는 경우 입력 한 내용을 배치할 수 있는 적절 한 로그를 찾으려고 Source 속성을 사용 됩니다. 이벤트 로그를 읽는 경우 지정 하거나 원본 또는는 <xref:System.Diagnostics.EventLog.Log%2A>및 <xref:System.Diagnostics.EventLog.MachineName%2A>.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > 지정할 필요가 없습니다는 <xref:System.Diagnostics.EventLog.MachineName%2A>로그는 로컬 컴퓨터에 연결 하는 경우.</xref:System.Diagnostics.EventLog.MachineName%2A> 지정 하지 않는 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A>, 로컬 컴퓨터 (&quot;.&quot;)으로 간주 됩니다.</xref:System.Diagnostics.EventLog.MachineName%2A>       사용 하 여 <xref:System.Diagnostics.EventLog.WriteEvent%2A> <xref:System.Diagnostics.EventLog.WriteEntry%2A>이벤트 로그에 이벤트 쓰기</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.WriteEvent%2A> 이벤트를 작성 하는 이벤트 소스를 지정 해야 합니다. 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다.       응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>메서드.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.       기존 이벤트 로그 또는 새 이벤트 로그에 대 한 이벤트 소스를 만들 수 있습니다. 새 이벤트 로그에 대 한 새 원본을 만들 때 해당 로그에 대 한 소스를 등록 하는 시스템 하지만 첫 번째 항목에 기록할 때 까지는 로그가 만들어지지 않습니다.       소스는 로컬 컴퓨터에서 고유 해야 합니다. 새 소스 이름이 기존 원본 이름 또는 기존 이벤트 로그 이름과 일치할 수 없습니다. 각 소스; 한 번에 하나의 이벤트 로그에 쓸 수 있습니다. 그러나 응용 프로그램 여러 이벤트 로그에 쓸 수 여러 소스를 사용할 수 있습니다. 예를 들어 응용 프로그램에 다른 이벤트 로그 또는 서로 다른 리소스 파일에 대해 구성 된 여러 소스가 필요할 수 있습니다.       소스 값을 변경 하는 경우는 <xref:System.Diagnostics.EventLog>에 등록 되어 있는 닫혀 있으며 모든 이벤트 핸들이 해제 됩니다.</xref:System.Diagnostics.EventLog>       지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 해당 소스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>이벤트 로그에 대 한 리소스 식별자를 사용 하 여 항목을 작성 하는 메서드</xref:System.Diagnostics.EventLog.WriteEvent%2A> 를 사용 하 여 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       기존 소스 구성 세부 정보를 변경 하려면 소스를 삭제 하 고 새 구성으로 만듭니다. 다른 응용 프로그램이 나 구성 요소는 기존 소스를 사용 하는 경우 기존 소스를 삭제 하는 대신 업데이트 된 구성으로 새 소스를 만듭니다.      > [!NOTE] > 변경 내용 적용 하려면 컴퓨터를 다시 시작 해야 합니다는 원본 로그에 이미 매핑 되었습니다. 새 로그에 다시 매핑하려면을 합니다."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.Source Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_18_1.cs)]\n [!code-vb[Classic EventLog.Source Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_18_1.vb)]\n [!code-cpp[Classic EventLog.Source Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_18_1.cpp)]"
  syntax:
    content: public string Source { get; set; }
    return:
      type: System.String
      description: "항목의 소스로 이벤트 로그에 등록 된 이름입니다. 기본값은 빈 문자열 (&quot;&quot;)."
  overload: System.Diagnostics.EventLog.Source*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "소스 이름이 254 자를 넘는 레지스트리 키 경로에 발생합니다."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SourceExists(System.String)
  id: SourceExists(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SourceExists(String)
  nameWithType: EventLog.SourceExists(String)
  fullName: System.Diagnostics.EventLog.SourceExists(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "이벤트 소스가 로컬 컴퓨터에 등록 되었는지 여부를 결정 합니다."
  remarks: "이 메서드를 사용 하 여 이벤트 소스는 로컬 컴퓨터에 있는지 여부를 확인 합니다. 로컬 컴퓨터에 로그가 있는지 여부를 확인 하려는 경우 사용 <xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A>       이 메서드는 레지스트리를 액세스, 하므로 적절 한 레지스트리 사용 권한을 로컬 컴퓨터에 있어야 그렇지 않은 경우는 <xref:System.Security.SecurityException>throw 됩니다.</xref:System.Security.SecurityException>      > [!NOTE] > 이벤트 소스 Windows Vista 이상 또는 Windows Server 2003을 검색 하려면 관리자 권한이 있어야 합니다.   >>이 요구 사항에 대 한 이유 보안을 비롯 한 모든 이벤트 로그 이벤트 소스가 고유한 지 확인 하려면 검색 해야입니다. Windows Vista 이상에서는 사용자가 권한이 없습니다; 보안 로그에 액세스할 수 따라서 한 <xref:System.Security.SecurityException>throw 됩니다.</xref:System.Security.SecurityException>   >> Starting with Windows Vista 사용자 계정 컨트롤 (UAC)가 사용자 권한을 결정 합니다. 두 개의 런타임 액세스 토큰에 할당 된 기본 제공 Administrators 그룹의 구성원 인 경우: 표준 사용자 액세스 토큰 및 관리자 액세스 토큰입니다. 기본적으로 표준 사용자 역할에 속합니다. 성능 카운터에 액세스 하는 코드를 실행 하려면 먼저 높여야 귀하의 권한을 표준 사용자에서 관리자에 게 있습니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭 하 고 관리자 권한으로 실행 되도록 지정 하 여 응용 프로그램을 시작 하는 경우이 수행할 수 있습니다.      > [!NOTE] > 아래에서 실행 되 고 있는 서비스는 <xref:System.ServiceProcess.ServiceAccount>계정에이 메서드를 실행 하는 데 필요한 권한이 없는.</xref:System.ServiceProcess.ServiceAccount> 해결 방법은 이벤트 소스에 있는지 여부를 확인 하는 <xref:System.ServiceProcess.ServiceInstaller>, 존재, 소스를 만들려면 설치 프로그램의 경우.</xref:System.ServiceProcess.ServiceInstaller>       동일한 컴퓨터에서 기존 원본 이름 새 소스를 지정할 수 없습니다, 때문에이 메서드를 사용 하기 전에 호출할 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>되도록 원본으로 지정 된 이름의 `source` 로컬 컴퓨터에 이미 존재 하지 않습니다.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> `source` 매개 변수는 대/소문자 구분 하지 않습니다."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.Source Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_14_1.cs)]\n [!code-vb[Classic EventLog.Source Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_14_1.vb)]\n [!code-cpp[Classic EventLog.Source Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_14_1.cpp)]"
  syntax:
    content: public static bool SourceExists (string source);
    parameters:
    - id: source
      type: System.String
      description: "이벤트 원본의 이름입니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>이벤트 소스가 로컬 컴퓨터에 등록 하는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Diagnostics.EventLog.SourceExists*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<code>source</code>찾을 수 없는 했지만 일부 또는 모든 이벤트 로그를 검색할 수 없습니다."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  id: SourceExists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SourceExists(String,String)
  nameWithType: EventLog.SourceExists(String,String)
  fullName: System.Diagnostics.EventLog.SourceExists(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "이벤트 소스가 지정한 컴퓨터에 등록 되었는지 여부를 결정 합니다."
  remarks: "이 메서드를 사용 하 여 이벤트 소스에서 지정한 컴퓨터에 있는지 여부를 결정 하는 `machineName` 매개 변수입니다. 지정된 된 컴퓨터에 로그가 있는지 여부를 확인 하려는 경우 사용 <xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A>       이 메서드는 레지스트리를 액세스, 하므로 적절 한 레지스트리 사용 권한을 지정 된 서버에 있어야 그렇지 않은 경우는 <xref:System.Security.SecurityException>throw 됩니다.</xref:System.Security.SecurityException>      > [!NOTE] > 이벤트 소스 Windows Vista 이상 또는 Windows Server 2003을 검색 하려면 관리자 권한이 있어야 합니다.   >>이 요구 사항에 대 한 이유 보안을 비롯 한 모든 이벤트 로그 이벤트 소스가 고유한 지 확인 하려면 검색 해야입니다. Windows Vista 이상에서는 사용자가 권한이 없습니다; 보안 로그에 액세스할 수 따라서 한 <xref:System.Security.SecurityException>throw 됩니다.</xref:System.Security.SecurityException>   >> Starting with Windows Vista 사용자 계정 컨트롤 (UAC)가 사용자 권한을 결정 합니다. 두 개의 런타임 액세스 토큰에 할당 된 기본 제공 Administrators 그룹의 구성원 인 경우: 표준 사용자 액세스 토큰 및 관리자 액세스 토큰입니다. 기본적으로 표준 사용자 역할에 속합니다. 성능 카운터에 액세스 하는 코드를 실행 하려면 먼저 높여야 귀하의 권한을 표준 사용자에서 관리자에 게 있습니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭 하 고 관리자 권한으로 실행 되도록 지정 하 여 응용 프로그램을 시작 하는 경우이 수행할 수 있습니다.      > [!NOTE] > 아래에서 실행 되 고 있는 서비스는 <xref:System.ServiceProcess.ServiceAccount>계정에이 메서드를 실행 하는 데 필요한 권한이 없는.</xref:System.ServiceProcess.ServiceAccount> 해결 방법은 이벤트 소스에 있는지 여부를 확인 하는 <xref:System.ServiceProcess.ServiceInstaller>, 존재, 소스를 만들려면 설치 프로그램의 경우.</xref:System.ServiceProcess.ServiceInstaller>       동일한 컴퓨터에서 기존 원본 이름 새 소스를 지정할 수 없습니다, 때문에이 메서드를 사용 하기 전에 호출할 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>되도록 원본으로 지정 된 이름의 `source` 는 컴퓨터에 이미 존재 하지 않습니다.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> `source` 및 `machineName` 매개 변수는 대/소문자 구분 하지 않습니다.       <xref:System.Diagnostics.EventLog.SourceExists%2A>이 `static` 메서드, 클래스 자체에 호출할 수 있습니다.</xref:System.Diagnostics.EventLog.SourceExists%2A> <xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A> 호출</xref:System.Diagnostics.EventLog> 의 인스턴스를 만들 필요는 없습니다."
  example:
  - "The following example creates the source `MySource` on the computer `MyServer`, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_16_1.cpp)]\n [!code-cs[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_16_1.cs)]\n [!code-vb[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_16_1.vb)]"
  syntax:
    content: public static bool SourceExists (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "이벤트 원본의 이름입니다."
    - id: machineName
      type: System.String
      description: "이름에 검색할 컴퓨터 또는 &quot;.&quot; 로컬 컴퓨터에 대 한 합니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>이벤트 소스가 지정한 컴퓨터에 등록 하는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Diagnostics.EventLog.SourceExists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>machineName</code>잘못 된 컴퓨터 이름이입니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<code>source</code>찾을 수 없는 했지만 일부 또는 모든 이벤트 로그를 검색할 수 없습니다."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
  fullName: System.Diagnostics.EventLog.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "결과로 발생 하는 이벤트 처리기 호출을 마샬링하는 데 사용 되는 개체를 가져오거나 설정 합니다.는 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> 항목 쓰기 이벤트입니다."
  remarks: "SynchronizingObject 다음과 같은 경우 `null`를 처리 하는 메서드가 <xref:System.Diagnostics.EventLog.EntryWritten>이벤트 시스템 스레드 풀의 스레드라도에서 호출 됩니다.</xref:System.Diagnostics.EventLog.EntryWritten> 시스템 스레드 풀에 대 한 자세한 내용은 <xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool> 을 참조 하십시오.       경우는 <xref:System.Diagnostics.EventLog.EntryWritten>시스템 스레드 풀을 통해 구성 요소에 액세스 하는 단추와 같은 구성 요소가 작동 하지 않을 수 또는 예외가 발생할 수 있습니다는 Windows Forms 시각적 이벤트를 처리 합니다.</xref:System.Diagnostics.EventLog.EntryWritten> SynchronizingObject를 처리 하는 메서드가 Windows Forms 구성 요소를 설정 하 여이 문제를 방지는 <xref:System.Diagnostics.EventLog.EntryWritten>구성 요소를 만든 동일한 스레드에서 호출 이벤트입니다.</xref:System.Diagnostics.EventLog.EntryWritten>       경우는 <xref:System.Diagnostics.EventLog>안에서 사용 [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] Windows Forms 디자이너에서 SynchronizingObject로 자동 설정 됩니다 <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog> 를 포함 하는 컨트롤</xref:System.Diagnostics.EventLog> 예를 들어, 배치 하는 경우는 <xref:System.Diagnostics.EventLog>form1 디자이너에서 (에서 상속 되 <xref:System.Windows.Forms.Form>)의 SynchronizingObject 속성 <xref:System.Diagnostics.EventLog>Form1의 인스턴스로 설정 됩니다.</xref:System.Diagnostics.EventLog> </xref:System.Windows.Forms.Form> </xref:System.Diagnostics.EventLog>"
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "<xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref> 의 결과로 발생 하는 이벤트 처리기 호출을 마샬링하는 데 사용 된 <xref href=&quot;System.Diagnostics.EventLog.EntryWritten&quot;> </xref> 이벤트 로그에 이벤트입니다."
  overload: System.Diagnostics.EventLog.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String)
  id: WriteEntry(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String)
  nameWithType: EventLog.WriteEntry(String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "이벤트 로그에 지정 된 메시지 텍스트로 정보 형식 엔트리를 씁니다."
  remarks: "이 메서드를 사용 하 여이 연결 된 이벤트 로그에 정보 항목을 쓸 <xref:System.Diagnostics.EventLog>인스턴스.</xref:System.Diagnostics.EventLog> 기타 손해 <xref:System.Diagnostics.EventLogEntryType> <xref:System.Diagnostics.EventLog.WriteEntry%2A>안내 하십시오.</xref:System.Diagnostics.EventLog.WriteEntry%2A> 다른 오버 로드를 사용 하 여,</xref:System.Diagnostics.EventLogEntryType> 지정 하려는 경우      > [!NOTE] >는 `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.       <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog>로그에 항목을 작성 하려면 먼저 구성 요소</xref:System.Diagnostics.EventLog> 에서 속성</xref:System.Diagnostics.EventLog.Source%2A> 을 설정 해야 합니다. 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다.       응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>메서드.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.       소스에 지정 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A>속성 <xref:System.Diagnostics.EventLog>인스턴스 구성 요소를 작성 하는 컴퓨터에 등록 되지 않았습니다 <xref:System.Diagnostics.EventLog.WriteEntry%2A>호출 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>소스를 등록 하 고.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > 지정 하지 않을 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A>에 대 한 프로그램 <xref:System.Diagnostics.EventLog>호출 하기 전에 인스턴스 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>또는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 로컬 컴퓨터 (&quot;.&quot;)으로 간주 됩니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       시스템에서 <xref:System.Diagnostics.EventLog.Source%2A>호출 <xref:System.Diagnostics.EventLog.WriteEntry%2A>하 고 <xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog>인스턴스를 로그는 응용 프로그램 로그에 기본적</xref:System.Diagnostics.EventLog> 으로에 속성이 설정 되지 않았습니다</xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> 을 통해</xref:System.Diagnostics.EventLog.Source%2A> 등록 하는 데 필요한 경우      > [!NOTE] > 위에 나온 예외 목록의 대부분 <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A> 를 등록 하는 동안 발생 하는 오류 생성 되지만       지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A> 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A>메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 해당 소스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>이벤트 로그에 대 한 리소스 식별자를 사용 하 여 항목을 작성 하는 메서드</xref:System.Diagnostics.EventLog.WriteEvent%2A> 를 사용 하 여 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 원격 컴퓨터에 항목을 쓸 메시지 (텍스트 문자열)의 값 수 원격 컴퓨터의.NET Framework를 실행 하지 않는 경우 기대 합니다.      > [!NOTE] > 경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_7_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_7_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_7_1.vb)]"
  syntax:
    content: public void WriteEntry (string message);
    parameters:
    - id: message
      type: System.String
      description: "이벤트 로그에 쓸 문자열입니다."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이벤트 로그에 대 한 레지스트리 키를 열 수 없습니다."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "운영 체제 이벤트 로그에 이벤트 항목을 쓸 때 오류가 발생 했습니다. Windows 오류 코드를 사용할 수 없는 경우"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "이벤트 로그에 오류, 경고, 정보, 성공 감사 또는 실패 감사 엔트리 지정한 메시지 텍스트를 씁니다."
  remarks: "지정 된 <xref:System.Diagnostics.EventLogEntryType>이벤트 로그에</xref:System.Diagnostics.EventLogEntryType> 항목을 기록 하려면이 방법을 사용합니다 `type` 아이콘 및 텍스트 로그의 이벤트 뷰어에서 유형 열에 표시 됩니다.      > [!NOTE] >는 `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.       <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog>로그에 항목을 작성 하려면 먼저 구성 요소</xref:System.Diagnostics.EventLog> 에서 속성</xref:System.Diagnostics.EventLog.Source%2A> 을 설정 해야 합니다. 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다.       응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>메서드.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.       소스에 지정 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A>속성 <xref:System.Diagnostics.EventLog>인스턴스 구성 요소를 작성 하는 컴퓨터에 등록 되지 않았습니다 <xref:System.Diagnostics.EventLog.WriteEntry%2A>호출 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>소스를 등록 하 고.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > 지정 하지 않을 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A>에 대 한 프로그램 <xref:System.Diagnostics.EventLog>호출 하기 전에 인스턴스 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>또는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 로컬 컴퓨터 (&quot;.&quot;)으로 간주 됩니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       시스템에서 <xref:System.Diagnostics.EventLog.Source%2A>호출 <xref:System.Diagnostics.EventLog.WriteEntry%2A>하 고 <xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog>인스턴스를 로그는 응용 프로그램 로그에 기본적</xref:System.Diagnostics.EventLog> 으로에 속성이 설정 되지 않았습니다</xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> 을 통해</xref:System.Diagnostics.EventLog.Source%2A> 등록 하는 데 필요한 경우      > [!NOTE] > <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A> 를 등록 하는 동안 발생 한 오류에서 위에 나열 된 대부분의 예외 생성       지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A> 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A>메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 해당 소스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>이벤트 로그에 대 한 리소스 식별자를 사용 하 여 항목을 작성 하는 메서드</xref:System.Diagnostics.EventLog.WriteEvent%2A> 를 사용 하 여 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 원격 컴퓨터에 항목을 쓸 메시지 (텍스트 문자열)의 값 수 원격 컴퓨터의.NET Framework를 실행 하지 않는 경우 기대 합니다.      > [!NOTE] > 경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다."
  example:
  - "The following example writes a warning entry to an event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/cpp/19aeba79-224e-4604-90d9-_1.cpp)]\n [!code-cs[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/csharp/19aeba79-224e-4604-90d9-_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/visualbasic/19aeba79-224e-4604-90d9-_1.vb)]"
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);
    parameters:
    - id: message
      type: System.String
      description: "이벤트 로그에 쓸 문자열입니다."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "중 하나는 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> 값입니다."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>유효 하지 않거나 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>합니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이벤트 로그에 대 한 레지스트리 키를 열 수 없습니다."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "운영 체제 이벤트 로그에 이벤트 항목을 쓸 때 오류가 발생 했습니다. Windows 오류 코드를 사용할 수 없는 경우"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  id: WriteEntry(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String)
  nameWithType: EventLog.WriteEntry(String,String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "특정된 등록된 이벤트 소스를 사용 하 여 이벤트 로그에 지정 된 메시지 텍스트로 정보 형식 엔트리를 씁니다."
  remarks: "이 메서드를 사용 하 여 적절 한 로그에 대 한 이벤트 소스로 이미 등록 되어 있는 원본을 사용 하 여 이벤트 로그에 정보 항목을 기록 합니다. 기타 손해 <xref:System.Diagnostics.EventLogEntryType> <xref:System.Diagnostics.EventLog.WriteEntry%2A>안내 하십시오.</xref:System.Diagnostics.EventLog.WriteEntry%2A> 다른 오버 로드를 사용 하 여,</xref:System.Diagnostics.EventLogEntryType> 지정 하려는 경우       만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>메서드.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.       지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A> 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A>메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 해당 소스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>이벤트 로그에 대 한 리소스 식별자를 사용 하 여 항목을 작성 하는 메서드</xref:System.Diagnostics.EventLog.WriteEvent%2A> 를 사용 하 여 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다.   >>는 `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_3_1.cpp)]\n [!code-cs[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_3_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_3_1.vb)]"
  syntax:
    content: public static void WriteEntry (string source, string message);
    parameters:
    - id: source
      type: System.String
      description: "지정된 된 컴퓨터에 등록 되는 응용 프로그램의 소스입니다."
    - id: message
      type: System.String
      description: "이벤트 로그에 쓸 문자열입니다."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이벤트 로그에 대 한 레지스트리 키를 열 수 없습니다."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "운영 체제 이벤트 로그에 이벤트 항목을 쓸 때 오류가 발생 했습니다. Windows 오류 코드를 사용할 수 없는 경우"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "이벤트 로그에 응용 프로그램 정의 이벤트 식별자와 지정한 메시지 텍스트는 엔트리를 씁니다."
  remarks: "이 메서드를 사용 하 여 응용 프로그램 정의 된 `eventID` 이벤트 로그에 있습니다. `eventID` 소스와 함께 이벤트 고유 하 게 식별 합니다. 각 응용 프로그램 자체 번호가 매겨진된 이벤트 및 매핑되는 설명 문자열을 정의할 수 있습니다. 이벤트 뷰어 사용자가 오류를 확인 하 고 적절 한 조치를 수행할 수 있도록 이러한 문자열 값을 표시 합니다.      > [!NOTE] >는 `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.       이벤트 식별자와 함께 <xref:System.Diagnostics.EventLogEntryType>이벤트 로그에 쓰는 이벤트에 대해</xref:System.Diagnostics.EventLogEntryType> 지정할 수 있습니다. `type` 아이콘 및 텍스트 로그의 이벤트 뷰어에서 유형 열에 표시 됩니다. 이 매개 변수는 오류, 경고, 정보, 성공 감사 또는 실패 감사 이벤트 형식이 인지를 나타냅니다.       <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog>로그에 항목을 작성 하려면 먼저 구성 요소</xref:System.Diagnostics.EventLog> 에서 속성</xref:System.Diagnostics.EventLog.Source%2A> 을 설정 해야 합니다. 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다.       응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>메서드.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.       소스에 지정 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A>속성 <xref:System.Diagnostics.EventLog>인스턴스 구성 요소를 작성 하는 컴퓨터에 등록 되지 않았습니다 <xref:System.Diagnostics.EventLog.WriteEntry%2A>호출 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>소스를 등록 하 고.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > 지정 하지 않을 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A>에 대 한 프로그램 <xref:System.Diagnostics.EventLog>호출 하기 전에 인스턴스 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>또는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 로컬 컴퓨터 (&quot;.&quot;)으로 간주 됩니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       시스템에서 <xref:System.Diagnostics.EventLog.Source%2A>호출 <xref:System.Diagnostics.EventLog.WriteEntry%2A>하 고 <xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog>인스턴스를 로그는 응용 프로그램 로그에 기본적</xref:System.Diagnostics.EventLog> 으로에 속성이 설정 되지 않았습니다</xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> 을 통해</xref:System.Diagnostics.EventLog.Source%2A> 등록 하는 데 필요한 경우      > [!NOTE] > <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A> 를 등록 하는 동안 발생 한 오류에서 위에 나열 된 대부분의 예외 생성       지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A> 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A>메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 해당 소스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>이벤트 로그에 대 한 리소스 식별자를 사용 하 여 항목을 작성 하는 메서드</xref:System.Diagnostics.EventLog.WriteEvent%2A> 를 사용 하 여 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 원격 컴퓨터에 항목을 쓸 메시지 (텍스트 문자열)의 값 수 원격 컴퓨터의.NET Framework를 실행 하지 않는 경우 기대 합니다.      > [!NOTE] > 경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#3](~/add/codesnippet/cpp/597042ed-6d84-4ccf-a867-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#3](~/add/codesnippet/csharp/597042ed-6d84-4ccf-a867-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#3](~/add/codesnippet/visualbasic/597042ed-6d84-4ccf-a867-_1.vb)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);
    parameters:
    - id: message
      type: System.String
      description: "이벤트 로그에 쓸 문자열입니다."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "중 하나는 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> 값입니다."
    - id: eventID
      type: System.Int32
      description: "이벤트에 대 한 응용 프로그램별 식별자입니다."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이벤트 로그에 대 한 레지스트리 키를 열 수 없습니다."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>유효 하지 않거나 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>합니다."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "운영 체제 이벤트 로그에 이벤트 항목을 쓸 때 오류가 발생 했습니다. Windows 오류 코드를 사용할 수 없는 경우"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "특정된 등록된 이벤트 소스를 사용 하 여 이벤트 로그에 오류, 경고, 정보, 성공 감사 또는 실패 감사 엔트리 지정한 메시지 텍스트를 씁니다."
  remarks: "<xref:System.Diagnostics.EventLogEntryType>이벤트 로그에 적절 한 로그에 대 한 이벤트 소스로 이미 등록 된 소스를 사용 하 여</xref:System.Diagnostics.EventLogEntryType> 지정 된 항목을 기록 하려면이 방법을 사용합니다 `type` 아이콘 및 텍스트 로그의 이벤트 뷰어에서 유형 열에 표시 됩니다.      > [!NOTE] >는 `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.       만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>메서드.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.       지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A> 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A>메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 해당 소스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>이벤트 로그에 대 한 리소스 식별자를 사용 하 여 항목을 작성 하는 메서드</xref:System.Diagnostics.EventLog.WriteEvent%2A> 를 사용 하 여 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다."
  example:
  - "The following example writes a warning entry to an event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cs[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/csharp/c03f903c-8fbd-441f-afe0-_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/visualbasic/c03f903c-8fbd-441f-afe0-_1.vb)]\n [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/cpp/c03f903c-8fbd-441f-afe0-_1.cpp)]"
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);
    parameters:
    - id: source
      type: System.String
      description: "지정된 된 컴퓨터에 등록 되는 응용 프로그램의 소스입니다."
    - id: message
      type: System.String
      description: "이벤트 로그에 쓸 문자열입니다."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "중 하나는 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> 값입니다."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이벤트 로그에 대 한 레지스트리 키를 열 수 없습니다."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>유효 하지 않거나 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>합니다."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "운영 체제 이벤트 로그에 이벤트 항목을 쓸 때 오류가 발생 했습니다. Windows 오류 코드를 사용할 수 없는 경우"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "이벤트 로그에 지정 된 메시지 텍스트, 응용 프로그램 정의 이벤트 식별자 및 응용 프로그램 정의 범주로 엔트리를 씁니다."
  remarks: "이 메서드를 사용 하 여 응용 프로그램 정의 된 `category` 이벤트 로그에 있습니다. 이벤트 뷰어에서 이벤트 소스를 기록한 이벤트를 필터링 하려면 범주를 사용 합니다. 이벤트 뷰어를 숫자 값으로 범주를 표시할 수 있습니다 또는 지역화 된 범주 문자열을 표시 하는 범주를 리소스 식별자로 사용할 수 있습니다.      > [!NOTE] >는 `category` 매개 변수는 양수 값 이어야 합니다. 음수 범주 값 뷰어를 이벤트에 상호 보완적인 양수 표시 됩니다. 예를 들어 – 10 65,526 나타납니다.      > [!NOTE] >는 `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.       이벤트 뷰어에서 지역화 된 범주 문자열을 표시 하려면 범주 리소스 파일을 사용 하 여 구성 하 고 설정 이벤트 소스를 사용 해야 합니다는 `category` 범주 리소스 파일의 리소스 식별자로. 구성된 범주 리소스 파일 또는 지정 된 이벤트 소스에 없는 경우 `category` 이벤트 뷰어에서 해당 항목에 대 한 숫자 범주 값 표시 한 다음 category 리소스 파일에 문자열을 인덱싱하지 않습니다. 범주 리소스 파일에서 <xref:System.Diagnostics.EventLogInstaller>또는 <xref:System.Diagnostics.EventSourceCreationData>클래스</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller> 를 사용 하 여 리소스 파일에서 범주 문자열 수와 함께 구성       범주와 함께 이벤트 로그에 기록 되 고 이벤트에 대 한 이벤트 식별자를 지정할 수 있습니다. 이벤트 소스와 함께 이벤트 식별자는 고유 하 게 이벤트를 식별 합니다. 각 응용 프로그램 자체 번호가 매겨진된 이벤트 및 매핑되는 설명 문자열을 정의할 수 있습니다. 이벤트 뷰어 사용자가 오류를 확인 하 고 적절 한 조치를 수행할 수 있도록 이러한 문자열 값을 표시 합니다.       <xref:System.Diagnostics.EventLogEntryType>이벤트 로그에 쓰는 이벤트에 대해</xref:System.Diagnostics.EventLogEntryType> 지정할 수 있는 마지막으로, `type` 아이콘 및 텍스트 로그의 이벤트 뷰어에서 유형 열에 표시 됩니다. 이 매개 변수는 오류, 경고, 정보, 성공 감사 또는 실패 감사 이벤트 형식이 인지를 나타냅니다.       <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog>로그에 항목을 작성 하려면 먼저 구성 요소</xref:System.Diagnostics.EventLog> 에서 속성</xref:System.Diagnostics.EventLog.Source%2A> 을 설정 해야 합니다. 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다.       응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>메서드.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.       소스에 지정 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A>속성 <xref:System.Diagnostics.EventLog>인스턴스 구성 요소를 작성 하는 컴퓨터에 등록 되지 않았습니다 <xref:System.Diagnostics.EventLog.WriteEntry%2A>호출 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>소스를 등록 하 고.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > 지정 하지 않을 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A>에 대 한 프로그램 <xref:System.Diagnostics.EventLog>호출 하기 전에 인스턴스 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>또는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 로컬 컴퓨터 (&quot;.&quot;)으로 간주 됩니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       시스템에서 <xref:System.Diagnostics.EventLog.Source%2A>호출 <xref:System.Diagnostics.EventLog.WriteEntry%2A>하 고 <xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog>인스턴스를 로그는 응용 프로그램 로그에 기본적</xref:System.Diagnostics.EventLog> 으로에 속성이 설정 되지 않았습니다</xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> 을 통해</xref:System.Diagnostics.EventLog.Source%2A> 등록 하는 데 필요한 경우      > [!NOTE] > <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A> 를 등록 하는 동안 발생 한 오류에서 위에 나열 된 대부분의 예외 생성       지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A> 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A>메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 해당 소스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>이벤트 로그에 대 한 리소스 식별자를 사용 하 여 항목을 작성 하는 메서드</xref:System.Diagnostics.EventLog.WriteEvent%2A> 를 사용 하 여 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 원격 컴퓨터에 항목을 쓸 메시지 (텍스트 문자열)의 값 수 원격 컴퓨터의.NET Framework를 실행 하지 않는 경우 기대 합니다.      > [!NOTE] > 경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#3](~/add/codesnippet/cpp/b3db94bc-a96c-4168-a8f0-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#3](~/add/codesnippet/csharp/b3db94bc-a96c-4168-a8f0-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#3](~/add/codesnippet/visualbasic/b3db94bc-a96c-4168-a8f0-_1.vb)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);
    parameters:
    - id: message
      type: System.String
      description: "이벤트 로그에 쓸 문자열입니다."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "중 하나는 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> 값입니다."
    - id: eventID
      type: System.Int32
      description: "이벤트에 대 한 응용 프로그램별 식별자입니다."
    - id: category
      type: System.Int16
      description: "메시지에 연결 된 응용 프로그램별 하위 범주입니다."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이벤트 로그에 대 한 레지스트리 키를 열 수 없습니다."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>유효 하지 않거나 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>합니다."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "운영 체제 이벤트 로그에 이벤트 항목을 쓸 때 오류가 발생 했습니다. Windows 오류 코드를 사용할 수 없는 경우"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "특정된 등록된 이벤트 소스를 사용 하 여 이벤트 로그에 응용 프로그램 정의 이벤트 식별자와 지정한 메시지 텍스트는 엔트리를 씁니다."
  remarks: "이 메서드를 사용 하 여 응용 프로그램 정의 된 `eventID` 적절 한 로그에 대 한 이벤트 소스로 이벤트 로그에는 소스를 이미 사용 하 여 등록 합니다. `eventID`는 소스와 함께 이벤트 고유 하 게 식별 합니다. 각 응용 프로그램 자체 번호가 매겨진된 이벤트 및 매핑되는 설명 문자열을 정의할 수 있습니다. 이벤트 뷰어 사용자가 오류를 확인 하 고 적절 한 조치를 수행할 수 있도록 사용자에 게 이러한 문자열을 표시 합니다.      > [!NOTE] >는 `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.       <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLogEntryType>이벤트 로그에 쓰는 이벤트에 대 한</xref:System.Diagnostics.EventLogEntryType> 지정 하면</xref:System.Diagnostics.EventLog.WriteEntry%2A> 이 오버 로드 이벤트 식별자 `type` 아이콘 및 텍스트 로그의 이벤트 뷰어에서 유형 열에 표시 됩니다. 이 매개 변수는 오류, 경고, 정보, 성공 감사 또는 실패 감사 이벤트 형식이 인지를 나타냅니다.       만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>메서드.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.       지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A> 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A>메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 해당 소스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>이벤트 로그에 대 한 리소스 식별자를 사용 하 여 항목을 작성 하는 메서드</xref:System.Diagnostics.EventLog.WriteEvent%2A> 를 사용 하 여 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다."
  example:
  - >-
    [!code-cs[EventLog_WriteEntry_4#1](~/add/codesnippet/csharp/2d8498b8-a54d-48c9-9ee7-_1.cs)]
     [!code-cpp[EventLog_WriteEntry_4#1](~/add/codesnippet/cpp/2d8498b8-a54d-48c9-9ee7-_1.cpp)]
     [!code-vb[EventLog_WriteEntry_4#1](~/add/codesnippet/visualbasic/2d8498b8-a54d-48c9-9ee7-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);
    parameters:
    - id: source
      type: System.String
      description: "지정된 된 컴퓨터에 등록 되는 응용 프로그램의 소스입니다."
    - id: message
      type: System.String
      description: "이벤트 로그에 쓸 문자열입니다."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "중 하나는 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> 값입니다."
    - id: eventID
      type: System.Int32
      description: "이벤트에 대 한 응용 프로그램별 식별자입니다."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이벤트 로그에 대 한 레지스트리 키를 열 수 없습니다."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>유효 하지 않거나 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>합니다."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "운영 체제 이벤트 로그에 이벤트 항목을 쓸 때 오류가 발생 했습니다. Windows 오류 코드를 사용할 수 없는 경우"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "지정한 메시지 텍스트, 응용 프로그램 정의 이벤트 식별자 및 응용 프로그램 정의 범주로 엔트리 이벤트 로그에 쓰고 메시지에 이진 데이터를 추가 합니다."
  remarks: "이 오버 로드를 사용 하 여 이벤트 로그에 이벤트 관련 응용 프로그램 정의 데이터를 쓰려고 합니다. 이벤트 뷰어는이 데이터를 해석 하지 않으므로 원시 데이터는 결합 된&16; 진수 및 텍스트 형식에만 표시 됩니다. 사용 이벤트 관련 데이터는 것은 문제를 디버깅 하는 사람에 게 유용한 경우에 포함 합니다. 또한 응용 프로그램 이벤트 뷰어 독립적으로 처리할 수 정보를 저장할 이벤트 관련 데이터를 사용할 수 있습니다. 예를 들어 사용자 이벤트에 대해 특별히 뷰어를 작성 하거나 이벤트 관련 데이터에서 정보를 포함 하는 보고서를 만들고 로그 파일을 검색 하는 프로그램을 작성할 수 있습니다.       이진 데이터 뿐만 아니라 응용 프로그램 정의 된 범주 및 응용 프로그램 정의 이벤트 식별자를 지정할 수 있습니다. 이벤트 뷰어에서 이벤트 소스를 기록한 이벤트를 필터링 하려면 범주를 사용 합니다. 이벤트 뷰어를 숫자 값으로 범주를 표시할 수 있습니다 또는 지역화 된 범주 문자열을 표시 하는 범주를 리소스 식별자로 사용할 수 있습니다.      > [!NOTE] >는 `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.      > [!NOTE] >는 `category` 매개 변수는 양수 값 이어야 합니다. 음수 범주 값 뷰어를 이벤트에 상호 보완적인 양수 표시 됩니다. 예를 들어 – 10 65,526 나타납니다.       이벤트 뷰어에서 지역화 된 범주 문자열을 표시 하려면 범주 리소스 파일을 사용 하 여 구성 하 고 설정 이벤트 소스를 사용 해야 합니다는 `category` 범주 리소스 파일의 리소스 식별자로. 구성된 범주 리소스 파일 또는 지정 된 이벤트 소스에 없는 경우 `category` 이벤트 뷰어에서 해당 항목에 대 한 숫자 범주 값 표시 한 다음 category 리소스 파일에 문자열을 인덱싱하지 않습니다. 범주 리소스 파일에서 <xref:System.Diagnostics.EventLogInstaller>또는 <xref:System.Diagnostics.EventSourceCreationData>클래스</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller> 를 사용 하 여 리소스 파일에서 범주 문자열 수와 함께 구성       이벤트 소스와 함께 이벤트 식별자는 고유 하 게 이벤트를 식별 합니다. 각 응용 프로그램 자체 번호가 매겨진된 이벤트 및 매핑되는 설명 문자열을 정의할 수 있습니다. 이벤트 뷰어 사용자가 오류를 확인 하 고 적절 한 조치를 수행할 수 있도록 이러한 문자열 값을 표시 합니다.       <xref:System.Diagnostics.EventLogEntryType>이벤트 로그에 쓰는 이벤트에 대해</xref:System.Diagnostics.EventLogEntryType> 지정할 수 있는 마지막으로, `type` 아이콘 및 텍스트 로그의 이벤트 뷰어에서 유형 열에 표시 됩니다. 이 매개 변수는 오류, 경고, 정보, 성공 감사 또는 실패 감사 이벤트 형식이 인지를 나타냅니다.       <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog>로그에 항목을 작성 하려면 먼저 구성 요소</xref:System.Diagnostics.EventLog> 에서 속성</xref:System.Diagnostics.EventLog.Source%2A> 을 설정 해야 합니다. 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다.       응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>메서드.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.       소스에 지정 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A>속성 <xref:System.Diagnostics.EventLog>인스턴스 구성 요소를 작성 하는 컴퓨터에 등록 되지 않았습니다 <xref:System.Diagnostics.EventLog.WriteEntry%2A>호출 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>소스를 등록 하 고.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > 지정 하지 않을 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A>에 대 한 프로그램 <xref:System.Diagnostics.EventLog>호출 하기 전에 인스턴스 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>또는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 로컬 컴퓨터 (&quot;.&quot;)으로 간주 됩니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       시스템에서 <xref:System.Diagnostics.EventLog.Source%2A>호출 <xref:System.Diagnostics.EventLog.WriteEntry%2A>하 고 <xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog>인스턴스를 로그는 응용 프로그램 로그에 기본적</xref:System.Diagnostics.EventLog> 으로에 속성이 설정 되지 않았습니다</xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> 을 통해</xref:System.Diagnostics.EventLog.Source%2A> 등록 하는 데 필요한 경우      > [!NOTE] > <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A> 를 등록 하는 동안 발생 한 오류에서 위에 나열 된 대부분의 예외 생성       지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A> 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A>메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 해당 소스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>이벤트 로그에 대 한 리소스 식별자를 사용 하 여 항목을 작성 하는 메서드</xref:System.Diagnostics.EventLog.WriteEvent%2A> 를 사용 하 여 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 원격 컴퓨터에 항목을 쓸 메시지 (텍스트 문자열)의 값 수 원격 컴퓨터의.NET Framework를 실행 하지 않는 경우 기대 합니다.      > [!NOTE] > 경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다."
  example:
  - >-
    [!code-cs[EventLog_WriteEntry_5#1](~/add/codesnippet/csharp/1c6518b6-dc55-4c74-9028-_1.cs)]
     [!code-vb[EventLog_WriteEntry_5#1](~/add/codesnippet/visualbasic/1c6518b6-dc55-4c74-9028-_1.vb)]
     [!code-cpp[EventLog_WriteEntry_5#1](~/add/codesnippet/cpp/1c6518b6-dc55-4c74-9028-_1.cpp)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);
    parameters:
    - id: message
      type: System.String
      description: "이벤트 로그에 쓸 문자열입니다."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "중 하나는 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> 값입니다."
    - id: eventID
      type: System.Int32
      description: "이벤트에 대 한 응용 프로그램별 식별자입니다."
    - id: category
      type: System.Int16
      description: "메시지에 연결 된 응용 프로그램별 하위 범주입니다."
    - id: rawData
      type: System.Byte[]
      description: "항목과 연관 된 이진 데이터를 보유 하는 바이트 배열입니다."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이벤트 로그에 대 한 레지스트리 키를 열 수 없습니다."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>유효 하지 않거나 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>합니다."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "운영 체제 이벤트 로그에 이벤트 항목을 쓸 때 오류가 발생 했습니다. Windows 오류 코드를 사용할 수 없는 경우"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "특정된 등록된 이벤트 소스를 사용 하 여 이벤트 로그에 지정 된 메시지 텍스트, 응용 프로그램 정의 이벤트 식별자 및 응용 프로그램 정의 범주로 엔트리를 씁니다. <code> category </code> 이벤트 뷰어 로그의 이벤트를 필터링 하 여 사용할 수 있습니다."
  remarks: "이 메서드를 사용 하 여 응용 프로그램 정의 된 `category` 이벤트 로그에 적절 한 로그에 대 한 이벤트 소스로 이미 등록 되어 있는 소스를 사용 합니다. 이벤트 뷰어에서 이벤트 소스를 기록한 이벤트를 필터링 하려면 범주를 사용 합니다. 이벤트 뷰어를 숫자 값으로 범주를 표시할 수 있습니다 또는 지역화 된 범주 문자열을 표시 하는 범주를 리소스 식별자로 사용할 수 있습니다.      > [!NOTE] >는 `category` 매개 변수는 양수 값 이어야 합니다. 음수 범주 값 뷰어를 이벤트에 상호 보완적인 양수 표시 됩니다. 예를 들어 – 10 65,526 나타납니다.       이벤트 뷰어에서 지역화 된 범주 문자열을 표시 하려면 범주 리소스 파일을 사용 하 여 구성 하 고 설정 이벤트 소스를 사용 해야 합니다는 `category` 범주 리소스 파일의 리소스 식별자로. 구성된 범주 리소스 파일 또는 지정 된 이벤트 소스에 없는 경우 `category` 이벤트 뷰어에서 해당 항목에 대 한 숫자 범주 값 표시 한 다음 category 리소스 파일에 문자열을 인덱싱하지 않습니다. 범주 리소스 파일에서 <xref:System.Diagnostics.EventLogInstaller>또는 <xref:System.Diagnostics.EventSourceCreationData>클래스</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller> 를 사용 하 여 리소스 파일에서 범주 문자열 수와 함께 구성       범주와 함께 이벤트 로그에 기록 되 고 이벤트에 대 한 이벤트 식별자를 지정할 수 있습니다. 이벤트 소스와 함께 이벤트 식별자는 고유 하 게 이벤트를 식별 합니다. 각 응용 프로그램 자체 번호가 매겨진된 이벤트 및 매핑되는 설명 문자열을 정의할 수 있습니다. 이벤트 뷰어 사용자가 오류를 확인 하 고 적절 한 조치를 수행할 수 있도록 이러한 문자열 값을 표시 합니다.       <xref:System.Diagnostics.EventLogEntryType>이벤트 로그에 쓰는 이벤트에 대해</xref:System.Diagnostics.EventLogEntryType> 지정할 수 있는 마지막으로, `type` 아이콘 및 텍스트 로그의 이벤트 뷰어에서 유형 열에 표시 됩니다. 이 매개 변수는 오류, 경고, 정보, 성공 감사 또는 실패 감사 이벤트 형식이 인지를 나타냅니다.       만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>메서드.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.       지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A> 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A>메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 해당 소스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>이벤트 로그에 대 한 리소스 식별자를 사용 하 여 항목을 작성 하는 메서드</xref:System.Diagnostics.EventLog.WriteEvent%2A> 를 사용 하 여 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다.   >>는 `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#1](~/add/codesnippet/cpp/189fd615-c100-4e72-9c0b-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#1](~/add/codesnippet/csharp/189fd615-c100-4e72-9c0b-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#1](~/add/codesnippet/visualbasic/189fd615-c100-4e72-9c0b-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);
    parameters:
    - id: source
      type: System.String
      description: "지정된 된 컴퓨터에 등록 되는 응용 프로그램의 소스입니다."
    - id: message
      type: System.String
      description: "이벤트 로그에 쓸 문자열입니다."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "중 하나는 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> 값입니다."
    - id: eventID
      type: System.Int32
      description: "이벤트에 대 한 응용 프로그램별 식별자입니다."
    - id: category
      type: System.Int16
      description: "메시지에 연결 된 응용 프로그램별 하위 범주입니다."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이벤트 로그에 대 한 레지스트리 키를 열 수 없습니다."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>유효 하지 않거나 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>합니다."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "운영 체제 이벤트 로그에 이벤트 항목을 쓸 때 오류가 발생 했습니다. Windows 오류 코드를 사용할 수 없는 경우"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "지정한 메시지 텍스트, 응용 프로그램 정의 이벤트 식별자 및 응용 프로그램 정의 범주로 엔트리 (특정된 등록된 이벤트 소스를 사용 하 여) 이벤트 로그에 쓰고 메시지에 이진 데이터를 추가 합니다."
  remarks: "이 메서드를 사용 하 여 적절 한 로그에 대 한 이벤트 소스로 이미 등록 된 소스를 사용 하 여 이벤트 로그에 이벤트 관련 응용 프로그램 정의 데이터를 쓰려고 합니다. 이벤트 뷰어는이 데이터를 해석 하지 않으므로 원시 데이터는 결합 된&16; 진수 및 텍스트 형식에만 표시 됩니다. 이벤트 관련 데이터를 사용 하 여 엄밀한; 유용할 것 경우에 포함 합니다. 또한 응용 프로그램 이벤트 뷰어 독립적으로 처리할 수 정보를 저장할 이벤트 관련 데이터를 사용할 수 있습니다. 예를 들어 사용자 이벤트에 대해 특별히 뷰어를 작성 하거나 이벤트 관련 데이터에서 정보를 포함 하는 보고서를 만들고 로그 파일을 검색 하는 프로그램을 작성할 수 있습니다.       이진 데이터 뿐만 아니라 응용 프로그램 정의 된 범주 및 응용 프로그램 정의 이벤트 식별자를 지정할 수 있습니다. 이벤트 뷰어에서 이벤트 소스를 기록한 이벤트를 필터링 하려면 범주를 사용 합니다. 이벤트 뷰어를 숫자 값으로 범주를 표시할 수 있습니다 또는 지역화 된 범주 문자열을 표시 하는 범주를 리소스 식별자로 사용할 수 있습니다.      > [!NOTE] >는 `category` 매개 변수는 양수 값 이어야 합니다. 음수 범주 값 뷰어를 이벤트에 상호 보완적인 양수 표시 됩니다. 예를 들어 – 10 65,526 표시 됩니다.       이벤트 뷰어에서 지역화 된 범주 문자열을 표시 하려면 범주 리소스 파일을 사용 하 여 구성 하 고 설정 이벤트 소스를 사용 해야 합니다는 `category` 범주 리소스 파일의 리소스 식별자로. 구성된 범주 리소스 파일 또는 지정 된 이벤트 소스에 없는 경우 `category` 이벤트 뷰어에서 해당 항목에 대 한 숫자 범주 값 표시 한 다음 category 리소스 파일에 문자열을 인덱싱하지 않습니다. 범주 리소스 파일에서 <xref:System.Diagnostics.EventLogInstaller>또는 <xref:System.Diagnostics.EventSourceCreationData>클래스</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller> 를 사용 하 여 리소스 파일에서 범주 문자열 수와 함께 구성       이벤트 소스와 함께 이벤트 식별자는 고유 하 게 이벤트를 식별 합니다. 각 응용 프로그램 자체 번호가 매겨진된 이벤트 및 매핑되는 설명 문자열을 정의할 수 있습니다. 이벤트 뷰어 사용자가 오류를 확인 하 고 적절 한 조치를 수행할 수 있도록 이러한 문자열 값을 표시 합니다.       <xref:System.Diagnostics.EventLogEntryType>이벤트 로그에 쓰는 이벤트에 대해</xref:System.Diagnostics.EventLogEntryType> 지정할 수 있는 마지막으로, `type` 아이콘 및 텍스트 로그의 이벤트 뷰어에서 유형 열에 표시 됩니다. 이 매개 변수는 오류, 경고, 정보, 성공 감사 또는 실패 감사 이벤트 형식이 인지를 나타냅니다.       만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>메서드.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.       지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A> 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A>메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 해당 소스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>이벤트 로그에 대 한 리소스 식별자를 사용 하 여 항목을 작성 하는 메서드</xref:System.Diagnostics.EventLog.WriteEvent%2A> 를 사용 하 여 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다.   >>는 `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#2](~/add/codesnippet/cpp/0b90a83a-dcc8-46e6-a8db-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#2](~/add/codesnippet/csharp/0b90a83a-dcc8-46e6-a8db-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#2](~/add/codesnippet/visualbasic/0b90a83a-dcc8-46e6-a8db-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);
    parameters:
    - id: source
      type: System.String
      description: "지정된 된 컴퓨터에 등록 되는 응용 프로그램의 소스입니다."
    - id: message
      type: System.String
      description: "이벤트 로그에 쓸 문자열입니다."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "중 하나는 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> 값입니다."
    - id: eventID
      type: System.Int32
      description: "이벤트에 대 한 응용 프로그램별 식별자입니다."
    - id: category
      type: System.Int16
      description: "메시지에 연결 된 응용 프로그램별 하위 범주입니다."
    - id: rawData
      type: System.Byte[]
      description: "항목과 연관 된 이진 데이터를 보유 하는 바이트 배열입니다."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>유효 하지 않거나 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>합니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이벤트 로그에 대 한 레지스트리 키를 열 수 없습니다."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "운영 체제 이벤트 로그에 이벤트 항목을 쓸 때 오류가 발생 했습니다. Windows 오류 코드를 사용할 수 없는 경우"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  id: WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "이벤트 로그에 지역화 된 엔트리를 씁니다."
  remarks: "이 메서드를 사용 하 여 이벤트 로그에 지역화 된 엔트리를 씁니다. 문자열 값이 아닌 리소스 식별자와 함께 이벤트 속성을 지정 합니다. 이벤트 뷰어에서 리소스 식별자를 사용 하 여 <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A> 에 대 한 지역화 된 리소스 파일에서 해당 문자열 표시 리소스 식별자를 사용 하 여 이벤트를 작성 하기 전에 해당 리소스 파일에는 소스를 등록 해야 합니다.       입력 `instance` 인스턴스 이벤트 메시지 및 속성을 지정 합니다. 설정의 <xref:System.Diagnostics.EventInstance.InstanceId%2A>의 `instance` 소스 메시지 리소스 파일에서 정의 된 메시지에 대 한 입력.</xref:System.Diagnostics.EventInstance.InstanceId%2A> 선택적으로 설정할 수는 <xref:System.Diagnostics.EventInstance.CategoryId%2A>및 <xref:System.Diagnostics.EventInstance.EntryType%2A>의 `instance` 이벤트 항목의 범주 및 이벤트 유형을 정의 하는 입력.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> 지역화 된 메시지 텍스트에 삽입 하는 언어에 관계 없이 문자열의 배열을 지정할 수도 있습니다. 설정 `values` 를 `null` 이벤트 메시지 대체 문자열에 대 한 서식 지정 자리 표시자 포함 되어 있지 않습니다.       <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> 사용 하기 전에 구성 요소</xref:System.Diagnostics.EventLog> 에서 속성</xref:System.Diagnostics.EventLog.Source%2A> 을 설정 해야 합니다. 로그에 지역화 된 엔트리를 쓰기 위한 지정한 소스를 구성 합니다. 소스에 최소한 있어야 메시지 리소스 파일을 정의 합니다.       만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>메서드.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.       지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A>응용 프로그램 이벤트 로그에 직접 문자열 값을 쓰는 경우 메서드</xref:System.Diagnostics.EventLog.WriteEntry%2A> 를 사용 하 여       리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 해당 소스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>이벤트 로그에 대 한 리소스 식별자를 사용 하 여 항목을 작성 하는 메서드</xref:System.Diagnostics.EventLog.WriteEvent%2A> 를 사용 하 여 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] >는 원격 컴퓨터의 값에 항목을 기록 하는 경우는 `message` 문자열 원격 컴퓨터의.NET Framework를 실행 하지 않는 경우 예상 되지 않을 수 있습니다. 또한는 `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다."
  example:
  - "The following example writes two audit entries to the event log `myNewLog`. The example creates a new event source and a new event log if they do not exist on the local computer. The event message text is specified using a resource identifier in a resource file.  \n  \n [!code-cpp[EventLog_WriteEvent#7](~/add/codesnippet/cpp/6a714dbf-bcbc-4f5a-a8b4-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#7](~/add/codesnippet/visualbasic/6a714dbf-bcbc-4f5a-a8b4-_1.vb)]\n [!code-cs[EventLog_WriteEvent#7](~/add/codesnippet/csharp/6a714dbf-bcbc-4f5a-a8b4-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void WriteEvent (System.Diagnostics.EventInstance instance, object[] values);
    parameters:
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> 지역화 된 이벤트 로그 엔트리를 나타내는 인스턴스입니다."
    - id: values
      type: System.Object[]
      description: "이벤트 로그 항목의 메시지 텍스트로 병합 될 문자열의 배열입니다."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이벤트 로그에 대 한 레지스트리 키를 열 수 없습니다."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "운영 체제 이벤트 로그에 이벤트 항목을 쓸 때 오류가 발생 했습니다. Windows 오류 코드를 사용할 수 없는 경우"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  id: WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Byte[],Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "지정 된 이벤트 데이터, 메시지 대체 문자열 및 관련된 이진 데이터가 포함 된 이벤트 로그 엔트리를 씁니다."
  remarks: "이 메서드를 사용 하 여 이벤트 로그에 이벤트 관련 데이터가 추가 지역화 된 엔트리를 씁니다. 문자열 값이 아닌 리소스 식별자와 함께 이벤트 속성을 지정 합니다. 이벤트 뷰어에서 리소스 식별자를 사용 하 여 <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A> 에 대 한 지역화 된 리소스 파일에서 해당 문자열 표시 리소스 식별자를 사용 하 여 이벤트를 작성 하기 전에 해당 리소스 파일에는 소스를 등록 해야 합니다.       입력 `instance` 인스턴스 이벤트 메시지 및 속성을 지정 합니다. 설정의 <xref:System.Diagnostics.EventInstance.InstanceId%2A>의 `instance` 소스 메시지 리소스 파일에서 정의 된 메시지에 대 한 입력.</xref:System.Diagnostics.EventInstance.InstanceId%2A> 선택적으로 설정할 수는 <xref:System.Diagnostics.EventInstance.CategoryId%2A>및 <xref:System.Diagnostics.EventInstance.EntryType%2A>의 `instance` 이벤트 항목의 범주 및 이벤트 유형을 정의 하는 입력.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> 지역화 된 메시지 텍스트에 삽입 하는 언어에 관계 없이 문자열의 배열을 지정할 수도 있습니다. 설정 `values` 를 `null` 이벤트 메시지 대체 문자열에 대 한 서식 지정 자리 표시자 포함 되어 있지 않습니다.       이진 데이터는 이벤트에 대 한 추가 정보를 제공 해야 하는 경우의 이벤트를 지정 합니다. 예를 들어, 사용 된 `data` 특정 오류에 대 한 정보를 포함 하도록 매개 변수입니다. 이벤트 뷰어에서 관련된 이벤트 데이터를 해석 하지는 않습니다. 결합 된&16; 진수 및 텍스트 형식에서 데이터를 표시합니다. 이벤트 관련 데이터를 사용 하 여 엄밀한; 유용할 것 경우에 포함 합니다. 또한 응용 프로그램 이벤트 뷰어 독립적으로 처리할 수 정보를 저장할 이벤트 관련 데이터를 사용할 수 있습니다. 예를 들어 뷰어를 사용자 이벤트에 대해 특별히 작성 하거나 이벤트 로그를 검사 하 고 이벤트 관련 데이터에서 정보를 포함 하는 보고서를 만듭니다는 프로그램을 작성할 수 있습니다.       <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog>구성 요소 <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> 사용 하기 전에 하기 전에 구성 요소</xref:System.Diagnostics.EventLog> 에서 속성</xref:System.Diagnostics.EventLog.Source%2A> 을 설정 해야 합니다. 로그에 지역화 된 엔트리를 쓰기 위한 지정한 소스를 구성 합니다. 소스에 최소한 있어야 메시지 리소스 파일을 정의 합니다.       만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>메서드.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.      > [!NOTE] > 지정 하지 않을 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A>에 대 한 프로그램 <xref:System.Diagnostics.EventLog>호출 하기 전에 인스턴스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>, 로컬 컴퓨터 (&quot;.&quot;)으로 간주 됩니다.</xref:System.Diagnostics.EventLog.WriteEvent%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A>응용 프로그램 이벤트 로그에 직접 문자열 값을 쓰는 경우 메서드</xref:System.Diagnostics.EventLog.WriteEntry%2A> 를 사용 하 여       리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 해당 소스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>이벤트 로그에 대 한 리소스 식별자를 사용 하 여 항목을 작성 하는 메서드</xref:System.Diagnostics.EventLog.WriteEvent%2A> 를 사용 하 여 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] >는 원격 컴퓨터의 값에 항목을 기록 하는 경우는 `message` 문자열 원격 컴퓨터의.NET Framework를 실행 하지 않는 경우 예상 되지 않을 수 있습니다. 또한는 `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다."
  example:
  - "The following example writes two audit entries to the event log `myNewLog`. The example creates a new event source and a new event log if they do not exist on the local computer. The event message text is specified using a resource identifier in a resource file.  \n  \n [!code-cpp[EventLog_WriteEvent#7](~/add/codesnippet/cpp/9c997f17-0108-4c5c-b894-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#7](~/add/codesnippet/visualbasic/9c997f17-0108-4c5c-b894-_1.vb)]\n [!code-cs[EventLog_WriteEvent#7](~/add/codesnippet/csharp/9c997f17-0108-4c5c-b894-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, object[] values);
    parameters:
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> 지역화 된 이벤트 로그 엔트리를 나타내는 인스턴스입니다."
    - id: data
      type: System.Byte[]
      description: "항목과 연관 된 이진 데이터를 보유 하는 바이트 배열입니다."
    - id: values
      type: System.Object[]
      description: "이벤트 로그 항목의 메시지 텍스트로 병합 될 문자열의 배열입니다."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이벤트 로그에 대 한 레지스트리 키를 열 수 없습니다."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "운영 체제 이벤트 로그에 이벤트 항목을 쓸 때 오류가 발생 했습니다. Windows 오류 코드를 사용할 수 없는 경우"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  id: WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(String,EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "특정된 등록된 이벤트 소스를 사용 하 여 데이터와 메시지 대체 문자열이 지정 된 이벤트와 이벤트 로그 엔트리를 씁니다."
  remarks: "이 메서드를 사용 하 여 적절 한 로그에 대 한 이벤트 소스로 이미 등록 된 소스를 사용 하 여 이벤트 로그에 지역화 된 엔트리를 씁니다. 문자열 값이 아닌 리소스 식별자와 함께 이벤트 속성을 지정 합니다. 이벤트 뷰어에서 리소스 식별자를 사용 하 여 원본에 대 한 지역화 된 리소스 파일에서 해당 문자열을 표시 합니다. 리소스 식별자를 사용 하 여 이벤트를 작성 하기 전에 해당 리소스 파일에는 소스를 등록 해야 합니다.       입력 `instance` 인스턴스 이벤트 메시지 및 속성을 지정 합니다. 설정의 <xref:System.Diagnostics.EventInstance.InstanceId%2A>의 `instance` 소스 메시지 리소스 파일에서 정의 된 메시지에 대 한 입력.</xref:System.Diagnostics.EventInstance.InstanceId%2A> 선택적으로 설정할 수는 <xref:System.Diagnostics.EventInstance.CategoryId%2A>및 <xref:System.Diagnostics.EventInstance.EntryType%2A>의 `instance` 이벤트 항목의 범주 및 이벤트 유형을 정의 하는 입력.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> 지역화 된 메시지 텍스트에 삽입 하는 언어에 관계 없이 문자열의 배열을 지정할 수도 있습니다. 설정 `values` 를 `null` 이벤트 메시지 대체 문자열에 대 한 서식 지정 자리 표시자 포함 되어 있지 않습니다.       지정된 된 소스 이벤트 로그에 대 한 <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> 사용 하기 전에 등록 해야 로그에 지역화 된 엔트리를 쓰기 위한 지정한 소스를 구성 합니다. 소스에 최소한 있어야 메시지 리소스 파일을 정의 합니다.       만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>메서드.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.       지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A>응용 프로그램 이벤트 로그에 직접 문자열 값을 쓰는 경우 메서드</xref:System.Diagnostics.EventLog.WriteEntry%2A> 를 사용 하 여       리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 해당 소스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>이벤트 로그에 대 한 리소스 식별자를 사용 하 여 항목을 작성 하는 메서드</xref:System.Diagnostics.EventLog.WriteEvent%2A> 를 사용 하 여 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A>"
  example:
  - "The following example writes an informational event entry and a warning event entry to an existing event log. The event message text is specified using a resource identifier in a resource file. The example assumes the corresponding resource file has been registered for the source.  \n  \n [!code-cpp[EventLog_WriteEvent#8](~/add/codesnippet/cpp/a57d89b3-94d2-4b9a-803c-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#8](~/add/codesnippet/visualbasic/a57d89b3-94d2-4b9a-803c-_1.vb)]\n [!code-cs[EventLog_WriteEvent#8](~/add/codesnippet/csharp/a57d89b3-94d2-4b9a-803c-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, object[] values);
    parameters:
    - id: source
      type: System.String
      description: "지정된 된 컴퓨터에서 응용 프로그램에 대해 등록 된 이벤트 원본의 이름입니다."
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> 지역화 된 이벤트 로그 엔트리를 나타내는 인스턴스입니다."
    - id: values
      type: System.Object[]
      description: "이벤트 로그 항목의 메시지 텍스트로 병합 될 문자열의 배열입니다."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이벤트 로그에 대 한 레지스트리 키를 열 수 없습니다."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "운영 체제 이벤트 로그에 이벤트 항목을 쓸 때 오류가 발생 했습니다. Windows 오류 코드를 사용할 수 없는 경우"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  id: WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(String,EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "등록 된 이벤트 소스를 사용 하 여 지정 된 이벤트 로그 항목이 지정 된 이벤트 데이터에 대해 메시지 대체 문자열 및 관련 이진 데이터를 씁니다."
  remarks: "이 메서드를 사용 하 여 적절 한 로그에 대 한 이벤트 소스로 이미 등록 된 소스를 사용 하 여 이벤트 로그에 이벤트 관련 데이터가 추가 지역화 된 엔트리를 씁니다. 문자열 값이 아닌 리소스 식별자와 함께 이벤트 속성을 지정 합니다. 이벤트 뷰어에서 리소스 식별자를 사용 하 여 원본에 대 한 지역화 된 리소스 파일에서 해당 문자열을 표시 합니다. 리소스 식별자를 사용 하 여 이벤트를 작성 하기 전에 해당 리소스 파일에는 소스를 등록 해야 합니다.       입력 `instance` 인스턴스 이벤트 메시지 및 속성을 지정 합니다. 설정의 <xref:System.Diagnostics.EventInstance.InstanceId%2A>의 `instance` 소스 메시지 리소스 파일에서 정의 된 메시지에 대 한 입력.</xref:System.Diagnostics.EventInstance.InstanceId%2A> 선택적으로 설정할 수는 <xref:System.Diagnostics.EventInstance.CategoryId%2A>및 <xref:System.Diagnostics.EventInstance.EntryType%2A>의 `instance` 이벤트 항목의 범주 및 이벤트 유형을 정의 하는 입력.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> 지역화 된 메시지 텍스트에 삽입 하는 언어에 관계 없이 문자열의 배열을 지정할 수도 있습니다. 설정 `values` 를 `null` 이벤트 메시지 대체 문자열에 대 한 서식 지정 자리 표시자 포함 되어 있지 않습니다.       이진 데이터는 이벤트에 대 한 추가 정보를 제공 해야 하는 경우의 이벤트를 지정 합니다. 예를 들어, 사용 된 `data` 특정 오류에 대 한 정보를 포함 하도록 매개 변수입니다. 이벤트 뷰어에서 관련된 이벤트 데이터를 해석 하지는 않습니다. 결합 된&16; 진수 및 텍스트 형식에서 데이터를 표시합니다. 이벤트 관련 데이터를 사용 하 여 엄밀한; 유용할 것 경우에 포함 합니다. 또한 응용 프로그램 이벤트 뷰어 독립적으로 처리할 수 정보를 저장할 이벤트 관련 데이터를 사용할 수 있습니다. 예를 들어 뷰어를 사용자 이벤트에 대해 특별히 작성 하거나 이벤트 로그를 검사 하 고 이벤트 관련 데이터에서 정보를 포함 하는 보고서를 만듭니다는 프로그램을 작성할 수 있습니다.       지정된 된 소스 이벤트 로그에 대 한 <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> 사용 하기 전에 등록 해야 로그에 지역화 된 엔트리를 쓰기 위한 지정한 소스를 구성 합니다. 소스에 최소한 있어야 메시지 리소스 파일을 정의 합니다.       만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>메서드.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.       지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A>응용 프로그램 이벤트 로그에 직접 문자열 값을 쓰는 경우 메서드</xref:System.Diagnostics.EventLog.WriteEntry%2A> 를 사용 하 여       리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 해당 소스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>이벤트 로그에 대 한 리소스 식별자를 사용 하 여 항목을 작성 하는 메서드</xref:System.Diagnostics.EventLog.WriteEvent%2A> 를 사용 하 여 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.</xref:System.Diagnostics.EventLog.WriteEntry%2A>"
  example:
  - "The following example writes an informational event entry and a warning event entry to an existing event log. The event message text is specified using a resource identifier in a resource file. The example assumes the corresponding resource file has been registered for the source.  \n  \n [!code-cpp[EventLog_WriteEvent#8](~/add/codesnippet/cpp/d4971002-e0d1-493b-96f8-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#8](~/add/codesnippet/visualbasic/d4971002-e0d1-493b-96f8-_1.vb)]\n [!code-cs[EventLog_WriteEvent#8](~/add/codesnippet/csharp/d4971002-e0d1-493b-96f8-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, object[] values);
    parameters:
    - id: source
      type: System.String
      description: "지정된 된 컴퓨터에서 응용 프로그램에 대해 등록 된 이벤트 원본의 이름입니다."
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> 지역화 된 이벤트 로그 엔트리를 나타내는 인스턴스입니다."
    - id: data
      type: System.Byte[]
      description: "항목과 연관 된 이진 데이터를 보유 하는 바이트 배열입니다."
    - id: values
      type: System.Object[]
      description: "이벤트 로그 항목의 메시지 텍스트로 병합 될 문자열의 배열입니다."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "이벤트 로그에 대 한 레지스트리 키를 열 수 없습니다."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "운영 체제 이벤트 로그에 이벤트 항목을 쓸 때 오류가 발생 했습니다. Windows 오류 코드를 사용할 수 없는 경우"
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Diagnostics.EventLog.#ctor
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog()
  nameWithType: EventLog.EventLog()
  fullName: System.Diagnostics.EventLog.EventLog()
- uid: System.Diagnostics.EventLog.#ctor(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String)
  nameWithType: EventLog.EventLog(String)
  fullName: System.Diagnostics.EventLog.EventLog(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String,String)
  nameWithType: EventLog.EventLog(String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String)
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String,String,String)
  nameWithType: EventLog.EventLog(String,String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String,String)
- uid: System.Diagnostics.EventLog.BeginInit
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: BeginInit()
  nameWithType: EventLog.BeginInit()
  fullName: System.Diagnostics.EventLog.BeginInit()
- uid: System.Diagnostics.EventLog.Clear
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Clear()
  nameWithType: EventLog.Clear()
  fullName: System.Diagnostics.EventLog.Clear()
- uid: System.Diagnostics.EventLog.Close
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Close()
  nameWithType: EventLog.Close()
  fullName: System.Diagnostics.EventLog.Close()
- uid: System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(EventSourceCreationData)
  nameWithType: EventLog.CreateEventSource(EventSourceCreationData)
  fullName: System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData)
- uid: System.Diagnostics.EventSourceCreationData
  parent: System.Diagnostics
  isExternal: false
  name: EventSourceCreationData
  nameWithType: EventSourceCreationData
  fullName: System.Diagnostics.EventSourceCreationData
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(String,String)
  nameWithType: EventLog.CreateEventSource(String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String)
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(String,String,String)
  nameWithType: EventLog.CreateEventSource(String,String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String,String)
- uid: System.Diagnostics.EventLog.Delete(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete(String)
  nameWithType: EventLog.Delete(String)
  fullName: System.Diagnostics.EventLog.Delete(String)
- uid: System.Diagnostics.EventLog.Delete(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete(String,String)
  nameWithType: EventLog.Delete(String,String)
  fullName: System.Diagnostics.EventLog.Delete(String,String)
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource(String)
  nameWithType: EventLog.DeleteEventSource(String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String)
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource(String,String)
  nameWithType: EventLog.DeleteEventSource(String,String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String,String)
- uid: System.Diagnostics.EventLog.Dispose(System.Boolean)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: EventLog.Dispose(Boolean)
  fullName: System.Diagnostics.EventLog.Dispose(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.EventLog.EnableRaisingEvents
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
  fullName: System.Diagnostics.EventLog.EnableRaisingEvents
- uid: System.Diagnostics.EventLog.EndInit
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EndInit()
  nameWithType: EventLog.EndInit()
  fullName: System.Diagnostics.EventLog.EndInit()
- uid: System.Diagnostics.EventLog.Entries
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Entries
  nameWithType: EventLog.Entries
  fullName: System.Diagnostics.EventLog.Entries
- uid: System.Diagnostics.EventLogEntryCollection
  parent: System.Diagnostics
  isExternal: false
  name: EventLogEntryCollection
  nameWithType: EventLogEntryCollection
  fullName: System.Diagnostics.EventLogEntryCollection
- uid: System.Diagnostics.EventLog.EntryWritten
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EntryWritten
  nameWithType: EventLog.EntryWritten
  fullName: System.Diagnostics.EventLog.EntryWritten
- uid: System.Diagnostics.EntryWrittenEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: EntryWrittenEventHandler
  nameWithType: EntryWrittenEventHandler
  fullName: System.Diagnostics.EntryWrittenEventHandler
- uid: System.Diagnostics.EventLog.Exists(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists(String)
  nameWithType: EventLog.Exists(String)
  fullName: System.Diagnostics.EventLog.Exists(String)
- uid: System.Diagnostics.EventLog.Exists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists(String,String)
  nameWithType: EventLog.Exists(String,String)
  fullName: System.Diagnostics.EventLog.Exists(String,String)
- uid: System.Diagnostics.EventLog.GetEventLogs
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs()
  nameWithType: EventLog.GetEventLogs()
  fullName: System.Diagnostics.EventLog.GetEventLogs()
- uid: System.Diagnostics.EventLog[]
  parent: System.Diagnostics
  isExternal: false
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog[]
  spec.csharp:
  - uid: System.Diagnostics.EventLog
    name: EventLog
    nameWithType: EventLog
    fullName: EventLog[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.GetEventLogs(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs(String)
  nameWithType: EventLog.GetEventLogs(String)
  fullName: System.Diagnostics.EventLog.GetEventLogs(String)
- uid: System.Diagnostics.EventLog.Log
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Log
  nameWithType: EventLog.Log
  fullName: System.Diagnostics.EventLog.Log
- uid: System.Diagnostics.EventLog.LogDisplayName
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
  fullName: System.Diagnostics.EventLog.LogDisplayName
- uid: System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogNameFromSourceName(String,String)
  nameWithType: EventLog.LogNameFromSourceName(String,String)
  fullName: System.Diagnostics.EventLog.LogNameFromSourceName(String,String)
- uid: System.Diagnostics.EventLog.MachineName
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MachineName
  nameWithType: EventLog.MachineName
  fullName: System.Diagnostics.EventLog.MachineName
- uid: System.Diagnostics.EventLog.MaximumKilobytes
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
  fullName: System.Diagnostics.EventLog.MaximumKilobytes
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.EventLog.MinimumRetentionDays
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
  fullName: System.Diagnostics.EventLog.MinimumRetentionDays
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: ModifyOverflowPolicy(OverflowAction,Int32)
  nameWithType: EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  fullName: System.Diagnostics.EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
- uid: System.Diagnostics.OverflowAction
  parent: System.Diagnostics
  isExternal: false
  name: OverflowAction
  nameWithType: OverflowAction
  fullName: System.Diagnostics.OverflowAction
- uid: System.Diagnostics.EventLog.OverflowAction
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
  fullName: System.Diagnostics.EventLog.OverflowAction
- uid: System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: RegisterDisplayName(String,Int64)
  nameWithType: EventLog.RegisterDisplayName(String,Int64)
  fullName: System.Diagnostics.EventLog.RegisterDisplayName(String,Int64)
- uid: System.Diagnostics.EventLog.Source
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Source
  nameWithType: EventLog.Source
  fullName: System.Diagnostics.EventLog.Source
- uid: System.Diagnostics.EventLog.SourceExists(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists(String)
  nameWithType: EventLog.SourceExists(String)
  fullName: System.Diagnostics.EventLog.SourceExists(String)
- uid: System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists(String,String)
  nameWithType: EventLog.SourceExists(String,String)
  fullName: System.Diagnostics.EventLog.SourceExists(String,String)
- uid: System.Diagnostics.EventLog.SynchronizingObject
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
  fullName: System.Diagnostics.EventLog.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.EventLog.WriteEntry(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String)
  nameWithType: EventLog.WriteEntry(String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType)
- uid: System.Diagnostics.EventLogEntryType
  parent: System.Diagnostics
  isExternal: false
  name: EventLogEntryType
  nameWithType: EventLogEntryType
  fullName: System.Diagnostics.EventLogEntryType
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String)
  nameWithType: EventLog.WriteEntry(String,String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Object[])
- uid: System.Diagnostics.EventInstance
  parent: System.Diagnostics
  isExternal: false
  name: EventInstance
  nameWithType: EventInstance
  fullName: System.Diagnostics.EventInstance
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Byte[],Object[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(String,EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Object[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(String,EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
- uid: System.Diagnostics.EventLog.#ctor*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog
  nameWithType: EventLog.EventLog
- uid: System.Diagnostics.EventLog.BeginInit*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: BeginInit
  nameWithType: EventLog.BeginInit
- uid: System.Diagnostics.EventLog.Clear*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Clear
  nameWithType: EventLog.Clear
- uid: System.Diagnostics.EventLog.Close*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Close
  nameWithType: EventLog.Close
- uid: System.Diagnostics.EventLog.CreateEventSource*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource
  nameWithType: EventLog.CreateEventSource
- uid: System.Diagnostics.EventLog.Delete*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete
  nameWithType: EventLog.Delete
- uid: System.Diagnostics.EventLog.DeleteEventSource*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource
  nameWithType: EventLog.DeleteEventSource
- uid: System.Diagnostics.EventLog.Dispose*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Dispose
  nameWithType: EventLog.Dispose
- uid: System.Diagnostics.EventLog.EnableRaisingEvents*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
- uid: System.Diagnostics.EventLog.EndInit*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EndInit
  nameWithType: EventLog.EndInit
- uid: System.Diagnostics.EventLog.Entries*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Entries
  nameWithType: EventLog.Entries
- uid: System.Diagnostics.EventLog.Exists*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists
  nameWithType: EventLog.Exists
- uid: System.Diagnostics.EventLog.GetEventLogs*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs
  nameWithType: EventLog.GetEventLogs
- uid: System.Diagnostics.EventLog.Log*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Log
  nameWithType: EventLog.Log
- uid: System.Diagnostics.EventLog.LogDisplayName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
- uid: System.Diagnostics.EventLog.LogNameFromSourceName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogNameFromSourceName
  nameWithType: EventLog.LogNameFromSourceName
- uid: System.Diagnostics.EventLog.MachineName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MachineName
  nameWithType: EventLog.MachineName
- uid: System.Diagnostics.EventLog.MaximumKilobytes*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
- uid: System.Diagnostics.EventLog.MinimumRetentionDays*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: ModifyOverflowPolicy
  nameWithType: EventLog.ModifyOverflowPolicy
- uid: System.Diagnostics.EventLog.OverflowAction*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
- uid: System.Diagnostics.EventLog.RegisterDisplayName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: RegisterDisplayName
  nameWithType: EventLog.RegisterDisplayName
- uid: System.Diagnostics.EventLog.Source*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Source
  nameWithType: EventLog.Source
- uid: System.Diagnostics.EventLog.SourceExists*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists
  nameWithType: EventLog.SourceExists
- uid: System.Diagnostics.EventLog.SynchronizingObject*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
- uid: System.Diagnostics.EventLog.WriteEntry*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry
  nameWithType: EventLog.WriteEntry
- uid: System.Diagnostics.EventLog.WriteEvent*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent
  nameWithType: EventLog.WriteEvent
