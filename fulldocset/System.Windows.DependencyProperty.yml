### YamlMime:ManagedReference
items:
- uid: System.Windows.DependencyProperty
  id: DependencyProperty
  children:
  - System.Windows.DependencyProperty.AddOwner(System.Type)
  - System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.DefaultMetadata
  - System.Windows.DependencyProperty.GetHashCode
  - System.Windows.DependencyProperty.GetMetadata(System.Type)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  - System.Windows.DependencyProperty.GlobalIndex
  - System.Windows.DependencyProperty.IsValidType(System.Object)
  - System.Windows.DependencyProperty.IsValidValue(System.Object)
  - System.Windows.DependencyProperty.Name
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyProperty.OwnerType
  - System.Windows.DependencyProperty.PropertyType
  - System.Windows.DependencyProperty.ReadOnly
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.ToString
  - System.Windows.DependencyProperty.UnsetValue
  - System.Windows.DependencyProperty.ValidateValueCallback
  langs:
  - csharp
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
  type: Class
  summary: "와 같은 메서드를 통해 설정할 수 있는 속성, 스타일, 데이터 바인딩, 애니메이션 및 상속을 나타냅니다."
  remarks: "DependencyProperty에 다음과 같은 기능을 지원 [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]:-스타일의 속성을 설정할 수 있습니다. 자세한 내용은 참조 [스타일 및 템플릿](~/add/includes/ajax-current-ext-md.md)합니다.      -데이터 바인딩을 통해의 속성을 설정할 수 있습니다. 데이터 바인딩 종속성 속성에 대 한 자세한 내용은 참조 [하는 방법: 두 컨트롤 속성을 바인딩할](~/add/includes/ajax-current-ext-md.md)합니다.      -동적 리소스 참조와의 속성을 설정할 수 있습니다. 자세한 내용은 참조 [XAML 리소스](~/add/includes/ajax-current-ext-md.md)합니다.      -속성 요소 트리의 부모 요소 로부터 자동으로 해당 값을 상속할 수 있습니다. 자세한 내용은 참조 [속성 값 상속](~/add/includes/ajax-current-ext-md.md)합니다.      -속성에 애니메이션을 적용할 수 있습니다. 자세한 내용은 참조 [애니메이션 개요](~/add/includes/ajax-current-ext-md.md)합니다.      -속성은 속성의 이전 값을 변경 했으며 새로 속성 값을 강제 변환할 수 있는 경우 보고할 수 있습니다. 자세한 내용은 참조 [종속성 속성의 콜백 및 유효성 검사](~/add/includes/ajax-current-ext-md.md)합니다.      -속성에 대 한 정보를 보고 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]여부 속성 값을 변경 해야 요소에 대 한 시각적 개체를 다시 구성 하기 위해이 레이아웃 시스템 등입니다.      -속성에서 지원을 받습니다는 [!INCLUDE[wpfdesigner_current_long](~/add/includes/wpfdesigner-current-long-md.md)]합니다.  속성에서 편집할 수는 예를 들어는 **속성** 창.       종속성 속성에 대 한 자세한 참조 [종속성 속성 개요](~/add/includes/ajax-current-ext-md.md)합니다. 앞의 목록에 기능을 지원 하도록 사용자 지정 형식에서 속성을 원하는 경우에 종속성 속성을 만들어야 합니다.  사용자 지정 종속성 속성을 만드는 방법을 알아보려면 참조 [종속성 속성을 사용자 지정](~/add/includes/ajax-current-ext-md.md)합니다.       연결된 된 속성은 모든 개체에 연결 된 속성을 정의 하는 형식 정보를 보고할 수 있도록 하는 속성입니다. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]에서 상속 된 모든 형식을 <xref:System.Windows.DependencyObject>속성을 정의 하는 형식에서 상속 하는지 여부에 관계 없이 연결된 된 속성을 사용할 수 있습니다.</xref:System.Windows.DependencyObject> 연결된 된 속성의 기능은 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 언어입니다.  연결된 된 속성을 설정 하려면 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]를 사용 하 여는 *ownerType*.* propertyName* 구문입니다. 연결된 된 속성의 예로 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName>속성.</xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName> 모든에서 사용할 수 있는 속성을 만들려면 원하는 <xref:System.Windows.DependencyObject>형식, 연결된 된 속성을 만들어야 합니다.</xref:System.Windows.DependencyObject> 참조를 만드는 방법을 비롯 하 여 연결 된 속성에 대 한 자세한 내용을 보려면 [연결 된 속성 개요](~/add/includes/ajax-current-ext-md.md)합니다.      <a name=&quot;xamlAttributeUsage_DependencyProperty&quot;></a># # XAML 특성 사용 ```   <object property=&quot;dependencyPropertyName&quot;/>   - or -   <object property=&quot;ownerType.dependencyPropertyName&quot;/>   - or -   <object property=&quot;attachedPropertyOwnerType.attachedPropertyName&quot;/>   ``` <a name=&quot;xamlValues_DependencyProperty&quot;> </a> # # XAML 값 `dependencyPropertyName` 지정 하는 문자열은 <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>원하는 종속성 속성의.</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>       이 앞에 나와야 XML 네임 스페이스 접두사 속성 기본 XML 네임 스페이스에 없는 경우 (자세한 내용은 참조 [XAML 네임 스페이스 및 WPF XAML에 대 한 매핑 Namespace](~/add/includes/ajax-current-ext-md.md).)       `ownerType`.`dependencyPropertyName`    종속성 속성을 점 (.), 다음 <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>.</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName> 의 소유자 형식을 지정 하는 문자열 `ownerType`XML 네임 스페이스 접두사가 올 수도 있습니다. 이 사용은 런타임에 바인딩된 스타일 및 템플릿, 때문에 컨텍스트를 구문 분석에 대 한 종속성 속성의 소유자를 지정 해야 합니다는 `TargetType` 아직 알려지지 않은 합니다. 자세한 내용은 참조 [스타일 및 템플릿](../Topic/Styling%20and%20Templating.md)합니다.       `attachedPropertyOwnerType` *.* `attachedPropertyName`연결된 된 속성 이름, 점 (.), 연결된 된 속성의 소유자를 지정 하는 문자열입니다. `attachedPropertyOwnerType`XML 네임 스페이스 접두사가 올 수도 있습니다."
  syntax:
    content: >-
      [System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]

      [System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))]

      public sealed class DependencyProperty
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  id: AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "이미 등록 된 종속성 속성의 소유자로 다른 형식을 추가 합니다."
  remarks: "이 메서드는 해당 특정 종속성 속성을 초기에 등록 되지 않은 형식에서 종속성 속성을 인식 하도록 속성 시스템을 활성화 합니다.       종속성 속성을 이미 관리 되는 클래스 상속을 통해 해당 종속성 속성을 노출 하지 않는 클래스 추가 AddOwner 일반적으로 사용 됩니다 (클래스 상속 속성 파생된 클래스에서 상속할 수로 인해 및 따라서 이미 종속성 속성에 대 한 일반 멤버 테이블 액세스를 제공 합니다.). AddOwner 속성 시스템이을 해당 종속성 속성을 처음 등록 하지 않은 형식에 종속성 속성을 인식할 수 있습니다.       이 서명을 메타 데이터를 지정 하는 데 허용 하지 않습니다.  이 방법을 사용 하면 메타 데이터는 자동으로 생성 새 <xref:System.Windows.DependencyProperty>와 소유자 형식입니다.</xref:System.Windows.DependencyProperty> 자동 생성 된 메타 데이터에는이 속성이 정의 된 기본 형식의 모든 병합된 메타 데이터의 결과입니다. 병합 된 메타 데이터를 사용할 수 있는 속성에 대 한 기본 메타 데이터 사용 됩니다. 속성이 사용 하 여 등록 하는 경우는 <xref:System.Windows.DependencyProperty.RegisterAttached%2A>메서드를 기본 메타 데이터는 때 생성 되는 메타 데이터와 동일 하 게 <xref:System.Windows.DependencyProperty.RegisterAttached%2A>호출 되었습니다.</xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> 그렇지 않은 경우는 <xref:System.Windows.PropertyMetadata>개체를 만든는 <xref:System.Windows.PropertyMetadata.DefaultValue%2A>속성 형식의 기본값 및 다른 모든 속성을 설정 하는 속성은 <xref:System.Windows.PropertyMetadata>로 설정 되어 `null`.</xref:System.Windows.PropertyMetadata> </xref:System.Windows.PropertyMetadata.DefaultValue%2A> </xref:System.Windows.PropertyMetadata> 사용 하 여는 <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>서명이 제공 된 형식에 추가 되는 종속성 속성의 버전에 대 한 메타 데이터를 제공 하려는 경우.</xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>       이 메서드의 반환 값은 일반적으로 선언 하 고는 종속성 속성 식별자를 저장 하 여 종속성 속성을 노출 사용 됩니다. 식별자 속성 시스템 호출 하려는 경우 종속성 속성에 대 한 액세스를 제공 [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] 종속성 속성에 대해 특히 속성이 있을 때 추가 소유자 클래스에 있습니다. 원래 소유자와 추가 된 소유자에 대 한 속성 이름이 동일한 유사한 기능을 나타내는 데 사용할 해야 합니다. 사용 해야는 <xref:System.Windows.DependencyProperty>AddOwner 메서드 종속성 속성의 식별자를 정의 하 고 선언 하는 값을 반환 [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] AddOwner를 사용 하 여 형식에 추가 하는 종속성 속성에 대 한 속성 래퍼.</xref:System.Windows.DependencyProperty>       내에 선언 된 종속성 속성을 만들 때 위에서 권장 AddOwner 방법론을 사용 하는 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]합니다. 예를 들어, 둘 다 <xref:System.Windows.Controls.Border>및 <xref:System.Windows.Controls.Control>정의 `BorderBrush` 유사한 기능을 포함 하는 종속성 속성입니다.</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Border> <xref:System.Windows.Controls.Control>정의 `BorderBrush` 원래 소유자를 기준으로 속성을 AddOwner를 호출 하 여 속성 시스템 <xref:System.Windows.Controls.Border>및 등록 된 <xref:System.Windows.Controls.Border.BorderBrushProperty>종속성 속성 식별자입니다.</xref:System.Windows.Controls.Border.BorderBrushProperty> </xref:System.Windows.Controls.Border></xref:System.Windows.Controls.Control> AddOwner 반환 값을 설정 하는 새 정적 사용 다음 <xref:System.Windows.DependencyProperty>필드 (<xref:System.Windows.Controls.Control.BorderBrushProperty>) 해당 속성에 추가 된 소유자에 대 한 및 `BorderBrush` 속성 래퍼를 선언 합니다.</xref:System.Windows.Controls.Control.BorderBrushProperty> </xref:System.Windows.DependencyProperty>"
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType);
    parameters:
    - id: ownerType
      type: System.Type
      description: "이 종속성 속성의 소유자로 추가할 형식입니다."
    return:
      type: System.Windows.DependencyProperty
      description: "원본에 대 한 참조 <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> 종속성 속성을 식별 하는 식별자입니다. 이 식별자로 추가 하는 클래스에서 노출 되어야 합니다는 <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> 필드입니다."
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  id: AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "이미 등록 된 종속성 속성의 소유자로 다른 형식을 추가, 제공 된 소유자 형식에 존재 하는 종속성 속성에 대 한 종속성 속성 메타 데이터를 제공 합니다."
  remarks: "이 메서드는 해당 특정 종속성 속성을 초기에 등록 되지 않은 형식에서 종속성 속성을 인식 하도록 속성 시스템을 활성화 합니다.       추가 소유자 클래스에 있는 것 처럼에 특히 선언 하 고 종속성 속성을 노출 합니다.이 메서드의 반환 값 사용 됩니다. 일반적으로 원래 소유자와 추가 된 소유자에 대 한 속성 이름이 동일한 유사한 기능을 나타내는 데 사용할 해야 합니다. 것이 좋습니다도 새 식별자를 노출 하도록 [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] <xref:System.Windows.DependencyProperty.AddOwner%2A>.</xref:System.Windows.DependencyProperty.AddOwner%2A> 를 사용 하 여 형식에 추가 하는 종속성 속성에 대 한 속성 래퍼       <xref:System.Windows.DependencyProperty.AddOwner%2A>위에서 권장 방법론은 만들 때 사용 [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] 내에 선언 된 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)].</xref:System.Windows.DependencyProperty.AddOwner%2A> 예를 들어, 둘 다 <xref:System.Windows.Controls.Border>및 <xref:System.Windows.Controls.Control>정의 `BorderBrush` 유사한 기능을 포함 하는 종속성 속성입니다.</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Border> <xref:System.Windows.Controls.Control>정의 `BorderBrush` 속성을 호출 하 여 속성 시스템 <xref:System.Windows.DependencyProperty.AddOwner%2A>에 원래 소유자 <xref:System.Windows.Controls.Border>및 등록 된 <xref:System.Windows.Controls.Border.BorderBrushProperty>종속성 속성 식별자입니다.</xref:System.Windows.Controls.Border.BorderBrushProperty> </xref:System.Windows.Controls.Border> </xref:System.Windows.DependencyProperty.AddOwner%2A></xref:System.Windows.Controls.Control> <xref:System.Windows.DependencyProperty.AddOwner%2A>반환 값을 설정 하는 정적 사용 다음 <xref:System.Windows.DependencyProperty>필드 (<xref:System.Windows.Controls.Control.BorderBrushProperty>)의 해당 속성에 추가 된 소유자에 대 한 및 `BorderBrush` 속성 래퍼를 선언 합니다.</xref:System.Windows.Controls.Control.BorderBrushProperty> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.AddOwner%2A>       <xref:System.Windows.DependencyObject.GetValue%2A>.</xref:System.Windows.DependencyObject.GetValue%2A> 등의 작업에 사용할 추가 된 소유자의 종속성 속성 식별자 그러나 특정 형식의 작업 모두 관련 된 다른 메타 데이터와 소유자를 계속 추가 된 클래스의 인스턴스 반환할 경우에도 해당 예상된 결과 원래 (하지는 추가 된 소유자의) <xref:System.Windows.DependencyObject.GetValue%2A>나 <xref:System.Windows.DependencyProperty.GetMetadata%2A>.</xref:System.Windows.DependencyProperty.GetMetadata%2A> </xref:System.Windows.DependencyObject.GetValue%2A> 형식별에 종속성 속성 식별자 지정 메타 데이터는 AddOwner 추가 된 소유자가 적용 됩니다에 대 한 호출 자체를 반드시 추가 소유자 클래스 식별자 필드에서 명시적으로 참조 합니다. 그럼에도 불구 하 고 것이 좋습니다도 새 식별자를 노출 하도록 [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] 이렇게 정의 하면 간의 차이 만들기 때문에 AddOwner를 사용 하 여 형식에 추가 하는 종속성 속성에 대 한 속성 래퍼는 [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] 및 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 의 속성이 표현 합니다.       제공 된 메타 데이터는 기본 소유자에 있는 종속성 속성에 대 한 속성 메타 데이터와 병합 됩니다. 원래 기본 메타 데이터에 지정 된 특성을 계속 유지 됩니다. 새 메타 데이터에서 특별히 변경 된 특성에만 기본 메타 데이터의 특성을 재정의 합니다. 일부 특징와 같은 <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, 새 메타 데이터에서 지정 된 대체 됩니다.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> 다른 사용자와 같은 <xref:System.Windows.PropertyChangedCallback>, 결합 됩니다.</xref:System.Windows.PropertyChangedCallback> 병합 동작을 사용 하는 override, 여기에 설명 된 동작이 사용 되는 기존 속성 메타 데이터 클래스에 대 한 속성 메타 데이터 형식에 따라 다르며 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] 종속성 속성입니다. 자세한 내용은 참조 [종속성 속성 메타 데이터](~/add/includes/ajax-current-ext-md.md) 및 [프레임 워크 속성 메타 데이터](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: ownerType
      type: System.Type
      description: "이 종속성 속성의 소유자로 추가할 형식입니다."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "제공된 된 형식에 있는 종속성 속성을 정규화 하는 메타 데이터입니다."
    return:
      type: System.Windows.DependencyProperty
      description: "원본에 대 한 참조 <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> 종속성 속성을 식별 하는 식별자입니다. 이 식별자로 추가 하는 클래스에서 노출 되어야 합니다는 <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> 필드입니다."
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.DefaultMetadata
  id: DefaultMetadata
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "종속성 속성의 기본 메타 데이터를 가져옵니다."
  remarks: "기본 메타 데이터는 사용할 수 있는 특정 개체 또는 파생 형식인 개체에 명시적에서 대체 메타 데이터가 제공 된 이름에 속성 메타 데이터 <xref:System.Windows.DependencyProperty.Register%2A>또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>호출.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.Register%2A>       원래 소유자 첫 번째에 메타 데이터를 적용 하는 경우 <xref:System.Windows.DependencyProperty.Register%2A>DefaultMetadata로 반환 되 고 해당 메타 데이터 종속성 속성을 설정 하는 호출.</xref:System.Windows.DependencyProperty.Register%2A>       메타 데이터가 원래 적용 된 경우 <xref:System.Windows.DependencyProperty.Register%2A>호출, 기본 메타 데이터 내에서 생성 되는 <xref:System.Windows.DependencyProperty.Register%2A>호출 하 고이 값은 DefaultMetadata로 반환 됩니다.</xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty.Register%2A>       기본 메타 데이터와 연결 된의 주요 목적은 <xref:System.Windows.DependencyProperty>에서이 속성에 대 한 기본값을 제공 하 여 <xref:System.Windows.DependencyObject>또는 파생된 형식인.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyProperty>       연결 되지 않은 속성에 대 한이 속성에서 반환 되는 메타 데이터 형식으로 캐스팅할 수 없습니다 파생된 유형의 <xref:System.Windows.PropertyMetadata>최초 속성 된 파생 된 메타 데이터 형식으로 등록 된 경우에 입력 합니다.</xref:System.Windows.PropertyMetadata> 원래 등록 된 메타 데이터는 원래 수 있는 파생 된 메타 데이터 유형과 같은 호출 <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>형식을 매개 변수로 대신 원래 등록을 전달 합니다.</xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>       연결 된 속성에 대 한이 속성에서 반환 된 메타 데이터 형식에는 원래에 지정 된 형식과 일치 합니다 <xref:System.Windows.DependencyProperty.RegisterAttached%2A>등록 방법을.</xref:System.Windows.DependencyProperty.RegisterAttached%2A>"
  example:
  - "[!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]\n[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]"
  syntax:
    content: public System.Windows.PropertyMetadata DefaultMetadata { get; }
    return:
      type: System.Windows.PropertyMetadata
      description: "종속성 속성의 기본 메타 데이터입니다."
  overload: System.Windows.DependencyProperty.DefaultMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetHashCode
  id: GetHashCode
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "이 대 한 해시 코드를 반환 <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>합니다."
  remarks: "속성 시스템 자체 고유 식별자를 사용 하 여 <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, 해당 속성의 값은 GetHashCode에 의해 반환 됩니다.</xref:System.Windows.DependencyProperty.GlobalIndex%2A>"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "이 대 한 해시 코드 <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>합니다."
  overload: System.Windows.DependencyProperty.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  id: GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "지정된 된 기존 형식에 있는이 종속성 속성에 대 한 메타 데이터를 반환 합니다."
  remarks: "형식 또는 개체 참조 메타 데이터를 원래 등록 시와에서 다를 수 있으므로 형식을 키가 필요한 데 지정 <xref:System.Windows.DependencyProperty.AddOwner%2A>또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>형식에 있는 종속성 속성의 메타 데이터를 변경 하는 호출.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>"
  example:
  - "The following example gets metadata for a dependency property based on its type. The type is obtained by using a `typeof` operator.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatatype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (Type forType);
    parameters:
    - id: forType
      type: System.Type
      description: "종속성 속성 메타 데이터를 검색할 특정 형식입니다."
    return:
      type: System.Windows.PropertyMetadata
      description: "속성 메타 데이터 개체입니다."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  id: GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "지정 된 개체 인스턴스에 있을 때이 종속성 속성에 대 한 메타 데이터를 반환 합니다."
  remarks: "지정 하는 유형 또는 개체 참조가 필요한 특정된 종속성 속성의 메타 데이터를 원래 등록 시와에서 다를 수 있으므로 <xref:System.Windows.DependencyProperty.AddOwner%2A>또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>형식에 있는 것 처럼 속성 메타 데이터를 구체화할 수 있는 호출.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>       인스턴스에 따라 속성 메타 데이터를 요청할 때만 전달 하는 인스턴스가 해당 형식을 내부적으로 계산 될 수 있도록 합니다. 종속성 속성 메타 데이터 인스턴스; 별로 달라 지지 않습니다. 지정 된 type 속성 조합에 대해 일관성은 항상 있습니다."
  example:
  - "The following example gets metadata for a dependency property based on a specific <xref:System.Windows.DependencyObject> instance.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);
    parameters:
    - id: dependencyObject
      type: System.Windows.DependencyObject
      description: "종속성 속성의 형식별 버전 메타 데이터에서 가져와야 결정 하기 위해 형식이 검사 된 종속성 개체입니다."
    return:
      type: System.Windows.PropertyMetadata
      description: "속성 메타 데이터 개체입니다."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  id: GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "지정된 된 형식에 있는 것 처럼이 종속성 속성에 대 한 메타 데이터를 반환 합니다."
  remarks: "지정 하는 유형 또는 개체 참조가 필요한 특정된 종속성 속성의 메타 데이터를 원래 등록 시와에서 다를 수 있으므로 <xref:System.Windows.DependencyProperty.AddOwner%2A>또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>형식에 있는 것 처럼 속성 메타 데이터를 구체화할 수 있는 호출.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>"
  example:
  - "The following example gets metadata for a dependency property based on its <xref:System.Windows.DependencyObjectType>.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadotype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);
    parameters:
    - id: dependencyObjectType
      type: System.Windows.DependencyObjectType
      description: "종속성 속성 메타 데이터가 필요한 종속성 개체 형식을 기록 하는 특정 개체입니다."
    return:
      type: System.Windows.PropertyMetadata
      description: "속성 메타 데이터 개체입니다."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GlobalIndex
  id: GlobalIndex
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "종속성 속성을 고유 하 게 식별 하는 내부적으로 생성 된 값을 가져옵니다."
  remarks: "이 값이 정수는 [!INCLUDE[TLA#tla_guid](~/add/includes/ajax-current-ext-md.md)]합니다. 일반적으로이 인덱스 값을 사용 하 여은 필요 하지 않으며 모든 종속성 속성의 테이블에 인덱스 액세스할 수 없습니다. 종속성 속성 식별자 필드에서 대신 참조 하도록 합니다.       GlobalIndex에&0;부터 시작 배열 인덱스는 GlobalIndex를 사용 하는 데이터 구조에 대 한 빠른 액세스를 위해 내부적으로 사용 됩니다. 비슷한 사용 응용 프로그램 디자이너 또는 도구 있을 수 있습니다."
  syntax:
    content: public int GlobalIndex { get; }
    return:
      type: System.Int32
      description: "고유 숫자 식별자입니다."
  overload: System.Windows.DependencyProperty.GlobalIndex*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  id: IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "원래 종속성 속성 등록에 입력 한 속성 유형을 기준으로 지정된 된 값이 종속성 속성의이 형식에 대해 허용 가능한 지 확인 합니다."
  remarks: "값이 `null` 올바른 형식이 또는 참조 형식 종속성 속성에 대 한는 <xref:System.Nullable%601>종속성 속성을가 반환 `true` 이러한 경우에 대 한.</xref:System.Nullable%601> 종속성 속성의 두 참조 되는 경우에 또는 <xref:System.Nullable%601>형식 IsValidType 돌아갑니다 `false` 예외가 발생 하지 않고 null 값에 대 한.</xref:System.Nullable%601>"
  example:
  - "The following example uses IsValidType as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvalue)]\n [!code-vb[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]"
  syntax:
    content: public bool IsValidType (object value);
    parameters:
    - id: value
      type: System.Object
      description: "확인할 값입니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>지정 된 값이 등록 된 속성 형식 또는 파생된 형식이 적합 합니다. 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.DependencyProperty.IsValidType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  id: IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "제공 된 값은 기본 형식 검사를 통해 속성의 형식에 대 한 허용 여부를 결정 하 고 잠재적으로 해당 형식에 대 한 값의 허용 되는 범위 내에 있는 경우."
  remarks: "종속성 속성을 해당 형식에 대 한 값의 허용 되는 범위를 통해 지정할 수 있습니다는 <xref:System.Windows.ValidateValueCallback>종속성 속성 등록에 제공 하는.</xref:System.Windows.ValidateValueCallback>       이 메서드를 호출 <xref:System.Windows.DependencyProperty.IsValidType%2A>내부적으로.</xref:System.Windows.DependencyProperty.IsValidType%2A> 해당 종속성 속성에 없고 <xref:System.Windows.ValidateValueCallback>이 메서드를 호출 하는 것은 효과적으로 <xref:System.Windows.DependencyProperty.IsValidType%2A>.</xref:System.Windows.DependencyProperty.IsValidType%2A> 호출에 해당 하는</xref:System.Windows.ValidateValueCallback> 경우 종속성 속성이 없는 경우는 <xref:System.Windows.ValidateValueCallback>, 경우에 한 <xref:System.Windows.DependencyProperty.IsValidType%2A>반환는 `true`를 값으로 반환 되는 콜백을 구현 됩니다.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Windows.ValidateValueCallback>       Null 값 또는 참조 형식 종속성 속성에 대 한 유효한 값은는 <xref:System.Nullable%601>종속성 속성을 반환 하 고 `true` 이러한 경우에 대 한.</xref:System.Nullable%601> 종속성 속성의 두 참조 되는 경우에는 나 <xref:System.Nullable%601>형식 <xref:System.Windows.DependencyProperty.IsValidType%2A>반환 됩니다 `false` 예외가 발생 하지 않고 null 값에 대 한.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Nullable%601>"
  example:
  - "The following example uses IsValidValue as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]\n [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]"
  syntax:
    content: public bool IsValidValue (object value);
    parameters:
    - id: value
      type: System.Object
      description: "확인할 값입니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>값을 사용할 수 있고 올바른 형식 또는 파생된 형식이 하는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.DependencyProperty.IsValidValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Name
  id: Name
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "종속성 속성의 이름을 가져옵니다."
  remarks: "이 속성으로 제공 된 이름을 가져옵니다는 `name` 종속성 속성 등록 하는 동안 매개 변수입니다. 이 이름은 변경할 수 및 커야 `null` 또는 빈 문자열입니다. 중복 이름 등록과 같은 소유자 형식에 허용 되지 않습니다 및 중복 등록 하려고 할 때 예외가 throw 됩니다.      > [!IMPORTANT] > 종속성 속성의 Name의 &quot;Property&quot; 접미사-해당 종속성 속성 식별자의 이름과 일치 하는 규칙을 따라야 합니다. 자세한 내용은 참조 [사용자 지정 종속성 속성](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the Name.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "속성의 이름입니다."
  overload: System.Windows.DependencyProperty.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "기본 형식에서 상속 된 종속성 속성에 있는 메타 데이터를 재정의 하 여 지정 된 형식의 인스턴스에 있을 때이 종속성 속성에 대 한 대체 메타 데이터를 지정 합니다."
  remarks: "종속성 속성 메타 데이터 속성 시스템 종속성 속성을 사용 하기 전에 재정의 해야 합니다. 이 종속성 속성을 등록 하는 클래스를 사용 하 여 특정 인스턴스를 만들 때마다 하는 것과 같습니다. OverrideMetadata에 대 한 호출으로 자신을 제공 하는 형식의 정적 생성자 내에서 수행 해야는 `forType` 비슷한 인스턴스화를 통해 또는이 메서드의 매개 변수입니다. 소유자 형식의 인스턴스가 후 메타 데이터를 변경 하는 예외를 발생 시 키 지 않습니다 이지만 속성 시스템에 일관성 없는 동작이 발생 됩니다.       특정 파생된 클래스 재정의 대 한 메타 데이터는이 방법으로 설정 되 면이 같은 파생된 클래스에서 메타 데이터 재정의 이후에 하려고 하면 예외가 발생 합니다.       제공 된 메타 데이터는 기본 소유자에 있는 종속성 속성에 대 한 속성 메타 데이터와 병합 됩니다. 원래 기본 메타 데이터에 지정 된 특성에 계속 유지 됩니다. 새 메타 데이터에서 특별히 변경 된 특성에만 기본 메타 데이터의 특성을 재정의 합니다. 와 같은 일부 특징 <xref:System.Windows.PropertyMetadata.DefaultValue%2A>새 메타 데이터에 지정 된 경우 대체 됩니다.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> 다른 사용자와 같은 <xref:System.Windows.PropertyChangedCallback>, 결합 됩니다.</xref:System.Windows.PropertyChangedCallback> 병합 동작을 사용 하는 override, 여기에 설명 된 동작이 사용 되는 기존 속성 메타 데이터 클래스에 대 한 속성 메타 데이터 형식에 따라 다르며 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] 종속성 속성입니다. 자세한 내용은 참조 [종속성 속성 메타 데이터](~/add/includes/ajax-current-ext-md.md) 및 [프레임 워크 속성 메타 데이터](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: forType
      type: System.Type
      description: "이 종속성 속성은 상속 여기서 형식이 고 제공 된 대체 메타 데이터를 적용 되지 것입니다."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "재정의 하는 형식에서 종속성 속성에 적용할 메타 데이터입니다."
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "읽기 전용 종속성 속성에 대 한 메타 데이터를 재정의 하려고 했습니다 (작업을 수행할 수이 서명을 사용 하 여)."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "제공 된 형식에 있는 종속성 속성에 대 한 메타 데이터가 이미 설정 된 경우"
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "초기 종속성 속성 등록에 제공 된 메타 데이터 재정의 지정 된 형식의 인스턴스에 있을 때 대체 읽기 전용 종속성 속성에 대 한 메타 데이터를 제공 합니다. 전달 해야 합니다는 <xref href=&quot;System.Windows.DependencyPropertyKey&quot;> </xref> 예외가 발생 하지 않도록 하려면 읽기 전용 종속성 속성에 대 한 합니다."
  remarks: "이 서명을 읽기 전용 종속성 속성 식별자에 대 한 기본 구현을 제공 (<xref:System.Windows.DependencyPropertyKey>) 메서드.</xref:System.Windows.DependencyPropertyKey> 읽기 / 쓰기 종속성 속성에 대 한 메타 데이터를 재정의 하는 경우 사용 <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>       종속성 속성 메타 데이터 속성 시스템 종속성 속성을 사용 하기 전에 재정의 해야 합니다. 이 종속성 속성을 등록 하는 클래스에 대 한 시간을 특정 개체 생성 하는 것과 같습니다. 에 대 한 호출이 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>로 자신을 제공 하는 형식의 정적 생성자 내에서 수행할 수만 `forType` 비슷한 인스턴스화를 통해 또는이 메서드의 매개 변수.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 소유자 형식의 인스턴스가 후 메타 데이터를 변경 하는 예외를 발생 시 키 지 않습니다 이지만 속성 시스템에 일관성 없는 동작이 발생 됩니다.       특정 파생된 클래스 재정의 대 한 메타 데이터는이 방법으로 설정 되 면이 같은 파생된 클래스에서 메타 데이터 재정의 이후에 하려고 하면 예외가 발생 합니다.       제공 된 메타 데이터는 기본 소유자에 있는 종속성 속성에 대 한 속성 메타 데이터와 병합 됩니다. 원래 기본 메타 데이터에 지정 된 특성에 계속 유지 됩니다. 새 메타 데이터에서 특별히 변경 된 특성에만 기본 메타 데이터의 특성을 재정의 합니다. 와 같은 일부 특징 <xref:System.Windows.PropertyMetadata.DefaultValue%2A>새 메타 데이터에 지정 된 경우 대체 됩니다.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> 다른 사용자와 같은 <xref:System.Windows.PropertyChangedCallback>, 결합 됩니다.</xref:System.Windows.PropertyChangedCallback> 병합 동작 재정의에 사용 되 고 속성 메타 데이터 형식에 따라 달라 집니다. 자세한 내용은 참조 [종속성 속성 메타 데이터](~/add/includes/ajax-current-ext-md.md) 및 [프레임 워크 속성 메타 데이터](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);
    parameters:
    - id: forType
      type: System.Type
      description: "이 종속성 속성은 상속 여기서 형식이 고 제공 된 대체 메타 데이터를 적용 되지 것입니다."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "재정의 하는 형식에서 종속성 속성에 적용할 메타 데이터입니다."
    - id: key
      type: System.Windows.DependencyPropertyKey
      description: "읽기 전용 종속성 속성에 대 한 선택 키입니다."
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OwnerType
  id: OwnerType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "속성 시스템에 종속성 속성을 등록 하거나 자체적으로 속성 소유자로 추가한 개체의 형식을 가져옵니다."
  remarks: "속성을 등록할 때이 값이 제공 됩니다. 소유자 중 하나는 원래 등록 형식이의 경우 됩니다는 <xref:System.Windows.DependencyProperty>에서 생성 된 식별자는 <xref:System.Windows.DependencyProperty.Register%2A>통화 또는 형식 자체의 경우 소유자로 추가 <xref:System.Windows.DependencyProperty>에서 생성 된 식별자는 <xref:System.Windows.DependencyProperty.AddOwner%2A>호출.</xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty>       에 지정 된 모든 OwnerType <xref:System.Windows.DependencyProperty>는 변경할 수 및 커야 `null` 유효한 <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty>"
  example:
  - "The following example gets the owner type based on a dependency property identifier `dp`, and then gets metadata on the owner type for that same identifier. This operation is actually equivalent to getting <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> on `dp`.  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]"
  syntax:
    content: public Type OwnerType { get; }
    return:
      type: System.Type
      description: "속성을 등록 하거나 자체적으로 속성 소유자로 추가한 개체의 형식입니다."
  overload: System.Windows.DependencyProperty.OwnerType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.PropertyType
  id: PropertyType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "종속성 속성의 값에 대 한 사용 유형을 가져옵니다."
  remarks: "이 속성을 통해 원래 속성 등록 선언 된 속성의 값의 형식을 보고는 `propertyType` 매개 변수입니다. 비슷합니다는 <xref:System.Windows.DependencyProperty.Name%2A>, 등록 후 종속성 속성의 속성 형식을 변경할 수 없습니다.</xref:System.Windows.DependencyProperty.Name%2A>"
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the PropertyType. The type name string of the PropertyType is obtained from the returned <xref:System.Type>.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public Type PropertyType { get; }
    return:
      type: System.Type
      description: "<xref:System.Type>속성 값의.</xref:System.Type>"
  overload: System.Windows.DependencyProperty.PropertyType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ReadOnly
  id: ReadOnly
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "이 종속성 속성을 식별할지 여부를 나타내는 값을 가져옵니다 <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> 인스턴스가 읽기 전용 종속성 속성입니다."
  remarks: "읽기 전용 종속성 속성을 호출 하 여 속성 시스템 내에서 등록 된 <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>메서드가 아닌는 <xref:System.Windows.DependencyProperty.Register%2A>메서드.</xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> 연결 된 속성 읽기 전용으로 등록할 수 있습니다. <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A> 를 참조 하십시오.       읽기 전용 종속성 속성에는 필요는 <xref:System.Windows.DependencyPropertyKey>식별자 대신 <xref:System.Windows.DependencyProperty>식별자 값을 설정 또는 메타 데이터 재정의 같은 메타 데이터 작업을 수행 합니다.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyPropertyKey> 컬렉션을 구입한 경우 <xref:System.Windows.DependencyProperty>식별자에 대 한 호출을 통해 <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>또는 다른 [!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)] 호출 하기 전에 읽기 전용 값을 확인, 식별자를 노출 하는 <xref:System.Windows.DependencyObject.SetValue%2A>또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>입력된 매개 변수로 해당 종속성 속성 식별자를 사용 하 여 종속성 속성의 식별자를 나타내는 읽기 전용이 아닌지 확인 하십시오.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyObject.SetValue%2A> </xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> </xref:System.Windows.DependencyProperty> 읽기 전용 값이 `true` 에서 종속성 속성을 프로그래밍 방식으로 방법이 있으면에 대 한 참조를 가져올 수는 <xref:System.Windows.DependencyPropertyKey>또는 메타 데이터에서 해당 종속성 속성의 식별자는 <xref:System.Windows.DependencyProperty>식별자에 식별자가 호출 하기 위해 정적 필드로 사용할 수 있어야 <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>읽기 전용 종속성 속성에 대해.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyPropertyKey>       에 대 한 get 접근자만 정의 해야 읽기 전용으로 등록 하는 사용자 지정 종속성 속성을 만들는 [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] 래퍼 속성입니다. 그렇지 않은 경우 클래스 속성에 대 한 래퍼 보조 종속성 속성에 대 한 액세스에 대 한 혼란을 줄 개체 모델을 갖습니다. 자세한 내용은 참조 [사용자 지정 종속성 속성](~/add/includes/ajax-current-ext-md.md) 또는 [읽기 전용 종속성 속성](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public bool ReadOnly { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>종속성 속성은 읽기 전용 이면 하는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.DependencyProperty.ReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  id: Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "지정 된 속성 이름, 속성 형식 및 소유자 유형을 사용 종속성 속성을 등록합니다."
  remarks: "종속성 속성 등록에 대 한 자세한 내용은 <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> 을 참조 하십시오."
  example:
  - >-
    [!code-cs[WPFAquariumSln#Register3Param](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#register3param)]
     [!code-vb[WPFAquariumSln#Register3Param](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#register3param)]
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "등록할 종속성 속성의 이름입니다. 이름은 소유자 형식의 등록 네임 스페이스 내에서 고유 해야 합니다."
    - id: propertyType
      type: System.Type
      description: "속성의 형식입니다."
    - id: ownerType
      type: System.Type
      description: "종속성 속성을 등록 하는 소유자 유형입니다."
    return:
      type: System.Windows.DependencyProperty
      description: "값을 설정 하는 데 사용 해야 하는 종속성 속성 식별자는 <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> 클래스에 필드입니다. 종속성 속성을 나중 프로그래밍 방식으로 해당 값을 설정 하거나 메타 데이터를 가져오는 등의 작업에 대 한 참조를 해당 식별자 사용 됩니다."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "지정 된 속성 이름, 속성 형식, 소유자 유형 및 속성 메타 데이터와 종속성 속성을 등록합니다."
  remarks: "종속성 속성 등록에 대 한 자세한 내용은 <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> 을 참조 하십시오."
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "등록할 종속성 속성의 이름입니다."
    - id: propertyType
      type: System.Type
      description: "속성의 형식입니다."
    - id: ownerType
      type: System.Type
      description: "종속성 속성을 등록 하는 소유자 유형입니다."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "종속성 속성에 대 한 속성 메타 데이터입니다."
    return:
      type: System.Windows.DependencyProperty
      description: "값을 설정 하는 데 사용 해야 하는 종속성 속성 식별자는 <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> 클래스에 필드입니다. 종속성 속성을 나중 프로그래밍 방식으로 해당 값을 설정 하거나 메타 데이터를 가져오는 등의 작업에 대 한 참조를 해당 식별자 사용 됩니다."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "종속성 속성으로 지정된 된 속성 이름, 속성 형식, 소유자 유형, 속성 메타 데이터 및 속성에 대 한 값 유효성 검사 콜백을 등록합니다."
  remarks: "종속성 속성 등록에 대 한 자세한 내용은 <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> 을 참조 하십시오."
  example:
  - "The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <xref:System.Windows.ValidateValueCallback>).  \n  \n [!code-cs[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/csharp/DPCallbackOverride/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]\n [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/visualbasic/DPCallbackOverride.sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]"
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "등록할 종속성 속성의 이름입니다."
    - id: propertyType
      type: System.Type
      description: "속성의 형식입니다."
    - id: ownerType
      type: System.Type
      description: "종속성 속성을 등록 하는 소유자 유형입니다."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "종속성 속성에 대 한 속성 메타 데이터입니다."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "일반적인 형식 유효성 검사 이외에 종속성 속성 값의 사용자 지정 유효성 검사를 수행 해야 하는 콜백에 대 한 참조입니다."
    return:
      type: System.Windows.DependencyProperty
      description: "값을 설정 하는 데 사용 해야 하는 종속성 속성 식별자는 <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> 클래스에 필드입니다. 종속성 속성을 나중 프로그래밍 방식으로 해당 값을 설정 하거나 메타 데이터를 가져오는 등의 작업에 대 한 참조를 해당 식별자 사용 됩니다."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  id: RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "지정 된 속성 이름, 속성 형식 및 소유자 유형을와 연결된 된 속성을 등록합니다."
  remarks: "연결된 된 속성에 정의 된 속성 개념은 [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]합니다. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]종속성 속성으로 연결 된 속성을 구현 합니다. 때문에 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] 연결 된 속성은 종속성 속성, 레이아웃 특성을 보고 등의 작업에 대 한 일반 속성 시스템에서 사용할 수 있는 메타 데이터가 적용을 유지할 수 있습니다. 자세한 내용은 참조 [연결 된 속성 개요](~/add/includes/ajax-current-ext-md.md)합니다.       종속성 속성 등록에 대 한 자세한 내용은 <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> 을 참조 하십시오."
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "등록할 종속성 속성의 이름입니다."
    - id: propertyType
      type: System.Type
      description: "속성의 형식입니다."
    - id: ownerType
      type: System.Type
      description: "종속성 속성을 등록 하는 소유자 유형입니다."
    return:
      type: System.Windows.DependencyProperty
      description: "값을 설정 하는 데 사용 해야 하는 종속성 속성 식별자는 <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> 클래스에 필드입니다. 종속성 속성을 나중 프로그래밍 방식으로 해당 값을 설정 하거나 메타 데이터를 가져오는 등의 작업에 대 한 참조를 해당 식별자 사용 됩니다."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "지정 된 속성 이름, 속성 형식, 소유자 유형 및 속성 메타 데이터와 연결된 된 속성을 등록합니다."
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with RegisterAttached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with RegisterAttached even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use RegisterAttached to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "등록할 종속성 속성의 이름입니다."
    - id: propertyType
      type: System.Type
      description: "속성의 형식입니다."
    - id: ownerType
      type: System.Type
      description: "종속성 속성을 등록 하는 소유자 유형입니다."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "종속성 속성에 대 한 속성 메타 데이터입니다. 여기에 기본값 뿐만 아니라 다른 특성도 포함 됩니다."
    return:
      type: System.Windows.DependencyProperty
      description: "값을 설정 하는 데 사용 해야 하는 종속성 속성 식별자는 <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> 클래스에 필드입니다. 종속성 속성을 나중 프로그래밍 방식으로 해당 값을 설정 하거나 메타 데이터를 가져오는 등의 작업에 대 한 참조를 해당 식별자 사용 됩니다."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "연결된 된 속성으로 지정 된 속성 형식, 소유자 유형, 속성 메타 데이터 및 속성에 대 한 값 유효성 검사 콜백을 등록합니다."
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature. This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "등록할 종속성 속성의 이름입니다."
    - id: propertyType
      type: System.Type
      description: "속성의 형식입니다."
    - id: ownerType
      type: System.Type
      description: "종속성 속성을 등록 하는 소유자 유형입니다."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "종속성 속성에 대 한 속성 메타 데이터입니다. 여기에 기본값 뿐만 아니라 다른 특성도 포함 됩니다."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "일반적인 형식 유효성 검사 이외에 종속성 속성 값의 사용자 지정 유효성 검사를 수행 해야 하는 콜백에 대 한 참조입니다."
    return:
      type: System.Windows.DependencyProperty
      description: "값을 설정 하는 데 사용 해야 하는 종속성 속성 식별자는 <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> 클래스에 필드입니다. 종속성 속성을 나중 프로그래밍 방식으로 해당 값을 설정 하거나 메타 데이터를 가져오는 등의 작업에 대 한 참조를 해당 식별자 사용 됩니다."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "지정 된 속성 형식, 소유자 유형 및 속성 메타 데이터와 읽기 전용 연결 된 속성을 등록합니다."
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "등록할 종속성 속성의 이름입니다."
    - id: propertyType
      type: System.Type
      description: "속성의 형식입니다."
    - id: ownerType
      type: System.Type
      description: "종속성 속성을 등록 하는 소유자 유형입니다."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "종속성 속성에 대 한 속성 메타 데이터입니다."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "그런 다음 나중에 종속성 속성을 참조 하는 데 사용 되는 클래스의 정적 읽기 전용 필드의 값을 설정 하는 데 사용 해야 하는 종속성 속성 키입니다."
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "읽기 전용 연결 된 속성을 지정한 속성 형식, 소유자 유형, 속성 메타 데이터 및 유효성 검사 콜백을 등록 합니다."
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "등록할 종속성 속성의 이름입니다."
    - id: propertyType
      type: System.Type
      description: "속성의 형식입니다."
    - id: ownerType
      type: System.Type
      description: "종속성 속성을 등록 하는 소유자 유형입니다."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "종속성 속성에 대 한 속성 메타 데이터입니다."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "일반적인 형식 유효성 검사 이외에 종속성 속성 값의 사용자 지정 유효성 검사를 수행 해야 하는 사용자가 만든 콜백에 대 한 참조입니다."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "종속성 속성을 참조 하는을 사용 하 여 클래스의 정적 읽기 전용 필드의 값을 설정 하는 데 사용 해야 하는 종속성 속성 키입니다."
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "지정 된 속성 형식, 소유자 유형 및 속성 메타 데이터 사용 되는 읽기 전용 종속성 속성을 등록합니다."
  remarks: "이 메서드는 형식을 반환 <xref:System.Windows.DependencyPropertyKey>반면, <xref:System.Windows.DependencyProperty.RegisterAttached%2A>형식을 <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> 반환</xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyPropertyKey> 일반적으로 읽기 전용 속성을 나타내는 키 적용 되지 않습니다. public <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> 를 호출 하 여 종속성 속성 값을 설정 하는 키를 사용할 수 있으므로 클래스 디자인 요구 사항에 영향을 줍니다 없지만의 표시 여부 및 액세스 제한 하는 것이 좋습니다 일반적으로 <xref:System.Windows.DependencyPropertyKey>클래스 또는 응용 프로그램 논리의 일부로 해당 종속성 속성을 설정 하는 데 필요한 코드의 부분에.</xref:System.Windows.DependencyPropertyKey> 값을 노출 하 여 읽기 전용 종속성 속성에 대 한 종속성 속성 식별자를 노출 하는 것이 좋습니다 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>로 `public static readonly` 필드 프로그램 클래스에</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       읽기 전용 종속성 속성은 매우 일반적인 시나리오 둘 다의 기존 [!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)] 및 사용자 지정 시나리오 때문에 다른 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] 해당 속성을 호출자가 설정할 수 없는 경우에 기능 종속성 속성을 필요할 수 있습니다. 예를 종속성 속성을 사용 하는 다른 속성 시스템 작업에 대 한 기반으로 읽기 전용 종속성 속성의 값을 사용할 수는 <xref:System.Windows.Trigger>스타일에서 종속성 속성에.</xref:System.Windows.Trigger>       종속성 속성 등록에 대 한 자세한 내용은 <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> 을 참조 하십시오."
  example:
  - "The following example registers an `AquariumSize` dependency property as read-only. The example defines `AquariumSizeKey` as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as `AquariumSizeProperty`. Also, a wrapper is created for `AquariumSize`, with only a get accessor.  \n  \n [!code-cs[WPFAquariumSln#RODP](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#rodp)]\n [!code-vb[WPFAquariumSln#RODP](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#rodp)]"
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "등록할 종속성 속성의 이름입니다."
    - id: propertyType
      type: System.Type
      description: "속성의 형식입니다."
    - id: ownerType
      type: System.Type
      description: "종속성 속성을 등록 하는 소유자 유형입니다."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "종속성 속성에 대 한 속성 메타 데이터입니다."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "종속성 속성을 참조 하는을 사용 하 여 클래스의 정적 읽기 전용 필드의 값을 설정 하는 데 사용 해야 하는 종속성 속성 키입니다."
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "읽기 전용 종속성 속성을 지정한 속성 형식, 소유자 유형, 속성 메타 데이터 및 유효성 검사 콜백을 등록 합니다."
  remarks: "이 메서드는 형식을 반환 <xref:System.Windows.DependencyPropertyKey>반면, <xref:System.Windows.DependencyProperty.RegisterAttached%2A>형식을 <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> 반환</xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyPropertyKey> 일반적으로 읽기 전용 속성을 나타내는 키 적용 되지 않습니다. public <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> 를 호출 하 여 종속성 속성 값을 설정 하는 키를 사용할 수 있으므로 클래스 디자인 요구 사항에 영향을 줍니다 없지만의 표시 여부 및 액세스 제한 하는 것이 좋습니다 일반적으로 <xref:System.Windows.DependencyPropertyKey>클래스 또는 응용 프로그램 논리의 일부로 해당 종속성 속성을 설정 하는 데 필요한 코드의 부분에.</xref:System.Windows.DependencyPropertyKey> 값을 노출 하 여 읽기 전용 종속성 속성에 대 한 종속성 속성 식별자를 노출 하는 것이 좋습니다 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>로 `public static readonly` 필드 프로그램 클래스에</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       읽기 전용 종속성 속성은 매우 일반적인 시나리오입니다. 예를 종속성 속성을 사용 하는 다른 속성 시스템 작업에 대 한 기반으로 읽기 전용 종속성 속성의 값을 사용할 수는 <xref:System.Windows.Trigger>스타일에서 종속성 속성에.</xref:System.Windows.Trigger>       종속성 속성 등록에 대 한 자세한 내용은 <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> 을 참조 하십시오.       읽기 전용 종속성 속성의 유효성 검사에 덜 중요할 수 있습니다. 키에 대해 지정 하는 public이 아닌 액세스 수준을 임의의 잘못 된 입력에 대 한 위험을 줄일 수 있습니다."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "등록할 종속성 속성의 이름입니다."
    - id: propertyType
      type: System.Type
      description: "속성의 형식입니다."
    - id: ownerType
      type: System.Type
      description: "종속성 속성을 등록 하는 소유자 유형입니다."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "종속성 속성에 대 한 속성 메타 데이터입니다."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "일반적인 형식 유효성 검사 이외에 종속성 속성 값의 사용자 지정 유효성 검사를 수행 해야 하는 사용자가 만든 콜백에 대 한 참조입니다."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "그런 다음 나중에 종속성 속성을 참조 하는 데 사용 되는 클래스의 정적 읽기 전용 필드의 값을 설정 하는 데 사용 해야 하는 종속성 속성 키입니다."
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ToString
  id: ToString
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "종속성 속성의 문자열 표현을 반환합니다."
  remarks: "이 구현은 <xref:System.Windows.DependencyProperty.Name%2A>속성 값.</xref:System.Windows.DependencyProperty.Name%2A>"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "종속성 속성의 문자열 표현입니다."
  overload: System.Windows.DependencyProperty.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.UnsetValue
  id: UnsetValue
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
  type: Field
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "사용 되는 정적 값 지정는 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] 속성 시스템 보다는 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 속성이 존재 하지만 속성 시스템에서 설정한 해당 값이 없는 나타냅니다."
  remarks: "UnsetValue 시나리오에 사용 되는 데 센티널 값은 여기서는 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] 속성 시스템에서 요청 된 확인할 수 없으면 <xref:System.Windows.DependencyProperty>값.</xref:System.Windows.DependencyProperty> UnsetValue 사용 되는 대신 `null`때문에, `null` 유효한 속성 값으로 올바른 수 (및 자주 사용 되는) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.</xref:System.Windows.PropertyMetadata.DefaultValue%2A>       <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>.</xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName> 부족 UnsetValue는 반환 되지 않습니다. 호출 하는 경우 <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>에서 종속성 속성에는 <xref:System.Windows.DependencyObject>인스턴스를 다음 중 하나라도 충족 되:-종속성 속성의 기본값이 메타 데이터에서 설정 하 고 해당 값이 반환 됩니다.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName> 이 값은 <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</xref:System.Windows.DependencyProperty.DefaultMetadata%2A> 에서 가져올 수 있습니다.      -일부 다른 값 속성 시스템에 의해 구성 된 및 기본 값은 더 이상 해당 됩니다. 자세한 내용은 참조 [종속성 속성 값 우선 순위](~/add/includes/ajax-current-ext-md.md)합니다.       설정 된 <xref:System.Windows.PropertyMetadata.DefaultValue%2A>UnsetValue의 수는 없습니다.</xref:System.Windows.PropertyMetadata.DefaultValue%2A>       <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>요청된 된 속성이 로컬로 설정 하지 않은 경우 UnsetValue를 반환 합니다.</xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>       UnsetValue 특별 한 의미가 <xref:System.Windows.CoerceValueCallback>.</xref:System.Windows.CoerceValueCallback> 의 반환 값으로 사용 될 경우 자세한 내용은 참조 [종속성 속성의 콜백 및 유효성 검사](~/add/includes/ajax-current-ext-md.md)합니다.       데이터베이스에 바인딩하는 경우 유의 UnsetValue 동일 하지 않습니다 <xref:System.DBNull.Value>, 하는 방법 유사한 방식에서 <xref:System.DBNull.Value>는 동일 하지 않습니다.</xref:System.DBNull.Value> </xref:System.DBNull.Value>"
  syntax:
    content: public static readonly object UnsetValue;
    return:
      type: System.Object
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  id: ValidateValueCallback
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "종속성 속성에 대 한 값 유효성 검사 콜백을 가져옵니다."
  remarks: "이 속성에 포함 됩니다 `null` 종속성 속성에 등록 된 유효성 검사 콜백 없습니다.       정적 방식으로 작동 해야 하는 값 유효성 검사: 유효성 검사를 통해 적용 되는 <xref:System.Windows.ValidateValueCallback>제공 된 값에 특정 인스턴스가 올바른지 여부를 확인할 수 없습니다.</xref:System.Windows.ValidateValueCallback> 콜백은 종속성 속성을 소유 하는 모든 개체 해야 유효한 것으로 제공 된 값을 허용 하지 않아야 하는지 여부를 확인만 수 있습니다. 특정 인스턴스를 사용 하 여 다른 종속성 속성의 값을 사용 하는 유효성 검사를 수행 해야 할 경우는 <xref:System.Windows.CoerceValueCallback>대신.</xref:System.Windows.CoerceValueCallback> <xref:System.Windows.CoerceValueCallback>아닌 종속성 속성 식별자 바로 아래에 종속성 속성 메타 데이터의 일부로 등록 됩니다.</xref:System.Windows.CoerceValueCallback> 자세한 내용은 참조 [종속성 속성의 콜백 및 유효성 검사](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public System.Windows.ValidateValueCallback ValidateValueCallback { get; }
    return:
      type: System.Windows.ValidateValueCallback
      description: "이 종속성 속성에 제공 된 값 유효성 검사 콜백을 <code> validateValueCallback </code> 원래 종속성 속성 등록에서 매개 변수입니다."
  overload: System.Windows.DependencyProperty.ValidateValueCallback*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
- uid: System.Windows.PropertyMetadata
  parent: System.Windows
  isExternal: false
  name: PropertyMetadata
  nameWithType: PropertyMetadata
  fullName: System.Windows.PropertyMetadata
- uid: System.Windows.DependencyProperty.DefaultMetadata
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
- uid: System.Windows.DependencyObjectType
  parent: System.Windows
  isExternal: false
  name: DependencyObjectType
  nameWithType: DependencyObjectType
  fullName: System.Windows.DependencyObjectType
- uid: System.Windows.DependencyProperty.GlobalIndex
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
- uid: System.Windows.DependencyProperty.Name
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
- uid: System.Windows.DependencyPropertyKey
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyKey
  nameWithType: DependencyPropertyKey
  fullName: System.Windows.DependencyPropertyKey
- uid: System.Windows.DependencyProperty.OwnerType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.ValidateValueCallback
  parent: System.Windows
  isExternal: false
  name: ValidateValueCallback
  nameWithType: ValidateValueCallback
  fullName: System.Windows.ValidateValueCallback
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.ToString
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
- uid: System.Windows.DependencyProperty.UnsetValue
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
- uid: System.Windows.DependencyProperty.AddOwner*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner
  nameWithType: DependencyProperty.AddOwner
- uid: System.Windows.DependencyProperty.DefaultMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode
  nameWithType: DependencyProperty.GetHashCode
- uid: System.Windows.DependencyProperty.GetMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata
  nameWithType: DependencyProperty.GetMetadata
- uid: System.Windows.DependencyProperty.GlobalIndex*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType
  nameWithType: DependencyProperty.IsValidType
- uid: System.Windows.DependencyProperty.IsValidValue*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue
  nameWithType: DependencyProperty.IsValidValue
- uid: System.Windows.DependencyProperty.Name*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
- uid: System.Windows.DependencyProperty.OverrideMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata
  nameWithType: DependencyProperty.OverrideMetadata
- uid: System.Windows.DependencyProperty.OwnerType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register
  nameWithType: DependencyProperty.Register
- uid: System.Windows.DependencyProperty.RegisterAttached*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached
  nameWithType: DependencyProperty.RegisterAttached
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly
  nameWithType: DependencyProperty.RegisterAttachedReadOnly
- uid: System.Windows.DependencyProperty.RegisterReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly
  nameWithType: DependencyProperty.RegisterReadOnly
- uid: System.Windows.DependencyProperty.ToString*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString
  nameWithType: DependencyProperty.ToString
- uid: System.Windows.DependencyProperty.ValidateValueCallback*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
