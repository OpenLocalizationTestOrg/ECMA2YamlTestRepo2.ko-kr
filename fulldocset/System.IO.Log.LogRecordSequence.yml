### YamlMime:ManagedReference
items:
- uid: System.IO.Log.LogRecordSequence
  id: LogRecordSequence
  children:
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  - System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.BaseSequenceNumber
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.CreateReservationCollection
  - System.IO.Log.LogRecordSequence.Dispose
  - System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.Flush
  - System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.LastSequenceNumber
  - System.IO.Log.LogRecordSequence.LogStore
  - System.IO.Log.LogRecordSequence.MaximumRecordLength
  - System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.LogRecordSequence.ReadRestartAreas
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReservedBytes
  - System.IO.Log.LogRecordSequence.RestartSequenceNumber
  - System.IO.Log.LogRecordSequence.RetryAppend
  - System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.TailPinned
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: LogRecordSequence
  nameWithType: LogRecordSequence
  fullName: System.IO.Log.LogRecordSequence
  type: Class
  summary: "에 저장 된 레코드 시퀀스를 나타냅니다는 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>합니다."
  remarks: "LogRecordSequence 클래스에는 공통 로그 CLFS (File System) 로그 위에 레코드 시퀀스 인터페이스의 구현을 제공 합니다. 표준 레코드 기반 기능 외에도 로그 전체 상태를 방지 하 고 동일한 물리적 파일에서 클라이언트를 멀티플렉싱 하기 위한 정책 모델을 제공 합니다. 와 함께 작동는 <xref:System.IO.Log.LogStore>직접 조작 하 고 관리는 CLFS 로그 파일에 대 한 인터페이스를 제공 하는 클래스입니다.</xref:System.IO.Log.LogStore> 간의 관계는 <xref:System.IO.Log.LogStore>클래스 및 LogRecordSequence 클래스는 유사 디스크 파일 간의 관계 및 <xref:System.IO.FileStream>개체입니다.</xref:System.IO.FileStream> </xref:System.IO.Log.LogStore> 디스크 파일은 실제 저장소를 제공 하 고 길이 및 마지막 액세스 시간이; 같은 특성이 있으며 <xref:System.IO.FileStream>개체에서 읽고 쓰는.를 사용할 수 있는 파일에 대 한 뷰를 제공</xref:System.IO.FileStream> 하는 동안 마찬가지로,는 <xref:System.IO.Log.LogStore>; 디스크 범위의 컬렉션 및 정책과 같은 특성이 클래스 및 LogRecordSequence 클래스 데이터 읽기 및 쓰기 위한 레코드 기반 메커니즘을 제공 합니다.</xref:System.IO.Log.LogStore>"
  example:
  - "This example shows how to use the LogRecordSequence class:  \n  \n [!code-cs[S_UELogRecordSequence#0](~/add/codesnippet/csharp/t-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#0](~/add/codesnippet/visualbasic/t-system.io.log.logrecor_1.vb)]"
  syntax:
    content: 'public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  - System.IO.Log.IRecordSequence
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  id: '#ctor(System.IO.Log.LogStore)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> 지정된 된 로그 저장소를 사용 하 여 클래스입니다."
  remarks: "버퍼 크기는 추가 하거나 읽을 수 있는 레코드의 최대 크기를 결정 합니다. 이 생성자에는 기본값 64 설정 됩니다. 원하는 버퍼 수는 10으로 설정 됩니다."
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "<xref href=&quot;System.IO.Log.LogStore&quot;> </xref> 이 레코드 시퀀스를 사용 해야 합니다."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logStore</code>잘못 되었습니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> 로그 저장소와 액세스 모드를 지정된 된 경로 사용 하 여 클래스입니다."
  remarks: "이 생성자는 새 <xref:System.IO.Log.LogRecordSequence>에서 새로운 <xref:System.IO.Log.LogStore>개체는 지정 된 경로 모드를 사용 하 여.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> 저장소에 읽기/쓰기 액세스를 지정 하 고 읽기 권한을 공유 저장소는 열립니다."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "열려는 로그 저장소의 기본 파일에 대 한 상대 또는 절대 경로입니다."
    - id: mode
      type: System.IO.FileMode
      description: "중 하나는 <xref href=&quot;System.IO.FileMode&quot;> </xref> 열거나 저장소를 만들 방법을 결정 하는 값입니다."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>빈 문자열 (&quot;&quot;).       -또는- <code>path</code> 공백만 포함 합니다.       -또는- <code>path</code> 하나 이상의 잘못 된 문자가 포함 되어 있습니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>잘못 된 값을 포함합니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "파일을 찾을 수 없습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "로그 저장소를 열 때 I/O 오류가 발생 합니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "이 작업이 지원 되지 않습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>필요한 공통 로그 파일 시스템 (CLFS) 구성 요소가 설치 되어 있지 않으므로 사용할 수 없습니다. 사용 중인 플랫폼에 사용할 수 있으면 CLFS 구성 요소를 설치 하거나 사용 하 여 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> 클래스."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  id: '#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> 된 지정된 된 로그 저장소, 각 레코드에 대 한 버퍼 크기 및 버퍼 수입니다."
  remarks: "에 대 한 값을 지정 하려면이 생성자를 사용 하 여 `bufferSize` 및 `bufferCount` 64에 대 한 기본값을 사용 하지 않으려는 및 `bufferSize` 및에 대 한 10 `bufferCount`합니다."
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "<xref href=&quot;System.IO.Log.LogStore&quot;> </xref> 이 레코드 시퀀스를 사용 해야 합니다."
    - id: bufferSize
      type: System.Int32
      description: "원하는 버퍼 크기 (바이트)입니다. 버퍼 크기는 추가 하거나 읽을 수 있는 레코드의 최대 크기를 결정 합니다."
    - id: bufferCount
      type: System.Int32
      description: "원하는 버퍼 수입니다."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>logStore</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize </code>가 음수 이거나&0;입니다.       -또는- <code>bufferCount</code> 가 음수 이거나&0;입니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> 로그 저장소와 액세스 및 공유 모드를 지정된 된 경로 사용 하 여 클래스입니다."
  remarks: "이 생성자는 새 <xref:System.IO.Log.LogRecordSequence>에서 새로운 <xref:System.IO.Log.LogStore>지정 된 경로, 모드 및 액세스를 사용 하 여 개체.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> 저장소는 읽기 권한을 공유 열립니다."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "열려는 로그 저장소의 기본 파일에 대 한 상대 또는 절대 경로입니다."
    - id: mode
      type: System.IO.FileMode
      description: "중 하나는 <xref href=&quot;System.IO.FileMode&quot;> </xref> 열거나 저장소를 만들 방법을 결정 하는 값입니다."
    - id: access
      type: System.IO.FileAccess
      description: "중 하나는 <xref href=&quot;System.IO.FileAccess&quot;> </xref> 하 여 파일에 액세스할 수 있는 방법을 결정 하는 값은 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>합니다."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>빈 문자열 (&quot;&quot;).       -또는- <code>path</code> 공백만 포함 합니다.       -또는- <code>path</code> 하나 이상의 잘못 된 문자가 포함 되어 있습니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>잘못 된 값을 포함합니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "파일을 찾을 수 없습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "로그 저장소를 열 때 I/O 오류가 발생 합니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "이 작업이 지원 되지 않습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>필요한 공통 로그 파일 시스템 (CLFS) 구성 요소가 설치 되어 있지 않으므로 사용할 수 없습니다. 사용 중인 플랫폼에 사용할 수 있으면 CLFS 구성 요소를 설치 하거나 사용 하 여 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> 클래스."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> 로그 저장소와 액세스 모드를 지정된 된 경로 사용 하 여 클래스입니다."
  remarks: "이 생성자는 새 <xref:System.IO.Log.LogRecordSequence>에서 새로운 <xref:System.IO.Log.LogStore>지정 된 경로, 모드 및 액세스를 사용 하 여 개체.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> 지정 된 액세스 권한을 공유 저장소는 열립니다."
  example:
  - "This example shows how to use this <xref:System.IO.Log.LogRecordSequence> constructor:  \n  \n [!code-cs[S_UELogRecordSequence#1](~/add/codesnippet/csharp/5a33f64b-b9a0-4b07-9df4-_1.cs)]\n [!code-vb[S_UELogRecordSequence#1](~/add/codesnippet/visualbasic/5a33f64b-b9a0-4b07-9df4-_1.vb)]"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "열려는 로그 저장소의 기본 파일에 대 한 상대 또는 절대 경로입니다."
    - id: mode
      type: System.IO.FileMode
      description: "중 하나는 <xref href=&quot;System.IO.FileMode&quot;> </xref> 열거나 저장소를 만들 방법을 결정 하는 값입니다."
    - id: access
      type: System.IO.FileAccess
      description: "중 하나는 <xref href=&quot;System.IO.FileAccess&quot;> </xref> 하 여 파일에 액세스할 수 있는 방법을 결정 하는 값은 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>합니다."
    - id: share
      type: System.IO.FileShare
      description: "중 하나는 <xref href=&quot;System.IO.FileShare&quot;> </xref> 로그 저장소가 프로세스 간에 공유 될 방법을 결정 하는 값입니다."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>빈 문자열 (&quot;&quot;).       -또는- <code>path</code> 공백만 포함 합니다.       -또는- <code>path</code> 하나 이상의 잘못 된 문자가 포함 되어 있습니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>잘못 된 값을 포함합니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "파일을 찾을 수 없습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "로그 저장소를 열 때 I/O 오류가 발생 합니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "이 작업이 지원 되지 않습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>필요한 공통 로그 파일 시스템 (CLFS) 구성 요소가 설치 되어 있지 않으므로 사용할 수 없습니다. 사용 중인 플랫폼에 사용할 수 있으면 CLFS 구성 요소를 설치 하거나 사용 하 여 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> 클래스."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> 로그 저장소, 파일 사용 권한, 액세스 및 공유 모드 및 버퍼 크기 및 레코드 수가 지정 된 경로 사용 하 여 클래스입니다."
  remarks: "이 생성자는 새 <xref:System.IO.Log.LogRecordSequence>에서 새로운 <xref:System.IO.Log.LogStore>지정 된 경로, 모드 및 액세스를 사용 하 여 개체.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> 지정 된 액세스 권한을 공유 저장소는 열립니다."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);
    parameters:
    - id: path
      type: System.String
      description: "열려는 로그 저장소의 기본 파일에 대 한 상대 또는 절대 경로입니다."
    - id: mode
      type: System.IO.FileMode
      description: "중 하나는 <xref href=&quot;System.IO.FileMode&quot;> </xref> 열거나 저장소를 만들 방법을 결정 하는 값입니다."
    - id: access
      type: System.IO.FileAccess
      description: "중 하나는 <xref href=&quot;System.IO.FileAccess&quot;> </xref> 하 여 파일에 액세스할 수 있는 방법을 결정 하는 값은 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>합니다."
    - id: share
      type: System.IO.FileShare
      description: "중 하나는 <xref href=&quot;System.IO.FileShare&quot;> </xref> 로그 저장소가 프로세스 간에 공유 될 방법을 결정 하는 값입니다."
    - id: bufferSize
      type: System.Int32
      description: "원하는 버퍼 크기 (바이트)입니다. 버퍼 크기는 추가 하거나 읽을 수 있는 레코드의 최대 크기를 결정 합니다."
    - id: bufferCount
      type: System.Int32
      description: "원하는 버퍼 수입니다."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>빈 문자열 (&quot;&quot;).       -또는- <code>path</code> 공백만 포함 합니다.       -또는- <code>path</code> 하나 이상의 잘못 된 문자가 포함 되어 있습니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>잘못 된 값을 포함합니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "파일을 찾을 수 없습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "로그 저장소를 열 때 I/O 오류가 발생 합니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "이 작업이 지원 되지 않습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>필요한 공통 로그 파일 시스템 (CLFS) 구성 요소가 설치 되어 있지 않으므로 사용할 수 없습니다. 사용 중인 플랫폼에 사용할 수 있으면 CLFS 구성 요소를 설치 하거나 사용 하 여 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> 클래스."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> 클래스입니다."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "열려는 로그 저장소의 기본 파일에 대 한 상대 또는 절대 경로입니다."
    - id: mode
      type: System.IO.FileMode
      description: "유효한 <xref href=&quot;System.IO.FileMode&quot;> </xref> 열거나 저장소를 만들 방법을 결정 하는 값입니다."
    - id: access
      type: System.IO.FileAccess
      description: "유효한 <xref href=&quot;System.IO.FileAccess&quot;> </xref> 로그 저장소에 액세스할 수 있는 방법을 결정 하는 값입니다."
    - id: share
      type: System.IO.FileShare
      description: "유효한 <xref href=&quot;System.IO.FileShare&quot;> </xref> 로그 저장소가 프로세스 간에 공유 될 방법을 결정 하는 값입니다."
    - id: bufferSize
      type: System.Int32
      description: "원하는 버퍼 크기 (바이트)입니다. 버퍼 크기는 추가 하거나 읽을 수 있는 레코드의 최대 크기를 결정 합니다."
    - id: bufferCount
      type: System.Int32
      description: "원하는 버퍼 수입니다."
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "유효한 <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> 저장소를 만들어야 하는 경우 새로 만든된 저장소에 설정할 보안을 지정 하는 값입니다."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "지정한 파일 <code> path </code> 올바르지 않습니다.       -또는-지정 된 로그 저장소 파일 이름이 잘못 되었습니다.       -또는- <code> mode </code> 값 <xref href=&quot;System.IO.FileMode&quot;> </xref>, 쓰기 권한 없이 사용할 수 없습니다.       -또는- <code> mode </code> 값 <xref href=&quot;System.IO.FileMode&quot;> </xref>, 쓰기 권한 없이 사용할 수 없습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "인수 중 하나 이상이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "인수 중 하나 이상이 범위를 벗어났습니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "지정한 파일 <code> path </code> 찾을 수 없습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-지정 된 파일이 <code> path </code> 액세스할 수 없습니다 사용 중이기 때문에 다른 프로세스에서 합니다.       -또는-지정 된 파일이 <code> path </code> 파일 또는 디렉터리가 이미 있기 때문에 만들 수 없습니다.       -또는-로그 핸들을 스레드 풀에 바인딩할 수 없습니다.       -또는-지정 된 로그 파일 형식이 나 버전이 잘못 되었습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "이 작업이 지원 되지 않습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>필요한 공통 로그 파일 시스템 (CLFS) 구성 요소가 설치 되어 있지 않으므로 사용할 수 없습니다. 사용 중인 플랫폼에 사용할 수 있으면 CLFS 구성 요소를 설치 하거나 사용 하 여 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> 클래스."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "로그의 기준 시퀀스 번호를 앞으로 이동합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "이 메서드는 종종와 함께 사용 되는 <xref:System.IO.Log.LogRecordSequence.TailPinned>레코드에 공간을 확보 하는 이벤트입니다.</xref:System.IO.Log.LogRecordSequence.TailPinned> <xref:System.IO.Log.LogRecordSequence.TailPinned>이벤트 (즉, 기준 시퀀스 번호) 시퀀스의 테일 공간을 확보 하 앞으로 이동 해야 함을 나타냅니다.</xref:System.IO.Log.LogRecordSequence.TailPinned> 공간을 확보 하거나 작성 하 여 수행할 수 있습니다 재시작 영역을 사용 하는 <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>또는 로그를 자르는 메서드와 하 여 지정 된 로그의 기준 시퀀스 번호 이동 AdvanceBaseSequenceNumber 메서드를 사용 하는 `newBaseSequenceNumber` 매개 변수.</xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> &quot;예&quot; 섹션의 코드 예제에는 두 번째 방법을 보여 줍니다.       이 메서드를 호출 하는 동일한 방식으로 한 새 기준 시퀀스 번호를 사용 하 여 설정 된 <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>메서드를 제외 하 고 재시작 레코드를 로그에 쓰여집니다</xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>"
  example:
  - "This example shows how to use the AdvanceBaseSequenceNumber method with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a log sequence.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "새 기본 지정 <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> 로그에 대 한 합니다. 이 내에 있어야 현재 기준 시퀀스 번호와 로그의 마지막 시퀀스 번호 사이의 범위 까지입니다."
  overload: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>이 시퀀스에 대해 올바르지 않습니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "기존 또는 새 아카이브 테일이나 베이스가 활성 로그의 올바르지 않습니다.       -또는- <code> newBaseSequenceNumber </code> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "지정된 된 로그에는 범위가 없습니다. 레코드 시퀀스를 사용 하기 전에 하나 이상의 범위를 만들어야 합니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "로그 레코드를 기록 된 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "에 포함 된 데이터는 `data` 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       일반적으로이 메서드는 레코드를 쓰기 전에 완료 됩니다. 지정 하거나 기록 된 하려면는 <xref:System.IO.Log.RecordAppendOptions>플래그를 사용 하는 `recordAppendOptions` 매개 변수 또는 호출의 <xref:System.IO.Log.LogRecordSequence.Flush%2A>메서드.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example demonstrates how to use this method to append a log record to the sequence.  \n  \n [!code-cs[S_UELogRecordSequence#13](~/add/codesnippet/csharp/11cb4ef9-9d52-4994-983c-_1.cs)]\n [!code-vb[S_UELogRecordSequence#13](~/add/codesnippet/visualbasic/11cb4ef9-9d52-4994-983c-_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "이전 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "유효한 값 <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> 데이터를 작성 하는 방법을 지정 하는 합니다."
    return:
      type: System.IO.Log.SequenceNumber
      description: "추가 된 로그 레코드의 시퀀스 번호입니다."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>또는 <code>previousRecord</code> 이이 시퀀스에 유효 하지 않습니다.       -또는- <code>data</code> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.       -또는- <code>reservations</code> 이 레코드 시퀀스에서 만들어지지 않았습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "인수 중 하나 이상이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>또는 <code>previousRecord</code> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "로그 레코드를 추가 하는 <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "에 포함 된 데이터는 `data` 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       일반적으로이 메서드는 레코드를 쓰기 전에 완료 됩니다. 지정 하거나 기록 된 하려면는 <xref:System.IO.Log.RecordAppendOptions>플래그를 사용 하는 `recordAppendOptions` 매개 변수 또는 호출의 <xref:System.IO.Log.LogRecordSequence.Flush%2A>메서드.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "이전 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "유효한 값 <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> 데이터를 작성 하는 방법을 지정 하는 합니다."
    return:
      type: System.IO.Log.SequenceNumber
      description: "추가 된 로그 레코드의 시퀀스 번호입니다."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>또는 <code>previousRecord</code> 이이 시퀀스에 유효 하지 않습니다.       -또는- <code>data</code> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.       -또는- <code>reservations</code> 이 레코드 시퀀스에서 만들어지지 않았습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "인수 중 하나 이상이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>또는 <code>previousRecord</code> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "로그 레코드를 추가 하는 <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, 시퀀스에서 이전에 예약 된 공간을 사용 하 여 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "에 포함 된 데이터는 `data` 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       추가 된 레코드 이전에 예약 된, 변수로 지정 된 예약을 사용 하 여 공간을 사용 하면는 `reservations` 매개 변수입니다. 추가 작업이 성공 하면 및 예약 영역이 컬렉션에서 제거할 데이터를 포함 될 수 있는 가장 작은 예약 영역을 사용 합니다.       일반적으로이 메서드는 레코드를 쓰기 전에 완료 됩니다. 지정 하거나 기록 된 하려면는 <xref:System.IO.Log.RecordAppendOptions>플래그를 사용 하는 `recordAppendOptions` 매개 변수 또는 호출의 <xref:System.IO.Log.LogRecordSequence.Flush%2A>메서드.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "이전 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "유효한 값 <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> 데이터를 작성 하는 방법을 지정 하는 합니다."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> 이 레코드에 대해 사용 해야 하는 예약이 포함 된입니다."
    return:
      type: System.IO.Log.SequenceNumber
      description: "추가 된 로그 레코드의 시퀀스 번호입니다."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>또는 <code>previousRecord</code> 이이 시퀀스에 유효 하지 않습니다.       -또는- <code>data</code> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.       -또는- <code>reservations</code> 이 레코드 시퀀스에서 만들어지지 않았습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "인수 중 하나 이상이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>또는 <code>previousRecord</code> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "에 맞게 충분히 큰 예약이 <code> data </code> 있습니다 <code> reservations </code>합니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "로그 레코드를 추가 하는 <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, 시퀀스에서 이전에 예약 된 공간을 사용 하 여 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "에 포함 된 데이터는 `data` 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       추가 된 레코드 이전에 예약 된, 변수로 지정 된 예약을 사용 하 여 공간을 사용 하면는 `reservations` 매개 변수입니다. 추가 작업이 성공 하면 및 예약 영역이 컬렉션에서 제거할 데이터를 포함 될 수 있는 가장 작은 예약 영역을 사용 합니다.       일반적으로이 메서드는 레코드를 쓰기 전에 완료 됩니다. 지정 하거나 기록 된 하려면는 <xref:System.IO.Log.RecordAppendOptions>플래그를 사용 하는 `recordAppendOptions` 매개 변수 또는 호출의 <xref:System.IO.Log.IRecordSequence.Flush%2A>메서드.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "이전 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "유효한 값 <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> 데이터를 작성 하는 방법을 지정 하는 합니다."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> 이 레코드에 대해 사용 해야 하는 예약이 포함 된입니다."
    return:
      type: System.IO.Log.SequenceNumber
      description: "추가 된 로그 레코드의 시퀀스 번호입니다."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>또는 <code>previousRecord</code> 이이 시퀀스에 유효 하지 않습니다.       -또는- <code>data</code> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.       -또는- <code>reservations</code> 이 레코드 시퀀스에서 만들어지지 않았습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "인수 중 하나 이상이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>또는 <code>previousRecord</code> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "에 맞게 충분히 큰 예약이 <code> data </code> 있습니다 <code> reservations </code>합니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "현재에서 유효한 첫 번째 레코드의 시퀀스 번호를 가져옵니다 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>합니다."
  remarks: "유효한 시퀀스 번호는 보다 큰가 BaseSequenceNumber 같고 <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> 보다 작음       호출 하 여이 속성의 값을 변경할 수 있습니다는 <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>메서드 또는 <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>메서드.</xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> </xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>"
  example:
  - "This example shows how to use the BaseSequenceNumber member in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/p-system.io.log.logrecor_2_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_2_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "유효한 레코드에 해당 하는 가장 낮은 시퀀스 번호는 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>합니다."
  overload: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 속성에 액세스 합니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "비동기 시작 작업을 추가 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "전달 해야는 <xref:System.IAsyncResult>에이 메서드에서 반환 되는 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>메서드 추가 작업이 완료 된 고 리소스를 적절 하 게 해제할 수 있도록 합니다.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 될 때까지 비동기 추가 중 오류가 발생 했는지, 예외가 throw 되지 않습니다는 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>메서드는 <xref:System.IAsyncResult>이 메서드에서 반환 된.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       에 포함 된 데이터는 `data` 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       일반적으로이 메서드는 레코드를 쓰기 전에 완료 됩니다. 지정 하거나 기록 된 하려면는 <xref:System.IO.Log.RecordAppendOptions>플래그를 사용 하는 `recordAppendOptions` 매개 변수 또는 호출의 <xref:System.IO.Log.LogRecordSequence.Flush%2A>메서드.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "이전 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "유효한 값 <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> 데이터를 작성 하는 방법을 지정 하는 합니다."
    - id: callback
      type: System.AsyncCallback
      description: "추가 완료 되 면 호출 되는 선택적 비동기 콜백."
    - id: state
      type: System.Object
      description: "이 특정 비동기 구별 하는 사용자 제공 개체는 다른 요청에서 요청을 추가 합니다."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>보류 중일 수 있는 비동기 추가 나타내는입니다.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code>또는 <code>previousRecord</code> 이이 시퀀스에 유효 하지 않습니다.       -또는- <code>data</code> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.       -또는- <code>reservations</code> 이 레코드 시퀀스에서 만들어지지 않았습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "인수 중 하나 이상이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code>또는 <code>previousRecord</code> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "비동기 시작 작업을 추가 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "전달 해야는 <xref:System.IAsyncResult>에이 메서드에서 반환 되는 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>메서드 추가 작업이 완료 된 고 리소스를 적절 하 게 해제할 수 있도록 합니다.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 될 때까지 비동기 추가 중 오류가 발생 했는지, 예외가 throw 되지 않습니다는 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>메서드는 <xref:System.IAsyncResult>이 메서드에서 반환 된.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       에 포함 된 데이터는 `data` 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       일반적으로이 메서드는 레코드를 쓰기 전에 완료 됩니다. 지정 하거나 기록 된 하려면는 <xref:System.IO.Log.RecordAppendOptions>플래그를 사용 하는 `recordAppendOptions` 매개 변수 또는 호출의 <xref:System.IO.Log.LogRecordSequence.Flush%2A>메서드.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "이전 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "유효한 값 <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> 데이터를 작성 하는 방법을 지정 하는 합니다."
    - id: callback
      type: System.AsyncCallback
      description: "추가 완료 되 면 호출 되는 선택적 비동기 콜백."
    - id: state
      type: System.Object
      description: "이 특정 비동기 구별 하는 사용자 제공 개체는 다른 요청에서 요청을 추가 합니다."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>보류 중일 수 있는 비동기 추가 나타내는입니다.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>또는 <code>previousRecord</code> 이이 시퀀스에 유효 하지 않습니다.       -또는- <code>data</code> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.       -또는- <code>reservations</code> 이 레코드 시퀀스에서 만들어지지 않았습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "인수 중 하나 이상이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>또는 <code>previousRecord</code> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "비동기 시작 작업을 추가 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "전달 해야는 <xref:System.IAsyncResult>에이 메서드에서 반환 되는 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>메서드 추가 작업이 완료 된 고 리소스를 적절 하 게 해제할 수 있도록 합니다.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 될 때까지 비동기 추가 중 오류가 발생 했는지, 예외가 throw 되지 않습니다는 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>메서드는 <xref:System.IAsyncResult>이 메서드에서 반환 된.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       에 포함 된 데이터는 `data` 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       추가 된 레코드 이전에 예약 된, 변수로 지정 된 예약을 사용 하 여 공간을 사용 하면는 `reservations` 매개 변수입니다. 추가 작업이 성공 하면 및 예약 영역이 컬렉션에서 제거할 데이터를 포함 될 수 있는 가장 작은 예약 영역을 사용 합니다.       일반적으로이 메서드는 레코드를 쓰기 전에 완료 됩니다. 지정 하거나 기록 된 하려면는 <xref:System.IO.Log.RecordAppendOptions>플래그를 사용 하는 `recordAppendOptions` 매개 변수 또는 호출의 <xref:System.IO.Log.LogRecordSequence.Flush%2A>메서드.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "이전 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "유효한 값 <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> 데이터를 작성 하는 방법을 지정 하는 합니다."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> 이 레코드에 대해 사용 해야 하는 예약이 포함 된입니다."
    - id: callback
      type: System.AsyncCallback
      description: "추가 완료 되 면 호출 되는 선택적 비동기 콜백."
    - id: state
      type: System.Object
      description: "이 특정 비동기 구별 하는 사용자 제공 개체는 다른 요청에서 요청을 추가 합니다."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>보류 중일 수 있는 비동기 추가 나타내는입니다.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>또는 <code>previousRecord</code> 이이 시퀀스에 유효 하지 않습니다.       -또는- <code>data</code> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.       -또는- <code>reservations</code> 이 레코드 시퀀스에서 만들어지지 않았습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "인수 중 하나 이상이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>또는 <code>previousRecord</code> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "에 맞게 충분히 큰 예약이 <code> data </code> 있습니다 <code> reservations </code>합니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "비동기 시작 작업을 추가 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "전달 해야는 <xref:System.IAsyncResult>에이 메서드에서 반환 되는 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>메서드 추가 작업이 완료 된 고 리소스를 적절 하 게 해제할 수 있도록 합니다.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 될 때까지 비동기 추가 중 오류가 발생 했는지, 예외가 throw 되지 않습니다는 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>메서드는 <xref:System.IAsyncResult>이 메서드에서 반환 된.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       에 포함 된 데이터는 `data` 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       추가 된 레코드 이전에 예약 된, 변수로 지정 된 예약을 사용 하 여 공간을 사용 하면는 `reservations` 매개 변수입니다. 추가 작업이 성공 하면 및 예약 영역이 컬렉션에서 제거할 데이터를 포함 될 수 있는 가장 작은 예약 영역을 사용 합니다.       일반적으로이 메서드는 레코드를 쓰기 전에 완료 됩니다. 지정 하거나 기록 된 하려면는 <xref:System.IO.Log.RecordAppendOptions>플래그를 사용 하는 `recordAppendOptions` 매개 변수 또는 호출의 <xref:System.IO.Log.LogRecordSequence.Flush%2A>메서드.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "이전 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "유효한 값 <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> 데이터를 작성 하는 방법을 지정 하는 합니다."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> 이 레코드에 대해 사용 해야 하는 예약이 포함 된입니다."
    - id: callback
      type: System.AsyncCallback
      description: "추가 완료 되 면 호출 되는 선택적 비동기 콜백."
    - id: state
      type: System.Object
      description: "이 특정 비동기 구별 하는 사용자 제공 개체는 다른 요청에서 요청을 추가 합니다."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>보류 중일 수 있는 비동기 추가 나타내는입니다.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>또는 <code>previousRecord</code> 이이 시퀀스에 유효 하지 않습니다.       -또는- <code>data</code> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.       -또는- <code>reservations</code> 이 레코드 시퀀스에서 만들어지지 않았습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "인수 중 하나 이상이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>또는 <code>previousRecord</code> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "에 맞게 충분히 큰 예약이 <code> data </code> 있습니다 <code> reservations </code>합니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "시퀀스에서 이전에 예약 된 공간을 사용 하 여 비동기 플러시 작업을 시작 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "전달 해야는 <xref:System.IAsyncResult>를 현재 메서드에서 반환 되는 <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>메서드 여 플러시를 완료 하 고 리소스가 적절 하 게 해제 됩니다.</xref:System.IO.Log.LogRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> 될 때까지 비동기 플러시 중에 오류가 발생 하는 경우 예외가 throw 되지 않습니다는 <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>메서드는 <xref:System.IAsyncResult>이 메서드에서 반환 된.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndFlush%2A>       이 메서드를 호출 하면 모든 레코드가 있는에 추가 된는 <xref:System.IO.Log.LogRecordSequence>영속적으로 기록 됩니다.</xref:System.IO.Log.LogRecordSequence>       레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다. I/O 요청 중의 디스크 오류 예를 들어 비동기 플러시 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>메서드를 호출 합니다.</xref:System.IO.Log.LogRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "써야 하는 최신 레코드의 시퀀스 번호입니다. 이 경우 <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> 유효 하지 않을 경우 모든 레코드를 써야 합니다."
    - id: callback
      type: System.AsyncCallback
      description: "플러시가 완료 되 면 호출 되는 선택적 비동기 콜백."
    - id: state
      type: System.Object
      description: "이 특정 비동기 플러시 요청을 다른 요청과 구별 하는 사용자 제공 개체입니다."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>보류할 수를 나타내는 비동기 플러시 작업, 중일 수 있습니다.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>이 시퀀스에 대해 올바르지 않습니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이의 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "지정된 된 로그에는 범위가 없습니다. 레코드 시퀀스를 사용 하려면 먼저 하나 이상의 범위를 만들어야 합니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "비동기 예약 및 시작 작업을 추가 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "전달 해야는 <xref:System.IAsyncResult>에이 메서드에서 반환 되는 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>메서드 추가 작업이 완료 된 고 리소스를 적절 하 게 해제할 수 있도록 합니다.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> 될 때까지 비동기 추가 중 오류가 발생 했는지, 예외가 throw 되지 않습니다는 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>메서드는 <xref:System.IAsyncResult>이 메서드에서 반환 된.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>       에 포함 된 데이터는 `data` 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       추가 된 지정 된 예약은 레코드와 원자 단위 연산에서 컬렉션 추가 작업에 제공된 된 예약 합니다. 추가 실패, 없음 공간이 예약 됩니다.       일반적으로이 메서드는 레코드를 쓰기 전에 완료 될 수 있습니다. 지정 하거나 기록 된 하려면는 <xref:System.IO.Log.RecordAppendOptions>플래그를 사용 하는 `recordAppendOptions` 매개 변수 또는 호출의 <xref:System.IO.Log.LogRecordSequence.Flush%2A>메서드.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다. I/O 요청 중의 디스크 오류 예를 들어 비동기 추가 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>메서드를 호출 합니다.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "이전 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "유효한 값 <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> 데이터를 작성 하는 방법을 지정 하는 합니다."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "예약을 만들 예약 컬렉션입니다."
    - id: reservations
      type: System.Int64[]
      description: "바이트 단위로 만들 예약 합니다."
    - id: callback
      type: System.AsyncCallback
      description: "추가 완료 되 면 호출 되는 선택적 비동기 콜백."
    - id: state
      type: System.Object
      description: "이 특정 비동기 구별 하는 사용자 제공 개체는 다른 요청에서 요청을 추가 합니다."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>보류 중일 수 있는이 비동기 작업을 나타내는입니다.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>또는 <code>previousRecord</code> 이이 시퀀스에 유효 하지 않습니다.       -또는- <code>data</code> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.       -또는- <code>reservations</code> 이 레코드 시퀀스에서 만들어지지 않았습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "인수 중 하나 이상이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>또는 <code>previousRecord</code> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "에 맞게 충분히 큰 예약이 <code> data </code> 있습니다 <code> reservations </code>합니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "비동기 예약 및 시작 작업을 추가 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "전달 해야는 <xref:System.IAsyncResult>에이 메서드에서 반환 되는 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>메서드 추가 작업이 완료 된 고 리소스를 적절 하 게 해제할 수 있도록 합니다.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> 될 때까지 비동기 추가 중 오류가 발생 했는지, 예외가 throw 되지 않습니다는 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>메서드는 <xref:System.IAsyncResult>이 메서드에서 반환 된.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>       에 포함 된 데이터는 `data` 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       추가 된 지정 된 예약은 레코드와 원자 단위 연산에서 컬렉션 추가 작업에 제공된 된 예약 합니다. 추가 실패, 없음 공간이 예약 됩니다.       일반적으로이 메서드는 레코드를 쓰기 전에 완료 될 수 있습니다. 지정 하거나 기록 된 하려면는 <xref:System.IO.Log.RecordAppendOptions>플래그를 사용 하는 `recordAppendOptions` 매개 변수 또는 호출의 <xref:System.IO.Log.LogRecordSequence.Flush%2A>메서드.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다. I/O 요청 중의 디스크 오류 예를 들어 비동기 추가 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>메서드를 호출 합니다.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "이전 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "유효한 값 <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> 데이터를 작성 하는 방법을 지정 하는 합니다."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "예약을 만들 예약 컬렉션입니다."
    - id: reservations
      type: System.Int64[]
      description: "바이트 단위로 만들 예약 합니다."
    - id: callback
      type: System.AsyncCallback
      description: "추가 완료 되 면 호출 되는 선택적 비동기 콜백."
    - id: state
      type: System.Object
      description: "이 특정 비동기 구별 하는 사용자 제공 개체는 다른 요청에서 요청을 추가 합니다."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>보류 중일 수 있는이 비동기 작업을 나타내는입니다.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "인수 중 하나 이상이 올바르지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "레코드를 추가 하는 동안 I/O 오류가 발생 했습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스에서 새 레코드를 포함 하거나 예약을 변경 하려면 충분 한 여유 공간을 만들지 못했습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "시퀀스에서 이전에 예약 된 공간을 사용 하는 비동기 재시작 영역 쓰기 작업을 시작 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "전달 해야는 <xref:System.IAsyncResult>에이 메서드에서 반환 되는 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>메서드 재시작 영역 쓰기 작업이 완료 되 고 리소스를 적절 하 게 해제할 수 있도록 합니다.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> 될 때까지 비동기 재시작 영역 쓰기 작업 중 오류가 발생 했는지, 예외가 throw 되지 않습니다는 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>메서드는 <xref:System.IAsyncResult>이 메서드에서 반환 된.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>       에 포함 된 데이터는 `data` 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       작업을 성공적으로 완료 되 면 기준 세그먼트 번호가 업데이트 되었습니다. 모든 로그 레코드 시퀀스 번호를 가진 액세스할 수 없는 새 기준 시퀀스 번호 보다 작은.       경우는 <xref:System.IO.Log.ReservationCollection>을 지정 쓴된 재시작 영역은 이전에 예약 된, 컬렉션에 포함 된 예약을 사용 하 여 공간을 사용 합니다.</xref:System.IO.Log.ReservationCollection> 메서드가 성공 하면 예약이 컬렉션에서 제거 됩니다 및 사용자 데이터를 포함 될 수 있는 가장 작은 예약을 사용 합니다.       레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다. I/O 요청 중의 디스크 오류 예를 들어 비동기 추가 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>메서드를 호출 합니다.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트입니다."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "새 기준 시퀀스 번호입니다. 지정 된 시퀀스 수는 현재 기준 시퀀스 번호 보다 크거나 같아야 합니다."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> 이 재시작 영역에 사용 해야 하는 예약이 포함 된입니다."
    - id: callback
      type: System.AsyncCallback
      description: "재시작 영역 쓰기가 완료 되 면 호출 되는 선택적 비동기 콜백."
    - id: state
      type: System.Object
      description: "다른 요청에서 특정 비동기 재시작 영역 쓰기 요청을 구별 하는 사용자 제공 개체입니다."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>보류 중인 수는 비동기 재시작 영역 쓰기 작업을 나타내는 중일 수 있습니다.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>이 시퀀스에 대해 올바르지 않습니다.       -또는-지정 된 로그 열거형 시작 시퀀스 번호가 올바르지 않습니다.       -또는- <code>data</code> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.       -또는- <code>reservation</code> 이 레코드 시퀀스에서 만들어지지 않았습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "매개 변수 중 하나 이상이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "기존 또는 새 아카이브 테일이나 베이스가 활성 로그의 올바르지 않습니다.       -또는- <code> newBaseSeqNum </code> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "시퀀스에서 이전에 예약 된 공간을 사용 하는 비동기 재시작 영역 쓰기 작업을 시작 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "전달 해야는 <xref:System.IAsyncResult>에이 메서드에서 반환 되는 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>메서드 재시작 영역 쓰기 작업이 완료 되 고 리소스를 적절 하 게 해제할 수 있도록 합니다.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> 될 때까지 비동기 재시작 영역 쓰기 작업 중 오류가 발생 했는지, 예외가 throw 되지 않습니다는 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>메서드는 <xref:System.IAsyncResult>이 메서드에서 반환 된.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>       에 포함 된 데이터는 `data` 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       작업을 성공적으로 완료 되 면 기준 세그먼트 번호가 업데이트 되었습니다. 모든 로그 레코드 시퀀스 번호를 가진 액세스할 수 없는 새 기준 시퀀스 번호 보다 작은.       경우는 <xref:System.IO.Log.ReservationCollection>을 지정 쓴된 재시작 영역은 이전에 예약 된, 컬렉션에 포함 된 예약을 사용 하 여 공간을 사용 합니다.</xref:System.IO.Log.ReservationCollection> 메서드가 성공 하면 예약이 컬렉션에서 제거 됩니다 및 사용자 데이터를 포함 될 수 있는 가장 작은 예약을 사용 합니다.       레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다. I/O 요청 중의 디스크 오류 예를 들어 비동기 추가 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>메서드를 호출 합니다.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "새 기준 시퀀스 번호입니다. 지정 된 시퀀스 수는 현재 기준 시퀀스 번호 보다 크거나 같아야 합니다."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> 이 재시작 영역에 사용 해야 하는 예약이 포함 된입니다."
    - id: callback
      type: System.AsyncCallback
      description: "재시작 영역 쓰기가 완료 되 면 호출 되는 선택적 비동기 콜백."
    - id: state
      type: System.Object
      description: "다른 요청에서 특정 비동기 재시작 영역 쓰기 요청을 구별 하는 사용자 제공 개체입니다."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>보류 중인 수는 비동기 재시작 영역 쓰기 작업을 나타내는 중일 수 있습니다.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>이 시퀀스에 대해 올바르지 않습니다.       -또는-지정 된 로그 열거형 시작 시퀀스 번호가 올바르지 않습니다.       -또는- <code>data</code> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.       -또는- <code>reservationCollection</code> 이 레코드 시퀀스에서 만들어지지 않았습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "매개 변수 중 하나 이상이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "기존 또는 새 아카이브 테일이나 베이스가 활성 로그의 올바르지 않습니다.       -또는- <code> newBaseSeqNum </code> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "새 <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: ''
  example:
  - "Reservations can be performed in two ways as shown in the following examples. You can adopt the practices in the samples for robust processing. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \n//Using the ReserveAndAppend Method  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n  \n// Using the Manual Approach  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nreservations.Add(lengthOfUndoRecord);  \ntry  \n{  \n   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  \n}  \ncatch (Exception)  \n{  \n   reservations.Remove(lengthOfUndoRecord);  \n   throw;  \n}  \n  \nrecordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  \n```"
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "새로 만든 <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>합니다."
  overload: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Dispose
  id: Dispose
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "구성 요소에서 사용 하는 리소스를 해제 합니다."
  remarks: ''
  example:
  - "This example shows how to use Dispose to release resource:  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/m-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_1.vb)]  \n  \n [!code-cs[S_UELogRecordSequence#12](~/add/codesnippet/csharp/m-system.io.log.logrecor_2.cs)]\n [!code-vb[S_UELogRecordSequence#12](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_2.vb)]"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.LogRecordSequence.Dispose*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "비동기 종료 작업을 추가합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "이 메서드는 I/O 작업이 완료 될 때까지 차단 됩니다. 비동기 쓰기 요청 I/O 요청 중의 디스크 오류와 같은 중 발생 하는 오류 EndAppend를 호출할 때 표시 됩니다.       이 메서드를 정확히 한 번만 호출 해야 모든 <xref:System.IAsyncResult>에서 반환 되는 <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>메서드.</xref:System.IO.Log.LogRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "처리 중인 비동기 I/O 요청에 대 한 참조입니다."
    return:
      type: System.IO.Log.SequenceNumber
      description: "추가 된 로그 레코드의 시퀀스 번호입니다."
  overload: System.IO.Log.LogRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>잘못 되었습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End &quot; name=&quot;End &quot; href=&quot;&quot;></xref>가 이미 호출 되었습니다이 비동기 작업에 대 한 합니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "비동기 플러시 작업을 끝냅니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "이 메서드는 I/O 작업이 완료 될 때까지 차단 됩니다. I/O 요청 중의 디스크 오류와 같은 비동기 플러시 요청 중에 발생 하는 오류 EndFlush를 호출할 때 표시 됩니다.       이 메서드를 정확히 한 번만 호출 해야 모든 <xref:System.IAsyncResult>에서 반환 되는 <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>메서드.</xref:System.IO.Log.LogRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "처리 중인 비동기 I/O 요청에 대 한 참조입니다."
    return:
      type: System.IO.Log.SequenceNumber
      description: "마지막으로 쓴 레코드의 시퀀스 번호입니다."
  overload: System.IO.Log.LogRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>잘못 되었습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>가 이미 호출 되었습니다이 비동기 작업에 대 한 합니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "끝 비동기 예약 및 추가 작업 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "이 메서드는 I/O 작업이 완료 될 때까지 차단 됩니다. 비동기 쓰기 요청 I/O 요청 중의 디스크 오류와 같은 중 발생 하는 오류 EndReserveAndAppend를 호출할 때 표시 됩니다.       이 메서드를 정확히 한 번만 호출 해야 모든 <xref:System.IAsyncResult>에서 반환 되는 <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>메서드.</xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "처리 중인 비동기 I/O 요청에 대 한 참조입니다."
    return:
      type: System.IO.Log.SequenceNumber
      description: "추가 된 로그 레코드의 시퀀스 번호입니다."
  overload: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>잘못 되었습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>가 이미 호출 되었습니다이 비동기 작업에 대 한 합니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "비동기 재시작 영역 쓰기 작업을 종료합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "이 메서드는 I/O 작업이 완료 될 때까지 차단 됩니다. 비동기 쓰기 요청 I/O 요청 중의 디스크 오류와 같은 중 발생 하는 오류 EndWriteRestartArea를 호출할 때 표시 됩니다.       이 메서드를 정확히 한 번만 호출 해야 모든 <xref:System.IAsyncResult>에서 반환 되는 <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>메서드.</xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "처리 중인 비동기 I/O 요청에 대 한 참조입니다."
    return:
      type: System.IO.Log.SequenceNumber
      description: "쓴된 로그 레코드의 시퀀스 번호입니다."
  overload: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>잘못 되었습니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "기존 또는 새 아카이브 테일이나 베이스가 활성 로그의 올바르지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>가 이미 호출 되었습니다이 비동기 작업에 대 한 합니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "추가 된 모든 레코드가 썼는지 확인 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "이 메서드를 호출 하면 모든 레코드가 있는에 추가 된는 <xref:System.IO.Log.LogRecordSequence>영속적으로 씁니다.</xref:System.IO.Log.LogRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "마지막으로 쓴 레코드의 시퀀스 번호입니다."
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "데이터를 플러시하는 동안 I/O 오류가 발생 했습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "이 작업이 지원 되지 않습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스에서 새 재시작 영역을 포함 하도록 충분 한 공간이 만들지 못했습니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "지정된 된 로그에는 범위가 없습니다. 레코드 시퀀스를 사용 하려면 먼저 하나 이상의 범위를 만들어야 합니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "추가 된 모든 레코드 및 지정 된 시퀀스 번호와 레코드까지 영속적으로 기록 되었음을 확인 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "이 메서드를 사용 하면 시퀀스 번호를 모든 레코드가 최대 호출 하 고 지정 된 시퀀스 번호를 포함 하 여 영속적 기록 합니다."
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "써야 하는 최신 레코드의 시퀀스 번호입니다. 이 경우 <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> 유효 하지 않을 경우 모든 레코드를 써야 합니다."
    return:
      type: System.IO.Log.SequenceNumber
      description: "마지막으로 쓴 레코드의 시퀀스 번호입니다."
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>이 시퀀스에 대해 올바르지 않습니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이의 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "지정된 된 로그에는 범위가 없습니다. 레코드 시퀀스를 사용 하려면 먼저 하나 이상의 범위를 만들어야 합니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "시퀀스 번호를 가져옵니다 마지막으로 추가 된 레코드 보다 큰"
  remarks: "이 속성은 반드시 큰 시퀀스 번호를 포함 추가 된 레코드의 마지막 시퀀스 번호 보다 합니다. 유효한 시퀀스 번호 보다 크거나 같은 경우는 <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A>같고 LastSequenceNumber 보다.</xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> 다른 모든 시퀀스 번호가 올바르지 않습니다."
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "마지막으로 추가 된 레코드 보다 큰 시퀀스 번호입니다."
  overload: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 속성에 액세스 합니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LogStore
  id: LogStore
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "가져옵니다는 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> 이 레코드 시퀀스에 대 한 데이터를 포함 하 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: ''
  example:
  - "This example shows how to use the LogStore member to add extents.  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/p-system.io.log.logrecor_1_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_1_1.vb)]"
  syntax:
    content: public System.IO.Log.LogStore LogStore { get; }
    return:
      type: System.IO.Log.LogStore
      description: "<xref href=&quot;System.IO.Log.LogStore&quot;> </xref> 이 레코드 시퀀스에 대 한 데이터를 포함 하 합니다."
  overload: System.IO.Log.LogRecordSequence.LogStore*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "이 레코드 시퀀스에 추가할 수 있는 레코드의 최대 크기를 가져옵니다."
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "이 레코드 시퀀스에 추가할 수 있는 레코드의 최대 크기입니다."
  overload: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "시퀀스에 레코드의 열거 가능 컬렉션을 반환합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "이 메서드는 시퀀스에 레코드의 열거 가능 컬렉션을 반환합니다. 값에 따라 열거 되는 레코드의 순서는 `logRecordEnum` 매개 변수입니다."
  example:
  - "This example shows how to use ReadLogRecords in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/65162f37-dafe-4315-8e44-_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/65162f37-dafe-4315-8e44-_1.vb)]"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "읽기가 시작 되는 첫 번째 레코드의 시퀀스 번호입니다."
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "유효한 <xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;> </xref> 에서 레코드를 읽는에 (즉, 앞으로 또는 뒤로) 하는 방식을 지정 하는 값을 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>합니다."
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "시퀀스에 있는 레코드의 열거 가능한 컬렉션입니다."
  overload: System.IO.Log.LogRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>start</code>이 시퀀스에 대해 올바르지 않습니다.       -또는- <code>logRecordEnum</code> 올바르지 않습니다.       -또는-지정된 된 요소가 컬렉션에 없습니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code>이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이의 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.       -또는 읽기에 사용 되 고 버퍼 크기 보다 큰 로그 레코드를 쓰는 데 사용 되는 버퍼 크기입니다.       -또는-레코드 시퀀스가 손상 되었습니다.       -또는-지정 된 로그 파일 형식이 나 버전이 잘못 되었습니다.       -또는-호환 되지 않는 버전 레코드 시퀀스의 레코드를 작성 했습니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "열거가 시작 되지 않은 작업이 잘못 되었습니다. 에 대 한 호출 <xref:System.Collections.IEnumerator.MoveNext*>수 있어야 합니다.</xref:System.Collections.IEnumerator.MoveNext*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "시퀀스에 있는 재시작 영역의 열거 가능한 컬렉션을 반환합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "재시작 영역의 가장 낮은 시퀀스 번호를 시퀀스 번호가 가장 높은에서 즉, 역방향 시퀀스 번호 순서에 열거 됩니다. 마지막 시퀀스 번호 사이의 시퀀스 번호를 가진 재시작 영역만 기준 시퀀스 번호를 열거 합니다."
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "시퀀스에 있는 재시작 영역의 열거 가능한 컬렉션입니다."
  overload: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code>이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이의 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다.       -또는 읽기에 사용 되 고 버퍼 크기 보다 큰 로그 레코드를 쓰는 데 사용 되는 버퍼 크기입니다.       -또는-레코드 시퀀스가 손상 되었습니다.       -또는-지정 된 로그 파일 형식이 나 버전이 잘못 되었습니다.       -또는-호환 되지 않는 버전 레코드 시퀀스의 레코드를 작성 했습니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "열거가 시작 되지 않은 작업이 잘못 되었습니다. 에 대 한 호출 <xref:System.Collections.IEnumerator.MoveNext*>수 있어야 합니다.</xref:System.Collections.IEnumerator.MoveNext*>       -열거형이 끝난 경우 또는 합니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "자동으로 단일 예약을 만들고 시퀀스에 레코드를 추가 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "에 포함 된 데이터는 `data` 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       추가 된 지정 된 예약은 레코드와 원자 단위 연산에서 컬렉션 추가 작업에 제공된 된 예약 합니다. 추가 실패, 없음 공간이 예약 됩니다.       일반적으로이 메서드는 레코드를 쓰기 전에 완료 될 수 있습니다. 지정 하거나 기록 된 하려면는 <xref:System.IO.Log.RecordAppendOptions>플래그를 사용 하는 `recordAppendOptions` 매개 변수 또는 호출의 <xref:System.IO.Log.LogRecordSequence.Flush%2A>메서드.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example shows how to use this method to make reservations. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n```"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "이전 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "유효한 값 <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> 데이터를 작성 하는 방법을 지정 하는 합니다."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> 예약을 만들 컬렉션이 포함 된 합니다."
    - id: reservations
      type: System.Int64[]
      description: "바이트 단위로 만들 예약 합니다."
    return:
      type: System.IO.Log.SequenceNumber
      description: "추가 된 로그 레코드의 시퀀스 번호입니다."
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code>또는 <code>previousRecord</code> 이이 시퀀스에 유효 하지 않습니다.       -또는- <code>data</code> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.       -또는- <code>reservations</code> 이 레코드 시퀀스에서 만들어지지 않았습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "인수 중 하나 이상이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code>또는 <code>previousRecord</code> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "에 맞게 충분히 큰 예약이 <code> data </code> 있습니다 <code> reservations </code>합니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "자동으로 단일 예약을 만들고 시퀀스에 레코드를 추가 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "에 포함 된 데이터는 `data` 매개 변수는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       추가 된 지정 된 예약은 레코드와 원자 단위 연산에서 컬렉션 추가 작업에 제공된 된 예약 합니다. 추가 실패, 없음 공간이 예약 됩니다.       일반적으로이 메서드는 레코드를 쓰기 전에 완료 될 수 있습니다. 지정 하거나 기록 된 하려면는 <xref:System.IO.Log.RecordAppendOptions>플래그를 사용 하는 `recordAppendOptions` 매개 변수 또는 호출의 <xref:System.IO.Log.LogRecordSequence.Flush%2A>메서드.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "이전 순서에서 다음 레코드의 시퀀스 번호입니다."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "유효한 값 <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> 데이터를 작성 하는 방법을 지정 하는 합니다."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "예약을 만들 예약 컬렉션입니다."
    - id: reservations
      type: System.Int64[]
      description: "바이트 단위로 만들 예약 합니다."
    return:
      type: System.IO.Log.SequenceNumber
      description: "추가 된 로그 레코드의 시퀀스 번호입니다."
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "인수 중 하나 이상이 올바르지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "레코드를 추가 하는 동안 I/O 오류가 발생 했습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스에서 새 레코드를 포함 하거나 예약을 변경 하려면 충분 한 여유 공간을 만들지 못했습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "인수 중 하나 이상이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>또는 <code>previousRecord</code> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "에 맞게 충분히 큰 예약이 <code> data </code> 있습니다 <code> reservations </code>합니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "예약 된 바이트의 총 수를 가져옵니다."
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "이 레코드 시퀀스에서 만들어진 모든 예약의 총 크기입니다."
  overload: System.IO.Log.LogRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 속성에 액세스 합니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "로그의 끝과 가장 가까운 재시작 영역의 시퀀스 번호를 가져옵니다."
  remarks: "재시작 영역은 클라이언트의 마지막 검사점 작업이 포함 된 정보를 임시로 저장 하는 데 사용 됩니다. 공통 로그 파일 시스템 (CLFS)는 두 개의 재시작 영역 적어도 하나의 유효한 영역을 항상 사용할 수 있는지를 보장 하기 위해 유지 관리 합니다. 복구가 필요한 경우 CLFS 마지막 검사점 작업에서 재시작 영역을 모든 데이터를 읽습니다. 이 데이터를 복구 프로세스에서 사용할 수 있도록 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블 초기화 합니다.       사용 하는 <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>제거할 수, 가장 최근에 기록 된 재시작 영역의.</xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "로그의 끝과 가장 가까운 재시작 영역의 시퀀스 번호입니다."
  overload: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 속성에 액세스 합니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "나타내는 값을 가져오거나 여부 추가 로그가 꽉 찼을 경우 자동으로 다시 시도 합니다."
  remarks: "이 속성의 값이 `true`, 및 <xref:System.IO.Log.LogRecordSequence.Append%2A>시퀀스에 충분 한 공간이 없기 때문에 호출이 실패 하면, 레코드 시퀀스에서 공간을 확보 하 고 추가 다시 시도 하려고 합니다.</xref:System.IO.Log.LogRecordSequence.Append%2A>"
  example:
  - "This example shows how to use the RetryAppend property.  \n  \n [!code-cs[S_UELogRecordSequence#3](~/add/codesnippet/csharp/p-system.io.log.logrecor_0_1.cs)]\n [!code-vb[S_UELogRecordSequence#3](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_0_1.vb)]"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>하는 경우 추가 로그가 꽉 경우 자동으로 다시 시도 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.IO.Log.LogRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 속성에 액세스 합니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  id: SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "마지막 레코드에 설정 된 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>합니다."
  remarks: "지정 된 시퀀스 번호는 기준 시퀀스 번호 보다 커야 합니다.       이 메서드가 완료 되 면 이전에 추가한 지정 된 시퀀스 번호 보다 큰 시퀀스 번호를 가진 모든 레코드는 액세스할 수 없습니다."
  syntax:
    content: public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "에 마지막 신규 시퀀스 번호는 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>합니다.       이 로그에 현재 유효한 현재 레코드를 참조 해야 합니다."
  overload: System.IO.Log.LogRecordSequence.SetLastRecord*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>이 시퀀스에 대해 올바르지 않습니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "기존 또는 새 아카이브 테일이나 베이스가 활성 로그의 올바르지 않습니다.       -또는- <code> sequenceNumber </code> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-로그의 끝에 도달 했습니다.       -또는-지정 된 로그 파일 형식이 나 버전이 잘못 되었습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "시퀀스의 테일을 이동 해야 함을 나타냅니다."
  remarks: "레코드 시퀀스에 공간이 부족이 이벤트를 발생 시킬 수 있습니다. 이 이벤트는 발생 하는 경우 (즉, 기준 시퀀스 번호) 시퀀스의 테일이 공간을 확보 하 앞으로 이동 합니다.       이 이벤트는 언제 든 지 어떤 이유로 든 공간을 확보 해야 하는 레코드 시퀀스를 결정 하는 경우 발생할 수 있습니다. 예를 들어, CLFS 정책 엔진은 같은 로그 파일을 공유 하는 두 로그 클라이언트의 테일은 너무 멀리 떨어져 있는지를 결정 하는 경우 이벤트를 발생 시키는 결정할 수 있습니다. 공간을 확보 하거나 여 수행할 수 있습니다 재시작 영역을 쓰거나 또는 로그 잘라내기 및 사용 하는 <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>메서드 공간을 확보 합니다.</xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> &quot;예&quot; 섹션의 코드 예제에는 두 번째 방법을 보여 줍니다.       호출할 수도 있습니다는 <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>공간을 확보 하려면 TailPinned 이벤트 외부에서 메서드가.</xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> 재시작 영역은 다른 로그 처리 시스템의에서 검사점과 비슷합니다. 응용 프로그램에 완벽 하 게 완료 재시작 영역 전의 모든 이전 레코드가 것으로 간주 하 고 이후 레코드에 대 한 사용 가능한 추가 나타냅니다이 메서드를 호출 합니다. 다른 레코드와 마찬가지로,이 메서드가 기록한 레코드가 작동 하려면 로그에 실제 빈 공간이 필요 합니다."
  example:
  - "This example shows how to use the TailPinned event.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "재시작 영역을 씁니다는 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "재시작 영역은 클라이언트의 마지막 검사점 작업이 포함 된 정보를 임시로 저장 하는 데 사용 됩니다. 공통 로그 파일 시스템 (CLFS)는 두 개의 재시작 영역 적어도 하나의 유효한 영역을 항상 사용할 수 있는지를 보장 하기 위해 유지 관리 합니다. 복구가 필요한 경우 CLFS 마지막 검사점 작업에서 재시작 영역을 모든 데이터를 읽습니다. 이 데이터를 복구 프로세스에서 사용할 수 있도록 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블 초기화 합니다.       사용 하 여 재시작 영역을 읽을 수는 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>메서드.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       바이트 배열 세그먼트의 데이터는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "연결을 여 레코드로 추가할 배열 세그먼트입니다."
    return:
      type: System.IO.Log.SequenceNumber
      description: "쓴의 시퀀스 번호 영역 다시 시작합니다."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "인수 중 하나 이상이 올바르지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "재시작 영역을 쓰는 동안 I/O 오류가 발생 했습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스에서 새 재시작 영역을 포함 하도록 충분 한 공간이 만들지 못했습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "인수 중 하나 이상이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "재시작 영역을 씁니다는 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "재시작 영역은 클라이언트의 마지막 검사점 작업이 포함 된 정보를 임시로 저장 하는 데 사용 됩니다. 공통 로그 파일 시스템 (CLFS)는 두 개의 재시작 영역 적어도 하나의 유효한 영역을 항상 사용할 수 있는지를 보장 하기 위해 유지 관리 합니다. 복구가 필요한 경우 CLFS 마지막 검사점 작업에서 재시작 영역을 모든 데이터를 읽습니다. 이 데이터를 복구 프로세스에서 사용할 수 있도록 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블 초기화 합니다.       사용 하 여 재시작 영역을 읽을 수는 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>메서드.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       바이트 배열 세그먼트의 데이터는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    return:
      type: System.IO.Log.SequenceNumber
      description: "쓴의 시퀀스 번호 영역 다시 시작합니다."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "인수 중 하나 이상이 올바르지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "재시작 영역을 쓰는 동안 I/O 오류가 발생 했습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스에서 새 재시작 영역을 포함 하도록 충분 한 공간이 만들지 못했습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "인수 중 하나 이상이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "재시작 영역을 씁니다는 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> 기준 시퀀스 번호를 업데이트 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "재시작 영역은 클라이언트의 마지막 검사점 작업이 포함 된 정보를 임시로 저장 하는 데 사용 됩니다. 공통 로그 파일 시스템 (CLFS)는 두 개의 재시작 영역 적어도 하나의 유효한 영역을 항상 사용할 수 있는지를 보장 하기 위해 유지 관리 합니다. 복구가 필요한 경우 CLFS 마지막 검사점 작업에서 재시작 영역을 모든 데이터를 읽습니다. 이 데이터를 복구 프로세스에서 사용할 수 있도록 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블 초기화 합니다.       사용 하 여 재시작 영역을 읽을 수는 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>메서드.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       재시작 영역은 기록 되 면 바이트 배열 세그먼트의 데이터는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       이 메서드가 성공적으로 완료 되 면 기준 세그먼트 번호가 업데이트 되었습니다. 모든 로그 레코드 시퀀스 번호를 가진 액세스할 수 없는 새 기준 시퀀스 번호 보다 작은.       레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다. I/O 요청 중의 디스크 오류 예를 들어 비동기 추가 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>메서드를 호출 합니다.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "새 기준 시퀀스 번호입니다. 지정 된 시퀀스 수는 현재 기준 시퀀스 번호 보다 크거나 같아야 합니다."
    return:
      type: System.IO.Log.SequenceNumber
      description: "쓴의 시퀀스 번호 영역 다시 시작합니다."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "인수 중 하나 이상이 올바르지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "재시작 영역을 쓰는 동안 I/O 오류가 발생 했습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스에서 새 재시작 영역을 포함 하도록 충분 한 공간이 만들지 못했습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "재시작 영역을 씁니다는 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> 기준 시퀀스 번호를 업데이트 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "재시작 영역은 클라이언트의 마지막 검사점 작업이 포함 된 정보를 임시로 저장 하는 데 사용 됩니다. 공통 로그 파일 시스템 (CLFS)는 두 개의 재시작 영역 적어도 하나의 유효한 영역을 항상 사용할 수 있는지를 보장 하기 위해 유지 관리 합니다. 복구가 필요한 경우 CLFS 마지막 검사점 작업에서 재시작 영역을 모든 데이터를 읽습니다. 이 데이터를 복구 프로세스에서 사용할 수 있도록 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블 초기화 합니다.       사용 하 여 재시작 영역을 읽을 수는 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>메서드.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       재시작 영역은 기록 되 면 바이트 배열 세그먼트의 데이터는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       이 메서드가 성공적으로 완료 되 면 기준 세그먼트 번호가 업데이트 되었습니다. 모든 로그 레코드 시퀀스 번호를 가진 액세스할 수 없는 새 기준 시퀀스 번호 보다 작은.       레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다. I/O 요청 중의 디스크 오류 예를 들어 비동기 추가 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>메서드를 호출 합니다.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "새 기준 시퀀스 번호입니다. 지정 된 시퀀스 수는 현재 기준 시퀀스 번호 보다 크거나 같아야 합니다."
    return:
      type: System.IO.Log.SequenceNumber
      description: "쓴의 시퀀스 번호 영역 다시 시작합니다."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "인수 중 하나 이상이 올바르지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "재시작 영역을 쓰는 동안 I/O 오류가 발생 했습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스에서 새 재시작 영역을 포함 하도록 충분 한 공간이 만들지 못했습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "재시작 영역을 씁니다는 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> 예약을 사용 하 고 기준 시퀀스 번호를 업데이트 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "재시작 영역은 클라이언트의 마지막 검사점 작업이 포함 된 정보를 임시로 저장 하는 데 사용 됩니다. 공통 로그 파일 시스템 (CLFS)는 두 개의 재시작 영역 적어도 하나의 유효한 영역을 항상 사용할 수 있는지를 보장 하기 위해 유지 관리 합니다. 복구가 필요한 경우 CLFS 마지막 검사점 작업에서 재시작 영역을 모든 데이터를 읽습니다. 이 데이터를 복구 프로세스에서 사용할 수 있도록 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블 초기화 합니다.       사용 하 여 재시작 영역을 읽을 수는 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>메서드.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       재시작 영역은 기록 되 면 바이트 배열 세그먼트의 데이터는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       예약을 지정 하는 경우 쓴된 재시작 영역은 공간 이전에 예약 된, 컬렉션에 포함 된 예약을 사용 하 여을 사용 합니다. 메서드가 성공 하면 예약이 컬렉션에서 제거 됩니다 및 사용자 데이터를 포함할 수 있는 가장 작은 예약을 사용 합니다.       이 메서드가 성공적으로 완료 되 면 기준 세그먼트 번호가 업데이트 되었습니다. 모든 로그 레코드 시퀀스 번호를 가진 액세스할 수 없는 새 기준 시퀀스 번호 보다 작은.       레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다. I/O 요청 중의 디스크 오류 예를 들어 비동기 추가 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>메서드를 호출 합니다.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "새 기준 시퀀스 번호입니다. 지정 된 시퀀스 수는 현재 기준 시퀀스 번호 보다 크거나 같아야 합니다."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> 이 재시작 영역에 사용 해야 하는 예약이 포함 된입니다."
    return:
      type: System.IO.Log.SequenceNumber
      description: "쓴의 시퀀스 번호 영역 다시 시작합니다."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "인수 중 하나 이상이 올바르지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "재시작 영역을 쓰는 동안 I/O 오류가 발생 했습니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스에서 새 재시작 영역을 포함 하도록 충분 한 공간이 만들지 못했습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "재시작 영역을 씁니다는 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> 예약을 사용 하 고 기준 시퀀스 번호를 업데이트 합니다. 이 메서드는 상속 될 수 없습니다."
  remarks: "재시작 영역은 클라이언트의 마지막 검사점 작업이 포함 된 정보를 임시로 저장 하는 데 사용 됩니다. 공통 로그 파일 시스템 (CLFS)는 두 개의 재시작 영역 적어도 하나의 유효한 영역을 항상 사용할 수 있는지를 보장 하기 위해 유지 관리 합니다. 복구가 필요한 경우 CLFS 마지막 검사점 작업에서 재시작 영역을 모든 데이터를 읽습니다. 이 데이터를 복구 프로세스에서 사용할 수 있도록 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블 초기화 합니다.       사용 하 여 재시작 영역을 읽을 수는 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>메서드.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       재시작 영역은 기록 되 면 바이트 배열 세그먼트의 데이터는 레코드로 추가 하기 위한 단일 바이트 배열로 연결 됩니다. 재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할 하는 데 제공 되지 이루어집니다.       예약을 지정 하는 경우 쓴된 재시작 영역은 공간 이전에 예약 된, 컬렉션에 포함 된 예약을 사용 하 여을 사용 합니다. 메서드가 성공 하면 예약이 컬렉션에서 제거 됩니다 및 사용자 데이터를 포함할 수 있는 가장 작은 예약을 사용 합니다.       이 메서드가 성공적으로 완료 되 면 기준 세그먼트 번호가 업데이트 되었습니다. 모든 로그 레코드 시퀀스 번호를 가진 액세스할 수 없는 새 기준 시퀀스 번호 보다 작은.       레코드 시퀀스가 삭제 되었거나, 또는 잘못 된 인수를 전달 하는 경우이 작업 내에서 즉시 예외가 throw 됩니다. I/O 요청 중의 디스크 오류 예를 들어 비동기 추가 요청 중에 발생 한 오류 때 예외로 throw 됩니다는 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>메서드를 호출 합니다.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "연결을 여 레코드로 추가할 바이트 배열 세그먼트의 목록."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "새 기준 시퀀스 번호입니다. 지정 된 시퀀스 수는 현재 기준 시퀀스 번호 보다 크거나 같아야 합니다."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> 이 재시작 영역에 사용 해야 하는 예약이 포함 된입니다."
    return:
      type: System.IO.Log.SequenceNumber
      description: "쓴의 시퀀스 번호 영역 다시 시작합니다."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>이 시퀀스에 대해 올바르지 않습니다.       -또는-지정 된 로그 열거형 시작 시퀀스 번호가 올바르지 않습니다.       -또는- <code>data</code> 최대 레코드 크기 보다 크기 때문에 추가할 수 없습니다.       -또는- <code>reservationCollection</code> 이 레코드 시퀀스에서 만들어지지 않았습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "매개 변수 중 하나 이상이 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "기존 또는 새 아카이브 테일이나 베이스가 활성 로그의 올바르지 않습니다.       -또는- <code> newBaseSeqNum </code> 이 시퀀스의 기본 클래스와 마지막 시퀀스 번호 사이 있지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "예기치 못한 I/O 예외 때문에 요청을 수행할 수 없습니다.       -또는-I/O 장치 오류 때문에 요청을 수행할 수 없습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "시퀀스의 삭제 된 후 메서드가 호출 되었습니다."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "메모리가 부족 하 여 프로그램의 실행을 계속할 수 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "지정된 된 로그 시퀀스에 대 한 액세스는 운영 체제에서 거부 됩니다."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "레코드 시퀀스가 꽉 찼습니다."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.ReservationNotFoundException
  parent: System.IO.Log
  isExternal: false
  name: ReservationNotFoundException
  nameWithType: ReservationNotFoundException
  fullName: System.IO.Log.ReservationNotFoundException
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
- uid: System.IO.Log.LogStore
  parent: System.IO.Log
  isExternal: false
  name: LogStore
  nameWithType: LogStore
  fullName: System.IO.Log.LogStore
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.LogRecordSequence.Dispose
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.Flush
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.TailPinned
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.#ctor*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence
  nameWithType: LogRecordSequence.LogRecordSequence
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append
  nameWithType: LogRecordSequence.Append
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: LogRecordSequence.BeginAppend
- uid: System.IO.Log.LogRecordSequence.BeginFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: LogRecordSequence.BeginFlush
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: LogRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: LogRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: LogRecordSequence.CreateReservationCollection
- uid: System.IO.Log.LogRecordSequence.Dispose*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose
  nameWithType: LogRecordSequence.Dispose
- uid: System.IO.Log.LogRecordSequence.EndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: LogRecordSequence.EndAppend
- uid: System.IO.Log.LogRecordSequence.EndFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: LogRecordSequence.EndFlush
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: LogRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: LogRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.Flush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush
  nameWithType: LogRecordSequence.Flush
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: LogRecordSequence.ReadLogRecords
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: LogRecordSequence.ReadRestartAreas
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: LogRecordSequence.ReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.ReservedBytes*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
- uid: System.IO.Log.LogRecordSequence.SetLastRecord*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord
  nameWithType: LogRecordSequence.SetLastRecord
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: LogRecordSequence.WriteRestartArea
