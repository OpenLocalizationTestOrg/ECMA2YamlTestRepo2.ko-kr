### YamlMime:ManagedReference
items:
- uid: System.Runtime.Remoting.RemotingConfiguration
  id: RemotingConfiguration
  children:
  - System.Runtime.Remoting.RemotingConfiguration.ApplicationId
  - System.Runtime.Remoting.RemotingConfiguration.ApplicationName
  - System.Runtime.Remoting.RemotingConfiguration.Configure(System.String)
  - System.Runtime.Remoting.RemotingConfiguration.Configure(System.String,System.Boolean)
  - System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled(System.Boolean)
  - System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode
  - System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes
  - System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes
  - System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes
  - System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes
  - System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed(System.Type)
  - System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.Type)
  - System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.String,System.String)
  - System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.Type)
  - System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.String,System.String)
  - System.Runtime.Remoting.RemotingConfiguration.ProcessId
  - System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Runtime.Remoting.ActivatedClientTypeEntry)
  - System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)
  - System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Runtime.Remoting.ActivatedServiceTypeEntry)
  - System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)
  - System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Runtime.Remoting.WellKnownClientTypeEntry)
  - System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)
  - System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Runtime.Remoting.WellKnownServiceTypeEntry)
  - System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)
  langs:
  - csharp
  name: RemotingConfiguration
  nameWithType: RemotingConfiguration
  fullName: System.Runtime.Remoting.RemotingConfiguration
  type: Class
  summary: "원격 인프라를 구성 하기 위한 다양 한 정적 메서드를 제공 합니다."
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public static class RemotingConfiguration
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.ApplicationId
  id: ApplicationId
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: ApplicationId
  nameWithType: RemotingConfiguration.ApplicationId
  fullName: System.Runtime.Remoting.RemotingConfiguration.ApplicationId
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "현재 실행 중인 응용 프로그램의 ID를 가져옵니다."
  remarks: "응용 프로그램 ID는 앞에서 현재 실행 중인 응용 프로그램에 의해 생성 된 개체의 URI에 추가 됩니다."
  syntax:
    content: public static string ApplicationId { get; }
    return:
      type: System.String
      description: "A <xref:System.String>현재 실행 중인 응용 프로그램의 ID가 포함 된.</xref:System.String>"
  overload: System.Runtime.Remoting.RemotingConfiguration.ApplicationId*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "직접 실행 호출자를 인프라 수 있는 권한이 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.ApplicationName
  id: ApplicationName
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: ApplicationName
  nameWithType: RemotingConfiguration.ApplicationName
  fullName: System.Runtime.Remoting.RemotingConfiguration.ApplicationName
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "원격 응용 프로그램의 이름을 가져오거나 설정 합니다."
  remarks: "현재 속성을 통해 또는 구성 파일을 통해 응용 프로그램 이름은 한 번만 설정할 수 있습니다. 응용 프로그램 같은 인터넷 정보 서비스 (IIS), 호스트 된 환경 내에서 실행 되는 경우이 값이 이미 설정 되어 (일반적으로 가상 디렉터리)에 있습니다. 현재 속성은 반환 `null` 응용 프로그램 이름이 설정 되지 않은 경우."
  example:
  - "The following code example demonstrates the use of the ApplicationName property to indicate the name of the remoting application. For the full example code, see examples for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> and <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A> methods.  \n  \n [!code-cs[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/csharp/p-system.runtime.remotin_94_1.cs)]\n [!code-cpp[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/cpp/p-system.runtime.remotin_94_1.cpp)]\n [!code-vb[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/visualbasic/p-system.runtime.remotin_94_1.vb)]  \n  \n The following code example demonstrates how to access an object remoted from a named application.  \n  \n [!code-cpp[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/cpp/p-system.runtime.remotin_94_2.cpp)]\n [!code-cs[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/csharp/p-system.runtime.remotin_94_2.cs)]\n [!code-vb[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/visualbasic/p-system.runtime.remotin_94_2.vb)]"
  syntax:
    content: public static string ApplicationName { get; set; }
    return:
      type: System.String
      description: "원격 응용 프로그램의 이름입니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.ApplicationName*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다. 속성 값을 설정 하는 경우에이 예외가 throw 됩니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.Configure(System.String)
  id: Configure(System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: Configure(String)
  nameWithType: RemotingConfiguration.Configure(String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.Configure(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "구성 파일을 읽고 하 고 원격 인프라를 구성 합니다. 구성는 사용 되지 않습니다. 사용 하세요 &lt;xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%2CSystem.Boolean%29&gt; 대신 합니다."
  remarks: "> [!NOTE]> 구성는 사용 되지 않습니다. 사용 하세요 <xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%2CSystem.Boolean%29>대신.</xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%2CSystem.Boolean%29>       전달 `null` 로 `filename` 매개 변수 구성 파일의 존재를 요구 하지 않고 기본 원격 초기화를 수행 합니다.       구성 파일 구문에 대 한 참조 [원격 설정 스키마](http://msdn.microsoft.com/en-us/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e)합니다.      > [!NOTE] > 참조 방식 마샬링 개체 (마샬링된)에 있지 않으므로 메모리에 계속 합니다. 대신, 해당 형식 <xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=fullName>자체 수명 정책을 제어 하려면 각 MBR에.NET Framework remoting 시스템 메모리를 확보 하 고 삭제는 프로세스를 시작 하기 전에 제한 시간을.</xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=fullName> 자세한 내용은 참조 [수명 임대](http://msdn.microsoft.com/en-us/c72d561c-1266-4c8b-b258-2c168c08da9a)합니다."
  example:
  - >-
    [!code-cs[RemotingConfiguration_Configure_Client#1](~/add/codesnippet/csharp/m-system.runtime.remotin_8_1.cs)]
     [!code-vb[RemotingConfiguration_Configure_Client#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_8_1.vb)]
     [!code-cpp[RemotingConfiguration_Configure_Client#1](~/add/codesnippet/cpp/m-system.runtime.remotin_8_1.cpp)]
  syntax:
    content: public static void Configure (string filename);
    parameters:
    - id: filename
      type: System.String
      description: "원격 구성 파일의 이름입니다. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  overload: System.Runtime.Remoting.RemotingConfiguration.Configure*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.Configure(System.String,System.Boolean)
  id: Configure(System.String,System.Boolean)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: Configure(String,Boolean)
  nameWithType: RemotingConfiguration.Configure(String,Boolean)
  fullName: System.Runtime.Remoting.RemotingConfiguration.Configure(String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "구성 파일을 읽고 하 고 원격 인프라를 구성 합니다."
  remarks: "전달 `null` 로 `filename` 매개 변수 구성 파일의 존재를 요구 하지 않고 기본 원격 초기화를 수행 합니다. 원격 및 보안에 대 한 자세한 내용은 참조 하십시오. [Remoting의 보안 합니다.](http://msdn.microsoft.com/en-us/9574262c-d4b1-41c5-8600-24ff147c0add)       구성 파일 구문에 대 한 참조 [원격 설정 스키마](http://msdn.microsoft.com/en-us/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e)합니다.      > [!NOTE] > 참조 방식 마샬링 개체 (마샬링된)에 있지 않으므로 메모리에 계속 합니다. 대신, 해당 형식 <xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=fullName>자체 수명 정책을 제어 하려면 각 MBR에.NET Framework remoting 시스템 메모리를 확보 하 고 삭제는 프로세스를 시작 하기 전에 제한 시간을.</xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=fullName> 자세한 내용은 참조 [수명 임대](http://msdn.microsoft.com/en-us/c72d561c-1266-4c8b-b258-2c168c08da9a)합니다."
  syntax:
    content: public static void Configure (string filename, bool ensureSecurity);
    parameters:
    - id: filename
      type: System.String
      description: "원격 구성 파일의 이름입니다. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    - id: ensureSecurity
      type: System.Boolean
      description: "경우 설정 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> 보안은 필요 합니다. 경우로 설정 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>, 보안은 필요 하지 않지만 여전히 사용할 수 있습니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.Configure*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled(System.Boolean)
  id: CustomErrorsEnabled(System.Boolean)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: CustomErrorsEnabled(Boolean)
  nameWithType: RemotingConfiguration.CustomErrorsEnabled(Boolean)
  fullName: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "이 응용 프로그램 도메인의 서버 채널이 로컬 또는 원격 호출자에 게 완전 한 필터링 된 예외 정보를 반환 하는지 여부를 나타냅니다."
  remarks: "Complete exception information includes the exact server exception and the server stack trace. Filtered information includes a standard remoting exception but no server stack trace.  \n  \n The `CustomErrorsEnabled` method reflects configuration settings that were specified in the `mode` attribute of the `<customErrors>` element of the application configuration file. For more information about configuration options, see [&#91;\\<topic://cpconconfiguration>&#93;](http://msdn.microsoft.com/en-us/92c0c097-d984-4315-835b-7490ecdf1097).  \n  \n The following table shows the three server channel property values that specify which callers receive exception information and what type of information they receive.  \n  \n|Value|Description|  \n|-----------|-----------------|  \n|`off`|All callers receive complete exception information.|  \n|`on`|All callers receive filtered exception information.|  \n|`remoteOnly`|Local callers receive complete exception information; remote callers receive filtered exception information.|  \n  \n The following table shows the interaction of the `isLocalRequest` parameter and the server channel property.  \n  \n|Value|isLocalRequest|Return value|Description|  \n|-----------|--------------------|------------------|-----------------|  \n|`on`|`true`|`true`|Local callers receive filtered exception information.|  \n|`on`|`false`|`true`|Remote callers receive filtered exception information.|  \n|`off`|`true`|`false`|Local callers receive complete exception information.|  \n|`off`|`false`|`false`|Remote callers receive complete exception information.|  \n|`remoteOnly`|`true`|`false`|Local callers receive complete exception information.|  \n|`remoteOnly`|`false`|`true`|Remote callers receive filtered exception information.|  \n  \n For information about using application configuration files to control the return of exception information to callers, see the `<customErrors>` element."
  syntax:
    content: public static bool CustomErrorsEnabled (bool isLocalRequest);
    parameters:
    - id: isLocalRequest
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>로컬 호출자를 지정 하려면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 원격 호출자가 지정할 수 있습니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>에 지정 된 대로 로컬 또는 원격 호출자에 예외 정보를 필터링 하는 경우에 반환 되는 <code> isLocalRequest </code> ; 매개 변수 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 완료 하는 경우 예외 정보가 반환 됩니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode
  id: CustomErrorsMode
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: CustomErrorsMode
  nameWithType: RemotingConfiguration.CustomErrorsMode
  fullName: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "방식을 사용자 지정 오류를 나타내는 값을 가져오거나 설정 합니다. 처리 됩니다."
  syntax:
    content: public static System.Runtime.Remoting.CustomErrorsModes CustomErrorsMode { get; set; }
    return:
      type: System.Runtime.Remoting.CustomErrorsModes
      description: "멤버는 <xref href=&quot;System.Runtime.Remoting.CustomErrorsModes&quot;> </xref> 처리 되는 방식을 사용자 지정 오류를 나타내는 열거형입니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes
  id: GetRegisteredActivatedClientTypes
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: GetRegisteredActivatedClientTypes()
  nameWithType: RemotingConfiguration.GetRegisteredActivatedClientTypes()
  fullName: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "원격으로 활성화할 수 있는 형식으로 클라이언트에 등록 된 개체 유형을 검색 합니다."
  remarks: "에 대 한 자세한 설명은 클라이언트 활성 개체를 참조 하세요. [[\\<topic://cpconClientActivation >]](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a)합니다."
  syntax:
    content: public static System.Runtime.Remoting.ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes ();
    parameters: []
    return:
      type: System.Runtime.Remoting.ActivatedClientTypeEntry[]
      description: "클라이언트에서 원격으로 활성화 되는 형식으로 등록 된 개체 형식의 배열입니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes
  id: GetRegisteredActivatedServiceTypes
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: GetRegisteredActivatedServiceTypes()
  nameWithType: RemotingConfiguration.GetRegisteredActivatedServiceTypes()
  fullName: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "클라이언트의 요청에 활성화 될 수 있는 서비스 쪽에 등록 된 개체 형식의 배열을 검색 합니다."
  remarks: "에 대 한 자세한 설명은 클라이언트 활성 개체를 참조 하세요. [[\\<topic://cpconClientActivation >]](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a)합니다."
  example:
  - >-
    [!code-cs[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/add/codesnippet/csharp/131c20b0-ea6b-424e-a05f-_1.cs)]
     [!code-vb[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/add/codesnippet/visualbasic/131c20b0-ea6b-424e-a05f-_1.vb)]
     [!code-cpp[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/add/codesnippet/cpp/131c20b0-ea6b-424e-a05f-_1.cpp)]
  syntax:
    content: public static System.Runtime.Remoting.ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes ();
    parameters: []
    return:
      type: System.Runtime.Remoting.ActivatedServiceTypeEntry[]
      description: "클라이언트의 요청에 활성화 될 수 있는 서비스 쪽에 등록 된 개체 형식의 배열입니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes
  id: GetRegisteredWellKnownClientTypes
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: GetRegisteredWellKnownClientTypes()
  nameWithType: RemotingConfiguration.GetRegisteredWellKnownClientTypes()
  fullName: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "잘 알려진 형식으로 클라이언트 쪽에 등록 된 개체 형식의 배열을 검색 합니다."
  remarks: "Well-known object types can be either single call or singleton. If an object type is single call, then a new instance of it is created each time a call from the client comes in. All calls to a singleton object are handled by one instance of that object.  \n  \n For a more detailed description of well-known objects, see [&#91;\\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396)."
  example:
  - >-
    [!code-vb[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/add/codesnippet/visualbasic/90e2868e-717f-4977-8f71-_1.vb)]
     [!code-cs[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/add/codesnippet/csharp/90e2868e-717f-4977-8f71-_1.cs)]
     [!code-cpp[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/add/codesnippet/cpp/90e2868e-717f-4977-8f71-_1.cpp)]
  syntax:
    content: public static System.Runtime.Remoting.WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes ();
    parameters: []
    return:
      type: System.Runtime.Remoting.WellKnownClientTypeEntry[]
      description: "클라이언트 쪽에 잘 알려진 형식으로 등록 된 개체 형식의 배열입니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes
  id: GetRegisteredWellKnownServiceTypes
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: GetRegisteredWellKnownServiceTypes()
  nameWithType: RemotingConfiguration.GetRegisteredWellKnownServiceTypes()
  fullName: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "서비스 쪽에 잘 알려진 형식으로 등록 된 개체 형식의 배열을 검색 합니다."
  remarks: "Well-known object types can be either single call or singleton. If an object type is single call, then a new instance of it is created each time a call from the client comes in. All calls to a singleton object are handled by one instance of that object.  \n  \n For a more detailed description of well-known objects, see [&#91;\\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396)."
  example:
  - >-
    [!code-cs[RemotingConfiguration_Configure_Client#2](~/add/codesnippet/csharp/86dd75a5-23bc-425c-9a34-_1.cs)]
     [!code-vb[RemotingConfiguration_Configure_Client#2](~/add/codesnippet/visualbasic/86dd75a5-23bc-425c-9a34-_1.vb)]
     [!code-cpp[RemotingConfiguration_Configure_Client#2](~/add/codesnippet/cpp/86dd75a5-23bc-425c-9a34-_1.cpp)]
  syntax:
    content: public static System.Runtime.Remoting.WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes ();
    parameters: []
    return:
      type: System.Runtime.Remoting.WellKnownServiceTypeEntry[]
      description: "서비스 쪽에 잘 알려진 형식으로 등록 된 개체 형식의 배열입니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed(System.Type)
  id: IsActivationAllowed(System.Type)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: IsActivationAllowed(Type)
  nameWithType: RemotingConfiguration.IsActivationAllowed(Type)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed(Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "나타내는 부울 값을 반환 하는지 여부를 지정 된 <xref:System.Type>을 클라이언트에서 활성화할 수 있습니다.</xref:System.Type>"
  remarks: "현재 메서드는 개체의 활성화 여부를 확인 하려면 서버 쪽에서 사용 됩니다 <xref:System.Type>서버에서 명시적으로 허용 됩니다.</xref:System.Type>"
  example:
  - >-
    [!code-cs[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/add/codesnippet/csharp/m-system.runtime.remotin_30_1.cs)]
     [!code-vb[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_30_1.vb)]
     [!code-cpp[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/add/codesnippet/cpp/m-system.runtime.remotin_30_1.cpp)]
  syntax:
    content: public static bool IsActivationAllowed (Type svrType);
    parameters:
    - id: svrType
      type: System.Type
      description: "개체 <xref:System.Type>확인 하려면.</xref:System.Type>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>하는 경우 지정 된 <xref:System.Type>을 활성화 하는 클라이언트 수에서 허용 되 고, 그러지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Type>"
  overload: System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.Type)
  id: IsRemotelyActivatedClientType(System.Type)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: IsRemotelyActivatedClientType(Type)
  nameWithType: RemotingConfiguration.IsRemotelyActivatedClientType(Type)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "확인 여부 지정된 된 개체 <xref:System.Type>원격 활성된 클라이언트 유형으로 등록 됩니다.</xref:System.Type>"
  remarks: ''
  example:
  - >-
    [!code-cpp[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/add/codesnippet/cpp/3c46e8e7-ec3a-4a5f-8592-_1.cpp)]
     [!code-cs[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/add/codesnippet/csharp/3c46e8e7-ec3a-4a5f-8592-_1.cs)]
     [!code-vb[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/add/codesnippet/visualbasic/3c46e8e7-ec3a-4a5f-8592-_1.vb)]
  syntax:
    content: public static System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType (Type svrType);
    parameters:
    - id: svrType
      type: System.Type
      description: "확인할 개체 형식입니다."
    return:
      type: System.Runtime.Remoting.ActivatedClientTypeEntry
      description: "<xref href=&quot;System.Runtime.Remoting.ActivatedClientTypeEntry&quot;> </xref> 지정된 된 개체 형식에 해당 하는 합니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.String,System.String)
  id: IsRemotelyActivatedClientType(System.String,System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: IsRemotelyActivatedClientType(String,String)
  nameWithType: RemotingConfiguration.IsRemotelyActivatedClientType(String,String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "개체의 유형 이름 및 어셈블리 이름으로 지정 된 원격 활성된 클라이언트 유형으로 등록 되었는지 여부를 확인 합니다."
  remarks: ''
  example:
  - >-
    [!code-cpp[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/add/codesnippet/cpp/12883156-dae9-4c9d-b176-_1.cpp)]
     [!code-vb[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/add/codesnippet/visualbasic/12883156-dae9-4c9d-b176-_1.vb)]
     [!code-cs[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/add/codesnippet/csharp/12883156-dae9-4c9d-b176-_1.cs)]
  syntax:
    content: public static System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType (string typeName, string assemblyName);
    parameters:
    - id: typeName
      type: System.String
      description: "확인할 개체의 형식 이름입니다."
    - id: assemblyName
      type: System.String
      description: "확인할 개체의 어셈블리 이름입니다."
    return:
      type: System.Runtime.Remoting.ActivatedClientTypeEntry
      description: "<xref href=&quot;System.Runtime.Remoting.ActivatedClientTypeEntry&quot;> </xref> 지정된 된 개체 형식에 해당 하는 합니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.Type)
  id: IsWellKnownClientType(System.Type)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: IsWellKnownClientType(Type)
  nameWithType: RemotingConfiguration.IsWellKnownClientType(Type)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "확인 여부 지정된 된 개체 <xref:System.Type>잘 알려진 클라이언트 형식으로 등록 됩니다.</xref:System.Type>"
  remarks: ''
  example:
  - >-
    [!code-cs[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/add/codesnippet/csharp/e5a3d3ea-9352-4b35-bf3c-_1.cs)]
     [!code-cpp[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/add/codesnippet/cpp/e5a3d3ea-9352-4b35-bf3c-_1.cpp)]
     [!code-vb[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/add/codesnippet/visualbasic/e5a3d3ea-9352-4b35-bf3c-_1.vb)]
  syntax:
    content: public static System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType (Type svrType);
    parameters:
    - id: svrType
      type: System.Type
      description: "개체 <xref:System.Type>확인 하려면.</xref:System.Type>"
    return:
      type: System.Runtime.Remoting.WellKnownClientTypeEntry
      description: "<xref href=&quot;System.Runtime.Remoting.WellKnownClientTypeEntry&quot;> </xref> 지정된 된 개체 형식에 해당 하는 합니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.String,System.String)
  id: IsWellKnownClientType(System.String,System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: IsWellKnownClientType(String,String)
  nameWithType: RemotingConfiguration.IsWellKnownClientType(String,String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "개체의 유형 이름 및 어셈블리 이름으로 지정 된 잘 알려진 클라이언트 형식으로 등록 되었는지 여부를 확인 합니다."
  remarks: ''
  example:
  - >-
    [!code-cpp[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/add/codesnippet/cpp/2bdef175-1df9-4504-8b1f-_1.cpp)]
     [!code-cs[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/add/codesnippet/csharp/2bdef175-1df9-4504-8b1f-_1.cs)]
     [!code-vb[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/add/codesnippet/visualbasic/2bdef175-1df9-4504-8b1f-_1.vb)]
  syntax:
    content: public static System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType (string typeName, string assemblyName);
    parameters:
    - id: typeName
      type: System.String
      description: "확인할 개체의 형식 이름입니다."
    - id: assemblyName
      type: System.String
      description: "확인할 개체의 어셈블리 이름입니다."
    return:
      type: System.Runtime.Remoting.WellKnownClientTypeEntry
      description: "<xref href=&quot;System.Runtime.Remoting.WellKnownClientTypeEntry&quot;> </xref> 지정된 된 개체 형식에 해당 하는 합니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.ProcessId
  id: ProcessId
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: ProcessId
  nameWithType: RemotingConfiguration.ProcessId
  fullName: System.Runtime.Remoting.RemotingConfiguration.ProcessId
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "현재 실행 중인 프로세스의 ID를 가져옵니다."
  syntax:
    content: public static string ProcessId { get; }
    return:
      type: System.String
      description: "A <xref:System.String>현재 실행 중인 프로세스의 ID가 포함 된.</xref:System.String>"
  overload: System.Runtime.Remoting.RemotingConfiguration.ProcessId*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "직접 실행 호출자를 인프라 수 있는 권한이 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Runtime.Remoting.ActivatedClientTypeEntry)
  id: RegisterActivatedClientType(System.Runtime.Remoting.ActivatedClientTypeEntry)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: RegisterActivatedClientType(ActivatedClientTypeEntry)
  nameWithType: RemotingConfiguration.RegisterActivatedClientType(ActivatedClientTypeEntry)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(ActivatedClientTypeEntry)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "개체 등록 <xref:System.Type>에 제공 된 기록 <xref href=&quot;System.Runtime.Remoting.ActivatedClientTypeEntry&quot;> </xref> 서버에서 활성화 될 수 있는 형식으로 클라이언트 쪽에.</xref:System.Type>"
  remarks: "To create an instance of a client-activated object on the server, you must know its <xref:System.Type> and it must be registered on the server end by using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> method. To obtain a proxy for a new instance of the client-activated object, the client must first register a channel with <xref:System.Runtime.Remoting.Channels.ChannelServices> and then activate the object by calling `new`.  \n  \n To activate a client-activated object type with the `new` keyword, you must first register the object type on the client end using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method gives the remoting infrastructure the location of the remote application where `new` attempts to create it. If, on the other hand, you use the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method to create a new instance of the client-activated object, you must supply the remote application's URL as a parameter, so no prior registration on the client end is necessary. To supply the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method with the URL of the server where you want to create the object, you must encapsulate the URL in an instance of the <xref:System.Runtime.Remoting.Activation.UrlAttribute> class.  \n  \n For a detailed description of client-activated objects, see [&#91;\\<topic://cpconClientActivation>&#93;](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a)."
  syntax:
    content: public static void RegisterActivatedClientType (System.Runtime.Remoting.ActivatedClientTypeEntry entry);
    parameters:
    - id: entry
      type: System.Runtime.Remoting.ActivatedClientTypeEntry
      description: "클라이언트가 정품 인증 형식에 대 한 구성 설정입니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)
  id: RegisterActivatedClientType(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: RegisterActivatedClientType(Type,String)
  nameWithType: RemotingConfiguration.RegisterActivatedClientType(Type,String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(Type,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "개체 등록 <xref:System.Type>서버에서 활성화 될 수 있는 형식으로 클라이언트 쪽에서는의 새 인스턴스를 초기화 지정된 된 매개 변수를 사용 하 여 <xref href=&quot;System.Runtime.Remoting.ActivatedClientTypeEntry&quot;> </xref> 클래스</xref:System.Type>"
  remarks: "To create an instance of a client-activated object on the server, you must know its <xref:System.Type> and it must be registered on the server end by using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> method. To obtain a proxy for a new instance of the client-activated object, the client must first register a channel with <xref:System.Runtime.Remoting.Channels.ChannelServices> and then activate the object by calling `new`.  \n  \n To activate a client-activated object type with the `new` keyword, you must first register the object type on the client end using the RegisterActivatedClientType method. Calling the RegisterActivatedClientType method gives the remoting infrastructure the location of the remote application where `new` attempts to create it. If, on the other hand, you use the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method to create a new instance of the client-activated object, you must supply the remote application's URL as a parameter, so no prior registration on the client end is necessary. To supply the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method with the URL of the server where you want to create the object, you must encapsulate the URL in an instance of the <xref:System.Runtime.Remoting.Activation.UrlAttribute> class.  \n  \n For a detailed description of client-activated objects, see [&#91;\\<topic://cpconClientActivation>&#93;](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a)"
  example:
  - "The following code example demonstrates registration of an object type on the client end as a type that can be activated on the server. For the server code that corresponds to the presented client code, see the example for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> method.  \n  \n [!code-cs[RemotingConfiguration.ClientActivation#1](~/add/codesnippet/csharp/c2dd353b-ad06-48e7-888a-_1.cs)]\n [!code-cpp[RemotingConfiguration.ClientActivation#1](~/add/codesnippet/cpp/c2dd353b-ad06-48e7-888a-_1.cpp)]\n [!code-vb[RemotingConfiguration.ClientActivation#1](~/add/codesnippet/visualbasic/c2dd353b-ad06-48e7-888a-_1.vb)]"
  syntax:
    content: public static void RegisterActivatedClientType (Type type, string appUrl);
    parameters:
    - id: type
      type: System.Type
      description: "<xref:System.Type>입니다.</xref:System.Type> 개체"
    - id: appUrl
      type: System.String
      description: "이 형식은 활성화 되는 응용 프로그램의 URL입니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>typeName</code> or <code>URI</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Runtime.Remoting.ActivatedServiceTypeEntry)
  id: RegisterActivatedServiceType(System.Runtime.Remoting.ActivatedServiceTypeEntry)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: RegisterActivatedServiceType(ActivatedServiceTypeEntry)
  nameWithType: RemotingConfiguration.RegisterActivatedServiceType(ActivatedServiceTypeEntry)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(ActivatedServiceTypeEntry)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "에 제공 된 개체 형식을 기록 하는 레지스터 <xref href=&quot;System.Runtime.Remoting.ActivatedServiceTypeEntry&quot;> </xref> 으로 클라이언트의 요청에 활성화 될 수 있는 서비스 쪽에 있습니다."
  remarks: "To create an instance of a client-activated object on the server, you must know its <xref:System.Type> and it must be registered on the server end by using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> method. To obtain a proxy for a new instance of the client-activated object, the client must first register a channel with <xref:System.Runtime.Remoting.Channels.ChannelServices> and then activate the object by calling `new` or <xref:System.Activator.CreateInstance%2A?displayProperty=fullName>.  \n  \n To activate a client-activated object type with the `new` keyword, you must first register the object type on the client end using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method gives the remoting infrastructure the location of the remote application, where `new` attempts to create it. If, on the other hand, you use the <xref:System.Activator.CreateInstance%2A> method to create a new instance of the client-activated object, you must supply the remote application's URL as a parameter, so no prior registration on the client end is necessary. To supply the <xref:System.Activator.CreateInstance%2A> method with the URL of the server where you want to create the object, you must encapsulate the URL in an instance of the <xref:System.Runtime.Remoting.Activation.UrlAttribute> class.  \n  \n For a detailed description of client-activated objects, see [&#91;\\<topic://cpconClientActivation>&#93;](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a)."
  syntax:
    content: public static void RegisterActivatedServiceType (System.Runtime.Remoting.ActivatedServiceTypeEntry entry);
    parameters:
    - id: entry
      type: System.Runtime.Remoting.ActivatedServiceTypeEntry
      description: "클라이언트가 정품 인증 형식에 대 한 구성 설정입니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)
  id: RegisterActivatedServiceType(System.Type)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: RegisterActivatedServiceType(Type)
  nameWithType: RemotingConfiguration.RegisterActivatedServiceType(Type)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "서비스 쪽에 지정한 개체 유형에 클라이언트의 요청에 활성화 될 수 있는 형식으로 등록 합니다."
  remarks: "To create an instance of a client-activated object on the server, you must know its <xref:System.Type> and it must be registered on the server end by using the RegisterActivatedServiceType method. To obtain a proxy for a new instance of the client-activated object, the client must first register a channel with <xref:System.Runtime.Remoting.Channels.ChannelServices> and then activate the object by calling `new` or <xref:System.Activator.CreateInstance%2A?displayProperty=fullName>.  \n  \n To activate a client-activated object type with the `new` keyword, you must first register the object type on the client end using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method gives the remoting infrastructure the location of the remote application, where `new` attempts to create it. If, on the other hand, you use the <xref:System.Activator.CreateInstance%2A> method to create a new instance of the client-activated object, you must supply the remote application's URL as a parameter, so no prior registration on the client end is necessary. To supply the <xref:System.Activator.CreateInstance%2A> method with the URL of the server where you want to create the object, you must encapsulate the URL in an instance of the <xref:System.Runtime.Remoting.Activation.UrlAttribute> class.  \n  \n For a detailed description of client-activated objects, see [&#91;\\<topic://cpconClientActivation>&#93;](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a)."
  example:
  - "The following code example demonstrates registration of an object type on the server as a type that can be activated by the client. For the client code that corresponds to the presented server code, see the example for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method.  \n  \n [!code-cpp[RemotingConfiguration.ClientActivation#2](~/add/codesnippet/cpp/47d0882a-e55a-42b9-abb6-_1.cpp)]\n [!code-vb[RemotingConfiguration.ClientActivation#2](~/add/codesnippet/visualbasic/47d0882a-e55a-42b9-abb6-_1.vb)]\n [!code-cs[RemotingConfiguration.ClientActivation#2](~/add/codesnippet/csharp/47d0882a-e55a-42b9-abb6-_1.cs)]  \n  \n The following code example shows the service object registered in the sample code above.  \n  \n [!code-cpp[RemotingConfiguration.ClientActivation#3](~/add/codesnippet/cpp/47d0882a-e55a-42b9-abb6-_2.cpp)]\n [!code-vb[RemotingConfiguration.ClientActivation#3](~/add/codesnippet/visualbasic/47d0882a-e55a-42b9-abb6-_2.vb)]\n [!code-cs[RemotingConfiguration.ClientActivation#3](~/add/codesnippet/csharp/47d0882a-e55a-42b9-abb6-_2.cs)]"
  syntax:
    content: public static void RegisterActivatedServiceType (Type type);
    parameters:
    - id: type
      type: System.Type
      description: "<xref:System.Type>의 등록할 개체입니다.</xref:System.Type>"
  overload: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Runtime.Remoting.WellKnownClientTypeEntry)
  id: RegisterWellKnownClientType(System.Runtime.Remoting.WellKnownClientTypeEntry)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: RegisterWellKnownClientType(WellKnownClientTypeEntry)
  nameWithType: RemotingConfiguration.RegisterWellKnownClientType(WellKnownClientTypeEntry)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(WellKnownClientTypeEntry)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "개체 등록 <xref:System.Type>에 제공 된 기록 <xref href=&quot;System.Runtime.Remoting.WellKnownClientTypeEntry&quot;> </xref> 서버에서 활성화 될 수 있는 잘 알려진 형식으로 클라이언트 쪽에.</xref:System.Type>"
  remarks: "Any client that knows the URI of a registered well-known object can obtain a proxy for the object by registering the channel it prefers with <xref:System.Runtime.Remoting.Channels.ChannelServices>, and activating the object by calling `new` or <xref:System.Activator.GetObject%2A?displayProperty=fullName>. To activate a well-known object with `new`, you must first register the well-known object type on the client using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method gives the remoting infrastructure the location of the remote object, which allows the `new` keyword to create it. If, on the other hand, you use the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method to activate the well-known object, you must supply it with the object's URL as an argument, so no prior registration on the client end is necessary.  \n  \n For a detailed description of well-known objects, see [&#91;\\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396)."
  syntax:
    content: public static void RegisterWellKnownClientType (System.Runtime.Remoting.WellKnownClientTypeEntry entry);
    parameters:
    - id: entry
      type: System.Runtime.Remoting.WellKnownClientTypeEntry
      description: "잘 알려진 형식에 대 한 구성 설정입니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)
  id: RegisterWellKnownClientType(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: RegisterWellKnownClientType(Type,String)
  nameWithType: RemotingConfiguration.RegisterWellKnownClientType(Type,String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(Type,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "개체 등록 <xref:System.Type>서버에서 활성화 될 수 있는 잘 알려진 형식으로 클라이언트 쪽에서는의 새 인스턴스를 초기화 지정된 된 매개 변수를 사용 하 여 <xref href=&quot;System.Runtime.Remoting.WellKnownClientTypeEntry&quot;> </xref> 클래스</xref:System.Type>"
  remarks: "Any client that knows the URI of a registered well-known object can obtain a proxy for the object by registering the channel it prefers with <xref:System.Runtime.Remoting.Channels.ChannelServices>, and activating the object by calling `new` or <xref:System.Activator.GetObject%2A?displayProperty=fullName>. To activate a well-known object with `new`, you must first register the well-known object type on the client using the RegisterWellKnownClientType method. Calling the RegisterWellKnownClientType method gives the remoting infrastructure the location of the remote object, which allows the `new` keyword to create it. If, on the other hand, you use the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method to activate the well-known object, you must supply it with the object's URL as an argument, so no prior registration on the client end is necessary.  \n  \n For a detailed description of well-known objects, see [&#91;\\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396)."
  example:
  - "The following code example demonstrates registration of an object type on the client end as a well-known type. For the server code that corresponds to the presented client code, see the example for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A> method.  \n  \n [!code-cpp[RemotingConfiguration.ServerActivation1#5](~/add/codesnippet/cpp/a1a284a9-559a-423c-b0e1-_1.cpp)]\n [!code-cs[RemotingConfiguration.ServerActivation1#5](~/add/codesnippet/csharp/a1a284a9-559a-423c-b0e1-_1.cs)]\n [!code-vb[RemotingConfiguration.ServerActivation1#5](~/add/codesnippet/visualbasic/a1a284a9-559a-423c-b0e1-_1.vb)]  \n[!code-cpp[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/cpp/a1a284a9-559a-423c-b0e1-_2.cpp)]\n[!code-cs[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/csharp/a1a284a9-559a-423c-b0e1-_2.cs)]\n[!code-vb[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/visualbasic/a1a284a9-559a-423c-b0e1-_2.vb)]  \n[!code-cpp[RemotingConfiguration.ServerActivation1#7](~/add/codesnippet/cpp/a1a284a9-559a-423c-b0e1-_3.cpp)]\n[!code-cs[RemotingConfiguration.ServerActivation1#7](~/add/codesnippet/csharp/a1a284a9-559a-423c-b0e1-_3.cs)]\n[!code-vb[RemotingConfiguration.ServerActivation1#7](~/add/codesnippet/visualbasic/a1a284a9-559a-423c-b0e1-_3.vb)]"
  syntax:
    content: public static void RegisterWellKnownClientType (Type type, string objectUrl);
    parameters:
    - id: type
      type: System.Type
      description: "<xref:System.Type>입니다.</xref:System.Type> 개체"
    - id: objectUrl
      type: System.String
      description: "잘 알려진 클라이언트 개체의 URL입니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Runtime.Remoting.WellKnownServiceTypeEntry)
  id: RegisterWellKnownServiceType(System.Runtime.Remoting.WellKnownServiceTypeEntry)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: RegisterWellKnownServiceType(WellKnownServiceTypeEntry)
  nameWithType: RemotingConfiguration.RegisterWellKnownServiceType(WellKnownServiceTypeEntry)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(WellKnownServiceTypeEntry)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "개체 등록 <xref:System.Type>에 제공 된 기록 <xref href=&quot;System.Runtime.Remoting.WellKnownServiceTypeEntry&quot;> </xref> 잘 알려진 형식으로 서비스 쪽에.</xref:System.Type>"
  remarks: "Any client that knows the URI of a registered well-known object can obtain a proxy for the object by registering the channel it prefers with <xref:System.Runtime.Remoting.Channels.ChannelServices>, and activating the object by calling `new` or the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method. To activate a well-known object with `new`, you must first register the well-known object type on the client using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method gives the remoting infrastructure the location of the remote object, which allows the `new` keyword to create it. If, on the other hand, you use the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method to activate the well-known object, you must supply it with the object's URL as an argument, so no prior registration on the client end is necessary.  \n  \n When the call arrives at the server, the .NET Framework extracts the URI from the message, examines the remoting tables to locate the reference for the object that matches the URI, and then instantiates the object if necessary, forwarding the method call to the object. If the object is registered as <xref:System.Runtime.Remoting.WellKnownObjectMode>, it is destroyed after the method call is completed. A new instance of the object is created for each method called. The only difference between <xref:System.Activator.GetObject%2A?displayProperty=fullName> and `new` is that the former allows you to specify a URL as a parameter, and the latter obtains the URL from the configuration.  \n  \n The remote object itself is not instantiated by the registration process. This only happens when a client attempts to call a method on the object or activates the object from the client side.  \n  \n For a detailed description of well-known objects, see [&#91;\\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396)."
  example:
  - >-
    [!code-cs[CreateObjRef2#2](~/add/codesnippet/csharp/5b43d3ef-403f-408d-a561-_1.cs)]
     [!code-vb[CreateObjRef2#2](~/add/codesnippet/visualbasic/5b43d3ef-403f-408d-a561-_1.vb)]
     [!code-cpp[CreateObjRef2#2](~/add/codesnippet/cpp/5b43d3ef-403f-408d-a561-_1.cpp)]
  syntax:
    content: public static void RegisterWellKnownServiceType (System.Runtime.Remoting.WellKnownServiceTypeEntry entry);
    parameters:
    - id: entry
      type: System.Runtime.Remoting.WellKnownServiceTypeEntry
      description: "잘 알려진 형식에 대 한 구성 설정입니다."
  overload: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)
  id: RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: RegisterWellKnownServiceType(Type,String,WellKnownObjectMode)
  nameWithType: RemotingConfiguration.RegisterWellKnownServiceType(Type,String,WellKnownObjectMode)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(Type,String,WellKnownObjectMode)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "개체 등록 <xref:System.Type>잘 알려진 형식으로 서비스 쪽에서는 지정된 된 매개 변수의 새 인스턴스를 초기화를 사용 하 여 <xref href=&quot;System.Runtime.Remoting.WellKnownServiceTypeEntry&quot;> </xref>.</xref:System.Type>"
  remarks: "Any client that knows the URI of a registered well-known object can obtain a proxy for the object by registering the channel it prefers with <xref:System.Runtime.Remoting.Channels.ChannelServices>, and activating the object by calling `new` or the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method. To activate a well-known object with `new`, you must first register the well-known object type on the client using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method gives the remoting infrastructure the location of the remote object, which allows the `new` keyword to create it. If, on the other hand, you use the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method to activate the well-known object, you must supply it with the object's URL as an argument, so no prior registration on the client end is necessary.  \n  \n When the call arrives at the server, the .NET Framework extracts the URI from the message, examines the remoting tables to locate the reference for the object that matches the URI, and then instantiates the object if necessary, forwarding the method call to the object. If the object is registered as <xref:System.Runtime.Remoting.WellKnownObjectMode>, it is destroyed after the method call is completed. A new instance of the object is created for each method called. The only difference between <xref:System.Activator.GetObject%2A?displayProperty=fullName> and `new` is that the former allows you to specify a URL as a parameter, and the latter obtains the URL from the configuration.  \n  \n The remote object itself is not instantiated by the registration process. This only happens when a client attempts to call a method on the object or activates the object from the client side.  \n  \n For a detailed description of well-known objects, see [&#91;\\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396)."
  example:
  - "The following code example demonstrates registration of an object type on the server as a well-known object type. For the client code that corresponds to the presented server code, see the example for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method.  \n  \n [!code-cs[RemotingConfiguration.ServerActivation1#1](~/add/codesnippet/csharp/fe293b93-5873-439c-96b8-_1.cs)]\n [!code-cpp[RemotingConfiguration.ServerActivation1#1](~/add/codesnippet/cpp/fe293b93-5873-439c-96b8-_1.cpp)]\n [!code-vb[RemotingConfiguration.ServerActivation1#1](~/add/codesnippet/visualbasic/fe293b93-5873-439c-96b8-_1.vb)]  \n[!code-cs[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/csharp/fe293b93-5873-439c-96b8-_2.cs)]\n[!code-cpp[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/cpp/fe293b93-5873-439c-96b8-_2.cpp)]\n[!code-vb[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/visualbasic/fe293b93-5873-439c-96b8-_2.vb)]  \n[!code-cs[RemotingConfiguration.ServerActivation1#3](~/add/codesnippet/csharp/fe293b93-5873-439c-96b8-_3.cs)]\n[!code-cpp[RemotingConfiguration.ServerActivation1#3](~/add/codesnippet/cpp/fe293b93-5873-439c-96b8-_3.cpp)]\n[!code-vb[RemotingConfiguration.ServerActivation1#3](~/add/codesnippet/visualbasic/fe293b93-5873-439c-96b8-_3.vb)]  \n  \n The following code example shows the service object registered in the sample code above.  \n  \n [!code-cpp[RemotingConfiguration.ServerActivation1#4](~/add/codesnippet/cpp/fe293b93-5873-439c-96b8-_4.cpp)]\n [!code-cs[RemotingConfiguration.ServerActivation1#4](~/add/codesnippet/csharp/fe293b93-5873-439c-96b8-_4.cs)]\n [!code-vb[RemotingConfiguration.ServerActivation1#4](~/add/codesnippet/visualbasic/fe293b93-5873-439c-96b8-_4.vb)]"
  syntax:
    content: public static void RegisterWellKnownServiceType (Type type, string objectUri, System.Runtime.Remoting.WellKnownObjectMode mode);
    parameters:
    - id: type
      type: System.Type
      description: "<xref:System.Type>입니다.</xref:System.Type> 개체"
    - id: objectUri
      type: System.String
      description: "URI 개체입니다."
    - id: mode
      type: System.Runtime.Remoting.WellKnownObjectMode
      description: "등록 되는 잘 알려진 개체 유형의 정품 인증 모드입니다. (See <xref href=&quot;System.Runtime.Remoting.WellKnownObjectMode&quot;></xref>.)"
  overload: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "원격 형식 및 채널을 구성할 수 있는 권한을는 호출 스택의 상위 호출자 중 하나 이상 없습니다."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Runtime.Remoting.RemotingConfiguration.ApplicationId
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: ApplicationId
  nameWithType: RemotingConfiguration.ApplicationId
  fullName: System.Runtime.Remoting.RemotingConfiguration.ApplicationId
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Runtime.Remoting.RemotingConfiguration.ApplicationName
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: ApplicationName
  nameWithType: RemotingConfiguration.ApplicationName
  fullName: System.Runtime.Remoting.RemotingConfiguration.ApplicationName
- uid: System.Runtime.Remoting.RemotingConfiguration.Configure(System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: Configure(String)
  nameWithType: RemotingConfiguration.Configure(String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.Configure(String)
- uid: System.Runtime.Remoting.RemotingConfiguration.Configure(System.String,System.Boolean)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: Configure(String,Boolean)
  nameWithType: RemotingConfiguration.Configure(String,Boolean)
  fullName: System.Runtime.Remoting.RemotingConfiguration.Configure(String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled(System.Boolean)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: CustomErrorsEnabled(Boolean)
  nameWithType: RemotingConfiguration.CustomErrorsEnabled(Boolean)
  fullName: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled(Boolean)
- uid: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: CustomErrorsMode
  nameWithType: RemotingConfiguration.CustomErrorsMode
  fullName: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode
- uid: System.Runtime.Remoting.CustomErrorsModes
  parent: System.Runtime.Remoting
  isExternal: false
  name: CustomErrorsModes
  nameWithType: CustomErrorsModes
  fullName: System.Runtime.Remoting.CustomErrorsModes
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: GetRegisteredActivatedClientTypes()
  nameWithType: RemotingConfiguration.GetRegisteredActivatedClientTypes()
  fullName: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes()
- uid: System.Runtime.Remoting.ActivatedClientTypeEntry[]
  parent: System.Runtime.Remoting
  isExternal: false
  name: ActivatedClientTypeEntry
  nameWithType: ActivatedClientTypeEntry
  fullName: System.Runtime.Remoting.ActivatedClientTypeEntry[]
  spec.csharp:
  - uid: System.Runtime.Remoting.ActivatedClientTypeEntry
    name: ActivatedClientTypeEntry
    nameWithType: ActivatedClientTypeEntry
    fullName: ActivatedClientTypeEntry[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: GetRegisteredActivatedServiceTypes()
  nameWithType: RemotingConfiguration.GetRegisteredActivatedServiceTypes()
  fullName: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes()
- uid: System.Runtime.Remoting.ActivatedServiceTypeEntry[]
  parent: System.Runtime.Remoting
  isExternal: false
  name: ActivatedServiceTypeEntry
  nameWithType: ActivatedServiceTypeEntry
  fullName: System.Runtime.Remoting.ActivatedServiceTypeEntry[]
  spec.csharp:
  - uid: System.Runtime.Remoting.ActivatedServiceTypeEntry
    name: ActivatedServiceTypeEntry
    nameWithType: ActivatedServiceTypeEntry
    fullName: ActivatedServiceTypeEntry[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: GetRegisteredWellKnownClientTypes()
  nameWithType: RemotingConfiguration.GetRegisteredWellKnownClientTypes()
  fullName: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes()
- uid: System.Runtime.Remoting.WellKnownClientTypeEntry[]
  parent: System.Runtime.Remoting
  isExternal: false
  name: WellKnownClientTypeEntry
  nameWithType: WellKnownClientTypeEntry
  fullName: System.Runtime.Remoting.WellKnownClientTypeEntry[]
  spec.csharp:
  - uid: System.Runtime.Remoting.WellKnownClientTypeEntry
    name: WellKnownClientTypeEntry
    nameWithType: WellKnownClientTypeEntry
    fullName: WellKnownClientTypeEntry[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: GetRegisteredWellKnownServiceTypes()
  nameWithType: RemotingConfiguration.GetRegisteredWellKnownServiceTypes()
  fullName: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes()
- uid: System.Runtime.Remoting.WellKnownServiceTypeEntry[]
  parent: System.Runtime.Remoting
  isExternal: false
  name: WellKnownServiceTypeEntry
  nameWithType: WellKnownServiceTypeEntry
  fullName: System.Runtime.Remoting.WellKnownServiceTypeEntry[]
  spec.csharp:
  - uid: System.Runtime.Remoting.WellKnownServiceTypeEntry
    name: WellKnownServiceTypeEntry
    nameWithType: WellKnownServiceTypeEntry
    fullName: WellKnownServiceTypeEntry[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed(System.Type)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: IsActivationAllowed(Type)
  nameWithType: RemotingConfiguration.IsActivationAllowed(Type)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed(Type)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.Type)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: IsRemotelyActivatedClientType(Type)
  nameWithType: RemotingConfiguration.IsRemotelyActivatedClientType(Type)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(Type)
- uid: System.Runtime.Remoting.ActivatedClientTypeEntry
  parent: System.Runtime.Remoting
  isExternal: false
  name: ActivatedClientTypeEntry
  nameWithType: ActivatedClientTypeEntry
  fullName: System.Runtime.Remoting.ActivatedClientTypeEntry
- uid: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.String,System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: IsRemotelyActivatedClientType(String,String)
  nameWithType: RemotingConfiguration.IsRemotelyActivatedClientType(String,String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(String,String)
- uid: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.Type)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: IsWellKnownClientType(Type)
  nameWithType: RemotingConfiguration.IsWellKnownClientType(Type)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(Type)
- uid: System.Runtime.Remoting.WellKnownClientTypeEntry
  parent: System.Runtime.Remoting
  isExternal: false
  name: WellKnownClientTypeEntry
  nameWithType: WellKnownClientTypeEntry
  fullName: System.Runtime.Remoting.WellKnownClientTypeEntry
- uid: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.String,System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: IsWellKnownClientType(String,String)
  nameWithType: RemotingConfiguration.IsWellKnownClientType(String,String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(String,String)
- uid: System.Runtime.Remoting.RemotingConfiguration.ProcessId
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: ProcessId
  nameWithType: RemotingConfiguration.ProcessId
  fullName: System.Runtime.Remoting.RemotingConfiguration.ProcessId
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Runtime.Remoting.ActivatedClientTypeEntry)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterActivatedClientType(ActivatedClientTypeEntry)
  nameWithType: RemotingConfiguration.RegisterActivatedClientType(ActivatedClientTypeEntry)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(ActivatedClientTypeEntry)
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterActivatedClientType(Type,String)
  nameWithType: RemotingConfiguration.RegisterActivatedClientType(Type,String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(Type,String)
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Runtime.Remoting.ActivatedServiceTypeEntry)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterActivatedServiceType(ActivatedServiceTypeEntry)
  nameWithType: RemotingConfiguration.RegisterActivatedServiceType(ActivatedServiceTypeEntry)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(ActivatedServiceTypeEntry)
- uid: System.Runtime.Remoting.ActivatedServiceTypeEntry
  parent: System.Runtime.Remoting
  isExternal: false
  name: ActivatedServiceTypeEntry
  nameWithType: ActivatedServiceTypeEntry
  fullName: System.Runtime.Remoting.ActivatedServiceTypeEntry
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterActivatedServiceType(Type)
  nameWithType: RemotingConfiguration.RegisterActivatedServiceType(Type)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(Type)
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Runtime.Remoting.WellKnownClientTypeEntry)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterWellKnownClientType(WellKnownClientTypeEntry)
  nameWithType: RemotingConfiguration.RegisterWellKnownClientType(WellKnownClientTypeEntry)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(WellKnownClientTypeEntry)
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterWellKnownClientType(Type,String)
  nameWithType: RemotingConfiguration.RegisterWellKnownClientType(Type,String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(Type,String)
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Runtime.Remoting.WellKnownServiceTypeEntry)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterWellKnownServiceType(WellKnownServiceTypeEntry)
  nameWithType: RemotingConfiguration.RegisterWellKnownServiceType(WellKnownServiceTypeEntry)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(WellKnownServiceTypeEntry)
- uid: System.Runtime.Remoting.WellKnownServiceTypeEntry
  parent: System.Runtime.Remoting
  isExternal: false
  name: WellKnownServiceTypeEntry
  nameWithType: WellKnownServiceTypeEntry
  fullName: System.Runtime.Remoting.WellKnownServiceTypeEntry
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterWellKnownServiceType(Type,String,WellKnownObjectMode)
  nameWithType: RemotingConfiguration.RegisterWellKnownServiceType(Type,String,WellKnownObjectMode)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(Type,String,WellKnownObjectMode)
- uid: System.Runtime.Remoting.WellKnownObjectMode
  parent: System.Runtime.Remoting
  isExternal: false
  name: WellKnownObjectMode
  nameWithType: WellKnownObjectMode
  fullName: System.Runtime.Remoting.WellKnownObjectMode
- uid: System.Runtime.Remoting.RemotingConfiguration.ApplicationId*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: ApplicationId
  nameWithType: RemotingConfiguration.ApplicationId
- uid: System.Runtime.Remoting.RemotingConfiguration.ApplicationName*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: ApplicationName
  nameWithType: RemotingConfiguration.ApplicationName
- uid: System.Runtime.Remoting.RemotingConfiguration.Configure*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: Configure
  nameWithType: RemotingConfiguration.Configure
- uid: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: CustomErrorsEnabled
  nameWithType: RemotingConfiguration.CustomErrorsEnabled
- uid: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: CustomErrorsMode
  nameWithType: RemotingConfiguration.CustomErrorsMode
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: GetRegisteredActivatedClientTypes
  nameWithType: RemotingConfiguration.GetRegisteredActivatedClientTypes
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: GetRegisteredActivatedServiceTypes
  nameWithType: RemotingConfiguration.GetRegisteredActivatedServiceTypes
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: GetRegisteredWellKnownClientTypes
  nameWithType: RemotingConfiguration.GetRegisteredWellKnownClientTypes
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: GetRegisteredWellKnownServiceTypes
  nameWithType: RemotingConfiguration.GetRegisteredWellKnownServiceTypes
- uid: System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: IsActivationAllowed
  nameWithType: RemotingConfiguration.IsActivationAllowed
- uid: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: IsRemotelyActivatedClientType
  nameWithType: RemotingConfiguration.IsRemotelyActivatedClientType
- uid: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: IsWellKnownClientType
  nameWithType: RemotingConfiguration.IsWellKnownClientType
- uid: System.Runtime.Remoting.RemotingConfiguration.ProcessId*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: ProcessId
  nameWithType: RemotingConfiguration.ProcessId
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterActivatedClientType
  nameWithType: RemotingConfiguration.RegisterActivatedClientType
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterActivatedServiceType
  nameWithType: RemotingConfiguration.RegisterActivatedServiceType
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterWellKnownClientType
  nameWithType: RemotingConfiguration.RegisterWellKnownClientType
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterWellKnownServiceType
  nameWithType: RemotingConfiguration.RegisterWellKnownServiceType
