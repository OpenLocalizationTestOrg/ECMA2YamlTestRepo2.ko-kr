### YamlMime:ManagedReference
items:
- uid: System.Windows.Automation.Text.TextPatternRange
  id: TextPatternRange
  children:
  - System.Windows.Automation.Text.TextPatternRange.AddToSelection
  - System.Windows.Automation.Text.TextPatternRange.Clone
  - System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)
  - System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  - System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  - System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  - System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)
  - System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  - System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles
  - System.Windows.Automation.Text.TextPatternRange.GetChildren
  - System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement
  - System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)
  - System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  - System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  - System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  - System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection
  - System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)
  - System.Windows.Automation.Text.TextPatternRange.Select
  - System.Windows.Automation.Text.TextPatternRange.TextPattern
  langs:
  - csharp
  name: TextPatternRange
  nameWithType: TextPatternRange
  fullName: System.Windows.Automation.Text.TextPatternRange
  type: Class
  summary: "연속 된 텍스트의 범위를 나타냅니다는 <xref href=&quot;System.Windows.Automation.TextPattern&quot;> </xref> 컨테이너입니다."
  remarks: "삽입 지점 하위 집합 또는 모두에 있는 텍스트의 한 TextPatternRange를 나타낼 수 있습니다는 <xref:System.Windows.Automation.TextPattern>컨테이너.</xref:System.Windows.Automation.TextPattern>       TextPatternRange 다음 중 하나가 발생 하는 경우에 유효 하지 않게 됩니다:의 텍스트는 <xref:System.Windows.Automation.TextPattern>사용자 작업으로 인해 또는 <xref:System.Windows.Automation.ValuePattern.SetValue%2A>방식의 <xref:System.Windows.Automation.ValuePattern>프로그래밍 방식으로 텍스트의 값을 변경 하는 데 사용 되는 <xref:System.Windows.Automation.TextPattern>컨테이너.</xref:System.Windows.Automation.TextPattern> </xref:System.Windows.Automation.ValuePattern> </xref:System.Windows.Automation.ValuePattern.SetValue%2A> </xref:System.Windows.Automation.TextPattern>"
  syntax:
    content: public class TextPatternRange
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.AddToSelection
  id: AddToSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: AddToSelection()
  nameWithType: TextPatternRange.AddToSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.AddToSelection()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "추가 선택 서로 분리 된 여러를 지 원하는 텍스트 컨테이너의 강조 표시 된 텍스트 컬렉션에 있습니다."
  remarks: "새 선택의 영역에 텍스트 삽입 지점 이동합니다.       삽입 지점이 이동 디 제너 레이트 텍스트 범위를 제공 합니다."
  syntax:
    content: public void AddToSelection ();
    parameters: []
  overload: System.Windows.Automation.Text.TextPatternRange.AddToSelection*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "텍스트 공급자는 여러를 지원 하지 않는 경우 선택 항목을 서로 분리 된 (예를 들어 <xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>의 값이 있어야 <xref uid=&quot;langword_csharp_Multiple&quot; name=&quot;Multiple&quot; href=&quot;&quot;> </xref>).</xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Clone
  id: Clone
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Clone()
  nameWithType: TextPatternRange.Clone()
  fullName: System.Windows.Automation.Text.TextPatternRange.Clone()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "새 검색 <xref href=&quot;System.Windows.Automation.Text.TextPatternRange&quot;> </xref> 원본과 동일 <xref href=&quot;System.Windows.Automation.Text.TextPatternRange&quot;> </xref> 및 모든 속성을 상속 합니다."
  remarks: "또는 새를 만들 <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>에서 <xref:System.Windows.Automation.TextPattern>원래 텍스트 범위 끝점에 해당 하는 두 개의 끝점을 이동 합니다.</xref:System.Windows.Automation.TextPattern> </xref:System.Windows.Automation.TextPattern.DocumentRange%2A>       새 범위를에서 독립적으로 조작할 수 있습니다."
  example:
  - "[!code-cs[UIATextPattern_snip#1060](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1060)]  \n  \n [!code-vb[UIATextPattern_snip#2060](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2060)]"
  syntax:
    content: public System.Windows.Automation.Text.TextPatternRange Clone ();
    parameters: []
    return:
      type: System.Windows.Automation.Text.TextPatternRange
      description: "새 텍스트 범위입니다. Null 참조 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> 에 [!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)])는 반환 되지 않습니다."
  overload: System.Windows.Automation.Text.TextPatternRange.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)
  id: Compare(System.Windows.Automation.Text.TextPatternRange)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Compare(TextPatternRange)
  nameWithType: TextPatternRange.Compare(TextPatternRange)
  fullName: System.Windows.Automation.Text.TextPatternRange.Compare(TextPatternRange)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "반환은 <xref:System.Boolean>나타내는 값 여부 범위 (의 <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> 끝점을는 <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> 끝점) 범위는 다른 텍스트 범위와 동일한 텍스트.</xref:System.Boolean>"
  remarks: ''
  example:
  - "[!code-cs[UIATextPattern_snip#1061](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1061)]  \n  \n [!code-vb[UIATextPattern_snip#2061](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2061)]"
  syntax:
    content: public bool Compare (System.Windows.Automation.Text.TextPatternRange range);
    parameters:
    - id: range
      type: System.Windows.Automation.Text.TextPatternRange
      description: "비교할 텍스트 범위입니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>두 텍스트 범위가;와 같은 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.Automation.Text.TextPatternRange.Compare*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "범위와 비교 되는 경우 같은 텍스트 공급자에서 제공 되지 않습니다."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  id: CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "반환 된 <xref:System.Int32>두 텍스트 범위의 끝점이 동일한 지 여부를 나타내는.</xref:System.Int32>"
  remarks: "시작 및 끝 끝점을 동일한 텍스트 범위를 비교 하 여 텍스트 범위는 중복 제거 하거나 끝점 논리 텍스트 방향 순서 대로 경우를 식별할 수 있습니다."
  example:
  - "[!code-cs[UIATextPattern_snip#1062](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1062)]  \n  \n [!code-vb[UIATextPattern_snip#2062](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2062)]"
  syntax:
    content: public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);
    parameters:
    - id: endpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> 또는 <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> 호출자의 끝점입니다."
    - id: targetRange
      type: System.Windows.Automation.Text.TextPatternRange
      description: "비교에 대 한 대상 범위입니다."
    - id: targetEndpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> 또는 <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> 대상의 끝점입니다."
    return:
      type: System.Int32
      description: "호출자의 끝점이 대상 끝점 보다 텍스트의 앞부분에 나오는 발생 하는 경우 음수 값을 반환 합니다.       호출자의 끝점이 대상 끝점과 같은 위치에 있으면&0;을 반환 합니다.       호출자의 끝점이 대상 끝점 보다 텍스트에 나중에 나타나면 양수 값을 반환 합니다."
  overload: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "범위가 null 참조 이면 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> 에 [!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)])."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "범위를 다른 컨테이너에서 경우."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  id: ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: ExpandToEnclosingUnit(TextUnit)
  nameWithType: TextPatternRange.ExpandToEnclosingUnit(TextUnit)
  fullName: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(TextUnit)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "지정 된 텍스트 범위 확장 <xref href=&quot;System.Windows.Automation.Text.TextUnit&quot;> </xref>합니다."
  remarks: "범위 지정된 단위는 정확한 수량 이미 있으면 다음 변경 되지 않습니다.       ExpandToEnclosingUnit 메서드를 성공적으로 실행 되려면, 일련의 동작 원리를 자세히 파악할수록 수행 됩니다.      1.  텍스트 범위가 정규화 됩니다. 텍스트 범위에서 중복 제거 범위로 축소 되어, 즉는 <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>끝점을 만드는 <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>끝점이 불필요 해 집니다.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> 이 단계는 텍스트 범위에 걸쳐 있는 경우 모호성을 제거 하는 데 필요한 `unit` 경계; 예를 들어 &quot;{The U} RL [http://www.microsoft.com](http://www.microsoft.com) 텍스트에 포함 된&quot; 위치 &quot;{&quot; 및 &quot;}&quot;는 텍스트 범위 끝점입니다.      2.  결과 범위가 뒤로 이동는 <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>요청한의 시작 부분에 `unit` 경계.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      3.  범위에서 앞 이나 뒤로 이동 되는 <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>요청 된 수 만큼 `unit` 경계.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      4.  이동 하 여 중복 제거 범위 상태이 던 범위가 확장 한 다음 됩니다는 <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>요청 된 끝점 `unit` 경계.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>       ![이동 / / ExpandToEnclosingUnit으로 범위 조정](~/add/media/uia-textpattern-moveandexpand-examples.png &quot;이동 / / ExpandToEnclosingUnit으로 범위 조정&quot;) move () 및 ExpandToEnclosingUnit() 텍스트 범위가 조정 되는 방법의 예 > [!NOTE] >는 전체 단어, 문장 또는 삽입 지점 또는 가상 커서 위치에서 전체 단락 읽으므로 화면 판독기에 대 한 일반적이 단계는 필요 합니다.       ExpandToEnclosingUnit는 숨겨진 / 표시 텍스트를 존중 합니다. UI 자동화 클라이언트가 확인할 수는 <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>텍스트 표시 여부에 대 한.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>       ExpandToEnclosingUnit 단위는 다음 가장 큰 <xref:System.Windows.Automation.Text.TextUnit>지원 되는 경우에는 주어진 <xref:System.Windows.Automation.Text.TextUnit>컨트롤에서 지원 되지 않습니다.</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>       최소 단위에서 가장 큰, 순서, 아래에 나열 됩니다.      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit>"
  example:
  - "[!code-cs[UIATextPattern_snip#1063](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1063)]  \n  \n [!code-vb[UIATextPattern_snip#2063](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2063)]"
  syntax:
    content: public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);
    parameters:
    - id: unit
      type: System.Windows.Automation.Text.TextUnit
      description: "텍스트 단위입니다."
  overload: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  id: FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: FindAttribute(AutomationTextAttribute,Object,Boolean)
  nameWithType: TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "지정 된 특성 값을 갖는 텍스트 범위 하위 집합을 반환 합니다."
  remarks: "숨겨진 / 표시 텍스트 구분 되지 않습니다. UI 자동화 클라이언트 צ ְ ײ <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>텍스트 표시 여부를 확인 하려면.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>      > [!NOTE] > 사용 <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>전체 문서를 검색 하려면.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>"
  example:
  - "[!code-cs[UIATextPattern_snip#1064](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1064)]  \n  \n [!code-vb[UIATextPattern_snip#2064](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2064)]"
  syntax:
    content: public System.Windows.Automation.Text.TextPatternRange FindAttribute (System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward);
    parameters:
    - id: attribute
      type: System.Windows.Automation.AutomationTextAttribute
      description: "검색할 특성입니다."
    - id: value
      type: System.Object
      description: "검색할 특성 값입니다. 이 값은 특성에 대해 지정 된 형식과 일치 해야 합니다."
    - id: backward
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>첫 번째; 마지막으로 나타나는 텍스트 범위를 반환 해야 하는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
    return:
      type: System.Windows.Automation.Text.TextPatternRange
      description: "일치 하는 특성 및 특성 값 텍스트 범위 없으면 null (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> 에 [!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)])."
  overload: System.Windows.Automation.Text.TextPatternRange.FindAttribute*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)
  id: FindText(System.String,System.Boolean,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: FindText(String,Boolean,Boolean)
  nameWithType: TextPatternRange.FindText(String,Boolean,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindText(String,Boolean,Boolean)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "지정된 된 텍스트를 포함 하는 텍스트 범위 하위 집합을 반환 합니다."
  remarks: "숨겨진 / 표시 텍스트 구분 되지 않습니다. UI 자동화 클라이언트 צ ְ ײ <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>텍스트 표시 여부를 확인 하려면.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>      > [!NOTE] > 사용 <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>전체 문서를 검색 하려면.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>"
  example:
  - "[!code-cs[UIATextPattern_snip#1065](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1065)]  \n  \n [!code-vb[UIATextPattern_snip#2065](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2065)]"
  syntax:
    content: public System.Windows.Automation.Text.TextPatternRange FindText (string text, bool backward, bool ignoreCase);
    parameters:
    - id: text
      type: System.String
      description: "검색할 텍스트 문자열입니다."
    - id: backward
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>첫 번째; 마지막으로 나타나는 텍스트 범위를 반환 해야 하는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
    - id: ignoreCase
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>대/소문자를 구분 하지 않으면 하는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
    return:
      type: System.Windows.Automation.Text.TextPatternRange
      description: "지정된 된 텍스트와 일치 하는 텍스트 범위 없으면 null (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> 에 [!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)])."
  overload: System.Windows.Automation.Text.TextPatternRange.FindText*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  id: GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetAttributeValue(AutomationTextAttribute)
  nameWithType: TextPatternRange.GetAttributeValue(AutomationTextAttribute)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(AutomationTextAttribute)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "전체 텍스트 범위에서 지정된 된 특성의 값을 반환합니다."
  remarks: "숨겨진 / 표시 텍스트 구분 되지 않습니다. UI 자동화 클라이언트 צ ְ ײ <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>텍스트 표시 여부를 확인 하려면.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>"
  example:
  - "[!code-cs[UIATextPattern_snip#1066](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1066)]  \n  \n [!code-vb[UIATextPattern_snip#2066](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2066)]"
  syntax:
    content: public object GetAttributeValue (System.Windows.Automation.AutomationTextAttribute attribute);
    parameters:
    - id: attribute
      type: System.Windows.Automation.AutomationTextAttribute
      description: "텍스트 특성입니다."
    return:
      type: System.Object
      description: "지정된 된 특성의 값을 반환합니다. 예를 들어 GetAttributeValue(TextPattern.FontNameAttribute)는 부울 값을 반환 글꼴이 하나만 사용 되는 동안 텍스트 범위에 고유한 경우 글꼴 이름을 나타내는 문자열을 반환 합니다.       반환 <xref href=&quot;System.Windows.Automation.TextPattern.MixedAttributeValue&quot;> </xref> 경우 텍스트 범위에서 지정된 된 특성의 값에 따라 다릅니다.       반환 <xref href=&quot;System.Windows.Automation.AutomationElement.NotSupported&quot;> </xref> 경우 지정된 된 특성의 공급자 또는 컨트롤에서 지원 되지 않습니다."
  overload: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "지정 된 특성이 올바르지 않으면 합니다."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles
  id: GetBoundingRectangles
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetBoundingRectangles()
  nameWithType: TextPatternRange.GetBoundingRectangles()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "완전히 또는 부분적으로 표시 각 줄 텍스트 범위에서 텍스트의 경계 사각형의 컬렉션을 검색 합니다."
  remarks: ''
  example:
  - "[!code-cs[UIATextPattern_snip#1067](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1067)]  \n  \n [!code-vb[UIATextPattern_snip#2067](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2067)]"
  syntax:
    content: public System.Windows.Rect[] GetBoundingRectangles ();
    parameters: []
    return:
      type: System.Windows.Rect[]
      description: "각 전체 또는 부분 줄 텍스트 범위에서 텍스트의 경계 사각형의 배열입니다.       디 제너 레이트 텍스트 범위에 대 한 빈 배열입니다.       빈 배열을 텍스트 범위의 화면 좌표가 화면에서 완전히 벗어나거나, 스크롤되어 하거나 겹치는 창으로 가려진 합니다."
  overload: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetChildren
  id: GetChildren
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetChildren()
  nameWithType: TextPatternRange.GetChildren()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetChildren()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "텍스트 범위 안에 있는 모든 포함 된 개체의 컬렉션을 검색 합니다."
  remarks: ''
  example:
  - "[!code-vb[UIATextPattern_snip#StartTarget](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#starttarget)]\n [!code-cs[UIATextPattern_snip#StartTarget](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#starttarget)]  \n[!code-vb[UIATextPattern_snip#GetTextElement](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#gettextelement)]\n[!code-cs[UIATextPattern_snip#GetTextElement](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#gettextelement)]  \n[!code-vb[UIATextPattern_snip#GetEmbeddedObjects](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#getembeddedobjects)]\n[!code-cs[UIATextPattern_snip#GetEmbeddedObjects](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#getembeddedobjects)]"
  syntax:
    content: public System.Windows.Automation.AutomationElement[] GetChildren ();
    parameters: []
    return:
      type: System.Windows.Automation.AutomationElement[]
      description: "범위 안에 있는 모든 자식 개체의 컬렉션입니다. 범위와 겹치지만 완전히 포함 되지 않는 자식 개체 컬렉션에도 포함 됩니다.       자식 개체가 없으면 빈 컬렉션을 반환 합니다."
  overload: System.Windows.Automation.Text.TextPatternRange.GetChildren*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement
  id: GetEnclosingElement
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetEnclosingElement()
  nameWithType: TextPatternRange.GetEnclosingElement()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "가장 안쪽 함수가 반환 <xref href=&quot;System.Windows.Automation.AutomationElement&quot;> </xref> 하는 텍스트 범위를 포함 합니다."
  remarks: "묶는 <xref:System.Windows.Automation.AutomationElement>, 일반적으로 텍스트 범위를 제공 하는 텍스트 공급자입니다.</xref:System.Windows.Automation.AutomationElement> 그러나 텍스트 공급자에서 테이블 또는 하이퍼링크와 같은 자식 요소를 지 원하는 경우 다음 바깥쪽 요소 수는 텍스트 공급자의 하위 항목이 있습니다."
  example:
  - "[!code-cs[UIATextPattern_snip#1069](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1069)]  \n  \n [!code-vb[UIATextPattern_snip#2069](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2069)]"
  syntax:
    content: public System.Windows.Automation.AutomationElement GetEnclosingElement ();
    parameters: []
    return:
      type: System.Windows.Automation.AutomationElement
      description: "호출자를 포함 하는 가장 안쪽의 요소입니다."
  overload: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)
  id: GetText(System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetText(Int32)
  nameWithType: TextPatternRange.GetText(Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetText(Int32)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "텍스트 범위의 일반 텍스트를 반환합니다."
  remarks: "GetText는 숨겨진 / 표시 텍스트를 존중 합니다. UI 자동화 클라이언트가 확인할 수는 <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>텍스트 표시 여부에 대 한.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>       경우 `maxLength` 길이 보다 크면 호출자의 텍스트 범위를 반환 하는 문자열 텍스트 범위의 일반 텍스트 됩니다.       GetText은 텍스트 방향;에서 끝점 순서에 의해 적용 되지 않습니다. 논리적 텍스트 흐름 순서로 텍스트 범위의 시작 및 끝 끝점 사이의 텍스트 항상 반환 합니다."
  example:
  - "[!code-cs[UIATextPattern_snip#1070](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1070)]  \n  \n [!code-vb[UIATextPattern_snip#2070](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2070)]"
  syntax:
    content: public string GetText (int maxLength);
    parameters:
    - id: maxLength
      type: System.Int32
      description: "반환할 문자열의 최대 길이입니다. 사용 하 여 `-1` 제한이 필요한 경우."
    return:
      type: System.String
      description: "문자열이 지정 된 텍스트 범위의 일반 텍스트 <code> maxLength </code>합니다."
  overload: System.Windows.Automation.Text.TextPatternRange.GetText*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "경우 <code> maxLength </code> -1 보다 작습니다."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  id: Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Move(TextUnit,Int32)
  nameWithType: TextPatternRange.Move(TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.Move(TextUnit,Int32)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "텍스트 범위의 지정 된 텍스트 단위 수를 이동합니다."
  remarks: "텍스트 범위의 내용을 이동 해야 하는 Move 메서드를 성공적으로 실행 되려면 백그라운드 일련의 단계를 거쳐야 합니다.      1.  텍스트 범위가 정규화 됩니다. 텍스트 범위에서 중복 제거 범위로 축소 되어, 즉는 <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>끝점은 <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>끝점이 불필요 해 집니다.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> 이 단계는 텍스트 범위에 걸쳐 있는 경우 모호성을 제거 하는 데 필요한 `unit` 경계; 예를 들어 &quot;{The U} RL [http://www.microsoft.com](http://www.microsoft.com) 텍스트에 포함 된&quot; 위치 &quot;{&quot; 및 &quot;}&quot;는 텍스트 범위 끝점입니다.      2.  결과 범위가 뒤로 이동는 <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>요청한의 시작 부분에 `unit` 경계.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      3.  범위에서 앞 이나 뒤로 이동 되는 <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>요청 된 수 만큼 `unit` 경계.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      4.  이동 하 여 중복 제거 범위 상태이 던 범위가 확장 한 다음 됩니다는 <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>요청 된 끝점 `unit` 경계.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>       ![이동 / / ExpandToEnclosingUnit으로 범위 조정](~/add/media/uia-textpattern-moveandexpand-examples.png &quot;이동 / / ExpandToEnclosingUnit으로 범위 조정&quot;) move () 및 ExpandToEnclosingUnit() 텍스트 내용 (또는 내부 텍스트)의 텍스트 컨테이너 및 포함 된 개체, 예: 하이퍼링크 또는 테이블 셀에 대 한 텍스트 범위가 조정 되는 방법의 예는 컨트롤 뷰 및 콘텐츠 뷰 모두에서 지속적인 단일 텍스트 스트림으로 노출 되는 [!INCLUDE[TLA2#tla_uiautomation](~/add/includes/tla2sharptla-uiautomation-md.md)] 트리; 개체 경계는 무시 됩니다. UI 자동화 클라이언트가 낭독, 해석 또는 다른 방법으로 분석 하기 위해 텍스트를 검색 하는 경우 텍스트 내용이 나 기타 포함 된 개체가 있는 테이블과 같이 특수 한 경우에는 텍스트 범위를 확인 해야 합니다. 이 호출 하 여 수행할 수 있습니다 <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>가져올 수는 <xref:System.Windows.Automation.AutomationElement>각 포함 된 개체 호출 다음에 대 한 <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A>각 요소에 대 한 텍스트 범위를 가져오려면이 모든 텍스트 내용이 검색 될 때까지 반복적으로 수행 됩니다.</xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> </xref:System.Windows.Automation.AutomationElement> </xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>       ![포함 된 개체에 포함 되는 텍스트 범위입니다. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png &quot;포함 된 개체에 포함 되는 텍스트 범위입니다.&quot;)   포함 된 개체와 해당 범위의 있는 텍스트 스트림과 예 이동 측면 모두 숨겨진 및 표시 되는 텍스트를 포함 합니다. UI 자동화 클라이언트가 확인할 수는 <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>텍스트 표시 여부에 대 한.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>       이동 단위는 다음 가장 큰 <xref:System.Windows.Automation.Text.TextUnit>지원 되는 경우에는 주어진 <xref:System.Windows.Automation.Text.TextUnit>컨트롤에서 지원 되지 않습니다.</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>       최소 단위에서 가장 큰, 순서, 아래에 나열 됩니다.      - <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>> [!NOTE] > 텍스트 범위는 텍스트의 다른 부분에만 걸쳐으로 텍스트는 전혀 변경 되지 않습니다.</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>"
  example:
  - "[!code-vb[UIATextPattern_snip#StartTarget](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#starttarget)]\n [!code-cs[UIATextPattern_snip#StartTarget](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#starttarget)]  \n[!code-vb[UIATextPattern_snip#GetTextElement](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#gettextelement)]\n[!code-cs[UIATextPattern_snip#GetTextElement](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#gettextelement)]  \n[!code-vb[UIATextPattern_snip#MoveSelection](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#moveselection)]\n[!code-cs[UIATextPattern_snip#MoveSelection](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#moveselection)]"
  syntax:
    content: public int Move (System.Windows.Automation.Text.TextUnit unit, int count);
    parameters:
    - id: unit
      type: System.Windows.Automation.Text.TextUnit
      description: "텍스트 단위 경계입니다."
    - id: count
      type: System.Int32
      description: "이동할 텍스트 단위 수입니다. 양수 값을 텍스트 범위를 앞으로 이동 하 고 음수 값을 이동 하면 텍스트 범위가 뒤로, 0은 효과가 없습니다."
    return:
      type: System.Int32
      description: "실제로 이동한 단위 수입니다. 이 새 텍스트 범위의 끝점 중 하나는 보다 크거나 작은 경우 요청 된 수보다 작을 수 보다는 <xref:System.Windows.Automation.TextPattern.DocumentRange*>끝점.</xref:System.Windows.Automation.TextPattern.DocumentRange*>"
  overload: System.Windows.Automation.Text.TextPatternRange.Move*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  id: MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "텍스트 범위의 한 끝점을 두 번째 텍스트 범위의 지정된 된 끝점으로 이동합니다."
  remarks: "이동 하는 끝점이 동일한 텍스트 범위에 다른 끝점을 교차 경우 다른 끝점도 이동 하는 중복 제거 범위에서 확장 하 고 끝점의 순서가 올바르게 (즉, <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>항상 보다 작거나 같음 <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>).</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>"
  example:
  - "[!code-cs[UIATextPattern_snip#1072](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1072)]  \n  \n [!code-vb[UIATextPattern_snip#2072](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2072)]"
  syntax:
    content: public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);
    parameters:
    - id: endpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "이동할 끝점입니다."
    - id: targetRange
      type: System.Windows.Automation.Text.TextPatternRange
      description: "같은 텍스트 공급자의 다른 범위입니다."
    - id: targetEndpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "다른 범위의 끝점입니다."
  overload: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  id: MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  nameWithType: TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "한 끝점에서 텍스트의 범위 지정된 된 수의 이동 <xref href=&quot;System.Windows.Automation.Text.TextUnit&quot;> </xref>문서 범위 내에서."
  remarks: "텍스트 범위의 내용을 이동 해야 하는 백그라운드에서 순서에 대 한 일련의 단계를 거쳐야는 <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A>메서드를 실행 합니다.</xref:System.Windows.Automation.Text.TextPatternRange.Move%2A>      1.  텍스트 범위가 정규화 됩니다. 텍스트 범위에서 중복 제거 범위로 축소 되어, 즉는 <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>끝점은 <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>끝점이 불필요 해 집니다.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> 이 단계는 텍스트 범위에 걸쳐 있는 경우 모호성을 제거 하는 데 필요한 `unit` 경계; 예를 들어 &quot;{The U} RL [http://www.microsoft.com](http://www.microsoft.com) 텍스트에 포함 된&quot; 위치 &quot;{&quot; 및 &quot;}&quot;는 텍스트 범위 끝점입니다.      2.  결과 범위가 뒤로 이동는 <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>요청한의 시작 부분에 `unit` 경계.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      3.  이동 하 여 중복 제거 범위 상태이 던 범위가 확장 한 다음 됩니다는 <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>요청 된 끝점 `unit` 경계.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>       ![이동 / / ExpandToEnclosingUnit으로 범위 조정](~/add/media/uia-textpattern-moveandexpand-examples.png &quot;이동 / / ExpandToEnclosingUnit으로 범위 조정&quot;) move () 및 ExpandToEnclosingUnit() 텍스트 내용 (또는 내부 텍스트)의 텍스트 컨테이너 및 포함 된 개체, 예: 하이퍼링크 또는 테이블 셀에 대 한 텍스트 범위가 조정 되는 방법의 예는 컨트롤 뷰 및 콘텐츠 뷰 모두에서 지속적인 단일 텍스트 스트림으로 노출 되는 [!INCLUDE[TLA2#tla_uiautomation](~/add/includes/tla2sharptla-uiautomation-md.md)] 트리; 개체 경계는 무시 됩니다. UI 자동화 클라이언트가 낭독, 해석 또는 다른 방법으로 분석 하기 위해 텍스트를 검색 하는 경우 텍스트 내용이 나 기타 포함 된 개체가 있는 테이블과 같이 특수 한 경우에는 텍스트 범위를 확인 해야 합니다. 이 호출 하 여 수행할 수 있습니다 <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>가져올 수는 <xref:System.Windows.Automation.AutomationElement>각 포함 된 개체 호출 다음에 대 한 <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A>각 요소에 대 한 텍스트 범위를 가져오려면이 모든 텍스트 내용이 검색 될 때까지 반복적으로 수행 됩니다.</xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> </xref:System.Windows.Automation.AutomationElement> </xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>       ![포함 된 개체에 포함 되는 텍스트 범위입니다. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png &quot;포함 된 개체에 포함 되는 텍스트 범위입니다.&quot;)   포함 된 개체와 해당 범위의 MoveEndpointByUnit 단위는 다음 텍스트 스트림과 예 가장 큰 <xref:System.Windows.Automation.Text.TextUnit>지원 되는 지정 된 <xref:System.Windows.Automation.Text.TextUnit>컨트롤에서 지원 되지 않습니다.</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>       최소 단위에서 가장 큰, 순서, 아래에 나열 됩니다.      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit>"
  example:
  - "[!code-cs[UIATextPattern_snip#1073](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1073)]  \n  \n [!code-vb[UIATextPattern_snip#2073](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2073)]"
  syntax:
    content: public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);
    parameters:
    - id: endpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "이동할 끝점입니다."
    - id: unit
      type: System.Windows.Automation.Text.TextUnit
      description: "이동할 텍스트 단위입니다."
    - id: count
      type: System.Int32
      description: "이동할 단위 수입니다. 양수에는 끝점이 앞으로 이동 합니다. 음수 개수 뒤로 이동합니다. 0에는 영향이 없습니다."
    return:
      type: System.Int32
      description: "실제로 이동한 단위 수 이며 수 면 요청 된 수보다 작을 이동 하면서 수 시작 이나 끝 문서의으로 끝점 실행 합니다."
  overload: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection
  id: RemoveFromSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: RemoveFromSelection()
  nameWithType: TextPatternRange.RemoveFromSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "영역을 호출 하는 텍스트 범위에 해당 하는 텍스트의 <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> 및 <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> 끝점에서 지 원하는 여러 텍스트 컨테이너의 강조 표시 된 텍스트의 기존 컬렉션에서 선택 항목 서로 분리 합니다."
  remarks: "텍스트 삽입 지점 제거 강조 표시 영역으로 이동 합니다.       디 제너 레이트 텍스트 범위를 제공 하는 삽입 지점을 이동 합니다."
  syntax:
    content: public void RemoveFromSelection ();
    parameters: []
  overload: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "텍스트 공급자는 여러를 지원 하지 않는 경우 선택 항목을 서로 분리 된 (예를 들어 <xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>의 값이 있어야 <xref uid=&quot;langword_csharp_Multiple&quot; name=&quot;Multiple&quot; href=&quot;&quot;> </xref>).</xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)
  id: ScrollIntoView(System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: ScrollIntoView(Boolean)
  nameWithType: TextPatternRange.ScrollIntoView(Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(Boolean)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "텍스트 컨트롤이 텍스트 범위 뷰포트에 표시 될 때까지 세로로 스크롤합니다."
  remarks: "ScrollIntoView는 숨겨진 / 표시 텍스트를 존중 합니다. UI 자동화 클라이언트가 확인할 수는 <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>텍스트 표시 여부에 대 한.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> 텍스트 범위를 숨길 경우에 텍스트 컨트롤은 숨겨진된 텍스트 뷰포트에 앵커를 포함 하는 경우에 스크롤됩니다."
  example:
  - "[!code-cs[UIATextPattern_snip#1074](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1074)]  \n  \n [!code-vb[UIATextPattern_snip#2074](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2074)]"
  syntax:
    content: public void ScrollIntoView (bool alignToTop);
    parameters:
    - id: alignToTop
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>텍스트 컨트롤 스크롤하여 뷰포트 맨 위에 텍스트 범위는 경우 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 뷰포트 맨 아래에 맞추려면 해야 합니다."
  overload: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "경우 스크롤 컨트롤에서 지원 되지 않습니다."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Select
  id: Select
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Select()
  nameWithType: TextPatternRange.Select()
  fullName: System.Windows.Automation.Text.TextPatternRange.Select()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "텍스트 범위에 해당 하는 텍스트 컨트롤에 텍스트를 강조 표시 <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> 및 <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> 끝점입니다."
  remarks: "디 제너 레이트 텍스트 범위를 제공 하는 경우에 텍스트 삽입 지점에서 이동 하 여 <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>텍스트 범위의 끝점입니다.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>"
  example:
  - "[!code-cs[UIATextPattern_snip#1075](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1075)]  \n  \n [!code-vb[UIATextPattern_snip#2075](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2075)]"
  syntax:
    content: public void Select ();
    parameters: []
  overload: System.Windows.Automation.Text.TextPatternRange.Select*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "텍스트 컨트롤에서 텍스트 선택이 지원 되지 않는 경우 발생 합니다."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.TextPattern
  id: TextPattern
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: TextPattern
  nameWithType: TextPatternRange.TextPattern
  fullName: System.Windows.Automation.Text.TextPatternRange.TextPattern
  type: Property
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "가져옵니다는 <xref href=&quot;System.Windows.Automation.TextPattern&quot;> </xref> 텍스트 범위와 연결 합니다."
  remarks: ''
  example:
  - "[!code-cs[UIATextPattern_snip#1076](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1076)]  \n  \n [!code-vb[UIATextPattern_snip#2076](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2076)]"
  syntax:
    content: public System.Windows.Automation.TextPattern TextPattern { get; }
    return:
      type: System.Windows.Automation.TextPattern
      description: "텍스트 공급자입니다."
  overload: System.Windows.Automation.Text.TextPatternRange.TextPattern*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Windows.Automation.Text.TextPatternRange.AddToSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: AddToSelection()
  nameWithType: TextPatternRange.AddToSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.AddToSelection()
- uid: System.Windows.Automation.Text.TextPatternRange.Clone
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Clone()
  nameWithType: TextPatternRange.Clone()
  fullName: System.Windows.Automation.Text.TextPatternRange.Clone()
- uid: System.Windows.Automation.Text.TextPatternRange
  parent: System.Windows.Automation.Text
  isExternal: false
  name: TextPatternRange
  nameWithType: TextPatternRange
  fullName: System.Windows.Automation.Text.TextPatternRange
- uid: System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Compare(TextPatternRange)
  nameWithType: TextPatternRange.Compare(TextPatternRange)
  fullName: System.Windows.Automation.Text.TextPatternRange.Compare(TextPatternRange)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Automation.Text.TextPatternRangeEndpoint
  parent: System.Windows.Automation.Text
  isExternal: false
  name: TextPatternRangeEndpoint
  nameWithType: TextPatternRangeEndpoint
  fullName: System.Windows.Automation.Text.TextPatternRangeEndpoint
- uid: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ExpandToEnclosingUnit(TextUnit)
  nameWithType: TextPatternRange.ExpandToEnclosingUnit(TextUnit)
  fullName: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(TextUnit)
- uid: System.Windows.Automation.Text.TextUnit
  parent: System.Windows.Automation.Text
  isExternal: false
  name: TextUnit
  nameWithType: TextUnit
  fullName: System.Windows.Automation.Text.TextUnit
- uid: System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindAttribute(AutomationTextAttribute,Object,Boolean)
  nameWithType: TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
- uid: System.Windows.Automation.AutomationTextAttribute
  parent: System.Windows.Automation
  isExternal: false
  name: AutomationTextAttribute
  nameWithType: AutomationTextAttribute
  fullName: System.Windows.Automation.AutomationTextAttribute
- uid: System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindText(String,Boolean,Boolean)
  nameWithType: TextPatternRange.FindText(String,Boolean,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindText(String,Boolean,Boolean)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetAttributeValue(AutomationTextAttribute)
  nameWithType: TextPatternRange.GetAttributeValue(AutomationTextAttribute)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(AutomationTextAttribute)
- uid: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetBoundingRectangles()
  nameWithType: TextPatternRange.GetBoundingRectangles()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles()
- uid: System.Windows.Rect[]
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect[]
  spec.csharp:
  - uid: System.Windows.Rect
    name: Rect
    nameWithType: Rect
    fullName: Rect[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Automation.Text.TextPatternRange.GetChildren
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetChildren()
  nameWithType: TextPatternRange.GetChildren()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetChildren()
- uid: System.Windows.Automation.AutomationElement[]
  parent: System.Windows.Automation
  isExternal: false
  name: AutomationElement
  nameWithType: AutomationElement
  fullName: System.Windows.Automation.AutomationElement[]
  spec.csharp:
  - uid: System.Windows.Automation.AutomationElement
    name: AutomationElement
    nameWithType: AutomationElement
    fullName: AutomationElement[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetEnclosingElement()
  nameWithType: TextPatternRange.GetEnclosingElement()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement()
- uid: System.Windows.Automation.AutomationElement
  parent: System.Windows.Automation
  isExternal: false
  name: AutomationElement
  nameWithType: AutomationElement
  fullName: System.Windows.Automation.AutomationElement
- uid: System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetText(Int32)
  nameWithType: TextPatternRange.GetText(Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetText(Int32)
- uid: System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Move(TextUnit,Int32)
  nameWithType: TextPatternRange.Move(TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.Move(TextUnit,Int32)
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  nameWithType: TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
- uid: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: RemoveFromSelection()
  nameWithType: TextPatternRange.RemoveFromSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection()
- uid: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ScrollIntoView(Boolean)
  nameWithType: TextPatternRange.ScrollIntoView(Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(Boolean)
- uid: System.Windows.Automation.Text.TextPatternRange.Select
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Select()
  nameWithType: TextPatternRange.Select()
  fullName: System.Windows.Automation.Text.TextPatternRange.Select()
- uid: System.Windows.Automation.Text.TextPatternRange.TextPattern
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: TextPattern
  nameWithType: TextPatternRange.TextPattern
  fullName: System.Windows.Automation.Text.TextPatternRange.TextPattern
- uid: System.Windows.Automation.TextPattern
  parent: System.Windows.Automation
  isExternal: false
  name: TextPattern
  nameWithType: TextPattern
  fullName: System.Windows.Automation.TextPattern
- uid: System.Windows.Automation.Text.TextPatternRange.AddToSelection*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: AddToSelection
  nameWithType: TextPatternRange.AddToSelection
- uid: System.Windows.Automation.Text.TextPatternRange.Clone*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Clone
  nameWithType: TextPatternRange.Clone
- uid: System.Windows.Automation.Text.TextPatternRange.Compare*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Compare
  nameWithType: TextPatternRange.Compare
- uid: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: CompareEndpoints
  nameWithType: TextPatternRange.CompareEndpoints
- uid: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ExpandToEnclosingUnit
  nameWithType: TextPatternRange.ExpandToEnclosingUnit
- uid: System.Windows.Automation.Text.TextPatternRange.FindAttribute*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindAttribute
  nameWithType: TextPatternRange.FindAttribute
- uid: System.Windows.Automation.Text.TextPatternRange.FindText*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindText
  nameWithType: TextPatternRange.FindText
- uid: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetAttributeValue
  nameWithType: TextPatternRange.GetAttributeValue
- uid: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetBoundingRectangles
  nameWithType: TextPatternRange.GetBoundingRectangles
- uid: System.Windows.Automation.Text.TextPatternRange.GetChildren*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetChildren
  nameWithType: TextPatternRange.GetChildren
- uid: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetEnclosingElement
  nameWithType: TextPatternRange.GetEnclosingElement
- uid: System.Windows.Automation.Text.TextPatternRange.GetText*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetText
  nameWithType: TextPatternRange.GetText
- uid: System.Windows.Automation.Text.TextPatternRange.Move*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Move
  nameWithType: TextPatternRange.Move
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByRange
  nameWithType: TextPatternRange.MoveEndpointByRange
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByUnit
  nameWithType: TextPatternRange.MoveEndpointByUnit
- uid: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: RemoveFromSelection
  nameWithType: TextPatternRange.RemoveFromSelection
- uid: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ScrollIntoView
  nameWithType: TextPatternRange.ScrollIntoView
- uid: System.Windows.Automation.Text.TextPatternRange.Select*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Select
  nameWithType: TextPatternRange.Select
- uid: System.Windows.Automation.Text.TextPatternRange.TextPattern*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: TextPattern
  nameWithType: TextPatternRange.TextPattern
