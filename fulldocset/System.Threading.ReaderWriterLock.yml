### YamlMime:ManagedReference
items:
- uid: System.Threading.ReaderWriterLock
  id: ReaderWriterLock
  children:
  - System.Threading.ReaderWriterLock.#ctor
  - System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  - System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  - System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  - System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  - System.Threading.ReaderWriterLock.Finalize
  - System.Threading.ReaderWriterLock.IsReaderLockHeld
  - System.Threading.ReaderWriterLock.IsWriterLockHeld
  - System.Threading.ReaderWriterLock.ReleaseLock
  - System.Threading.ReaderWriterLock.ReleaseReaderLock
  - System.Threading.ReaderWriterLock.ReleaseWriterLock
  - System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  - System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  - System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.WriterSeqNum
  langs:
  - csharp
  name: ReaderWriterLock
  nameWithType: ReaderWriterLock
  fullName: System.Threading.ReaderWriterLock
  type: Class
  summary: "여러 판독기와 단일 작성기를 지 원하는 잠금을 정의 합니다."
  remarks: "> [!IMPORTANT]>은 [!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)] 는 두 개의 판독기 및 작성기 잠금 <xref:System.Threading.ReaderWriterLockSlim>및 ReaderWriterLock.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>새로운 개발의 모든 것이 좋습니다.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>유사한 ReaderWriterLock, 재귀 및 업그레이드 및 잠금 상태를 다운 그레이드에 대 한 규칙 간소화 합니다.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>대부분의 경우 잠재적인 교착 상태를 방지할 수 있습니다.</xref:System.Threading.ReaderWriterLockSlim> 또한의 성능 <xref:System.Threading.ReaderWriterLockSlim>ReaderWriterLock 보다 훨씬 더 좋습니다.</xref:System.Threading.ReaderWriterLockSlim>       ReaderWriterLock은 리소스에 대 한 액세스를 동기화 하는 데 사용 됩니다. 지정된 된 시간에 여러 스레드에 대 한 동시 읽기 액세스 하거나 단일 스레드에 대 한 쓰기 권한을 허용합니다. 리소스 자주 변경 되는 경우에는 `ReaderWriterLock` <xref:System.Threading.Monitor>.</xref:System.Threading.Monitor> 같은 간단한 한 런타임 잠금 보다 처리량이 향상       `ReaderWriterLock`대부분 액세스는 읽기에 쓰기가 자주 수행 되 고 짧은 기간 가장 잘 작동 합니다. 어떤 오랜 시간 동안 차단 되도록 여러 판독기와 단일 작성기 대체 합니다.      > [!NOTE] > 오랜 시간 동안 다른 스레드에서 실행할 수 없게 됩니다에 대 한 잠금 판독기 또는 작성기 잠금을 보유 합니다. 최상의 성능을 위해 쓰기의 기간을 최소화 하기 위해 응용 프로그램을 재구성 하는 것이 좋습니다.       스레드 잠금 또는 기록기 잠금으로 하나만 동시에 판독기를 보유할 수 있습니다. 판독기 잠금을 작성기 잠금을 획득 하기 위해 해제 하는 대신 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> 및</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> 사용할 수 있습니다.       재귀적 잠금 요청에서 잠금을 잠금 수를 늘립니다.       판독기와 작성기는 별도로 대기 됩니다. 작성기 잠금을 해제 하는 스레드를 즉시 판독기 queue에서 대기 중인 모든 스레드에 판독기 잠금이; 부여 됩니다. 때 모든 판독기 잠금이 해제 된, 작성기에서 다음 스레드 대기 중인 있는 경우 작성기 잠금이 부여 되 면 큐 등에입니다. 즉, `ReaderWriterLock` 독자의 컬렉션과 기록기 간을 전환 합니다.       잠금이 해제 될 현재 판독기에 대 한 스레드 작성기 큐에서 대기 하는 동안 새 판독기 잠금을 요청 하는 스레드 판독기 큐에 누적 됩니다. 해당 요청은 권한을 부여 하지 동시 액세스 기존 판독기 잠금 소유자에 게;와 공유할 수 있지만 이 판독기에서 무한 중단에 대 한 작성자를 보호할 수 있습니다.       잠금을 획득 하는 것에 대 한 대부분의 메서드는 `ReaderWriterLock` 제한 시간 값을 허용 합니다. 응용 프로그램에서 교착 상태 방지 하려면 제한 시간을 사용 합니다. 스레드 수 하나의 리소스에 대해 작성기 잠금을 설정 하 고 두 번째 리소스;에 대 한 판독기 잠금을 요청 하는 예를 들어 그 동안에 다른 스레드에서 두 번째 리소스에 작성기 잠금을 설정 하 고 첫 번째 판독기 잠금을 요청 하 여 될 수 있습니다. 제한 시간을 사용 하지 않는 스레드 교착 상태가 발생 합니다.       시간 제한 간격이 만료 되는 경우 잠금 요청이 허용 되지 않았음을 메서드가 제어를 호출 스레드로 <xref:System.ApplicationException>.</xref:System.ApplicationException> throw 하 여 스레드 수이 예외를 catch 하 고을 수행 하는 작업을 결정 합니다.       제한 시간 (밀리초)로 표시 됩니다. <xref:System.TimeSpan?displayProperty=fullName>제한 시간을 지정 하려면 사용 되는 값은에 <xref:System.TimeSpan>.</xref:System.TimeSpan> 나타내는 정수 밀리초의 총 수는</xref:System.TimeSpan?displayProperty=fullName> 를 사용 하는 경우 다음 표에서 시간 (밀리초)에 유효한 제한 시간 값을 보여 줍니다.      | 값 | 설명 |   |-----------|-----------------|   |-1 | 스레드는 잠금을 얻으면 소요 되는 시간 될 때까지 대기 합니다. 정수 제한 시간을 지정 하는 방법에 대 한 <xref:System.Threading.Timeout.Infinite>상수를 사용할 수 있습니다. |   |&0; | 스레드 잠금을 기다리지 않습니다.</xref:System.Threading.Timeout.Infinite> 메서드가 반환 하는 경우 잠금을 획득할 수 없는 즉시. |   | >&0; | 시간 (밀리초)의 수입니다. |       -1을 제외한 음수 시간 제한 값 허용 되지 않습니다. -1이 아닌 음수를 지정 하는 경우 시간 제한 값이&0;이 대신 사용 됩니다. (즉, 메서드는, 대기 하지 않고 즉시 잠금을 가져올 수 있는 경우) 지정 하는 경우는 <xref:System.TimeSpan>음수-1 이외의 시간 (밀리초)을 나타내는 <xref:System.ArgumentOutOfRangeException>throw 됩니다.</xref:System.ArgumentOutOfRangeException> </xref:System.TimeSpan>"
  example:
  - "The following example demonstrates how to use a ReaderWriterLock to protect a shared resource, an integer value named `resource`, that is read concurrently and written exclusively by multiple threads. Note that the ReaderWriterLock is declared at the class level so that it is visible to all threads.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#1](~/add/codesnippet/cpp/t-system.threading.reade_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#1](~/add/codesnippet/csharp/t-system.threading.reade_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#1](~/add/codesnippet/visualbasic/t-system.threading.reade_1.vb)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  inheritance:
  - System.Object
  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.#ctor
  id: '#ctor'
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReaderWriterLock()
  nameWithType: ReaderWriterLock.ReaderWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReaderWriterLock()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Threading.ReaderWriterLock&quot;> </xref> 클래스입니다."
  remarks: ''
  example:
  - "The following code example demonstrates how to create a new instance of the <xref:System.Threading.ReaderWriterLock> class.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_0_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_0_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_0_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_0_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_0_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_0_2.vb)]"
  syntax:
    content: public ReaderWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  id: AcquireReaderLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireReaderLock(Int32)
  nameWithType: ReaderWriterLock.AcquireReaderLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "판독기를 획득 잠금, 사용 하는 <xref:System.Int32>제한 시간에 대 한 값.</xref:System.Int32>"
  remarks: "AcquireReaderLock 다른 스레드에 작성기 잠금이 있으면 하나 이상의 스레드가 기록기 잠금으로 인해 대기 하는 경우 차단 합니다.      > [!NOTE] > 현재 스레드에 작성기 잠금이 이미 있으면 판독기 잠금이 획득 됩니다. 대신, 작성기 잠금을 잠금 수가 증가 합니다. 이 자체 작성기 잠금을 차단에서 스레드를 차단 합니다. 결과 정확 하 게 호출할 때와 동일 <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, 및를 추가로 호출 <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>는 작성기 잠금을 해제 하는 경우 필요 합니다.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> </xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       `AcquireReaderLock`재귀적 판독기 잠금 요청을 지원합니다. 즉, 스레드 수 AcquireReaderLock를 여러 번 호출할 때마다 잠금 수를 증가입니다. 호출 해야 <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>호출할 때마다에 대해 한 번씩 `AcquireReaderLock`.</xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> 호출할 수 있습니다 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>즉시&0; 잠금 수를 줄일 수 있습니다.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       재귀적 잠금 요청은 항상 요청 하는 스레드의 판독기 큐에 배치 하지 않고 즉시, 부여 됩니다. 오랜 시간 동안 작성기 잠금 요청을 차단 되지 않도록 주의 해야 재귀적 잠금을 사용.       유효한 제한 시간 값에 대 한 참조 <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_6_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_6_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_6_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#3](~/add/codesnippet/cpp/m-system.threading.reade_6_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#3](~/add/codesnippet/csharp/m-system.threading.reade_6_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#3](~/add/codesnippet/visualbasic/m-system.threading.reade_6_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_6_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_6_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_6_3.vb)]"
  syntax:
    content: public void AcquireReaderLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "밀리초 단위로 제한 시간입니다."
  overload: System.Threading.ReaderWriterLock.AcquireReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>millisecondsTimeout</code>잠금 요청이 부여 되기 전에 만료 됩니다."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  id: AcquireReaderLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireReaderLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireReaderLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "판독기를 획득 잠금, 사용 하는 <xref:System.TimeSpan>제한 시간에 대 한 값.</xref:System.TimeSpan>"
  remarks: "<xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A>작성기 잠금을 보유 한 다른 스레드 또는 하나 이상의 스레드가 기록기 잠금으로 인해 대기 하는 경우 차단 합니다.</xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A>      > [!NOTE] > 현재 스레드에 작성기 잠금이 이미 있으면 판독기 잠금이 획득 됩니다. 대신, 작성기 잠금을 잠금 수가 증가 합니다. 이 자체 작성기 잠금을 차단에서 스레드를 차단 합니다. 결과 정확 하 게 호출할 때와 동일 <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, 및를 추가로 호출 <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>는 작성기 잠금을 해제 하는 경우 필요 합니다.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> </xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       `AcquireReaderLock`재귀적 판독기 잠금 요청을 지원합니다. 즉, 스레드 수 AcquireReaderLock를 여러 번 호출할 때마다 잠금 수를 증가입니다. 호출 해야 <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>호출할 때마다에 대해 한 번씩 `AcquireReaderLock`.</xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> 호출할 수 있습니다 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>즉시&0; 잠금 수를 줄일 수 있습니다.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       재귀적 잠금 요청은 항상 요청 하는 스레드의 판독기 큐에 배치 하지 않고 즉시, 부여 됩니다. 오랜 시간 동안 작성기 잠금 요청을 차단 되지 않도록 주의 해야 재귀적 잠금을 사용.       유효한 제한 시간 값에 대 한 참조 <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public void AcquireReaderLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "A <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> 제한 시간을 지정 합니다."
  overload: System.Threading.ReaderWriterLock.AcquireReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>잠금 요청이 부여 되기 전에 만료 됩니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>-1 밀리초 이외의 음수 값을 지정합니다."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  id: AcquireWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireWriterLock(Int32)
  nameWithType: ReaderWriterLock.AcquireWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "작성기 획득 잠금, 사용 하는 <xref:System.Int32>제한 시간에 대 한 값.</xref:System.Int32>"
  remarks: "이 메서드는 다른 스레드가 판독기 잠금을 또는 작성기 잠금을 차단 됩니다. 방법에 대 한 설명을 여러 동시 판독기 잠금을 작성기 잠금 대체 참조 <xref:System.Threading.ReaderWriterLock>클래스</xref:System.Threading.ReaderWriterLock>       판독기 잠금을 있는 스레드는 두 가지 방법 중 하나로 작성기 잠금을 획득할 수: AcquireWriterLock를 호출 하기 전에 판독기 잠금을 해제 하 여 또는 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> 를 호출 하 여      > [!CAUTION] > 스레드가 호출 하는 경우 `AcquireWriterLock` 의 자체 판독기 잠금이 차단 됩니다 판독기 잠금으로 아직, 동안; 스레드가 교착 상태가 무한 한 제한 시간을 지정 합니다. 이러한 교착 상태를 방지 하려면 사용 <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>현재 스레드에 판독기 잠금이 이미에 있는지 확인 하려면.</xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       `AcquireWriterLock`재귀적 작성기 잠금 요청을 지원합니다. 즉, 스레드 호출 수 `AcquireWriterLock` 여러 번 있는 잠금 수가 때마다 커집니다. 호출 해야 <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>호출할 때마다에 대해 한 번씩 `AcquireWriterLock`.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> 호출할 수 있습니다 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>즉시&0; 잠금 수를 줄일 수 있습니다.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       재귀적 잠금 요청은 항상 요청 하는 스레드의 작성기 큐에 배치 하지 않고 즉시, 부여 됩니다.       유효한 제한 시간 값에 대 한 참조 <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_4_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_4_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_4_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#4](~/add/codesnippet/cpp/m-system.threading.reade_4_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#4](~/add/codesnippet/csharp/m-system.threading.reade_4_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#4](~/add/codesnippet/visualbasic/m-system.threading.reade_4_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_4_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_4_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_4_3.vb)]"
  syntax:
    content: public void AcquireWriterLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "밀리초 단위로 제한 시간입니다."
  overload: System.Threading.ReaderWriterLock.AcquireWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>잠금 요청이 부여 되기 전에 만료 됩니다."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  id: AcquireWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "작성기 획득 잠금, 사용 하는 <xref:System.TimeSpan>제한 시간에 대 한 값.</xref:System.TimeSpan>"
  remarks: "이 메서드는 다른 스레드가 판독기 잠금을 또는 작성기 잠금을 차단 됩니다. 방법에 대 한 설명을 여러 동시 판독기 잠금을 작성기 잠금 대체 참조 <xref:System.Threading.ReaderWriterLock>클래스</xref:System.Threading.ReaderWriterLock>       판독기 잠금을 있는 스레드는 두 가지 방법 중 하나로 작성기 잠금을 획득할 수: 호출 하기 전에 판독기 잠금을 해제 하 여 <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> 를 호출 하 여</xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>      > [!CAUTION] > 스레드가 호출 하는 경우 `AcquireWriterLock` 의 자체 판독기 잠금이 차단 됩니다 판독기 잠금으로 아직, 동안; 스레드가 교착 상태가 무한 한 제한 시간을 지정 합니다. 이러한 교착 상태를 방지 하려면 사용 <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>현재 스레드에 판독기 잠금이 이미에 있는지 확인 하려면.</xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       `AcquireWriterLock`재귀적 작성기 잠금 요청을 지원합니다. 즉, 스레드 호출 수 `AcquireWriterLock` 여러 번 있는 잠금 수가 때마다 커집니다. 호출 해야 <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>호출할 때마다에 대해 한 번씩 `AcquireWriterLock`.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> 호출할 수 있습니다 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>즉시&0; 잠금 수를 줄일 수 있습니다.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       재귀적 잠금 요청은 항상 요청 하는 스레드의 작성기 큐에 배치 하지 않고 즉시, 부여 됩니다.       유효한 제한 시간 값에 대 한 참조 <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public void AcquireWriterLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "<xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> 제한 시간을 지정 합니다."
  overload: System.Threading.ReaderWriterLock.AcquireWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>잠금 요청이 부여 되기 전에 만료 됩니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>-1 밀리초 이외의 음수 값을 지정합니다."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  id: AnyWritersSince(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AnyWritersSince(Int32)
  nameWithType: ReaderWriterLock.AnyWritersSince(Int32)
  fullName: System.Threading.ReaderWriterLock.AnyWritersSince(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "시퀀스 번호를 가져온 후 작성기 잠금이 임의의 스레드에 부여 되어 있는지 여부를 나타냅니다."
  remarks: "사용할 수 있습니다 <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A>및 `AnyWritersSince` 응용 프로그램 성능 향상을 위해.</xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> 예를 들어 스레드 판독기 잠금을 보유 하는 동안 가져온 정보를 캐시할 수 있습니다. 스레드 잠금을 썼는지 나중에 있으며, צ ְ ײ `AnyWritersSince` 중간;에 다른 스레드가 리소스에 작성 한 경우 여부, 캐시 된 정보를 사용할 수를 확인 하려면. 이 기술은 유용 잠금으로 보호 되는 정보를 읽는 비쌉니다. 예를 들어 데이터베이스 쿼리를 실행 합니다.       호출자가 보유 하 고 있어야 판독기 잠금을 또는 기록기 잠금으로 유용 하 게 되려면 시퀀스 번호에 대 한 순서 대로 합니다."
  example:
  - "The following code example shows how to use the AnyWritersSince method and the <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> property to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_8_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_8_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_8_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_8_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_8_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_8_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_8_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_8_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_8_3.vb)]"
  syntax:
    content: public bool AnyWritersSince (int seqNum);
    parameters:
    - id: seqNum
      type: System.Int32
      description: "시퀀스 번호입니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>시퀀스 번호를 가져온; 이후 스레드에 작성기 잠금이 부여 된 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Threading.ReaderWriterLock.AnyWritersSince*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  id: DowngradeFromWriterLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: DowngradeFromWriterLock(LockCookie)
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "복원 하기 전에 스레드의 잠금 상태를 복원 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>호출 되었습니다.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>"
  remarks: "DowngradeFromWriterLock 재귀 잠금 수에 관계 없이 작성기 잠금을 해제 하 고 판독기 잠금을 작성기 잠금으로 업그레이드 하기 전에 스레드에 의해 보유 된를 복원 합니다. 판독기 잠금을 잠금 수가 복원 됩니다.      > [!NOTE]  >   `DowngradeFromWriterLock` <xref:System.Threading.LockCookie> <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> 를 호출 하 여 가져온</xref:System.Threading.LockCookie> 허용 사용 하지 않는 한 `LockCookie` <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> 반환한       스레드에는 작성기 잠금이 해제 될 때 모든 판독기 잠금 요청 권한이 부여 되므로 다른 스레드에서 작성기 잠금을 기다리는 경우에 작성기 잠금을에서 다운 그레이드할 때을 차단 하지 않습니다."
  example:
  - "The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#5](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#5](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#5](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_3.vb)]"
  syntax:
    content: public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);
    parameters:
    - id: lockCookie
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;> </xref> <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*> 반환한"
  overload: System.Threading.ReaderWriterLock.DowngradeFromWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "스레드에는 작성기 잠금이 않아도 됩니다."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "주소 <code> lockCookie </code> 가 null 포인터입니다."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.Finalize
  id: Finalize
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: Finalize()
  nameWithType: ReaderWriterLock.Finalize()
  fullName: System.Threading.ReaderWriterLock.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "리소스가 해제 되 고 가비지 수집기가 회수 하는 경우 다른 정리 작업이 수행 되도록는 <xref href=&quot;System.Threading.ReaderWriterLock&quot;> </xref> 개체입니다."
  remarks: "가비지 수집기 호출이 완료 될 때 현재 <xref:System.Threading.ReaderWriterLock>개체는 종료 될.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: ~ReaderWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld
  id: IsReaderLockHeld
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
  fullName: System.Threading.ReaderWriterLock.IsReaderLockHeld
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "현재 스레드에 판독기 잠금이 있는지 여부를 나타내는 값을 가져옵니다."
  remarks: ''
  example:
  - "The following code example demonstrates how to use `IsReaderLockHeld` to avoid deadlocks.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/cpp/p-system.threading.reade_1_1.cpp)]\n [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/visualbasic/p-system.threading.reade_1_1.vb)]\n [!code-cs[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/csharp/p-system.threading.reade_1_1.cs)]"
  syntax:
    content: public bool IsReaderLockHeld { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>현재 스레드에 판독기 잠금이; 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Threading.ReaderWriterLock.IsReaderLockHeld*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld
  id: IsWriterLockHeld
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
  fullName: System.Threading.ReaderWriterLock.IsWriterLockHeld
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "현재 스레드에 작성기 잠금이 있는지 여부를 나타내는 값을 가져옵니다."
  remarks: ''
  example:
  - "The following code example demonstrates that when an attempt is made to acquire a reader lock on a thread that has a writer lock, `ReaderWriterLock` does not grant the reader lock but instead increments the lock count on the writer lock.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/cpp/p-system.threading.reade_0_1.cpp)]\n [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/visualbasic/p-system.threading.reade_0_1.vb)]\n [!code-cs[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/csharp/p-system.threading.reade_0_1.cs)]"
  syntax:
    content: public bool IsWriterLockHeld { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>현재 스레드에 작성기 잠금이; 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Threading.ReaderWriterLock.IsWriterLockHeld*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseLock
  id: ReleaseLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseLock()
  nameWithType: ReaderWriterLock.ReleaseLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "스레드에서 잠금을 가져온 횟수에 관계 없이 잠금을 해제 합니다."
  remarks: "ReleaseLock은 판독기 잠금 또는 재귀 잠금 수에 관계 없이 작성기 잠금을 해제합니다. 잠금 수를 포함 하 여 잠금 상태를 복원 하려면 <xref:System.Threading.LockCookie> <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A> </xref:System.Threading.LockCookie> 전달"
  example:
  - "The following code example shows how to use the ReleaseLock method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_1_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_1_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_1_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_1_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_1_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_1_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_1_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_1_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_1_3.vb)]"
  syntax:
    content: public System.Threading.LockCookie ReleaseLock ();
    parameters: []
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;> </xref> 해제 된 잠금을 나타내는 값입니다."
  overload: System.Threading.ReaderWriterLock.ReleaseLock*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock
  id: ReleaseReaderLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseReaderLock()
  nameWithType: ReaderWriterLock.ReleaseReaderLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseReaderLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "잠금 횟수를 줄입니다."
  remarks: "잠금 횟수를 ReleaseReaderLock 줄입니다. 수가&0;에 도달 하면 잠금이 해제 됩니다.      > [!NOTE] > 호출 스레드에 작성기 잠금이 있으면 `ReleaseReaderLock` <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> 호출 것과 동일한 결과가 호출 스레드가 잠금이 없습니다 경우 `ReleaseReaderLock` <xref:System.ApplicationException>.</xref:System.ApplicationException> throw"
  example:
  - "The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_5_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_5_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_5_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#3](~/add/codesnippet/cpp/m-system.threading.reade_5_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#3](~/add/codesnippet/csharp/m-system.threading.reade_5_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#3](~/add/codesnippet/visualbasic/m-system.threading.reade_5_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_5_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_5_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_5_3.vb)]"
  syntax:
    content: public void ReleaseReaderLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.ReleaseReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "스레드는 판독기 또는 작성기 잠금을 없습니다."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock
  id: ReleaseWriterLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseWriterLock()
  nameWithType: ReaderWriterLock.ReleaseWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseWriterLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "작성기 잠금을 잠금 횟수를 줄입니다."
  remarks: "기록기 잠금 횟수를 ReleaseWriterLock 줄입니다. 횟수가&0; 작성기 잠금이 해제 됩니다.      > [!NOTE] > 호출 스레드가 판독기 잠금 또는 잠금 없음 있으면 `ReleaseWriterLock` <xref:System.ApplicationException>.</xref:System.ApplicationException> throw"
  example:
  - "The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_3_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_3_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_3_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#4](~/add/codesnippet/cpp/m-system.threading.reade_3_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#4](~/add/codesnippet/csharp/m-system.threading.reade_3_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#4](~/add/codesnippet/visualbasic/m-system.threading.reade_3_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_3_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_3_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_3_3.vb)]"
  syntax:
    content: public void ReleaseWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.ReleaseWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "스레드에는 작성기 잠금이 않아도 됩니다."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  id: RestoreLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: RestoreLock(LockCookie)
  nameWithType: ReaderWriterLock.RestoreLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.RestoreLock(LockCookie)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "복원 <xref:System.Threading.ReaderWriterLock.ReleaseLock*>.</xref:System.Threading.ReaderWriterLock.ReleaseLock*> 를 호출 하기 전에 스레드의 잠금 상태를 복구 합니다."
  remarks: "상태에서 복원할 `RestoreLock` 재귀 잠금 수를 포함 합니다.       스레드는 차단 되는 잠금 판독기 또는 작성기 잠금을 다른 스레드가 가져온 후 작성기 잠금을 복원 하려는 경우 또는 다른 스레드에 작성기 잠금이 가져온 후 판독기 잠금을 복원 하려고 합니다. 때문에 `RestoreLock` 는 제한 시간을 허용 하지 않습니다 가능한 교착 상태를 방지 하기 위해 주의 해야 합니다.      > [!CAUTION] > 호출 하기 전에 `RestoreLock`, <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> 호출 이후 모든 잠금을 해제 했는지 확인 예를 들어 한 스레드 교착 상태 판독기 잠금을 획득 하 고 이전 기록기 잠금으로 복원 하려고 시도 합니다. 사용 하 여 <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>및 <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A>에 이러한 추가 잠금을 검색.</xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> </xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       <xref:System.Threading.LockCookie> <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> 에서 반환 되</xref:System.Threading.LockCookie> 는 사용 하지 마십시오"
  example:
  - "The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_2_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_2_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_2_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_2_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_2_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_2_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_2_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_2_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_2_3.vb)]"
  syntax:
    content: public void RestoreLock (ref System.Threading.LockCookie lockCookie);
    parameters:
    - id: lockCookie
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;> </xref> <xref:System.Threading.ReaderWriterLock.ReleaseLock*>.</xref:System.Threading.ReaderWriterLock.ReleaseLock*> 반환한"
  overload: System.Threading.ReaderWriterLock.RestoreLock*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "주소 <code> lockCookie </code> 가 null 포인터입니다."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  id: UpgradeToWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: UpgradeToWriterLock(Int32)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "판독기 잠금을 작성기 잠금으로 업그레이드를 사용 하 여 프로그램 <xref uid=&quot;langword_csharp_Int32&quot; name=&quot;Int32&quot; href=&quot;&quot;> </xref> 제한 시간 값입니다."
  remarks: "호출 하면 스레드 `UpgradeToWriterLock` 판독기 잠금을 잠금 수에 관계 없이 해제 되 고 스레드 작성기 잠금을 큐의 끝으로 이동 합니다. 따라서 다른 스레드에서 업그레이드 작성기 잠금이 부여를 요청 하는 스레드 하기 전에 리소스를 쓸 수 있습니다.      > [!IMPORTANT] > UpgradeToWriterLock 메서드를 호출한 스레드가 판독기 잠금을 다시 가져올 수 있습니다 때까지 시간 초과 예외가 throw 되지 않습니다. 기록기 잠금으로 인해 대기 하는 다른 스레드가 있으면 즉시 전파 합니다. 그러나 작성기 잠금을 다른 스레드에서 큐에 대기 하는 경우 UpgradeToWriterLock 메서드를 호출한 스레드에 모든 현재 판독기가 잠금을 해제 하 고 스레드 하나에 획득 하 고 작성기 잠금을 해제할 때까지 판독기 잠금을 다시 가져올 수 없습니다. 작성기 잠금을 요청 하는 다른 스레드가 현재 스레드 UpgradeToWriterLock 메서드를 호출한 후 요청 하는 경우에 마찬가지입니다.       잠금 상태를 복원 하려면 호출 <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>를 사용 하는 <xref:System.Threading.LockCookie>반환한 `UpgradeToWriterLock`.</xref:System.Threading.LockCookie> </xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> 이 사용 하지 마십시오 `LockCookie` <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A>       스레드에 판독기 잠금이 사용 하지 마십시오 `UpgradeToWriterLock`합니다. 사용 하 여 <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>대신.</xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       유효한 제한 시간 값에 대 한 참조 <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_7_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_7_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_7_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#5](~/add/codesnippet/cpp/m-system.threading.reade_7_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#5](~/add/codesnippet/csharp/m-system.threading.reade_7_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#5](~/add/codesnippet/visualbasic/m-system.threading.reade_7_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_7_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_7_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_7_3.vb)]"
  syntax:
    content: public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "밀리초 단위로 제한 시간입니다."
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;></xref> value."
  overload: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>millisecondsTimeout</code>잠금 요청이 부여 되기 전에 만료 됩니다."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  id: UpgradeToWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: UpgradeToWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "판독기 잠금을 작성기 잠금으로 업그레이드를 사용 하 여 한 <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> 제한 시간 값입니다."
  remarks: "호출 하면 스레드 `UpgradeToWriterLock` 판독기 잠금을 잠금 수에 관계 없이 해제 되 고 스레드 작성기 잠금을 큐의 끝으로 이동 합니다. 따라서 다른 스레드에서 업그레이드 작성기 잠금이 부여를 요청 하는 스레드 하기 전에 리소스를 쓸 수 있습니다.      > [!IMPORTANT] >까지 호출한 스레드가 시간 초과 예외가 throw 되지 않습니다는 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>메서드는 판독기 잠금을 다시 가져올 수 있습니다.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> 기록기 잠금으로 인해 대기 하는 다른 스레드가 있으면 즉시 전파 합니다. 그러나 작성기 잠금을 다른 스레드에서 큐에 대기 하는 경우를 호출한 스레드가 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>모든 현재 판독기가 잠금을 해제 하 고 스레드 하나에 획득 하 고 작성기 잠금을 해제할 때까지 메서드는 판독기 잠금을 다시 가져올 수 없습니다.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> 작성기 잠금을 요청 하는 다른 스레드가 현재 스레드의 호출 후 요청 하는 경우에 마찬가지입니다는 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>메서드.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>       잠금 상태를 복원 하려면 호출 <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>를 사용 하는 <xref:System.Threading.LockCookie>반환한 `UpgradeToWriterLock`.</xref:System.Threading.LockCookie> </xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> 이 사용 하지 마십시오 `LockCookie` <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A>       스레드에 판독기 잠금이 사용 하지 마십시오 `UpgradeToWriterLock`합니다. 사용 하 여 <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>대신.</xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       유효한 제한 시간 값에 대 한 참조 <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "<xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> 제한 시간을 지정 합니다."
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;></xref> value."
  overload: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>잠금 요청이 부여 되기 전에 만료 됩니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>-1 밀리초 이외의 음수 값을 지정합니다."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.WriterSeqNum
  id: WriterSeqNum
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
  fullName: System.Threading.ReaderWriterLock.WriterSeqNum
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "현재 시퀀스 번호를 가져옵니다."
  remarks: "시퀀스 번호가 증가 때마다 스레드 작성기 잠금을 가져옵니다. 시퀀스 번호를 저장 하 고 전달 <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>다른 스레드에서 그 동안 작성기 잠금을 획득 못한 있는지 여부를 확인 하려는 경우 이후 한 번에.</xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>       사용할 수 있습니다 `WriterSeqNum` 응용 프로그램 성능 향상을 위해 합니다. 예를 들어 스레드 판독기 잠금을 보유 하는 동안 가져온 정보를 캐시할 수 있습니다. 나중에 잠금이 썼는지 있으며, 스레드가 다른 스레드에서 호출 하 여 리소스에 썼는지 여부를 확인할 수 `AnyWritersSince`; 이면 not, 캐시 된 정보를 사용할 수 있습니다. 잠금에 의해 보호 된 정보를 읽는 하는 것은 비용이 많이 드는; 때이 기술은 유용 합니다. 예를 들어 데이터베이스 쿼리를 실행 합니다.       호출자가 보유 하 고 있어야 판독기 잠금을 또는 기록기 잠금으로 유용 하 게 되려면 시퀀스 번호에 대 한 순서 대로 합니다."
  example:
  - "The following code example shows how to use the WriterSeqNum property and the <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> method to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/p-system.threading.reade_2_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/p-system.threading.reade_2_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/p-system.threading.reade_2_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/p-system.threading.reade_2_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/p-system.threading.reade_2_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/p-system.threading.reade_2_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/p-system.threading.reade_2_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/p-system.threading.reade_2_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/p-system.threading.reade_2_3.vb)]"
  syntax:
    content: public int WriterSeqNum { get; }
    return:
      type: System.Int32
      description: "현재 시퀀스 번호입니다."
  overload: System.Threading.ReaderWriterLock.WriterSeqNum*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  isExternal: false
  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.Threading.ReaderWriterLock.#ctor
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReaderWriterLock()
  nameWithType: ReaderWriterLock.ReaderWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReaderWriterLock()
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock(Int32)
  nameWithType: ReaderWriterLock.AcquireReaderLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireReaderLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock(Int32)
  nameWithType: ReaderWriterLock.AcquireWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)
- uid: System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AnyWritersSince(Int32)
  nameWithType: ReaderWriterLock.AnyWritersSince(Int32)
  fullName: System.Threading.ReaderWriterLock.AnyWritersSince(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: DowngradeFromWriterLock(LockCookie)
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
- uid: System.Threading.LockCookie
  parent: System.Threading
  isExternal: false
  name: LockCookie
  nameWithType: LockCookie
  fullName: System.Threading.LockCookie
- uid: System.Threading.ReaderWriterLock.Finalize
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: Finalize()
  nameWithType: ReaderWriterLock.Finalize()
  fullName: System.Threading.ReaderWriterLock.Finalize()
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
  fullName: System.Threading.ReaderWriterLock.IsReaderLockHeld
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
  fullName: System.Threading.ReaderWriterLock.IsWriterLockHeld
- uid: System.Threading.ReaderWriterLock.ReleaseLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseLock()
  nameWithType: ReaderWriterLock.ReleaseLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseLock()
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseReaderLock()
  nameWithType: ReaderWriterLock.ReleaseReaderLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseReaderLock()
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseWriterLock()
  nameWithType: ReaderWriterLock.ReleaseWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseWriterLock()
- uid: System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: RestoreLock(LockCookie)
  nameWithType: ReaderWriterLock.RestoreLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.RestoreLock(LockCookie)
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock(Int32)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(Int32)
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
- uid: System.Threading.ReaderWriterLock.WriterSeqNum
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
  fullName: System.Threading.ReaderWriterLock.WriterSeqNum
- uid: System.Threading.ReaderWriterLock.#ctor*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReaderWriterLock
  nameWithType: ReaderWriterLock.ReaderWriterLock
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock
  nameWithType: ReaderWriterLock.AcquireReaderLock
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock
  nameWithType: ReaderWriterLock.AcquireWriterLock
- uid: System.Threading.ReaderWriterLock.AnyWritersSince*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AnyWritersSince
  nameWithType: ReaderWriterLock.AnyWritersSince
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: DowngradeFromWriterLock
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock
- uid: System.Threading.ReaderWriterLock.Finalize*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: Finalize
  nameWithType: ReaderWriterLock.Finalize
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
- uid: System.Threading.ReaderWriterLock.ReleaseLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseLock
  nameWithType: ReaderWriterLock.ReleaseLock
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseReaderLock
  nameWithType: ReaderWriterLock.ReleaseReaderLock
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseWriterLock
  nameWithType: ReaderWriterLock.ReleaseWriterLock
- uid: System.Threading.ReaderWriterLock.RestoreLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: RestoreLock
  nameWithType: ReaderWriterLock.RestoreLock
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock
  nameWithType: ReaderWriterLock.UpgradeToWriterLock
- uid: System.Threading.ReaderWriterLock.WriterSeqNum*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
