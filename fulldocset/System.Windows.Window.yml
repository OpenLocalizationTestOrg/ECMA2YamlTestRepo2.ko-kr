### YamlMime:ManagedReference
items:
- uid: System.Windows.Window
  id: Window
  children:
  - System.Windows.Window.#ctor
  - System.Windows.Window.Activate
  - System.Windows.Window.Activated
  - System.Windows.Window.AllowsTransparency
  - System.Windows.Window.AllowsTransparencyProperty
  - System.Windows.Window.ArrangeOverride(System.Windows.Size)
  - System.Windows.Window.Close
  - System.Windows.Window.Closed
  - System.Windows.Window.Closing
  - System.Windows.Window.ContentRendered
  - System.Windows.Window.Deactivated
  - System.Windows.Window.DialogResult
  - System.Windows.Window.DpiChanged
  - System.Windows.Window.DpiChangedEvent
  - System.Windows.Window.DragMove
  - System.Windows.Window.GetWindow(System.Windows.DependencyObject)
  - System.Windows.Window.Hide
  - System.Windows.Window.Icon
  - System.Windows.Window.IconProperty
  - System.Windows.Window.IsActive
  - System.Windows.Window.IsActiveProperty
  - System.Windows.Window.Left
  - System.Windows.Window.LeftProperty
  - System.Windows.Window.LocationChanged
  - System.Windows.Window.LogicalChildren
  - System.Windows.Window.MeasureOverride(System.Windows.Size)
  - System.Windows.Window.OnActivated(System.EventArgs)
  - System.Windows.Window.OnClosed(System.EventArgs)
  - System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)
  - System.Windows.Window.OnContentChanged(System.Object,System.Object)
  - System.Windows.Window.OnContentRendered(System.EventArgs)
  - System.Windows.Window.OnCreateAutomationPeer
  - System.Windows.Window.OnDeactivated(System.EventArgs)
  - System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)
  - System.Windows.Window.OnLocationChanged(System.EventArgs)
  - System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)
  - System.Windows.Window.OnSourceInitialized(System.EventArgs)
  - System.Windows.Window.OnStateChanged(System.EventArgs)
  - System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)
  - System.Windows.Window.OwnedWindows
  - System.Windows.Window.Owner
  - System.Windows.Window.ResizeMode
  - System.Windows.Window.ResizeModeProperty
  - System.Windows.Window.RestoreBounds
  - System.Windows.Window.Show
  - System.Windows.Window.ShowActivated
  - System.Windows.Window.ShowActivatedProperty
  - System.Windows.Window.ShowDialog
  - System.Windows.Window.ShowInTaskbar
  - System.Windows.Window.ShowInTaskbarProperty
  - System.Windows.Window.SizeToContent
  - System.Windows.Window.SizeToContentProperty
  - System.Windows.Window.SourceInitialized
  - System.Windows.Window.StateChanged
  - System.Windows.Window.TaskbarItemInfo
  - System.Windows.Window.TaskbarItemInfoProperty
  - System.Windows.Window.Title
  - System.Windows.Window.TitleProperty
  - System.Windows.Window.Top
  - System.Windows.Window.Topmost
  - System.Windows.Window.TopmostProperty
  - System.Windows.Window.TopProperty
  - System.Windows.Window.WindowStartupLocation
  - System.Windows.Window.WindowState
  - System.Windows.Window.WindowStateProperty
  - System.Windows.Window.WindowStyle
  - System.Windows.Window.WindowStyleProperty
  langs:
  - csharp
  name: Window
  nameWithType: Window
  fullName: System.Windows.Window
  type: Class
  summary: "만들기, 구성, 표시 및 창 및 대화 상자의 수명을 관리 하는 기능을 제공 합니다."
  remarks: "사용자와 독립 실행형 응용 프로그램 간의 상호 작용 지점 창입니다. A [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] 창 두 개의 개별 영역으로 이루어져:-를 호스팅하는 아이콘, 제목, 시스템 메뉴를 포함 하 여 창 장식을 비클라이언트 영역을 최소화 단추, 단추, 복원 단추, 닫기 단추 및 테두리를 최대화 합니다.      -응용 프로그램 관련 콘텐츠를 호스트 하는 A 클라이언트 영역입니다.       표준 창이 다음 그림에 나와: ![창 요소](~/add/media/windowoverviewfigure1.PNG &quot;창 요소&quot;) 작성, 구성, 표시 및 창 및 대화 상자를 둘 다의 수명을 관리 하는 기능을 캡슐화 하 고 다음과 같은 핵심 서비스를 제공 하는 창: **수명 관리**: <xref:System.Windows.Window.Activate%2A>, <xref:System.Windows.Window.Activated> <xref:System.Windows.Window.Close%2A>, <xref:System.Windows.Window.Closed> <xref:System.Windows.Window.Closing>, <xref:System.Windows.Window.Deactivated> <xref:System.Windows.Window.Hide%2A> <xref:System.Windows.Window.IsActive%2A>, <xref:System.Windows.Window.Show%2A> <xref:System.Windows.Window.SourceInitialized>.</xref:System.Windows.Window.SourceInitialized> </xref:System.Windows.Window.Show%2A> </xref:System.Windows.Window.IsActive%2A> </xref:System.Windows.Window.Hide%2A> ,</xref:System.Windows.Window.Deactivated> </xref:System.Windows.Window.Closing> </xref:System.Windows.Window.Closed> </xref:System.Windows.Window.Close%2A> </xref:System.Windows.Window.Activated> </xref:System.Windows.Window.Activate%2A>       **창 관리**: <xref:System.Windows.Window.GetWindow%2A>, <xref:System.Windows.Window.OwnedWindows%2A> <xref:System.Windows.Window.Owner%2A>.</xref:System.Windows.Window.Owner%2A> </xref:System.Windows.Window.OwnedWindows%2A> </xref:System.Windows.Window.GetWindow%2A>       **Appearance and Behavior**: <xref:System.Windows.Window.AllowsTransparency%2A>, <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>, <xref:System.Windows.Window.Left%2A>, <xref:System.Windows.Window.LocationChanged>, <xref:System.Windows.Window.ResizeMode%2A>, <xref:System.Windows.Window.RestoreBounds%2A>, <xref:System.Windows.Window.ShowActivated%2A>, <xref:System.Windows.Window.ShowInTaskbar%2A>, <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A>       **Dialog Boxes**: <xref:System.Windows.Window.DialogResult%2A>, <xref:System.Windows.Window.ShowDialog%2A>.</xref:System.Windows.Window.ShowDialog%2A></xref:System.Windows.Window.DialogResult%2A></xref:System.Windows.Window.WindowStyle%2A></xref:System.Windows.Window.WindowState%2A></xref:System.Windows.Window.WindowStartupLocation%2A></xref:System.Windows.Window.Topmost%2A></xref:System.Windows.Window.Top%2A></xref:System.Windows.Window.Title%2A></xref:System.Windows.Window.StateChanged></xref:System.Windows.Window.SizeToContent%2A></xref:System.Windows.Window.ShowInTaskbar%2A></xref:System.Windows.Window.ShowActivated%2A></xref:System.Windows.Window.RestoreBounds%2A></xref:System.Windows.Window.ResizeMode%2A></xref:System.Windows.Window.LocationChanged></xref:System.Windows.Window.Left%2A></xref:System.Windows.Window.Icon%2A></xref:System.Windows.Window.DragMove%2A></xref:System.Windows.Window.ContentRendered></xref:System.Windows.Window.AllowsTransparency%2A>       또한 <xref:System.Windows.Application>모든 응용 프로그램의 창 관리 하기 위한 특별 한 지원을 노출:-응용 프로그램에는 현재 응용 프로그램에서 시작 된 모든 창의 목록을 유지 관리 합니다.</xref:System.Windows.Application> 이 목록에 의해 노출 되는 <xref:System.Windows.Application.Windows%2A>속성.</xref:System.Windows.Application.Windows%2A>      -기본적으로 <xref:System.Windows.Application.MainWindow%2A>기능은 응용 프로그램에서 시작 하는 첫 번째 창에 대 한 참조로 자동 설정 됩니다.</xref:System.Windows.Application.MainWindow%2A> 따라서이 창을 기본 응용 프로그램 창.       창이 태그, 태그 및 코드 숨김 또는 코드를 사용 하 여 구현할 수 있습니다.       창 및 독립 실행형 응용 프로그램에 대 한 대화 상자를 표시 하려면 창 주로 사용 됩니다. 그러나 창 수준에서 탐색 하는 응용 프로그램 대신 사용할 수 있습니다 <xref:System.Windows.Navigation.NavigationWindow>를; <xref:System.Windows.Navigation.NavigationWindow>창에서 파생 되 고 브라우저 스타일 탐색 지원을 사용 하도록 확장 합니다.</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.NavigationWindow>      > [!NOTE] > Navigable 콘텐츠의 제도 <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> 를 사용 하 여 다른 콘텐츠 및 콘텐츠 컨테이너에 통합할 수       창이 `UnmanagedCode` 인스턴스화할 수 있는 보안 권한이 있습니다. 이 다음과 같은 결과가 발생:- [!INCLUDE[TLA#tla_clickonce](~/add/includes/tlasharptla-clickonce-md.md)]-배포 된 독립 실행형 응용 프로그램은 인터넷 또는 로컬 인트라넷 영역에서 시작 하는 경우 권한 상승을 요청 합니다.      - [!INCLUDE[TLA2#tla_xbap#plural](~/add/includes/tla2sharptla-xbapsharpplural-md.md)] 하는 보다 낮은 권한을 요청 대 한 모든 권한을 창 또는 대화 상자를 인스턴스화할 수 없습니다.       독립 실행형 응용 프로그램 배포 및 보안 고려 사항에 대 한 정보를 참조 하십시오. [WPF 보안 전략-플랫폼 보안](~/add/includes/ajax-current-ext-md.md)합니다.       창이 <xref:System.Windows.Controls.ContentControl>, 즉, 모든 형식 (예: 문자열, 이미지 또는 패널)의 단일 개체가 포함 될 수 있습니다.</xref:System.Windows.Controls.ContentControl> 자세한 내용은 <xref:System.Windows.Controls.ContentControl>클래스</xref:System.Windows.Controls.ContentControl> 를 참조 하십시오. 또한 창은 루트 요소 이며, 따라서 다른 요소의 콘텐츠가 포함 될 수 없습니다.      > [!NOTE] >는 <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.Window.Top%2A>, 및 <xref:System.Windows.Window.Left%2A>런타임 시 속성이 설정 된 스타일을 사용 하는 창에 적용 되지 것입니다.</xref:System.Windows.Window.Left%2A> </xref:System.Windows.Window.Top%2A> </xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.Height%2A>      ## 여러 개의 창 컨트롤을 사용 하 여 동일한 속성 설정을 적용할는 창 컨트롤을 사용자 지정의 <xref:System.Windows.FrameworkElement.Style%2A>속성.</xref:System.Windows.FrameworkElement.Style%2A> 기본값을 수정할 수 <xref:System.Windows.Controls.ControlTemplate>고유한 모양을 제어할 수 있습니다.</xref:System.Windows.Controls.ControlTemplate> 만들기에 대 한 자세한 내용은 <xref:System.Windows.Controls.ControlTemplate>, 참조 [는 ControlTemplate을 만들어 기존 컨트롤의 모양 사용자 지정](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.Controls.ControlTemplate>  부분 및 창에 관련 된 상태를 보려면 참조 [창 스타일 및 템플릿](~/add/includes/ajax-current-ext-md.md)합니다.       종속성 속성을이 컨트롤은 컨트롤의 기본 스타일으로 설정할 수 있습니다.  기본 스타일 속성은 응용 프로그램에이 컨트롤이 표시 하는 경우 속성이 기본값에서 변경 될 수 있습니다. 기본 스타일 응용 프로그램이 실행 중인 때 사용 되는 데스크톱 테마에 따라 결정 됩니다.  자세한 내용은 참조 [기본 WPF 테마](http://go.microsoft.com/fwlink/?LinkID=158252)합니다.      > [!NOTE] > 시각적 속성을 설정만 영향을 미칠 속성 시각적 창이 컨트롤의 기본 서식 파일에 속성이 있으며를 사용 하 여 설정 된 경우는 합니다. &quot;변경의 시각적 구조의 정도 제어&quot; 섹션의 시각적 속성 목록을 찾을 수 있습니다 [는 ControlTemplate을 만들어 기존 컨트롤의 모양 사용자 지정](../Topic/Customizing%20the%20Appearance%20of%20an%20Existing%20Control%20by%20Creating%20a%20ControlTemplate.md)합니다."
  example:
  - "The following example shows how a standard window is defined using only markup:  \n  \n [!code-xml[WindowSnippets#WindowMARKUPONLY](~/add/codesnippet/xaml/WindowSnippets.CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  \n  \n The following example shows how a standard window is defined using only code:  \n  \n [!code-cs[WindowSnippets#WindowCODEONLY](~/add/codesnippet/csharp/WindowSnippets.CSharp/CodeOnlyWindow.cs#windowcodeonly)]\n [!code-vb[WindowSnippets#WindowCODEONLY](~/add/codesnippet/visualbasic/windowsnippets/codeonlywindow.vb#windowcodeonly)]  \n  \n The following example shows how a standard window is defined using a combination of markup and code-behind.  \n  \n [!code-xml[WindowSnippets#WindowXAML](~/add/codesnippet/xaml/WindowSnippets.CSharp/MainWindow.xaml#windowxaml)]  \n  \n [!code-cs[WindowSnippets#WindowCODEBEHIND](~/add/codesnippet/csharp/WindowSnippets.CSharp/MainWindow.xaml.cs#windowcodebehind)]\n [!code-vb[WindowSnippets#WindowCODEBEHIND](~/add/codesnippet/visualbasic/windowsnippets/mainwindow.xaml.vb#windowcodebehind)]"
  syntax:
    content: >-
      [System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)]

      public class Window : System.Windows.Controls.ContentControl
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.Media.Visual
  - System.Windows.UIElement
  - System.Windows.FrameworkElement
  - System.Windows.Controls.Control
  - System.Windows.Controls.ContentControl
  implements: []
  inheritedMembers:
  - System.Windows.Controls.ContentControl.AddChild(System.Object)
  - System.Windows.Controls.ContentControl.AddText(System.String)
  - System.Windows.Controls.ContentControl.Content
  - System.Windows.Controls.ContentControl.ContentProperty
  - System.Windows.Controls.ContentControl.ContentStringFormat
  - System.Windows.Controls.ContentControl.ContentStringFormatProperty
  - System.Windows.Controls.ContentControl.ContentTemplate
  - System.Windows.Controls.ContentControl.ContentTemplateProperty
  - System.Windows.Controls.ContentControl.ContentTemplateSelector
  - System.Windows.Controls.ContentControl.ContentTemplateSelectorProperty
  - System.Windows.Controls.ContentControl.HasContent
  - System.Windows.Controls.ContentControl.HasContentProperty
  - System.Windows.Controls.ContentControl.OnContentStringFormatChanged(System.String,System.String)
  - System.Windows.Controls.ContentControl.OnContentTemplateChanged(System.Windows.DataTemplate,System.Windows.DataTemplate)
  - System.Windows.Controls.ContentControl.OnContentTemplateSelectorChanged(System.Windows.Controls.DataTemplateSelector,System.Windows.Controls.DataTemplateSelector)
  - System.Windows.Controls.ContentControl.ShouldSerializeContent
  - System.Windows.Controls.ContentControl.System#Windows#Markup#IAddChild#AddChild(System.Object)
  - System.Windows.Controls.ContentControl.System#Windows#Markup#IAddChild#AddText(System.String)
  - System.Windows.Controls.Control.Background
  - System.Windows.Controls.Control.BackgroundProperty
  - System.Windows.Controls.Control.BorderBrush
  - System.Windows.Controls.Control.BorderBrushProperty
  - System.Windows.Controls.Control.BorderThickness
  - System.Windows.Controls.Control.BorderThicknessProperty
  - System.Windows.Controls.Control.FontFamily
  - System.Windows.Controls.Control.FontFamilyProperty
  - System.Windows.Controls.Control.FontSize
  - System.Windows.Controls.Control.FontSizeProperty
  - System.Windows.Controls.Control.FontStretch
  - System.Windows.Controls.Control.FontStretchProperty
  - System.Windows.Controls.Control.FontStyle
  - System.Windows.Controls.Control.FontStyleProperty
  - System.Windows.Controls.Control.FontWeight
  - System.Windows.Controls.Control.FontWeightProperty
  - System.Windows.Controls.Control.Foreground
  - System.Windows.Controls.Control.ForegroundProperty
  - System.Windows.Controls.Control.HandlesScrolling
  - System.Windows.Controls.Control.HorizontalContentAlignment
  - System.Windows.Controls.Control.HorizontalContentAlignmentProperty
  - System.Windows.Controls.Control.IsTabStop
  - System.Windows.Controls.Control.IsTabStopProperty
  - System.Windows.Controls.Control.MouseDoubleClick
  - System.Windows.Controls.Control.MouseDoubleClickEvent
  - System.Windows.Controls.Control.OnMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.Controls.Control.OnPreviewMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)
  - System.Windows.Controls.Control.Padding
  - System.Windows.Controls.Control.PaddingProperty
  - System.Windows.Controls.Control.PreviewMouseDoubleClick
  - System.Windows.Controls.Control.PreviewMouseDoubleClickEvent
  - System.Windows.Controls.Control.TabIndex
  - System.Windows.Controls.Control.TabIndexProperty
  - System.Windows.Controls.Control.Template
  - System.Windows.Controls.Control.TemplateProperty
  - System.Windows.Controls.Control.ToString
  - System.Windows.Controls.Control.VerticalContentAlignment
  - System.Windows.Controls.Control.VerticalContentAlignmentProperty
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.FrameworkElement.ActualHeight
  - System.Windows.FrameworkElement.ActualHeightProperty
  - System.Windows.FrameworkElement.ActualWidth
  - System.Windows.FrameworkElement.ActualWidthProperty
  - System.Windows.FrameworkElement.AddLogicalChild(System.Object)
  - System.Windows.FrameworkElement.ApplyTemplate
  - System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)
  - System.Windows.FrameworkElement.BeginInit
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  - System.Windows.FrameworkElement.BindingGroup
  - System.Windows.FrameworkElement.BindingGroupProperty
  - System.Windows.FrameworkElement.BringIntoView
  - System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)
  - System.Windows.FrameworkElement.ContextMenu
  - System.Windows.FrameworkElement.ContextMenuClosing
  - System.Windows.FrameworkElement.ContextMenuClosingEvent
  - System.Windows.FrameworkElement.ContextMenuOpening
  - System.Windows.FrameworkElement.ContextMenuOpeningEvent
  - System.Windows.FrameworkElement.ContextMenuProperty
  - System.Windows.FrameworkElement.Cursor
  - System.Windows.FrameworkElement.CursorProperty
  - System.Windows.FrameworkElement.DataContext
  - System.Windows.FrameworkElement.DataContextChanged
  - System.Windows.FrameworkElement.DataContextProperty
  - System.Windows.FrameworkElement.DefaultStyleKey
  - System.Windows.FrameworkElement.DefaultStyleKeyProperty
  - System.Windows.FrameworkElement.EndInit
  - System.Windows.FrameworkElement.FindName(System.String)
  - System.Windows.FrameworkElement.FindResource(System.Object)
  - System.Windows.FrameworkElement.FlowDirection
  - System.Windows.FrameworkElement.FlowDirectionProperty
  - System.Windows.FrameworkElement.FocusVisualStyle
  - System.Windows.FrameworkElement.FocusVisualStyleProperty
  - System.Windows.FrameworkElement.ForceCursor
  - System.Windows.FrameworkElement.ForceCursorProperty
  - System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)
  - System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)
  - System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)
  - System.Windows.FrameworkElement.GetTemplateChild(System.String)
  - System.Windows.FrameworkElement.GetUIParentCore
  - System.Windows.FrameworkElement.GetVisualChild(System.Int32)
  - System.Windows.FrameworkElement.Height
  - System.Windows.FrameworkElement.HeightProperty
  - System.Windows.FrameworkElement.HorizontalAlignment
  - System.Windows.FrameworkElement.HorizontalAlignmentProperty
  - System.Windows.FrameworkElement.InheritanceBehavior
  - System.Windows.FrameworkElement.Initialized
  - System.Windows.FrameworkElement.InputScope
  - System.Windows.FrameworkElement.InputScopeProperty
  - System.Windows.FrameworkElement.IsInitialized
  - System.Windows.FrameworkElement.IsLoaded
  - System.Windows.FrameworkElement.Language
  - System.Windows.FrameworkElement.LanguageProperty
  - System.Windows.FrameworkElement.LayoutTransform
  - System.Windows.FrameworkElement.LayoutTransformProperty
  - System.Windows.FrameworkElement.Loaded
  - System.Windows.FrameworkElement.LoadedEvent
  - System.Windows.FrameworkElement.Margin
  - System.Windows.FrameworkElement.MarginProperty
  - System.Windows.FrameworkElement.MaxHeight
  - System.Windows.FrameworkElement.MaxHeightProperty
  - System.Windows.FrameworkElement.MaxWidth
  - System.Windows.FrameworkElement.MaxWidthProperty
  - System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)
  - System.Windows.FrameworkElement.MinHeight
  - System.Windows.FrameworkElement.MinHeightProperty
  - System.Windows.FrameworkElement.MinWidth
  - System.Windows.FrameworkElement.MinWidthProperty
  - System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)
  - System.Windows.FrameworkElement.Name
  - System.Windows.FrameworkElement.NameProperty
  - System.Windows.FrameworkElement.OnApplyTemplate
  - System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)
  - System.Windows.FrameworkElement.OnInitialized(System.EventArgs)
  - System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  - System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  - System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkElement.OverridesDefaultStyle
  - System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  - System.Windows.FrameworkElement.Parent
  - System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)
  - System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  - System.Windows.FrameworkElement.RegisterName(System.String,System.Object)
  - System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)
  - System.Windows.FrameworkElement.RequestBringIntoView
  - System.Windows.FrameworkElement.RequestBringIntoViewEvent
  - System.Windows.FrameworkElement.Resources
  - System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)
  - System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  - System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  - System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  - System.Windows.FrameworkElement.ShouldSerializeResources
  - System.Windows.FrameworkElement.ShouldSerializeStyle
  - System.Windows.FrameworkElement.ShouldSerializeTriggers
  - System.Windows.FrameworkElement.SizeChanged
  - System.Windows.FrameworkElement.SizeChangedEvent
  - System.Windows.FrameworkElement.SourceUpdated
  - System.Windows.FrameworkElement.Style
  - System.Windows.FrameworkElement.StyleProperty
  - System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.FrameworkElement.Tag
  - System.Windows.FrameworkElement.TagProperty
  - System.Windows.FrameworkElement.TargetUpdated
  - System.Windows.FrameworkElement.TemplatedParent
  - System.Windows.FrameworkElement.ToolTip
  - System.Windows.FrameworkElement.ToolTipClosing
  - System.Windows.FrameworkElement.ToolTipClosingEvent
  - System.Windows.FrameworkElement.ToolTipOpening
  - System.Windows.FrameworkElement.ToolTipOpeningEvent
  - System.Windows.FrameworkElement.ToolTipProperty
  - System.Windows.FrameworkElement.Triggers
  - System.Windows.FrameworkElement.TryFindResource(System.Object)
  - System.Windows.FrameworkElement.Unloaded
  - System.Windows.FrameworkElement.UnloadedEvent
  - System.Windows.FrameworkElement.UnregisterName(System.String)
  - System.Windows.FrameworkElement.UpdateDefaultStyle
  - System.Windows.FrameworkElement.UseLayoutRounding
  - System.Windows.FrameworkElement.UseLayoutRoundingProperty
  - System.Windows.FrameworkElement.VerticalAlignment
  - System.Windows.FrameworkElement.VerticalAlignmentProperty
  - System.Windows.FrameworkElement.VisualChildrenCount
  - System.Windows.FrameworkElement.Width
  - System.Windows.FrameworkElement.WidthProperty
  - System.Windows.Media.Visual.AddVisualChild(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.FindCommonVisualAncestor(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.IsAncestorOf(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.IsDescendantOf(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)
  - System.Windows.Media.Visual.PointFromScreen(System.Windows.Point)
  - System.Windows.Media.Visual.PointToScreen(System.Windows.Point)
  - System.Windows.Media.Visual.RemoveVisualChild(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Media3D.Visual3D)
  - System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToDescendant(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToVisual(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.VisualBitmapEffect
  - System.Windows.Media.Visual.VisualBitmapEffectInput
  - System.Windows.Media.Visual.VisualBitmapScalingMode
  - System.Windows.Media.Visual.VisualCacheMode
  - System.Windows.Media.Visual.VisualClearTypeHint
  - System.Windows.Media.Visual.VisualClip
  - System.Windows.Media.Visual.VisualEdgeMode
  - System.Windows.Media.Visual.VisualEffect
  - System.Windows.Media.Visual.VisualOffset
  - System.Windows.Media.Visual.VisualOpacity
  - System.Windows.Media.Visual.VisualOpacityMask
  - System.Windows.Media.Visual.VisualParent
  - System.Windows.Media.Visual.VisualScrollableAreaClip
  - System.Windows.Media.Visual.VisualTextHintingMode
  - System.Windows.Media.Visual.VisualTextRenderingMode
  - System.Windows.Media.Visual.VisualTransform
  - System.Windows.Media.Visual.VisualXSnappingGuidelines
  - System.Windows.Media.Visual.VisualYSnappingGuidelines
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  - System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  - System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.AllowDrop
  - System.Windows.UIElement.AllowDropProperty
  - System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.UIElement.AreAnyTouchesCaptured
  - System.Windows.UIElement.AreAnyTouchesCapturedProperty
  - System.Windows.UIElement.AreAnyTouchesCapturedWithin
  - System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty
  - System.Windows.UIElement.AreAnyTouchesDirectlyOver
  - System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty
  - System.Windows.UIElement.AreAnyTouchesOver
  - System.Windows.UIElement.AreAnyTouchesOverProperty
  - System.Windows.UIElement.Arrange(System.Windows.Rect)
  - System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.UIElement.BitmapEffect
  - System.Windows.UIElement.BitmapEffectInput
  - System.Windows.UIElement.BitmapEffectInputProperty
  - System.Windows.UIElement.BitmapEffectProperty
  - System.Windows.UIElement.CacheMode
  - System.Windows.UIElement.CacheModeProperty
  - System.Windows.UIElement.CaptureMouse
  - System.Windows.UIElement.CaptureStylus
  - System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)
  - System.Windows.UIElement.Clip
  - System.Windows.UIElement.ClipProperty
  - System.Windows.UIElement.ClipToBounds
  - System.Windows.UIElement.ClipToBoundsProperty
  - System.Windows.UIElement.CommandBindings
  - System.Windows.UIElement.DesiredSize
  - System.Windows.UIElement.DragEnter
  - System.Windows.UIElement.DragEnterEvent
  - System.Windows.UIElement.DragLeave
  - System.Windows.UIElement.DragLeaveEvent
  - System.Windows.UIElement.DragOver
  - System.Windows.UIElement.DragOverEvent
  - System.Windows.UIElement.Drop
  - System.Windows.UIElement.DropEvent
  - System.Windows.UIElement.Effect
  - System.Windows.UIElement.EffectProperty
  - System.Windows.UIElement.Focus
  - System.Windows.UIElement.Focusable
  - System.Windows.UIElement.FocusableChanged
  - System.Windows.UIElement.FocusableProperty
  - System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.UIElement.GiveFeedback
  - System.Windows.UIElement.GiveFeedbackEvent
  - System.Windows.UIElement.GotFocus
  - System.Windows.UIElement.GotFocusEvent
  - System.Windows.UIElement.GotKeyboardFocus
  - System.Windows.UIElement.GotKeyboardFocusEvent
  - System.Windows.UIElement.GotMouseCapture
  - System.Windows.UIElement.GotMouseCaptureEvent
  - System.Windows.UIElement.GotStylusCapture
  - System.Windows.UIElement.GotStylusCaptureEvent
  - System.Windows.UIElement.GotTouchCapture
  - System.Windows.UIElement.GotTouchCaptureEvent
  - System.Windows.UIElement.HasAnimatedProperties
  - System.Windows.UIElement.HasEffectiveKeyboardFocus
  - System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)
  - System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)
  - System.Windows.UIElement.InputBindings
  - System.Windows.UIElement.InputHitTest(System.Windows.Point)
  - System.Windows.UIElement.InvalidateArrange
  - System.Windows.UIElement.InvalidateMeasure
  - System.Windows.UIElement.InvalidateVisual
  - System.Windows.UIElement.IsArrangeValid
  - System.Windows.UIElement.IsEnabled
  - System.Windows.UIElement.IsEnabledChanged
  - System.Windows.UIElement.IsEnabledCore
  - System.Windows.UIElement.IsEnabledProperty
  - System.Windows.UIElement.IsFocused
  - System.Windows.UIElement.IsFocusedProperty
  - System.Windows.UIElement.IsHitTestVisible
  - System.Windows.UIElement.IsHitTestVisibleChanged
  - System.Windows.UIElement.IsHitTestVisibleProperty
  - System.Windows.UIElement.IsInputMethodEnabled
  - System.Windows.UIElement.IsKeyboardFocused
  - System.Windows.UIElement.IsKeyboardFocusedChanged
  - System.Windows.UIElement.IsKeyboardFocusedProperty
  - System.Windows.UIElement.IsKeyboardFocusWithin
  - System.Windows.UIElement.IsKeyboardFocusWithinChanged
  - System.Windows.UIElement.IsKeyboardFocusWithinProperty
  - System.Windows.UIElement.IsManipulationEnabled
  - System.Windows.UIElement.IsManipulationEnabledProperty
  - System.Windows.UIElement.IsMeasureValid
  - System.Windows.UIElement.IsMouseCaptured
  - System.Windows.UIElement.IsMouseCapturedChanged
  - System.Windows.UIElement.IsMouseCapturedProperty
  - System.Windows.UIElement.IsMouseCaptureWithin
  - System.Windows.UIElement.IsMouseCaptureWithinChanged
  - System.Windows.UIElement.IsMouseCaptureWithinProperty
  - System.Windows.UIElement.IsMouseDirectlyOver
  - System.Windows.UIElement.IsMouseDirectlyOverChanged
  - System.Windows.UIElement.IsMouseDirectlyOverProperty
  - System.Windows.UIElement.IsMouseOver
  - System.Windows.UIElement.IsMouseOverProperty
  - System.Windows.UIElement.IsStylusCaptured
  - System.Windows.UIElement.IsStylusCapturedChanged
  - System.Windows.UIElement.IsStylusCapturedProperty
  - System.Windows.UIElement.IsStylusCaptureWithin
  - System.Windows.UIElement.IsStylusCaptureWithinChanged
  - System.Windows.UIElement.IsStylusCaptureWithinProperty
  - System.Windows.UIElement.IsStylusDirectlyOver
  - System.Windows.UIElement.IsStylusDirectlyOverChanged
  - System.Windows.UIElement.IsStylusDirectlyOverProperty
  - System.Windows.UIElement.IsStylusOver
  - System.Windows.UIElement.IsStylusOverProperty
  - System.Windows.UIElement.IsVisible
  - System.Windows.UIElement.IsVisibleChanged
  - System.Windows.UIElement.IsVisibleProperty
  - System.Windows.UIElement.KeyDown
  - System.Windows.UIElement.KeyDownEvent
  - System.Windows.UIElement.KeyUp
  - System.Windows.UIElement.KeyUpEvent
  - System.Windows.UIElement.LayoutUpdated
  - System.Windows.UIElement.LostFocus
  - System.Windows.UIElement.LostFocusEvent
  - System.Windows.UIElement.LostKeyboardFocus
  - System.Windows.UIElement.LostKeyboardFocusEvent
  - System.Windows.UIElement.LostMouseCapture
  - System.Windows.UIElement.LostMouseCaptureEvent
  - System.Windows.UIElement.LostStylusCapture
  - System.Windows.UIElement.LostStylusCaptureEvent
  - System.Windows.UIElement.LostTouchCapture
  - System.Windows.UIElement.LostTouchCaptureEvent
  - System.Windows.UIElement.ManipulationBoundaryFeedback
  - System.Windows.UIElement.ManipulationBoundaryFeedbackEvent
  - System.Windows.UIElement.ManipulationCompleted
  - System.Windows.UIElement.ManipulationCompletedEvent
  - System.Windows.UIElement.ManipulationDelta
  - System.Windows.UIElement.ManipulationDeltaEvent
  - System.Windows.UIElement.ManipulationInertiaStarting
  - System.Windows.UIElement.ManipulationInertiaStartingEvent
  - System.Windows.UIElement.ManipulationStarted
  - System.Windows.UIElement.ManipulationStartedEvent
  - System.Windows.UIElement.ManipulationStarting
  - System.Windows.UIElement.ManipulationStartingEvent
  - System.Windows.UIElement.Measure(System.Windows.Size)
  - System.Windows.UIElement.MouseDown
  - System.Windows.UIElement.MouseDownEvent
  - System.Windows.UIElement.MouseEnter
  - System.Windows.UIElement.MouseEnterEvent
  - System.Windows.UIElement.MouseLeave
  - System.Windows.UIElement.MouseLeaveEvent
  - System.Windows.UIElement.MouseLeftButtonDown
  - System.Windows.UIElement.MouseLeftButtonDownEvent
  - System.Windows.UIElement.MouseLeftButtonUp
  - System.Windows.UIElement.MouseLeftButtonUpEvent
  - System.Windows.UIElement.MouseMove
  - System.Windows.UIElement.MouseMoveEvent
  - System.Windows.UIElement.MouseRightButtonDown
  - System.Windows.UIElement.MouseRightButtonDownEvent
  - System.Windows.UIElement.MouseRightButtonUp
  - System.Windows.UIElement.MouseRightButtonUpEvent
  - System.Windows.UIElement.MouseUp
  - System.Windows.UIElement.MouseUpEvent
  - System.Windows.UIElement.MouseWheel
  - System.Windows.UIElement.MouseWheelEvent
  - System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)
  - System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)
  - System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)
  - System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)
  - System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)
  - System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)
  - System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)
  - System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  - System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)
  - System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.Opacity
  - System.Windows.UIElement.OpacityMask
  - System.Windows.UIElement.OpacityMaskProperty
  - System.Windows.UIElement.OpacityProperty
  - System.Windows.UIElement.PersistId
  - System.Windows.UIElement.PreviewDragEnter
  - System.Windows.UIElement.PreviewDragEnterEvent
  - System.Windows.UIElement.PreviewDragLeave
  - System.Windows.UIElement.PreviewDragLeaveEvent
  - System.Windows.UIElement.PreviewDragOver
  - System.Windows.UIElement.PreviewDragOverEvent
  - System.Windows.UIElement.PreviewDrop
  - System.Windows.UIElement.PreviewDropEvent
  - System.Windows.UIElement.PreviewGiveFeedback
  - System.Windows.UIElement.PreviewGiveFeedbackEvent
  - System.Windows.UIElement.PreviewGotKeyboardFocus
  - System.Windows.UIElement.PreviewGotKeyboardFocusEvent
  - System.Windows.UIElement.PreviewKeyDown
  - System.Windows.UIElement.PreviewKeyDownEvent
  - System.Windows.UIElement.PreviewKeyUp
  - System.Windows.UIElement.PreviewKeyUpEvent
  - System.Windows.UIElement.PreviewLostKeyboardFocus
  - System.Windows.UIElement.PreviewLostKeyboardFocusEvent
  - System.Windows.UIElement.PreviewMouseDown
  - System.Windows.UIElement.PreviewMouseDownEvent
  - System.Windows.UIElement.PreviewMouseLeftButtonDown
  - System.Windows.UIElement.PreviewMouseLeftButtonDownEvent
  - System.Windows.UIElement.PreviewMouseLeftButtonUp
  - System.Windows.UIElement.PreviewMouseLeftButtonUpEvent
  - System.Windows.UIElement.PreviewMouseMove
  - System.Windows.UIElement.PreviewMouseMoveEvent
  - System.Windows.UIElement.PreviewMouseRightButtonDown
  - System.Windows.UIElement.PreviewMouseRightButtonDownEvent
  - System.Windows.UIElement.PreviewMouseRightButtonUp
  - System.Windows.UIElement.PreviewMouseRightButtonUpEvent
  - System.Windows.UIElement.PreviewMouseUp
  - System.Windows.UIElement.PreviewMouseUpEvent
  - System.Windows.UIElement.PreviewMouseWheel
  - System.Windows.UIElement.PreviewMouseWheelEvent
  - System.Windows.UIElement.PreviewQueryContinueDrag
  - System.Windows.UIElement.PreviewQueryContinueDragEvent
  - System.Windows.UIElement.PreviewStylusButtonDown
  - System.Windows.UIElement.PreviewStylusButtonDownEvent
  - System.Windows.UIElement.PreviewStylusButtonUp
  - System.Windows.UIElement.PreviewStylusButtonUpEvent
  - System.Windows.UIElement.PreviewStylusDown
  - System.Windows.UIElement.PreviewStylusDownEvent
  - System.Windows.UIElement.PreviewStylusInAirMove
  - System.Windows.UIElement.PreviewStylusInAirMoveEvent
  - System.Windows.UIElement.PreviewStylusInRange
  - System.Windows.UIElement.PreviewStylusInRangeEvent
  - System.Windows.UIElement.PreviewStylusMove
  - System.Windows.UIElement.PreviewStylusMoveEvent
  - System.Windows.UIElement.PreviewStylusOutOfRange
  - System.Windows.UIElement.PreviewStylusOutOfRangeEvent
  - System.Windows.UIElement.PreviewStylusSystemGesture
  - System.Windows.UIElement.PreviewStylusSystemGestureEvent
  - System.Windows.UIElement.PreviewStylusUp
  - System.Windows.UIElement.PreviewStylusUpEvent
  - System.Windows.UIElement.PreviewTextInput
  - System.Windows.UIElement.PreviewTextInputEvent
  - System.Windows.UIElement.PreviewTouchDown
  - System.Windows.UIElement.PreviewTouchDownEvent
  - System.Windows.UIElement.PreviewTouchMove
  - System.Windows.UIElement.PreviewTouchMoveEvent
  - System.Windows.UIElement.PreviewTouchUp
  - System.Windows.UIElement.PreviewTouchUpEvent
  - System.Windows.UIElement.QueryContinueDrag
  - System.Windows.UIElement.QueryContinueDragEvent
  - System.Windows.UIElement.QueryCursor
  - System.Windows.UIElement.QueryCursorEvent
  - System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.ReleaseAllTouchCaptures
  - System.Windows.UIElement.ReleaseMouseCapture
  - System.Windows.UIElement.ReleaseStylusCapture
  - System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  - System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.UIElement.RenderSize
  - System.Windows.UIElement.RenderTransform
  - System.Windows.UIElement.RenderTransformOrigin
  - System.Windows.UIElement.RenderTransformOriginProperty
  - System.Windows.UIElement.RenderTransformProperty
  - System.Windows.UIElement.ShouldSerializeCommandBindings
  - System.Windows.UIElement.ShouldSerializeInputBindings
  - System.Windows.UIElement.SnapsToDevicePixels
  - System.Windows.UIElement.SnapsToDevicePixelsProperty
  - System.Windows.UIElement.StylusButtonDown
  - System.Windows.UIElement.StylusButtonDownEvent
  - System.Windows.UIElement.StylusButtonUp
  - System.Windows.UIElement.StylusButtonUpEvent
  - System.Windows.UIElement.StylusDown
  - System.Windows.UIElement.StylusDownEvent
  - System.Windows.UIElement.StylusEnter
  - System.Windows.UIElement.StylusEnterEvent
  - System.Windows.UIElement.StylusInAirMove
  - System.Windows.UIElement.StylusInAirMoveEvent
  - System.Windows.UIElement.StylusInRange
  - System.Windows.UIElement.StylusInRangeEvent
  - System.Windows.UIElement.StylusLeave
  - System.Windows.UIElement.StylusLeaveEvent
  - System.Windows.UIElement.StylusMove
  - System.Windows.UIElement.StylusMoveEvent
  - System.Windows.UIElement.StylusOutOfRange
  - System.Windows.UIElement.StylusOutOfRangeEvent
  - System.Windows.UIElement.StylusPlugIns
  - System.Windows.UIElement.StylusSystemGesture
  - System.Windows.UIElement.StylusSystemGestureEvent
  - System.Windows.UIElement.StylusUp
  - System.Windows.UIElement.StylusUpEvent
  - System.Windows.UIElement.TextInput
  - System.Windows.UIElement.TextInputEvent
  - System.Windows.UIElement.TouchDown
  - System.Windows.UIElement.TouchDownEvent
  - System.Windows.UIElement.TouchEnter
  - System.Windows.UIElement.TouchEnterEvent
  - System.Windows.UIElement.TouchesCaptured
  - System.Windows.UIElement.TouchesCapturedWithin
  - System.Windows.UIElement.TouchesDirectlyOver
  - System.Windows.UIElement.TouchesOver
  - System.Windows.UIElement.TouchLeave
  - System.Windows.UIElement.TouchLeaveEvent
  - System.Windows.UIElement.TouchMove
  - System.Windows.UIElement.TouchMoveEvent
  - System.Windows.UIElement.TouchUp
  - System.Windows.UIElement.TouchUpEvent
  - System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)
  - System.Windows.UIElement.Uid
  - System.Windows.UIElement.UidProperty
  - System.Windows.UIElement.UpdateLayout
  - System.Windows.UIElement.Visibility
  - System.Windows.UIElement.VisibilityProperty
  platform:
  - net462
- uid: System.Windows.Window.#ctor
  id: '#ctor'
  parent: System.Windows.Window
  langs:
  - csharp
  name: Window()
  nameWithType: Window.Window()
  fullName: System.Windows.Window.Window()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Windows.Window&quot;> </xref> 클래스입니다."
  remarks: "생성자가 초기화 하는 <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.Window.Top%2A>, 및 <xref:System.Windows.Window.Left%2A>속성을 기본 <xref:System.Windows.Window>값.</xref:System.Windows.Window> </xref:System.Windows.Window.Left%2A> </xref:System.Windows.Window.Top%2A> </xref:System.Windows.FrameworkElement.Height%2A> </xref:System.Windows.FrameworkElement.Width%2A>       창 내에서 만들어진 경우는 <xref:System.AppDomain>있는 <xref:System.Windows.Application>개체를 추가 하는 생성자는 <xref:System.Windows.Window>개체 집합에 <xref:System.Windows.Application>-관리를 통해 windows는 <xref:System.Windows.Application.Windows%2A>속성의는 <xref:System.Windows.Application>개체.</xref:System.Windows.Application> </xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Application> </xref:System.Windows.Window> </xref:System.Windows.Application> </xref:System.AppDomain>"
  syntax:
    content: public Window ();
    parameters: []
  overload: System.Windows.Window.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Activate
  id: Activate
  parent: System.Windows.Window
  langs:
  - csharp
  name: Activate()
  nameWithType: Window.Activate()
  fullName: System.Windows.Window.Activate()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창을를 포그라운드로 전환 하 고 활성화 합니다."
  remarks: "창이 활성화 여부를 결정 하는 규칙에서 사용 하는 것과 동일는 [!INCLUDE[TLA2#tla_win32](~/add/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` 함수 (User32.dll).       창에 활성화 된 경우에 [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] 아닌 응용 프로그램 사용자의 전경 응용 <xref:System.Windows.Application.Activated>이벤트가 발생 합니다.</xref:System.Windows.Application.Activated>      > [!NOTE] > 창이 브라우저에서 호스팅될 때이 메서드를 호출할 수 없습니다."
  syntax:
    content: public bool Activate ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우는 <xref href=&quot;System.Windows.Window&quot;> </xref> 성공적으로 활성화 되 고, 그러지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.Window.Activate*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Activated
  id: Activated
  parent: System.Windows.Window
  langs:
  - csharp
  name: Activated
  nameWithType: Window.Activated
  fullName: System.Windows.Window.Activated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창이 전경 창이 되 면 발생 합니다."
  remarks: "창이 활성화 될 (전경 창이 되) 경우:-창이 처음 열릴 합니다.      -ALT + TAB을 눌러 마우스를 사용 하거나 작업 관리자에서 선택 하 여 사용자는 창으로 전환 합니다.      -사용자가 창의 작업 표시줄 단추를 클릭 합니다.       활성화 되는 경우를 감지 해야 하는 Windows Activated 이벤트를 처리할 수 있습니다.       창이 처음 활성화 된 후 비활성화 하 고 해당 수명 동안 여러 번 다시 활성화 될 수 있습니다. 응용 프로그램의 동작 또는 상태는 정품 인증 상태에 따라 달라 지, <xref:System.Windows.Window.IsActive%2A>인치의 활성화 상태를 확인 하려면</xref:System.Windows.Window.IsActive%2A> 을 검사할 수 것       응용 프로그램 <xref:System.Windows.Application.Activated>입니다.</xref:System.Windows.Application.Activated> 될 수도 있습니다."
  syntax:
    content: public event EventHandler Activated;
    return:
      type: System.EventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.AllowsTransparency
  id: AllowsTransparency
  parent: System.Windows.Window
  langs:
  - csharp
  name: AllowsTransparency
  nameWithType: Window.AllowsTransparency
  fullName: System.Windows.Window.AllowsTransparency
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창의 클라이언트 영역 투명도 지원 하는지 여부를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "경우는 <xref:System.Windows.Controls.Control.Background%2A>창의 속성을 투명 한 색을 사용 하 여 <xref:System.Windows.Media.Brushes.Transparent%2A>예를 들어 창을 불투명 하 게 유지.</xref:System.Windows.Media.Brushes.Transparent%2A> </xref:System.Windows.Controls.Control.Background%2A> 즉, 바탕 화면 및 &quot;beneath&quot; 창의 실행 중인 응용 프로그램을 볼 수 없습니다. 이러한 종류의 투명도 사용 하도록 설정 하려면 AllowsTransparency로 설정 해야 `true`합니다.       AllowsTransparency의 사각형이 아닌 창 편리 하 게 존재 및 AllowsTransparency로 설정 된 경우에 따라서 `true`, 창의 <xref:System.Windows.Window.WindowStyle%2A> <xref:System.Windows.WindowStyle>.</xref:System.Windows.WindowStyle> 속성을 설정 해야 합니다</xref:System.Windows.Window.WindowStyle%2A>      <a name=&quot;dependencyPropertyInfo_WindowAllowsTransparency&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.Window.AllowsTransparencyProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.Window.AllowsTransparencyProperty>"
  syntax:
    content: public bool AllowsTransparency { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>창에서 투명도; 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.Window.AllowsTransparency*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "창에는 <xref:System.Windows.Window.WindowStyle*>아닌 값 <xref href=&quot;System.Windows.WindowStyle&quot;> </xref>.</xref:System.Windows.Window.WindowStyle*>"
  platform:
  - net462
- uid: System.Windows.Window.AllowsTransparencyProperty
  id: AllowsTransparencyProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: AllowsTransparencyProperty
  nameWithType: Window.AllowsTransparencyProperty
  fullName: System.Windows.Window.AllowsTransparencyProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.Window.AllowsTransparency*>종속성 속성입니다.</xref:System.Windows.Window.AllowsTransparency*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.ArrangeOverride(System.Windows.Size)
  id: ArrangeOverride(System.Windows.Size)
  parent: System.Windows.Window
  langs:
  - csharp
  name: ArrangeOverride(Size)
  nameWithType: Window.ArrangeOverride(Size)
  fullName: System.Windows.Window.ArrangeOverride(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "정렬 하 고 창 및 해당 자식 요소의 크기이 메서드를 재정의 합니다."
  remarks: "ArrangeOverride 호출 되지 않습니다 <xref:System.Windows.UIElement.Visibility%2A>속성 <xref:System.Windows.Visibility>안내 하십시오.</xref:System.Windows.Visibility> 값은</xref:System.Windows.UIElement.Visibility%2A> 하는 경우의 값은 <xref:System.Windows.UIElement.Visibility%2A>속성이 <xref:System.Windows.Visibility>또는 <xref:System.Windows.Visibility>, ArrangeOverride 호출 됩니다.</xref:System.Windows.Visibility> </xref:System.Windows.Visibility> </xref:System.Windows.UIElement.Visibility%2A>      > [!NOTE] > 때 중 하나 <xref:System.Windows.Window.Show%2A> <xref:System.Windows.Window.ShowDialog%2A>호출 <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Window> <xref:System.Windows.Visibility>.</xref:System.Windows.Visibility> </xref:System.Windows.Window> 의 속성</xref:System.Windows.UIElement.Visibility%2A> </xref:System.Windows.Window.ShowDialog%2A> 또는</xref:System.Windows.Window.Show%2A>"
  syntax:
    content: protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);
    parameters:
    - id: arrangeBounds
      type: System.Windows.Size
      description: "A <xref href=&quot;System.Windows.Size&quot;> </xref> 창이 자신과 자식을 정렬 하는 데 사용 해야 하 고 최종 크기를 반영 하 합니다."
    return:
      type: System.Windows.Size
      description: "A <xref href=&quot;System.Windows.Size&quot;> </xref> 하는 데 사용 된 실제 크기를 반영 합니다."
  overload: System.Windows.Window.ArrangeOverride*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Close
  id: Close
  parent: System.Windows.Window
  langs:
  - csharp
  name: Close()
  nameWithType: Window.Close()
  fullName: System.Windows.Window.Close()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "수동으로 닫습니다는 <xref href=&quot;System.Windows.Window&quot;> </xref>합니다."
  remarks: "A <xref:System.Windows.Window>, 여러 가지 방법 중 하나를 사용 하 여 닫아야 잘 알려진 시스템 제공 메커니즘 제목 표시줄을 포함 하 여에 있는:-ALT + f&4;.</xref:System.Windows.Window>      -시스템 메뉴 | **Close**.      - **닫기** 단추입니다.       포함 하 여 개발자가 제공 하는 클라이언트 영역 내에서 잘 알려진 몇 가지 메커니즘 중 하나를 사용 하는 <xref:System.Windows.Window>닫을 수도 있습니다.- **파일** | **종료** 주 창에서.</xref:System.Windows.Window>      -   **File** | **닫기** 또는 **닫기** 자식 창에서 단추입니다.      > [!NOTE]  >   **확인** 및 **취소** 대화 상자 단추는 또한 개발자가 제공한, 있지만 <xref:System.Windows.Window.DialogResult%2A> <xref:System.Windows.Window.ShowDialog%2A>.</xref:System.Windows.Window.ShowDialog%2A> 를 호출 하 여 열린 창이 자동으로 닫는,</xref:System.Windows.Window.DialogResult%2A> 설정 됩니다       이러한 메커니즘에 명시적으로 창을 닫으려면 Close를 호출 해야 합니다.      > [!NOTE] > 창에서 호출 하 여 열린 경우 <xref:System.Windows.Window.ShowDialog%2A>, 및는 <xref:System.Windows.Controls.Button>와 해당 <xref:System.Windows.Controls.Button.IsCancel%2A>단추를 클릭 하거나, 또는 esc 키를 누를 때에 자동으로 속성이 true로 설정 닫힙니다.</xref:System.Windows.Controls.Button.IsCancel%2A> </xref:System.Windows.Controls.Button> </xref:System.Windows.Window.ShowDialog%2A> <xref:System.Windows.Window.Show%2A>그러나 닫기 해야 명시적으로 호출 되는 등 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> <xref:System.Windows.Controls.Button>.</xref:System.Windows.Controls.Button> 에 대 한 이벤트 처리기</xref:System.Windows.Controls.Primitives.ButtonBase.Click> 의 경우와 마찬가지로,</xref:System.Windows.Window.Show%2A> 사용 하 여 창이 열린 경우       창을 닫으면는 <xref:System.Windows.Window.Closing>이벤트를 발생 합니다.</xref:System.Windows.Window.Closing> 경우는 <xref:System.Windows.Window.Closing>이벤트는 다음과 같은 결과가 발생 취소 하지 않으면:- <xref:System.Windows.Window>에서 제거 <xref:System.Windows.Application.Windows%2A?displayProperty=fullName>(경우는 <xref:System.Windows.Application>개체가 있습니다).</xref:System.Windows.Application> </xref:System.Windows.Application.Windows%2A?displayProperty=fullName> </xref:System.Windows.Window> </xref:System.Windows.Window.Closing>      - <xref:System.Windows.Window>소유자에서 제거 됩니다 <xref:System.Windows.Window>소유자/소유 관계가 설정 된 경우 소유 된 전에 <xref:System.Windows.Window>표시 된 소유자 후 <xref:System.Windows.Window>열린.</xref:System.Windows.Window> </xref:System.Windows.Window> </xref:System.Windows.Window> </xref:System.Windows.Window>      - <xref:System.Windows.Window.Closed>이벤트가 발생 합니다.</xref:System.Windows.Window.Closed>      -관리 되지 않는 리소스를에서 만든는 <xref:System.Windows.Window>삭제 됩니다.</xref:System.Windows.Window>      -If <xref:System.Windows.Window.ShowDialog%2A>이 호출 되어 표시를 <xref:System.Windows.Window>, <xref:System.Windows.Window.ShowDialog%2A>반환 합니다.</xref:System.Windows.Window.ShowDialog%2A> </xref:System.Windows.Window> </xref:System.Windows.Window.ShowDialog%2A>       닫기는 <xref:System.Windows.Window>닫힌다고 소유 하는 모든 창이.</xref:System.Windows.Window> 또한 닫기는 <xref:System.Windows.Window>방식에 따라 실행이 중지 될 수 있습니다 <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=fullName>속성을 설정 합니다.</xref:System.Windows.Application.ShutdownMode%2A?displayProperty=fullName> </xref:System.Windows.Window>      > [!NOTE] > 창이 브라우저에서 호스팅될 때이 메서드를 호출할 수 없습니다."
  example:
  - "The following example shows a **File** &#124; **Exit** menu being handled to explicitly call Close.  \n  \n [!code-xml[WindowCloseSnippets#WindowCloseXAML](~/add/codesnippet/xaml/WindowCloseSnippets.CSharp/MainWindow.xaml#windowclosexaml)]  \n  \n [!code-cs[WindowCloseSnippets#WindowCloseCODEBEHIND](~/add/codesnippet/csharp/WindowCloseSnippets.CSharp/MainWindow.xaml.cs#windowclosecodebehind)]\n [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/add/codesnippet/visualbasic/windowclosesnippets/mainwindow.xaml.vb#windowclosecodebehind)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Windows.Window.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Closed
  id: Closed
  parent: System.Windows.Window
  langs:
  - csharp
  name: Closed
  nameWithType: Window.Closed
  fullName: System.Windows.Window.Closed
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창을 닫으려면 되려고 할 때 발생 합니다."
  remarks: "이 이벤트는 발생 되 면 창은 닫는에서 제한할 수 없습니다."
  syntax:
    content: public event EventHandler Closed;
    return:
      type: System.EventHandler
      description: "추가할 수 있습니다."
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<>*>으로 설정 또는 <> </> *>, <> </> *>, 또는 <> </> *> 창을 닫는 동안에 호출 됩니다."
  platform:
  - net462
- uid: System.Windows.Window.Closing
  id: Closing
  parent: System.Windows.Window
  langs:
  - csharp
  name: Closing
  nameWithType: Window.Closing
  fullName: System.Windows.Window.Closing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "바로 뒤에 오는 <xref:System.Windows.Window.Close*>호출 되 고 창 닫기를 취소 하도록 처리할 수 있습니다.</xref:System.Windows.Window.Close*>"
  remarks: "닫는 검색 창의 닫을 때 처리 될 수 있습니다 (예를 들어 때 <xref:System.Windows.Window.Close%2A>라고).</xref:System.Windows.Window.Close%2A> 또한 창을 닫지 않으려면 닫는 사용할 수 있습니다. 창을를 닫지 않으려면 설정할 수 있습니다는 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A>의 속성은 <xref:System.ComponentModel.CancelEventArgs>인수를 `true`.</xref:System.ComponentModel.CancelEventArgs> </xref:System.ComponentModel.CancelEventArgs.Cancel%2A>       닫는 이벤트가 발생할 때 <xref:System.Windows.Window.Close%2A>창의 닫기 단추를 클릭 하면 또는 ALT + F4 키를 누를 경우 호출 됩니다.</xref:System.Windows.Window.Close%2A>       소유 된 창을 사용 하 여 해당 소유자 창에서 열린 경우 <xref:System.Windows.Window.Show%2A>, 및 소유자 창이 닫혀 있는, 소유 된 창 Closing 이벤트를 발생 하지 않습니다.</xref:System.Windows.Window.Show%2A> 창의 소유자 닫혀 있으면 (참조 <xref:System.Windows.Window.Owner%2A>), 닫는 소유 된 창에서 발생 하지 않습니다.</xref:System.Windows.Window.Owner%2A>       경우 <xref:System.Windows.Application.Shutdown%2A>호출 되 고 Closing 이벤트 발생 각 창에 대 한.</xref:System.Windows.Application.Shutdown%2A> 그러나 닫는 취소 되는 경우 취소는 무시 됩니다.       사용자가 로그 오프 하거나 종료 되는 세션이 종료, 닫는 발생 하지 않습니다. 처리 <xref:System.Windows.Application.SessionEnding>응용 프로그램 종료를 취소 하는 코드를 구현 합니다.</xref:System.Windows.Application.SessionEnding>       표시 하 고 응용 프로그램의 수명 동안 여러 번 창이 숨길 하 고 창을 표시 하면 때마다 다시 인스턴스화하 하지 않을 경우 Closing 이벤트를 처리, 취소를 호출할 수 있습니다는 <xref:System.Windows.Window.Hide%2A>메서드.</xref:System.Windows.Window.Hide%2A> 그런 다음 <xref:System.Windows.Window.Show%2A>다시 합니다. 동일한 인스턴스에 대해</xref:System.Windows.Window.Show%2A> 호출할 수 있습니다."
  example:
  - "The following example demonstrates a <xref:System.Windows.Window> that determines whether it needs user intervention to close.  \n  \n [!code-xml[WindowClosingSnippets#WindowClosingXAML1](~/add/codesnippet/xaml/WindowClosingSnippets.CSharp/DataWindow.xaml#windowclosingxaml1)]  \n[!code-xml[WindowClosingSnippets#WindowClosingXAML2](~/add/codesnippet/xaml/WindowClosingSnippets.CSharp/DataWindow.xaml#windowclosingxaml2)]  \n  \n [!code-cs[WindowClosingSnippets#WindowClosingCODEBEHIND1](~/add/codesnippet/csharp/WindowClosingSnippets.CSharp/DataWindow.xaml.cs#windowclosingcodebehind1)]\n [!code-vb[WindowClosingSnippets#WindowClosingCODEBEHIND1](~/add/codesnippet/visualbasic/windowclosingsnippets/datawindow.xaml.vb#windowclosingcodebehind1)]  \n[!code-cs[WindowClosingSnippets#WindowClosingCODEBEHIND2](~/add/codesnippet/csharp/WindowClosingSnippets.CSharp/DataWindow.xaml.cs#windowclosingcodebehind2)]\n[!code-vb[WindowClosingSnippets#WindowClosingCODEBEHIND2](~/add/codesnippet/visualbasic/windowclosingsnippets/datawindow.xaml.vb#windowclosingcodebehind2)]"
  syntax:
    content: public event System.ComponentModel.CancelEventHandler Closing;
    return:
      type: System.ComponentModel.CancelEventHandler
      description: "추가할 수 있습니다."
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<>*>으로 설정 또는 <> </> *>, <> </> *>, 또는 <> </> *> 창을 닫는 동안에 호출 됩니다."
  platform:
  - net462
- uid: System.Windows.Window.ContentRendered
  id: ContentRendered
  parent: System.Windows.Window
  langs:
  - csharp
  name: ContentRendered
  nameWithType: Window.ContentRendered
  fullName: System.Windows.Window.ContentRendered
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창의 콘텐츠가 렌더링 된 후 발생 합니다."
  remarks: "창에 콘텐츠가 없는 경우이 이벤트가 발생 하지 않습니다."
  syntax:
    content: public event EventHandler ContentRendered;
    return:
      type: System.EventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Deactivated
  id: Deactivated
  parent: System.Windows.Window
  langs:
  - csharp
  name: Deactivated
  nameWithType: Window.Deactivated
  fullName: System.Windows.Window.Deactivated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창이 배경 창이 되 면 발생 합니다."
  remarks: "비활성화 됩니다 (배경 창이 되) 경우:-현재 응용 프로그램의 다른 창으로 전환 합니다.      -사용자가 ALT + TAB을 사용 하 여 또는 작업 관리자를 사용 하 여 다른 응용 프로그램의 창으로 전환 합니다.      -사용자가 다른 응용 프로그램의 창에 대 한 작업 표시줄 단추를 클릭 합니다.       Deactivated 이벤트를 처리 하 여 비활성화 될 경우를 감지 하는 창입니다.       창이 처음 비활성화 된 후 다시 활성화 하 고 해당 수명 동안 여러 번 비활성화 될 수 있습니다. 응용 프로그램의 동작 또는 상태는 정품 인증 상태에 따라 달라 지, <xref:System.Windows.Window.IsActive%2A>인치의 활성화 상태를 확인 하려면</xref:System.Windows.Window.IsActive%2A> 을 검사할 수 것       응용 프로그램 <xref:System.Windows.Application.Deactivated>입니다.</xref:System.Windows.Application.Deactivated> 될 수도 있습니다."
  syntax:
    content: public event EventHandler Deactivated;
    return:
      type: System.EventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.DialogResult
  id: DialogResult
  parent: System.Windows.Window
  langs:
  - csharp
  name: DialogResult
  nameWithType: Window.DialogResult
  fullName: System.Windows.Window.DialogResult
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "반환 되는 값은 다음 대화 상자 결과 값을 가져오거나 설정 합니다.는 <xref:System.Windows.Window.ShowDialog*>메서드.</xref:System.Windows.Window.ShowDialog*>"
  remarks: "DialogResult 사용자 허용 하는지 여부를 확인 하려면 대화 상자를 표시 하는 코드에서 사용할 수 있습니다 (`true`) 또는 취소 (`false`) 대화 상자. 대화 상자, 허용 되 면이 열은 대화 상자를 사용자에 의해 수집 된 데이터를 검색 하 고 처리 하는 코드를 의미 합니다. 그러나 대화 상자를 취소 되 면 것을 의미는 코드를 호출 해야 처리를 중지 합니다.       대화 상자는 사용자가 다음 중 하나를 수행 하는 경우 기본적으로 취소:-PressesALT + f&4;입니다.      -가 **닫기** 단추입니다.      -선택 **닫기** 시스템 메뉴에서 합니다.       모든이 경우에서 DialogResult는 `false` 기본적으로 합니다.       대화 상자 단추로 사용 되는 대화 상자를 취소 하는 특수 단추는 일반적으로 제공 된 <xref:System.Windows.Controls.Button.IsCancel%2A>속성이 `true`.</xref:System.Windows.Controls.Button.IsCancel%2A> 이러한 방식으로 구성 하는 단추를 자동으로 닫힙니다 창을 누른 하거나 때나 ESC 키를 누를 때. 두이 경우 모두에서 DialogResult 남아 `false`합니다.       대화 상자에는 일반적으로 단추의 적용 단추, 제공 된 <xref:System.Windows.Controls.Button.IsDefault%2A>속성이로 설정 되어 `true`.</xref:System.Windows.Controls.Button.IsDefault%2A> 이러한 방식으로 구성 하는 단추에서 발생 하는 해당 <xref:System.Windows.Controls.Primitives.ButtonBase.Click>이벤트 것 또는 ENTER 키를 누를 때.</xref:System.Windows.Controls.Primitives.ButtonBase.Click> 그러나, 대화 상자에서 자동으로 닫지 하거나 DialogResult로 설정 됩니다 것 `true`합니다. 수동으로이 코드에서 일반적으로 기록해 야 하는 <xref:System.Windows.Controls.Primitives.ButtonBase.Click>기본 단추에 대 한 이벤트 처리기.</xref:System.Windows.Controls.Primitives.ButtonBase.Click>       DialogResult는 `null` 대화 상자가 표시 될 때 하지만 모두 허용 되거나 취소 합니다.       대화 상자가 닫힌 후에서 반환한 값에서 대화 상자 결과 얻을 수 있습니다 <xref:System.Windows.Window.ShowDialog%2A>메서드, 또는 DialogResult 속성을 검사 하 여.</xref:System.Windows.Window.ShowDialog%2A>       DialogResult만 경우 설정할 수는 <xref:System.Windows.Window>호출 하 여 열린 해당 <xref:System.Windows.Window.ShowDialog%2A>메서드.</xref:System.Windows.Window.ShowDialog%2A> </xref:System.Windows.Window>      > [!NOTE] > 설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다."
  example:
  - "The following example shows how to configure an OK button and a Cancel button to return the appropriate DialogResult.  \n  \n [!code-xml[WindowDialogResultSnippets#WindowDialogResultXAML](~/add/codesnippet/xaml/WindowDialogResultSnippets.CSharp/DialogBox.xaml#windowdialogresultxaml)]  \n  \n [!code-cs[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/add/codesnippet/csharp/WindowDialogResultSnippets.CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]\n [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/add/codesnippet/visualbasic/windowdialogresultsnippets/dialogbox.xaml.vb#windowdialogresultcodebehind)]"
  syntax:
    content: public Nullable<bool> DialogResult { get; set; }
    return:
      type: System.Nullable{System.Boolean}
      description: "A &lt;xref:System.Nullable%601&gt; <xref:System.Boolean>.</xref:System.Boolean> 형식의 값 기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.Window.DialogResult*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "호출 하 여 창이 열리기 전에 DialogResult 설정 <> </> *> 합니다.       -또는-DialogResult를 호출 하 여 열려 있는 창에 설정 되어 <> </> *> 합니다."
  platform:
  - net462
- uid: System.Windows.Window.DpiChanged
  id: DpiChanged
  parent: System.Windows.Window
  langs:
  - csharp
  name: DpiChanged
  nameWithType: Window.DpiChanged
  fullName: System.Windows.Window.DpiChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "DPI 창이 되는 화면 표시 변경 후에 발생 합니다."
  syntax:
    content: public event System.Windows.DpiChangedEventHandler DpiChanged;
    return:
      type: System.Windows.DpiChangedEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.DpiChangedEvent
  id: DpiChangedEvent
  parent: System.Windows.Window
  langs:
  - csharp
  name: DpiChangedEvent
  nameWithType: Window.DpiChangedEvent
  fullName: System.Windows.Window.DpiChangedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "A <xref href=&quot;System.Windows.RoutedEvent&quot;> </xref> 창 화면 DPI가 변경 내용에 있는 경우에 대 한 합니다."
  syntax:
    content: public static readonly System.Windows.RoutedEvent DpiChangedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.DragMove
  id: DragMove
  parent: System.Windows.Window
  langs:
  - csharp
  name: DragMove()
  nameWithType: Window.DragMove()
  fullName: System.Windows.Window.DragMove()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창을 이동 창의 클라이언트 영역의 노출 된 영역을 마우스 왼쪽된 단추를 누른를 사용 하 여 끌 수 있습니다."
  remarks: "마우스 왼쪽된 단추로 DragMove 호출 될 때 다운 이어야 합니다. 마우스 왼쪽된 단추를 누를 때 검색 하는 한 가지 방법은 처리 하기 위한 것은 <xref:System.Windows.UIElement.MouseLeftButtonDown>이벤트.</xref:System.Windows.UIElement.MouseLeftButtonDown>       DragMove를 호출할 때 창의 클라이언트 영역의 노출된 된 영역을 마우스 왼쪽된 단추를 누른 합니다.      > [!NOTE] > 창이 브라우저에서 호스팅될 때이 메서드를 호출할 수 없습니다."
  example:
  - "The following example shows how to override <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> to call DragMove.  \n  \n [!code-cs[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/add/codesnippet/csharp/WindowDragMoveSnippets/MainWindow.xaml.cs#callwindowdragmovecodebehind)]\n [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/add/codesnippet/visualbasic/windowdragmovesnippets/mainwindow.xaml.vb#callwindowdragmovecodebehind)]"
  syntax:
    content: public void DragMove ();
    parameters: []
  overload: System.Windows.Window.DragMove*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "마우스 왼쪽된 단추 아래쪽 않습니다."
  platform:
  - net462
- uid: System.Windows.Window.GetWindow(System.Windows.DependencyObject)
  id: GetWindow(System.Windows.DependencyObject)
  parent: System.Windows.Window
  langs:
  - csharp
  name: GetWindow(DependencyObject)
  nameWithType: Window.GetWindow(DependencyObject)
  fullName: System.Windows.Window.GetWindow(DependencyObject)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "에 대 한 참조를 반환 합니다.는 <xref href=&quot;System.Windows.Window&quot;> </xref> 개체를 호스팅하는 위치한 콘텐츠 트리는 종속성 개체입니다."
  syntax:
    content: public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);
    parameters:
    - id: dependencyObject
      type: System.Windows.DependencyObject
      description: "종속성 개체입니다."
    return:
      type: System.Windows.Window
      description: "A <xref href=&quot;System.Windows.Window&quot;> </xref> 호스트 창에 대 한 참조입니다."
  overload: System.Windows.Window.GetWindow*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>dependencyObject</code>null입니다."
  platform:
  - net462
- uid: System.Windows.Window.Hide
  id: Hide
  parent: System.Windows.Window
  langs:
  - csharp
  name: Hide()
  nameWithType: Window.Hide()
  fullName: System.Windows.Window.Hide()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창을 보이지 않게 합니다."
  remarks: "숨겨져 창이 닫힐 않으며는 <xref:System.Windows.Window.Closing>나 <xref:System.Windows.Window.Closed>이벤트가 발생 합니다.</xref:System.Windows.Window.Closed> </xref:System.Windows.Window.Closing> 대신, <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Visibility?displayProperty=fullName>.</xref:System.Windows.Visibility?displayProperty=fullName> 속성</xref:System.Windows.UIElement.Visibility%2A> 창       창을 응용 프로그램의 경우 <xref:System.Windows.Application.MainWindow%2A>및 응용 프로그램의 <xref:System.Windows.Application.ShutdownMode%2A>은 <xref:System.Windows.ShutdownMode>, 응용 프로그램 종료 되지 않습니다.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application.MainWindow%2A> 마찬가지로, 응용 프로그램 종료 하지 않은 경우 유일한 창입니다는 응용 프로그램의 종료 모드 <xref:System.Windows.ShutdownMode>.</xref:System.Windows.ShutdownMode>       표시 하 고 응용 프로그램의 수명 동안 여러 번 창이 숨길 하 고 다시 창을 인스턴스화할 때마다 하지 않을 경우 표시 하면, 처리할 수는 <xref:System.Windows.Window.Closing>이벤트를 취소 하 고 숨기기 메서드를 호출 합니다.</xref:System.Windows.Window.Closing> 그런 다음 <xref:System.Windows.Window.Show%2A>다시 열기를 동일한 인스턴스에 대해</xref:System.Windows.Window.Show%2A> 호출할 수 있습니다."
  syntax:
    content: public void Hide ();
    parameters: []
  overload: System.Windows.Window.Hide*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "숨기기 닫힐 있는 창에 호출 됩니다 (<xref href=&quot;System.Windows.Window.Closing&quot;></xref>) 닫힌 또는 (<xref href=&quot;System.Windows.Window.Closed&quot;></xref>)."
  platform:
  - net462
- uid: System.Windows.Window.Icon
  id: Icon
  parent: System.Windows.Window
  langs:
  - csharp
  name: Icon
  nameWithType: Window.Icon
  fullName: System.Windows.Window.Icon
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창의 아이콘을 가져오거나 설정 합니다."
  remarks: "[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]독립 실행형 응용 프로그램에는 두 가지 유형의 아이콘:-를 사용 하 여 지정 된 어셈블리 아이콘은 `<ApplicationIcon>` 응용 프로그램의 프로젝트 속성 파일을 작성 합니다. 이 아이콘은 어셈블리에 대 한 바탕 화면 아이콘으로 사용 됩니다.          > [!NOTE] > 프로그램 아이콘 Visual Studio에서 디버깅 하는 경우 호스팅 프로세스 인해 나타나지 않을 수 있습니다. 실행 파일을 실행 하는 경우에 아이콘이 표시 됩니다. 자세한 내용은 참조 [호스팅 프로세스 (vshost.exe)](~/add/includes/ajax-current-ext-md.md)합니다.      -아이콘을 설정 하 여 지정 된 창에 당 개 아이콘입니다. 각 창에 대해 해당 작업 표시줄 단추가 제목 표시줄에 있는 및의 ALT + TAB 응용 프로그램 선택 목록 항목에이 아이콘이 사용 됩니다.       A [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 항상 창 아이콘을 표시 합니다. 아이콘을 설정 하 여 하나가 제공 되지 않으면 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 다음 규칙에 따라 표시할 아이콘을 선택 합니다. 1.  지정 된 경우에 어셈블리 아이콘을 사용 합니다.      2.  어셈블리 아이콘이 지정 되지 않은 경우 기본 사용 [!INCLUDE[TLA#tla_win](~/add/includes/ajax-current-ext-md.md)] 아이콘입니다.       사용자 지정 창 아이콘을 지정 하려면 아이콘을 사용 하는 경우 아이콘을 설정 하 여 기본 응용 프로그램 아이콘을 복원할 수 있습니다 `null`합니다.       다양 한 방법으로 하나의 아이콘을 사용할 수 있습니다 [!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)], ALT + TAB 파일 선택 목록 창의 작업 표시줄 창의 제목 표시줄에 표시 되 고 포함 합니다. 다른 크기;를 사용 하 여 아이콘을 표시 이러한 각 ALT + TAB 파일 선택 목록에 표시 되는 32 x 32 픽셀 아이콘 동안 16 x 16 픽셀 아이콘은 창의 제목 표시줄에 하 고 작업 표시줄에 표시 됩니다. 와 같은 일부 응용 프로그램 [!INCLUDE[TLA#tla_winexpl](~/add/includes/tlasharptla-winexpl-md.md)], 제공는 **보기** 메뉴를 보려면 원하는 아이콘의 크기를 선택할 수 있도록 합니다.       다양 한 표시 크기에 맞도록, 아이콘 파일 각각 특정 크기 및 색 농도 대상으로 하는 아이콘의 버전을 나타냅니다는 하나 이상의 실제 아이콘으로 구성 됩니다. 예를 들어 한 아이콘 반면 다른 16 색와 256 색 모두 32 x 32 픽셀 아이콘과 16 x 16 픽셀 16 색으로 단일 16 x 16 픽셀 아이콘을 하나만 포함할 수 있습니다.       아이콘 파일 내에 모든 가능한 크기 및 색 농도 아이콘이 있을 경우 <xref:System.Windows.Window>해당 아이콘을 사용 합니다.</xref:System.Windows.Window> 아이콘 파일에는 가능한 모든 아이콘의 하위 집합만 포함 되어 있으면 <xref:System.Windows.Window>의 크기 및 색 농도 내림차순 다음 가장 적합 한 아이콘을 사용 하 여.</xref:System.Windows.Window>       결과 아이콘 항상에서 사용할 수는 <xref:System.Windows.Window>사용 되는 아이콘 필요한 크기와 색 농도 대상 하지 않더라도,.</xref:System.Windows.Window> 예를 들어를 16 색 16 x 16 픽셀 아이콘 256 개 색을 가진 32 x 32 픽셀 아이콘으로 표시 하기 위해 사용 될 수 있습니다. 이 픽셀화가, 예: 바람직하지 않은 시각 효과 발생할 수 있습니다 하지만 모든 대상된 크기와 색상에 대 한 아이콘을 만들어이 피할 수 있습니다.      > [!NOTE] > 설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.      <a name=&quot;dependencyPropertyInfo_WindowIcon&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.Window.IconProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.Window.IconProperty>"
  example:
  - "The following example shows how to set a window icon.  \n  \n [!code-xml[WindowIconSnippets#WindowIconSetXAML](~/add/codesnippet/xaml/WindowIconSnippets.WindowIconSample/MainWindow.xaml#windowiconsetxaml)]  \n  \n [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/add/codesnippet/visualbasic/windowiconsample/mainwindow.xaml.vb#setwindowiconincode)]\n [!code-cs[WindowIconSnippets#SetWindowIconInCode](~/add/codesnippet/csharp/WindowIconSnippets.WindowIconSample/MainWindow.xaml.cs#setwindowiconincode)]"
  syntax:
    content: public System.Windows.Media.ImageSource Icon { get; set; }
    return:
      type: System.Windows.Media.ImageSource
      description: "<xref href=&quot;System.Windows.Media.ImageSource&quot;> </xref> 아이콘을 나타내는 개체입니다."
  overload: System.Windows.Window.Icon*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.IconProperty
  id: IconProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: IconProperty
  nameWithType: Window.IconProperty
  fullName: System.Windows.Window.IconProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.Window.Icon*>종속성 속성입니다.</xref:System.Windows.Window.Icon*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IconProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.IsActive
  id: IsActive
  parent: System.Windows.Window
  langs:
  - csharp
  name: IsActive
  nameWithType: Window.IsActive
  fullName: System.Windows.Window.IsActive
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창이 활성화 되어 있는지 여부를 나타내는 값을 가져옵니다."
  remarks: "활성 창에는 사용자의 현재 전경 창을 이며에서 포커스가 있는 제목 표시줄의 활성 모양으로 표시 합니다. 활성 창도 명시적으로 설정 하지 않은 모든 최상위 창의 최상위 됩니다는 <xref:System.Windows.Window.Topmost%2A>속성.</xref:System.Windows.Window.Topmost%2A>      <a name=&quot;dependencyPropertyInfo_WindowIsActive&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.Window.IsActiveProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.Window.IsActiveProperty>"
  syntax:
    content: public bool IsActive { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>창이 활성화 되어 있는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.Window.IsActive*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.IsActiveProperty
  id: IsActiveProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: IsActiveProperty
  nameWithType: Window.IsActiveProperty
  fullName: System.Windows.Window.IsActiveProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.Window.IsActive*>종속성 속성입니다.</xref:System.Windows.Window.IsActive*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsActiveProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Left
  id: Left
  parent: System.Windows.Window
  langs:
  - csharp
  name: Left
  nameWithType: Window.Left
  fullName: System.Windows.Window.Left
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "바탕 화면을 기준으로 창의 왼쪽된 가장자리의 위치를 가져오거나 설정 합니다."
  remarks: "경우는 <xref:System.Windows.Window>최대화 되거나 최소화 되 면 <xref:System.Windows.Window>.</xref:System.Windows.Window> 지점의 복원의 왼쪽된 가장자리를이 값 나타냅니다</xref:System.Windows.Window>       스타일을 통해이 속성을 설정할 수 없습니다.       값을 지정 하지 않으면 왼쪽은 시스템 기본 값으로 설정 됩니다. 왼쪽 <xref:System.Double.NaN>.</xref:System.Double.NaN> 에서 설정 하 여 시스템 기본값을 지정할 수도 있습니다. 모두 <xref:System.Double.NegativeInfinity>또는 <xref:System.Double.PositiveInfinity>은 올바른 값이 유지.</xref:System.Double.PositiveInfinity> </xref:System.Double.NegativeInfinity>      > [!NOTE] > 설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.      <a name=&quot;dependencyPropertyInfo_WindowLeft&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.Window.LeftProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.Window.LeftProperty>"
  syntax:
    content: public double Left { get; set; }
    return:
      type: System.Double
      description: "창의 위치 왼쪽 가장자리 논리 단위에서 (1/96 인치)."
  overload: System.Windows.Window.Left*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.LeftProperty
  id: LeftProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: LeftProperty
  nameWithType: Window.LeftProperty
  fullName: System.Windows.Window.LeftProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.Window.Left*>종속성 속성입니다.</xref:System.Windows.Window.Left*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty LeftProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.LocationChanged
  id: LocationChanged
  parent: System.Windows.Window
  langs:
  - csharp
  name: LocationChanged
  nameWithType: Window.LocationChanged
  fullName: System.Windows.Window.LocationChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창의 위치가 변경 될 때 발생 합니다."
  remarks: "창의 위치가 변경 시기:-사용자가 창의 제목 표시줄으로 끌어 창 이동 합니다.      -창이 후 이동 하는 <xref:System.Windows.Window.DragMove%2A>호출 됩니다.</xref:System.Windows.Window.DragMove%2A>      -하거나는 <xref:System.Windows.Window.Left%2A>또는 <xref:System.Windows.Window.Top%2A>속성을 프로그래밍 방식으로 설정 합니다.</xref:System.Windows.Window.Top%2A> </xref:System.Windows.Window.Left%2A>      - **이동** 창의 시스템 메뉴의 메뉴 항목을 선택 합니다.      - <xref:System.Windows.Window.WindowState%2A>속성을 변경 합니다.</xref:System.Windows.Window.WindowState%2A>"
  syntax:
    content: public event EventHandler LocationChanged;
    return:
      type: System.EventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.LogicalChildren
  id: LogicalChildren
  parent: System.Windows.Window
  langs:
  - csharp
  name: LogicalChildren
  nameWithType: Window.LogicalChildren
  fullName: System.Windows.Window.LogicalChildren
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "요소를 창의 논리적 자식에 대 한 열거자를 가져옵니다."
  syntax:
    content: protected override System.Collections.IEnumerator LogicalChildren { get; }
    return:
      type: System.Collections.IEnumerator
      description: "<xref:System.Collections.IEnumerator>창의 논리적 자식 요소.</xref:System.Collections.IEnumerator>"
  overload: System.Windows.Window.LogicalChildren*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.MeasureOverride(System.Windows.Size)
  id: MeasureOverride(System.Windows.Size)
  parent: System.Windows.Window
  langs:
  - csharp
  name: MeasureOverride(Size)
  nameWithType: Window.MeasureOverride(Size)
  fullName: System.Windows.Window.MeasureOverride(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창의 크기를 측정 하려면이 메서드를 재정의 합니다."
  remarks: "일반적 호출 되지 않습니다 <xref:System.Windows.UIElement.Visibility%2A>속성 <xref:System.Windows.Visibility>안내 하십시오.</xref:System.Windows.Visibility> 값은</xref:System.Windows.UIElement.Visibility%2A> 하는 경우의 값은 <xref:System.Windows.UIElement.Visibility%2A>속성이 <xref:System.Windows.Visibility>또는 <xref:System.Windows.Visibility>, 일반적 호출 됩니다.</xref:System.Windows.Visibility> </xref:System.Windows.Visibility> </xref:System.Windows.UIElement.Visibility%2A>      > [!NOTE] > 때 중 하나 <xref:System.Windows.Window.Show%2A> <xref:System.Windows.Window.ShowDialog%2A>호출 <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Window> <xref:System.Windows.Visibility>.</xref:System.Windows.Visibility> </xref:System.Windows.Window> 의 속성</xref:System.Windows.UIElement.Visibility%2A> </xref:System.Windows.Window.ShowDialog%2A> 또는</xref:System.Windows.Window.Show%2A>"
  syntax:
    content: protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);
    parameters:
    - id: availableSize
      type: System.Windows.Size
      description: "A <xref href=&quot;System.Windows.Size&quot;> </xref> 이 창의 자식에 제공할 수는 사용 가능한 크기를 반영 하는 합니다. 창 크기는 모든 콘텐츠를 사용할 수 있는지를 나타내는 값으로 무한대를 지정할 수 있습니다."
    return:
      type: System.Windows.Size
      description: "A <xref href=&quot;System.Windows.Size&quot;> </xref> 이 창을 자식의 크기의 계산에 따라 레이아웃 중 필요한 것으로 결정 하는 크기를 반영 하는 합니다."
  overload: System.Windows.Window.MeasureOverride*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnActivated(System.EventArgs)
  id: OnActivated(System.EventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnActivated(EventArgs)
  nameWithType: Window.OnActivated(EventArgs)
  fullName: System.Windows.Window.OnActivated(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Window.Activated&quot;> </xref> 이벤트입니다."
  remarks: "OnActivated 발생는 <xref:System.Windows.Window.Activated>이벤트.</xref:System.Windows.Window.Activated>       파생 되는 형식을 <xref:System.Windows.Window>OnActivated를 재정의할 수 있습니다.</xref:System.Windows.Window> 재정의 된 메서드를 호출 해야 OnActivated 기본 클래스에 <xref:System.Windows.Window.Activated>발생 해야 합니다.</xref:System.Windows.Window.Activated>"
  syntax:
    content: protected virtual void OnActivated (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>이벤트 데이터를 포함 하는.</xref:System.EventArgs>"
  overload: System.Windows.Window.OnActivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnClosed(System.EventArgs)
  id: OnClosed(System.EventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnClosed(EventArgs)
  nameWithType: Window.OnClosed(EventArgs)
  fullName: System.Windows.Window.OnClosed(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Window.Closed&quot;> </xref> 이벤트입니다."
  remarks: "OnClosed 발생는 <xref:System.Windows.Window.Closed>이벤트.</xref:System.Windows.Window.Closed>       파생 되는 형식을 <xref:System.Windows.Window>OnClosed를 재정의할 수 있습니다.</xref:System.Windows.Window> 재정의 된 메서드를 호출 해야 OnClosed 기본 클래스에 <xref:System.Windows.Window.Closed>발생 해야 합니다.</xref:System.Windows.Window.Closed>"
  syntax:
    content: protected virtual void OnClosed (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>이벤트 데이터를 포함 하는.</xref:System.EventArgs>"
  overload: System.Windows.Window.OnClosed*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)
  id: OnClosing(System.ComponentModel.CancelEventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnClosing(CancelEventArgs)
  nameWithType: Window.OnClosing(CancelEventArgs)
  fullName: System.Windows.Window.OnClosing(CancelEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Window.Closing&quot;> </xref> 이벤트입니다."
  remarks: "OnClosing 발생는 <xref:System.Windows.Window.Closing>이벤트.</xref:System.Windows.Window.Closing>       파생 되는 형식을 <xref:System.Windows.Window>OnClosing를 재정의할 수 있습니다.</xref:System.Windows.Window> 재정의 된 메서드를 호출 해야 OnClosing 기본 클래스에 <xref:System.Windows.Window.Closing>발생 해야 합니다.</xref:System.Windows.Window.Closing>"
  syntax:
    content: protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);
    parameters:
    - id: e
      type: System.ComponentModel.CancelEventArgs
      description: "A <xref:System.ComponentModel.CancelEventArgs>이벤트 데이터를 포함 하는.</xref:System.ComponentModel.CancelEventArgs>"
  overload: System.Windows.Window.OnClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnContentChanged(System.Object,System.Object)
  id: OnContentChanged(System.Object,System.Object)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnContentChanged(Object,Object)
  nameWithType: Window.OnContentChanged(Object,Object)
  fullName: System.Windows.Window.OnContentChanged(Object,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "될 때 호출 된 <xref:System.Windows.Controls.ContentControl.Content*>속성 변경.</xref:System.Windows.Controls.ContentControl.Content*>"
  syntax:
    content: protected override void OnContentChanged (object oldContent, object newContent);
    parameters:
    - id: oldContent
      type: System.Object
      description: "이전 콘텐츠 트리의 루트에 대 한 참조입니다."
    - id: newContent
      type: System.Object
      description: "새 콘텐츠 트리의 루트에 대 한 참조입니다."
  overload: System.Windows.Window.OnContentChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnContentRendered(System.EventArgs)
  id: OnContentRendered(System.EventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnContentRendered(EventArgs)
  nameWithType: Window.OnContentRendered(EventArgs)
  fullName: System.Windows.Window.OnContentRendered(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Window.ContentRendered&quot;> </xref> 이벤트입니다."
  remarks: "OnContentRendered 발생는 <xref:System.Windows.Window.ContentRendered>이벤트.</xref:System.Windows.Window.ContentRendered>       파생 되는 형식을 <xref:System.Windows.Window>OnContentRendered를 재정의할 수 있습니다.</xref:System.Windows.Window> 재정의 된 메서드를 호출 해야 OnContentRendered 기본 클래스에 <xref:System.Windows.Window.ContentRendered>발생 해야 합니다.</xref:System.Windows.Window.ContentRendered>"
  syntax:
    content: protected virtual void OnContentRendered (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>이벤트 데이터를 포함 하는.</xref:System.EventArgs>"
  overload: System.Windows.Window.OnContentRendered*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnCreateAutomationPeer
  id: OnCreateAutomationPeer
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnCreateAutomationPeer()
  nameWithType: Window.OnCreateAutomationPeer()
  fullName: System.Windows.Window.OnCreateAutomationPeer()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "만들고 반환는 <xref href=&quot;System.Windows.Automation.Peers.WindowAutomationPeer&quot;> </xref> 이 대 한 개체 <xref href=&quot;System.Windows.Window&quot;> </xref>합니다."
  remarks: "이 메서드를 재정의 <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.</xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>"
  syntax:
    content: protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();
    parameters: []
    return:
      type: System.Windows.Automation.Peers.AutomationPeer
      description: "A <xref href=&quot;System.Windows.Automation.Peers.WindowAutomationPeer&quot;></xref> object for this <xref href=&quot;System.Windows.Window&quot;></xref>."
  overload: System.Windows.Window.OnCreateAutomationPeer*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnDeactivated(System.EventArgs)
  id: OnDeactivated(System.EventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnDeactivated(EventArgs)
  nameWithType: Window.OnDeactivated(EventArgs)
  fullName: System.Windows.Window.OnDeactivated(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Window.Deactivated&quot;> </xref> 이벤트입니다."
  remarks: "OnDeactivated 발생는 <xref:System.Windows.Window.Deactivated>이벤트.</xref:System.Windows.Window.Deactivated>       파생 되는 형식을 <xref:System.Windows.Window>OnDeactivated를 재정의할 수 있습니다.</xref:System.Windows.Window> 재정의 된 메서드를 호출 해야 OnDeactivated 기본 클래스에 <xref:System.Windows.Window.Deactivated>발생 해야 합니다.</xref:System.Windows.Window.Deactivated>"
  syntax:
    content: protected virtual void OnDeactivated (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>이벤트 데이터를 포함 하는.</xref:System.EventArgs>"
  overload: System.Windows.Window.OnDeactivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)
  id: OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnDpiChanged(DpiScale,DpiScale)
  nameWithType: Window.OnDpiChanged(DpiScale,DpiScale)
  fullName: System.Windows.Window.OnDpiChanged(DpiScale,DpiScale)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "될 때 호출 DPI입니다이 창이 변경 내용을 렌더링 됩니다."
  syntax:
    content: protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);
    parameters:
    - id: oldDpi
      type: System.Windows.DpiScale
      description: "이전 DPI 설정 소수 자릿수입니다."
    - id: newDpi
      type: System.Windows.DpiScale
      description: "설정 하는 새 DPI 배율입니다."
  overload: System.Windows.Window.OnDpiChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnLocationChanged(System.EventArgs)
  id: OnLocationChanged(System.EventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnLocationChanged(EventArgs)
  nameWithType: Window.OnLocationChanged(EventArgs)
  fullName: System.Windows.Window.OnLocationChanged(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Window.LocationChanged&quot;> </xref> 이벤트입니다."
  remarks: "OnLocationChanged 발생는 <xref:System.Windows.Window.LocationChanged>이벤트.</xref:System.Windows.Window.LocationChanged>       파생 되는 형식을 <xref:System.Windows.Window>OnLocationChanged를 재정의할 수 있습니다.</xref:System.Windows.Window> 재정의 된 메서드를 호출 해야 OnLocationChanged 기본 클래스에 <xref:System.Windows.Window.LocationChanged>발생 해야 합니다.</xref:System.Windows.Window.LocationChanged>"
  syntax:
    content: protected virtual void OnLocationChanged (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>이벤트 데이터를 포함 하는.</xref:System.EventArgs>"
  overload: System.Windows.Window.OnLocationChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)
  id: OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
  nameWithType: Window.OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
  fullName: System.Windows.Window.OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "될 때 호출 된 <xref href=&quot;System.Windows.UIElement.ManipulationBoundaryFeedback&quot;> </xref> 이벤트가 발생 합니다."
  remarks: "이 구현은 처리 상태를 변경 되지 않습니다 (의 <xref:System.Windows.RoutedEventArgs.Handled%2A>속성)의 <xref:System.Windows.UIElement.ManipulationBoundaryFeedback>이벤트 데이터입니다.</xref:System.Windows.UIElement.ManipulationBoundaryFeedback> </xref:System.Windows.RoutedEventArgs.Handled%2A>"
  syntax:
    content: protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.ManipulationBoundaryFeedbackEventArgs
      description: "이벤트에 대 한 데이터입니다."
  overload: System.Windows.Window.OnManipulationBoundaryFeedback*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnSourceInitialized(System.EventArgs)
  id: OnSourceInitialized(System.EventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnSourceInitialized(EventArgs)
  nameWithType: Window.OnSourceInitialized(EventArgs)
  fullName: System.Windows.Window.OnSourceInitialized(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Window.SourceInitialized&quot;> </xref> 이벤트입니다."
  remarks: "OnSourceInitialized 발생는 <xref:System.Windows.Window.SourceInitialized>이벤트.</xref:System.Windows.Window.SourceInitialized>       파생 되는 형식을 <xref:System.Windows.Window>OnSourceInitialized를 재정의할 수 있습니다.</xref:System.Windows.Window> 재정의 된 메서드를 호출 해야 OnSourceInitialized 기본 클래스에 <xref:System.Windows.Window.SourceInitialized>발생 해야 합니다.</xref:System.Windows.Window.SourceInitialized>"
  syntax:
    content: protected virtual void OnSourceInitialized (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>이벤트 데이터를 포함 하는.</xref:System.EventArgs>"
  overload: System.Windows.Window.OnSourceInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnStateChanged(System.EventArgs)
  id: OnStateChanged(System.EventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnStateChanged(EventArgs)
  nameWithType: Window.OnStateChanged(EventArgs)
  fullName: System.Windows.Window.OnStateChanged(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 된 <xref href=&quot;System.Windows.Window.StateChanged&quot;> </xref> 이벤트입니다."
  remarks: "OnStateChanged 발생는 <xref:System.Windows.Window.StateChanged>이벤트.</xref:System.Windows.Window.StateChanged>       파생 되는 형식을 <xref:System.Windows.Window>OnStateChanged를 재정의할 수 있습니다.</xref:System.Windows.Window> 재정의 된 메서드를 호출 해야 OnStateChanged 기본 클래스에 <xref:System.Windows.Window.StateChanged>발생 해야 합니다.</xref:System.Windows.Window.StateChanged>"
  syntax:
    content: protected virtual void OnStateChanged (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>이벤트 데이터를 포함 하는.</xref:System.EventArgs>"
  overload: System.Windows.Window.OnStateChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)
  id: OnVisualParentChanged(System.Windows.DependencyObject)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnVisualParentChanged(DependencyObject)
  nameWithType: Window.OnVisualParentChanged(DependencyObject)
  fullName: System.Windows.Window.OnVisualParentChanged(DependencyObject)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창의 부모가 변경 될 때 호출 됩니다."
  syntax:
    content: protected override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);
    parameters:
    - id: oldParent
      type: System.Windows.DependencyObject
      description: "이전 부모입니다. 경우에는 null로 설정 된 <xref href=&quot;System.Windows.DependencyObject&quot;> </xref> 이전 부모가 없습니다."
  overload: System.Windows.Window.OnVisualParentChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OwnedWindows
  id: OwnedWindows
  parent: System.Windows.Window
  langs:
  - csharp
  name: OwnedWindows
  nameWithType: Window.OwnedWindows
  fullName: System.Windows.Window.OwnedWindows
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 기간은 소유자 창의 컬렉션을 가져옵니다."
  remarks: "소유 된 창을 이란 해당 <xref:System.Windows.Window.Owner%2A>소유자 창으로 알려진 다른 창에 대 한 참조 속성은.</xref:System.Windows.Window.Owner%2A> 열거할 수는 소유자 창이 소유한 모든 창을 찾으려면 <xref:System.Windows.WindowCollection>OwnedWindows 속성에서 반환 하는.</xref:System.Windows.WindowCollection>"
  example:
  - "The following example shows how to enumerate OwnedWindows.  \n  \n [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/add/codesnippet/visualbasic/windowownerownedwindowssnippets/mainwindow.xaml.vb#getwindowownedwindowscode)]\n [!code-cs[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/add/codesnippet/csharp/WindowOwnerOwnedWindowsSnippets.CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]"
  syntax:
    content: public System.Windows.WindowCollection OwnedWindows { get; }
    return:
      type: System.Windows.WindowCollection
      description: "A <xref href=&quot;System.Windows.WindowCollection&quot;> </xref> 이 기간은 소유자 창에 참조가 들어 있는입니다."
  overload: System.Windows.Window.OwnedWindows*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Owner
  id: Owner
  parent: System.Windows.Window
  langs:
  - csharp
  name: Owner
  nameWithType: Window.Owner
  fullName: System.Windows.Window.Owner
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "가져오거나는 <xref href=&quot;System.Windows.Window&quot;> </xref> 이 소유 하는 <xref href=&quot;System.Windows.Window&quot;> </xref>합니다."
  remarks: "호출 하 여 자식 창의 부모 창에서 열 때 <xref:System.Windows.Window.ShowDialog%2A>, 부모와 자식 창 간에 암시적 관계가 설정 됩니다.</xref:System.Windows.Window.ShowDialog%2A> 이 관계는 최소화, 최대화 및 복원에 대해 포함 하 여 특정 동작을 적용 합니다.       그러나 호출 하 여 자식 창의 부모 창에서 만들 때 <xref:System.Windows.Window.Show%2A>을 자식 창 부모 창 관계가 정의 되어 있지 않습니다.</xref:System.Windows.Window.Show%2A> 즉:-자식 창의 부모 창에 대 한 참조는 없습니다.      -동작은 자식 창의 부모 창;의 동작에 종속 되지 않습니다. 두 창 중 하나를 포함할 수 또는 최소화, 최대화 및 서로 독립적으로 복원 합니다.       부모 창의 자식 창 사이의 관계를 만들 수 있도록 <xref:System.Windows.Window>소유권의 개념을 지원 합니다.</xref:System.Windows.Window> 다른 창 (소유자 창)에 대 한 참조 창 (소유한 창)의 소유자 속성을 설정 하는 경우 소유권 설정 됩니다.       이 관계 설정 되 면 다음 동작이 표시 됩니다:-소유자 창이 최소화 하는 경우 소유 된 모든 창도 최소화 됩니다.      -소유 창이 최소화 하는 경우에 해당 소유자 최소화 되지 않습니다.      -소유자 창이 최대화 하는 경우에 소유자 창 및 소유 된 창 모두 복원 됩니다.      -소유자 창 소유 된 창을 포함할 수 없습니다.      소유 windows를 사용 하 여 열려 있지 않은 <xref:System.Windows.Window.ShowDialog%2A>는 모달 대화 상자가.</xref:System.Windows.Window.ShowDialog%2A> 사용자는 소유자 창이 여전히 작용할 수 있습니다.      -소유자 창을 닫은 경우 소유 된 창도 닫힙니다.      -소유 된 창을 사용 하 여 해당 소유자 창에서 열린 경우 <xref:System.Windows.Window.Show%2A>, 소유자 창이 닫힌 경우 소유 된 창 <xref:System.Windows.Window.Closing>이벤트가 발생 하지 않습니다.</xref:System.Windows.Window.Closing> </xref:System.Windows.Window.Show%2A>       호출 하 여 자식 창을 열 때 <xref:System.Windows.Window.ShowDialog%2A>, 자식 창의 소유자 속성을 설정 해야 합니다.</xref:System.Windows.Window.ShowDialog%2A> 이렇게 하지 않으면 사용자가 작업 표시줄 단추를 눌러 자식 창과 부모 창으로 돌아갈 수 수 없습니다. 대신, 작업 표시줄 단추를 누르면를 생성 하 여 s e l e 부모와 자식 창을 포함 하 여 창의 목록을 선택한 기간만 복원 됩니다.      > [!IMPORTANT] > 설정 해야 Owner 속성 창에는 호출 하 여 열려 있는 <xref:System.Windows.Window.ShowDialog%2A>올바른 동작을 보장 하려면.</xref:System.Windows.Window.ShowDialog%2A>      > [!NOTE] > 설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다."
  example:
  - "The following example shows how to establish the owner/owned relationship.  \n  \n [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/add/codesnippet/visualbasic/windowownerownedwindowssnippets/mainwindow.xaml.vb#setwindowownercode)]\n [!code-cs[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/add/codesnippet/csharp/WindowOwnerOwnedWindowsSnippets.CSharp/MainWindow.xaml.cs#setwindowownercode)]"
  syntax:
    content: public System.Windows.Window Owner { get; set; }
    return:
      type: System.Windows.Window
      description: "A <xref href=&quot;System.Windows.Window&quot;> </xref> 이 소유자를 나타내는 개체 <xref href=&quot;System.Windows.Window&quot;> </xref>합니다."
  overload: System.Windows.Window.Owner*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "자체 소유 하려고 하는 창-또는-창이 서로 소유 하려고 합니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "소유자 속성은 사용 하 여 표시 된 창에 설정 <xref:System.Windows.Window.ShowDialog*>-또는-이전에 표시 되지 않은 창에서 소유자 속성을 설정 합니다.</xref:System.Windows.Window.ShowDialog*>"
  platform:
  - net462
- uid: System.Windows.Window.ResizeMode
  id: ResizeMode
  parent: System.Windows.Window
  langs:
  - csharp
  name: ResizeMode
  nameWithType: Window.ResizeMode
  fullName: System.Windows.Window.ResizeMode
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "크기 조정 모드를 가져오거나 설정 합니다."
  remarks: "4 가지 옵션이 있습니다:- **NoResize**합니다. 사용자는 창의 크기를 조정할 수 없습니다. 최대화, 최소화 상자 표시 되지 않습니다.      - **CanMinimize**합니다. 만 사용자 창을 최소화 하 고 작업 표시줄에서 복원할 수 있습니다. 최소화 및 최대화 상자 모두 표시 되지만 최소화 상자만 사용 하도록 설정 합니다.      - **CanResize**합니다. 사용자에 게 창 주변의 최소화 및 최대화 상자 및 draggable 개요를 사용 하는 창의 크기를 조정할 수 있습니다. 최소화 및 최대화 상자를 표시 하 고 사용 됩니다. (기본값).      - **CanResizeWithGrip**합니다. 이 옵션은 동일한 기능을 <xref:System.Windows.ResizeMode>을 창의 오른쪽 맨 아래에 &quot;크기 조정 그립&quot;를 추가 하지만.</xref:System.Windows.ResizeMode>      > [!NOTE] > 설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.      <a name=&quot;dependencyPropertyInfo_WindowResizeMode&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.Window.ResizeModeProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.Window.ResizeModeProperty>"
  syntax:
    content: public System.Windows.ResizeMode ResizeMode { get; set; }
    return:
      type: System.Windows.ResizeMode
      description: "A <xref href=&quot;System.Windows.ResizeMode&quot;> </xref> 크기 조정 모드를 지정 하는 값입니다."
  overload: System.Windows.Window.ResizeMode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.ResizeModeProperty
  id: ResizeModeProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: ResizeModeProperty
  nameWithType: Window.ResizeModeProperty
  fullName: System.Windows.Window.ResizeModeProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.Window.ResizeMode*>종속성 속성입니다.</xref:System.Windows.Window.ResizeMode*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ResizeModeProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.RestoreBounds
  id: RestoreBounds
  parent: System.Windows.Window
  langs:
  - csharp
  name: RestoreBounds
  nameWithType: Window.RestoreBounds
  fullName: System.Windows.Window.RestoreBounds
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "되 고 최소화 또는 최대화 하기 전에 크기 및 창 위치를 가져옵니다."
  remarks: "복원 사각형은 지역 창에 최소화 또는 최대화 전에 사용 합니다. RestoreBounds를 사용 하 여 응용 프로그램을 닫기 전에 마지막 크기 및 창 위치를 저장할 수 있으며 응용 프로그램이 시작 하 여 사용자는 방식과 창을 복원 하려면 다음에 해당 값을 검색할 수 있습니다.       window가 표시 되기 전에 또는 종료 된 RestoreBounds를 쿼리 하는 경우 <xref:System.Windows.Rect.Empty%2A>반환 됩니다.</xref:System.Windows.Rect.Empty%2A>      > [!NOTE] > 창이 브라우저에서 호스팅될 때이 속성을 가져올 수 없습니다."
  example:
  - "The following example uses RestoreBounds and isolated storage to ensure the size and location of a window are the same as they were the previous time the window was shown.  \n  \n [!code-xml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/add/codesnippet/xaml/WindowRestoreBoundsSnippets/MainWindow.xaml#windowrestoreboundsxaml1)]  \n[!code-xml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/add/codesnippet/xaml/WindowRestoreBoundsSnippets/MainWindow.xaml#windowrestoreboundsxaml2)]  \n  \n [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/add/codesnippet/visualbasic/windowrestoreboundssnippets/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]\n [!code-cs[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/add/codesnippet/csharp/WindowRestoreBoundsSnippets/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]  \n[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/add/codesnippet/visualbasic/windowrestoreboundssnippets/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]\n[!code-cs[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/add/codesnippet/csharp/WindowRestoreBoundsSnippets/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]"
  syntax:
    content: public System.Windows.Rect RestoreBounds { get; }
    return:
      type: System.Windows.Rect
      description: "A <xref href=&quot;System.Windows.Rect&quot;> </xref> 지정 하는 크기와 창 위치 있을 때까지 최소화 또는 최대화 합니다."
  overload: System.Windows.Window.RestoreBounds*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Show
  id: Show
  parent: System.Windows.Window
  langs:
  - csharp
  name: Show()
  nameWithType: Window.Show()
  fullName: System.Windows.Window.Show()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창을 열고 새로 열린된 창이 닫힐 때까지 기다리지 않고 반환 합니다."
  remarks: "경우는 <xref:System.Windows.Window>클래스가 인스턴스화되면, 기본적으로 표시 되지 않습니다.</xref:System.Windows.Window> 표시 창을 표시 하 고 창이 닫힐 때까지 기다리지 않고 즉시 반환 합니다. 따라서 열린된 창 응용 프로그램에서 다른 windows와 상호 작용에서 사용자가 방해 되지는 않습니다. 이러한 형식의 라고는 *모덜리스* 창. 일반적인 모덜리스 창은 속성 창과 도구 상자 팔레트 있습니다. 특정 창 상호 작용 하는 사용자를 제한 하는 창을 열어야 <xref:System.Windows.Window.ShowDialog%2A>.</xref:System.Windows.Window.ShowDialog%2A> 를 호출 하 여       표시를 호출 하 여 열려 있는 창에 자동으로 열었을; 창 사용 하 여 관계 없는 특히, 열린된 창은 창을 연을 인식 하지 못합니다. 사용 하 여이 관계를 설정할 수는 <xref:System.Windows.Window.Owner%2A>속성과 관리 되는 사용 하는 <xref:System.Windows.Window.OwnedWindows%2A>속성.</xref:System.Windows.Window.OwnedWindows%2A> </xref:System.Windows.Window.Owner%2A>       <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Window> <xref:System.Windows.Visibility>.</xref:System.Windows.Visibility> 개체</xref:System.Windows.Window> 의 속성</xref:System.Windows.UIElement.Visibility%2A> 을 설정으로 동일한 최종 결과 달성 호출 표시 그러나 타이밍 관점에서 둘 사이 차이가 있습니다.       후에 반환 하는 동기 작업은 호출 표시는 <xref:System.Windows.FrameworkElement.Loaded>자식 창에 이벤트가 발생: [!code-vb [WindowShowTimingSnippets #ShowSync](~/add/codesnippet/visualbasic/windowshowtimingsnippets/window1.xaml.vb#showsync)][!code-cs[WindowShowTimingSnippets #ShowSync](~/add/codesnippet/csharp/WindowShowTimingSnippets.CSharp/Window1.xaml.cs#showsync) ] 설정 <xref:System.Windows.UIElement.Visibility%2A>, 인데 즉시 반환 하는 비동기 작업: [!code-vb [WindowShowTimingSnippets #ShowASync](~/add/codesnippet/visualbasic/windowshowtimingsnippets/window1.xaml.vb#showasync)][!code-cs[WindowShowTimingSnippets #ShowASync](~/add/codesnippet/csharp/WindowShowTimingSnippets.CSharp/Window1.xaml.cs#showasync) ] 설정할 때 <xref:System.Windows.UIElement.Visibility%2A>, 설정 하기 전에 등록 창 이벤트 <xref:System.Windows.UIElement.Visibility%2A>을 설정한 메서드 지날 때까지 발생할 수 있습니다 <xref:System.Windows.UIElement.Visibility%2A>실행을 완료 합니다.</xref:System.Windows.UIElement.Visibility%2A> </xref:System.Windows.UIElement.Visibility%2A> </xref:System.Windows.UIElement.Visibility%2A>   </xref:System.Windows.UIElement.Visibility%2A>   </xref:System.Windows.FrameworkElement.Loaded>"
  example:
  - "The following sample demonstrates how to open a modeless window.  \n  \n [!code-vb[WindowShowSnippets#WindowShowCODE](~/add/codesnippet/visualbasic/windowshowsnippets/mainwindow.xaml.vb#windowshowcode)]\n [!code-cs[WindowShowSnippets#WindowShowCODE](~/add/codesnippet/csharp/WindowShowSnippets.CSharp/MainWindow.xaml.cs#windowshowcode)]"
  syntax:
    content: public void Show ();
    parameters: []
  overload: System.Windows.Window.Show*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "표시에서 닫는 있는 창에 호출 됩니다 (<xref href=&quot;System.Windows.Window.Closing&quot;></xref>) 닫힌 또는 (<xref href=&quot;System.Windows.Window.Closed&quot;></xref>)."
  platform:
  - net462
- uid: System.Windows.Window.ShowActivated
  id: ShowActivated
  parent: System.Windows.Window
  langs:
  - csharp
  name: ShowActivated
  nameWithType: Window.ShowActivated
  fullName: System.Windows.Window.ShowActivated
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창이 처음 표시 될 때 활성화 되었는지 여부를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "ShowActivated 속성이로 설정 된 창을 `false` 은 열, 창이 활성화 되지 않으면 해당 <xref:System.Windows.Window.Activated>합니다.를 선택 하 여이 창을 수동으로 활성화 될 때까지 이벤트가 발생 하지 않습니다</xref:System.Windows.Window.Activated> 창의 선택 된 후 활성화 되거나 정상적으로 비활성화 합니다.       창이 열릴 때 활성화 되 고 되지 않도록 하려면 ShowActivated 속성 설정 해야 `false` 창이 표시 되기 전에 (호출 하 여 <xref:System.Windows.Window.Show%2A>); ShowActivated 설정을 `false` 아무 효과가 창이 표시 되기 후.</xref:System.Windows.Window.Show%2A>       ShowActivated 설정 `false` 모달 형식으로 호출 하 여 열려 있는 창에 <xref:System.Windows.Window.ShowDialog%2A>, 실제 영향을 주지 않습니다.</xref:System.Windows.Window.ShowDialog%2A> 모달 창이 활성화 되지 않지만 모달 창 사용자 다른 열려 있는 응용 프로그램 창을 활성화 수 없게 됩니다.      <a name=&quot;dependencyPropertyInfo_WindowShowActivated&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.Window.ShowActivatedProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.Window.ShowActivatedProperty>"
  example:
  - "The following example shows how to use markup to configure a window to be opened without being activated.  \n  \n [!code-xml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/add/codesnippet/xaml/WindowShowActivatedSnippets/AWindow.xaml#showunactivatedmarkup1)]  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]  \n  \n [!code-cs[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/add/codesnippet/csharp/WindowShowActivatedSnippets/AWindow.xaml.cs#showunactivatedcodebehind)]\n [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/add/codesnippet/visualbasic/windowshowactivatedsnippets/awindow.xaml.vb#showunactivatedcodebehind)]  \n  \n The following example shows how to use code to configure a window to be opened without it being activated.  \n  \n [!code-cs[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/add/codesnippet/csharp/WindowShowActivatedSnippets/Window1.xaml.cs#showunactivatedwindowcode)]\n [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/add/codesnippet/visualbasic/windowshowactivatedsnippets/window1.xaml.vb#showunactivatedwindowcode)]"
  syntax:
    content: public bool ShowActivated { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>창이 처음 표시; 될 때 활성화 된 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.Window.ShowActivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.ShowActivatedProperty
  id: ShowActivatedProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: ShowActivatedProperty
  nameWithType: Window.ShowActivatedProperty
  fullName: System.Windows.Window.ShowActivatedProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.Window.ShowActivated*>종속성 속성입니다.</xref:System.Windows.Window.ShowActivated*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ShowActivatedProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.ShowDialog
  id: ShowDialog
  parent: System.Windows.Window
  langs:
  - csharp
  name: ShowDialog()
  nameWithType: Window.ShowDialog()
  fullName: System.Windows.Window.ShowDialog()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창을 열고 새로 열린된 창이 닫혀 있는 경우에 반환 합니다."
  remarks: "경우는 <xref:System.Windows.Window>클래스가 인스턴스화되면, 기본적으로 표시 되지 않습니다.</xref:System.Windows.Window> ShowDialog 창을 보여, 응용 프로그램에서 다른 모든 창을 사용 하지 않도록 설정 및 창이 닫혀 있는 경우에 반환 합니다. 이러한 형식의 라고는 *모달* 창.       모달 창은 대화 상자로 주로 사용 됩니다. 대화 상자는 특수 한 유형의 응용 프로그램 파일을 열거나 문서 인쇄 등의 작업을 완료 하는 사용자 상호 작용 하는 데 사용 하는 창입니다. 대화 상자는 일반적으로 적용 하거나 취소할 작업을 표시 된 대화 상자를 닫기 전에 사용자가 허용 합니다. ShowDialog 반환는 <xref:System.Nullable%601> <xref:System.Boolean>활동 적용 하거나 취소 여부를 지정 하는 값입니다.</xref:System.Boolean></xref:System.Nullable%601> 반환 값의 값은는 <xref:System.Windows.Window.DialogResult%2A>속성 창이 닫히기 전에.</xref:System.Windows.Window.DialogResult%2A> 자세한 내용은 <xref:System.Windows.Window.DialogResult%2A>.</xref:System.Windows.Window.DialogResult%2A> 을 참조 하십시오.       ShowDialog 메서드를 호출 하 여 열려 있는 창에 자동으로 열었을; 창 사용 하 여 관계 없는 특히, 열린된 창은 창을 연을 인식 하지 못합니다. 사용 하 여이 관계를 설정할 수는 <xref:System.Windows.Window.Owner%2A>속성과 관리 되는 사용 하는 <xref:System.Windows.Window.OwnedWindows%2A>속성.</xref:System.Windows.Window.OwnedWindows%2A> </xref:System.Windows.Window.Owner%2A> 지원 하기 위해 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] 자동화 (참조 [UI 자동화 개요](~/add/includes/ajax-current-ext-md.md)), <xref:System.Windows.Window.Owner%2A>ShowDialog를 호출 하 여 연 창에 대 한 설정 해야 합니다.</xref:System.Windows.Window.Owner%2A>       모달 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 창 (ShowDialog를 호출 하 여 열린 창) 폐쇄형 이며, 이전에 활성화 된 창 다시 활성화 됩니다. 경우 모달 [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 창에 소유자 (참조 <xref:System.Windows.Window.Owner%2A>), 소유자 창이 때 다시 활성화 modal [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] 이전에 활성화 된 창 않은 창이 닫혀.</xref:System.Windows.Window.Owner%2A>      > [!NOTE] > 창이 브라우저에서 호스팅될 때이 메서드를 호출할 수 없습니다."
  example:
  - "The following sample demonstrates how to open a modal window.  \n  \n [!code-cs[WindowShowDialogSnippets#WindowShowDialogCODE](~/add/codesnippet/csharp/WindowShowDialogSnippets.CSharp/MainWindow.xaml.cs#windowshowdialogcode)]\n [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/add/codesnippet/visualbasic/windowshowdialogsnippets/mainwindow.xaml.vb#windowshowdialogcode)]"
  syntax:
    content: public Nullable<bool> ShowDialog ();
    parameters: []
    return:
      type: System.Nullable{System.Boolean}
      description: "A &lt;xref:System.Nullable%601&gt; 형식의 값 <xref:System.Boolean>활동 수락 하는지 여부를 지정 하는 (<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>) 또는 취소 (<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>).</xref:System.Boolean> 반환 값의 값은는 <xref:System.Windows.Window.DialogResult*>속성 창이 닫히기 전에.</xref:System.Windows.Window.DialogResult*>"
  overload: System.Windows.Window.ShowDialog*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "ShowDialog 닫힐 있는 창에 호출 됩니다 (<xref href=&quot;System.Windows.Window.Closing&quot;></xref>) 닫힌 또는 (<xref href=&quot;System.Windows.Window.Closed&quot;></xref>)."
  platform:
  - net462
- uid: System.Windows.Window.ShowInTaskbar
  id: ShowInTaskbar
  parent: System.Windows.Window
  langs:
  - csharp
  name: ShowInTaskbar
  nameWithType: Window.ShowInTaskbar
  fullName: System.Windows.Window.ShowInTaskbar
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창의 작업 표시줄 단추가 있는지 여부를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "ShowInTaskbar로 설정 되어 있으면 `true`, ALT + TAB 응용 프로그램 선택 목록에도 창이 나타납니다.       작업 표시줄 단추와 ALT + TAB 응용 프로그램 선택 목록에 사용 되는 아이콘의 값인는 <xref:System.Windows.Window.Icon%2A>속성.</xref:System.Windows.Window.Icon%2A>      > [!NOTE] > 설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.      <a name=&quot;dependencyPropertyInfo_WindowShowInTaskbar&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.Window.ShowInTaskbarProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.Window.ShowInTaskbarProperty>"
  syntax:
    content: public bool ShowInTaskbar { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>창에 작업 표시줄 단추가; 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 창을 브라우저에서 호스팅되는 경우 적용 되지 않습니다."
  overload: System.Windows.Window.ShowInTaskbar*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.ShowInTaskbarProperty
  id: ShowInTaskbarProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: ShowInTaskbarProperty
  nameWithType: Window.ShowInTaskbarProperty
  fullName: System.Windows.Window.ShowInTaskbarProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.Window.ShowInTaskbar*>종속성 속성입니다.</xref:System.Windows.Window.ShowInTaskbar*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.SizeToContent
  id: SizeToContent
  parent: System.Windows.Window
  langs:
  - csharp
  name: SizeToContent
  nameWithType: Window.SizeToContent
  fullName: System.Windows.Window.SizeToContent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창 크기 조정할지 여부를 자동으로 해당 콘텐츠의 크기에 맞게 자체를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "SizeToContent로 설정 되 면 <xref:System.Windows.SizeToContent>, 설정 <xref:System.Windows.FrameworkElement.Height%2A>또는 <xref:System.Windows.FrameworkElement.Width%2A>아무 효과가; 두 속성을 설정할 수 있지만 설정 값 창에 적용 되지 않습니다.</xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.Height%2A> </xref:System.Windows.SizeToContent>       SizeToContent로 설정 되 면 <xref:System.Windows.SizeToContent>설정 <xref:System.Windows.FrameworkElement.Height%2A>창의 높이 변경 되지 않습니다.</xref:System.Windows.FrameworkElement.Height%2A> </xref:System.Windows.SizeToContent>       SizeToContent로 설정 되 면 <xref:System.Windows.SizeToContent>설정 <xref:System.Windows.FrameworkElement.Width%2A>창의 너비를 변경 되지 않습니다.</xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.SizeToContent>       값이 있으면 SizeToContent 이외의 <xref:System.Windows.SizeToContent>:-SizeToContent로 자동 설정 됩니다 <xref:System.Windows.SizeToContent>사용자가 창의 크기 조정 그립을 사용 하거나 테두리를 끌어.</xref:System.Windows.SizeToContent> </xref:System.Windows.SizeToContent>      -콘텐츠 크기를 자체를 조정할 경우 창이 하는 방식으로 변경 되 면 <xref:System.Windows.FrameworkElement.SizeChanged>발생 합니다.</xref:System.Windows.FrameworkElement.SizeChanged>       창이 투명 한 경우 (참조 <xref:System.Windows.Window.AllowsTransparency%2A>), SizeToContent을 설정 하는 것이 좋습니다 <xref:System.Windows.SizeToContent>표시 된 콘텐츠를 보다 작은 창이 되는지.</xref:System.Windows.SizeToContent> </xref:System.Windows.Window.AllowsTransparency%2A>      > [!NOTE] > 설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.      <a name=&quot;dependencyPropertyInfo_WindowSizeToContent&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.Window.SizeToContentProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.Window.SizeToContentProperty>"
  example:
  - "The following example shows how to set the SizeToContent property in code to specify how a window resizes to fit its content.  \n  \n [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/add/codesnippet/visualbasic/howtowindowmanagementsnippets/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]\n [!code-cs[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/add/codesnippet/csharp/HOWTOWindowManagementSnippets/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]"
  syntax:
    content: public System.Windows.SizeToContent SizeToContent { get; set; }
    return:
      type: System.Windows.SizeToContent
      description: "A <xref href=&quot;System.Windows.SizeToContent&quot;></xref> value. 기본값은 <xref href=&quot;System.Windows.SizeToContent&quot;> </xref>합니다."
  overload: System.Windows.Window.SizeToContent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.SizeToContentProperty
  id: SizeToContentProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: SizeToContentProperty
  nameWithType: Window.SizeToContentProperty
  fullName: System.Windows.Window.SizeToContentProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.Window.SizeToContent*>종속성 속성입니다.</xref:System.Windows.Window.SizeToContent*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty SizeToContentProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.SourceInitialized
  id: SourceInitialized
  parent: System.Windows.Window
  langs:
  - csharp
  name: SourceInitialized
  nameWithType: Window.SourceInitialized
  fullName: System.Windows.Window.SourceInitialized
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "와 상호 운용을 지원 하기 위해이 이벤트는 [!INCLUDE[TLA#tla_win32](~/add/includes/tlasharptla-win32-md.md)]합니다. See <xref href=&quot;System.Windows.Interop.HwndSource&quot;></xref>."
  syntax:
    content: public event EventHandler SourceInitialized;
    return:
      type: System.EventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.StateChanged
  id: StateChanged
  parent: System.Windows.Window
  langs:
  - csharp
  name: StateChanged
  nameWithType: Window.StateChanged
  fullName: System.Windows.Window.StateChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "발생 경우 창의 <xref:System.Windows.Window.WindowState*>속성 변경.</xref:System.Windows.Window.WindowState*>"
  syntax:
    content: public event EventHandler StateChanged;
    return:
      type: System.EventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.TaskbarItemInfo
  id: TaskbarItemInfo
  parent: System.Windows.Window
  langs:
  - csharp
  name: TaskbarItemInfo
  nameWithType: Window.TaskbarItemInfo
  fullName: System.Windows.Window.TaskbarItemInfo
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "가져오거나는 [!INCLUDE[win7](~/add/includes/win7-md.md)] 에 대 한 작업 표시줄의 미리 보기는 <xref href=&quot;System.Windows.Window&quot;> </xref>합니다."
  remarks: "사용 하는 방법에 대 한 자세한 내용은 [!INCLUDE[win7](~/add/includes/win7-md.md)] 작업 표시줄 축소판 그림 <xref:System.Windows.Shell.TaskbarItemInfo>클래스</xref:System.Windows.Shell.TaskbarItemInfo> 를 참조 하십시오."
  syntax:
    content: public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }
    return:
      type: System.Windows.Shell.TaskbarItemInfo
      description: "[!INCLUDE[win7](~/add/includes/win7-md.md)] 에 대 한 작업 표시줄의 미리 보기는 <xref href=&quot;System.Windows.Window&quot;> </xref>합니다."
  overload: System.Windows.Window.TaskbarItemInfo*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.TaskbarItemInfoProperty
  id: TaskbarItemInfoProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: TaskbarItemInfoProperty
  nameWithType: Window.TaskbarItemInfoProperty
  fullName: System.Windows.Window.TaskbarItemInfoProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.Window.TaskbarItemInfo*>종속성 속성입니다.</xref:System.Windows.Window.TaskbarItemInfo*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Title
  id: Title
  parent: System.Windows.Window
  langs:
  - csharp
  name: Title
  nameWithType: Window.Title
  fullName: System.Windows.Window.Title
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창의 제목을 가져오거나 설정 합니다."
  remarks: "제목은 <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, 또는 [!INCLUDE[TLA#tla_iegeneric](~/add/includes/tlasharptla-iegeneric-md.md)], <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=fullName>.</xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=fullName> 를 사용 하 여 설정할 수도 있습니다</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Window>      <a name=&quot;dependencyPropertyInfo_WindowTitle&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.Window.TitleProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.Window.TitleProperty>"
  syntax:
    content: public string Title { get; set; }
    return:
      type: System.String
      description: "A <xref:System.String>창의 제목이 들어 있는.</xref:System.String>"
  overload: System.Windows.Window.Title*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.TitleProperty
  id: TitleProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: TitleProperty
  nameWithType: Window.TitleProperty
  fullName: System.Windows.Window.TitleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.Window.Title*>종속성 속성입니다.</xref:System.Windows.Window.Title*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TitleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Top
  id: Top
  parent: System.Windows.Window
  langs:
  - csharp
  name: Top
  nameWithType: Window.Top
  fullName: System.Windows.Window.Top
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "바탕 화면을 기준으로 창의 위쪽 가장자리의 위치를 가져오거나 설정 합니다."
  remarks: "경우는 <xref:System.Windows.Window>최대화 또는 최소화, 복원의 위쪽 가장자리 <xref:System.Windows.Window>.</xref:System.Windows.Window> 지점의이 값 나타냅니다</xref:System.Windows.Window>       스타일을 통해이 속성을 설정할 수 없습니다.       값을 지정 하지 않는 경우 Top 시스템 기본 값으로 설정 됩니다. 위쪽 <xref:System.Double.NaN>.</xref:System.Double.NaN> 를 설정 하 여 시스템 기본값을 지정할 수도 있습니다. 모두 <xref:System.Double.NegativeInfinity>또는 <xref:System.Double.PositiveInfinity>위쪽에 대 한 유효한 값인지.</xref:System.Double.PositiveInfinity> </xref:System.Double.NegativeInfinity>      > [!NOTE] > 설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.      <a name=&quot;dependencyPropertyInfo_WindowTop&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.Window.TopProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.Window.TopProperty>"
  syntax:
    content: public double Top { get; set; }
    return:
      type: System.Double
      description: "논리 단위 (1/96&quot;)에 창 위쪽의 위치입니다."
  overload: System.Windows.Window.Top*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Topmost
  id: Topmost
  parent: System.Windows.Window
  langs:
  - csharp
  name: Topmost
  nameWithType: Window.Topmost
  fullName: System.Windows.Window.Topmost
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창이 맨 위 z 순서로 표시 되는지 여부를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "맨 위에 있는 속성이로 설정 되는 창 `true` 모든 위에 나타납니다 맨 위에 있는 속성을 가진로 설정 된 windows `false`합니다.       Topmost 있는 windows 그룹의 속성이로 설정 되어 `true`, 현재 활성화 된의 맨 위에 있는 창입니다. 마찬가지로 Topmost 있는 windows 그룹에 대 한 속성이 `false`합니다.      > [!NOTE] > 설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.      <a name=&quot;dependencyPropertyInfo_WindowTopmost&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.Window.TopmostProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.Window.TopmostProperty>"
  syntax:
    content: public bool Topmost { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>창이 맨 위에 있으면 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.Window.Topmost*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.TopmostProperty
  id: TopmostProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: TopmostProperty
  nameWithType: Window.TopmostProperty
  fullName: System.Windows.Window.TopmostProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.Window.Topmost*>종속성 속성입니다.</xref:System.Windows.Window.Topmost*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TopmostProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.TopProperty
  id: TopProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: TopProperty
  nameWithType: Window.TopProperty
  fullName: System.Windows.Window.TopProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.Window.Top*>종속성 속성입니다.</xref:System.Windows.Window.Top*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TopProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.WindowStartupLocation
  id: WindowStartupLocation
  parent: System.Windows.Window
  langs:
  - csharp
  name: WindowStartupLocation
  nameWithType: Window.WindowStartupLocation
  fullName: System.Windows.Window.WindowStartupLocation
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "처음 표시 될 때 창의 위치를 가져오거나 설정 합니다."
  remarks: "설정 <xref:System.Windows.WindowStartupLocation>를 <xref:System.Windows.WindowStartupLocation>설정에 따라 배치 된 창은 해당 <xref:System.Windows.Window.Left%2A>및 <xref:System.Windows.Window.Top%2A>속성 값.</xref:System.Windows.Window.Top%2A> </xref:System.Windows.Window.Left%2A> </xref:System.Windows.WindowStartupLocation> </xref:System.Windows.WindowStartupLocation> 경우는 <xref:System.Windows.Window.Left%2A>또는 <xref:System.Windows.Window.Top%2A>해당 값은 따라 결정을 속성 지정 하지 않으면 [!INCLUDE[TLA2#tla_mswin](~/add/includes/tla2sharptla-mswin-md.md)].</xref:System.Windows.Window.Top%2A> </xref:System.Windows.Window.Left%2A>       설정 <xref:System.Windows.WindowStartupLocation>마우스 커서가 포함 된 화면 가운데에 배치 될 창이.</xref:System.Windows.WindowStartupLocation>       설정 <xref:System.Windows.WindowStartupLocation>를 <xref:System.Windows.WindowStartupLocation>소유자 창의 가운데에 배치 될 창이 (참조 <xref:System.Windows.Window.Owner%2A>), 지정 된 경우.</xref:System.Windows.Window.Owner%2A> </xref:System.Windows.WindowStartupLocation> </xref:System.Windows.WindowStartupLocation> 다른 WPF 창 또는 비 WPF 창 소유자 창이 될 수 있습니다.      > [!NOTE] > WPF 창 비 WPF windows에 대 한 자세한 내용은 참조 하십시오. [WPF 및 Win32 상호 운용](~/add/includes/ajax-current-ext-md.md) 및 <xref:System.Windows.Interop.WindowInteropHelper>.</xref:System.Windows.Interop.WindowInteropHelper>       창의 위치가 같은 방식으로 결정 됩니다 소유자 창이 지정 되지 않은 경우 처럼 <xref:System.Windows.WindowStartupLocation>를 <xref:System.Windows.WindowStartupLocation>.</xref:System.Windows.WindowStartupLocation> </xref:System.Windows.WindowStartupLocation>      > [!NOTE] > 설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성의 값을 가져올 수 없습니다."
  syntax:
    content: public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }
    return:
      type: System.Windows.WindowStartupLocation
      description: "A <xref href=&quot;System.Windows.WindowStartupLocation&quot;> </xref> 처음 표시 될 때 창 위쪽/왼쪽 위치를 지정 하는 값입니다. 기본값은 <xref href=&quot;System.Windows.WindowStartupLocation&quot;> </xref>합니다."
  overload: System.Windows.Window.WindowStartupLocation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.WindowState
  id: WindowState
  parent: System.Windows.Window
  langs:
  - csharp
  name: WindowState
  nameWithType: Window.WindowState
  fullName: System.Windows.Window.WindowState
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창을 복원, 최소화, 또는 최대화를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "크기와 위치 <xref:System.Windows.Window.RestoreBounds%2A>.</xref:System.Windows.Window.RestoreBounds%2A> 에 저장 된 창이 최소화 되거나 최대화 된, 전에 창을 복원 후, 해당 크기와 위치 값 <xref:System.Windows.Window.RestoreBounds%2A>.</xref:System.Windows.Window.RestoreBounds%2A> 의 값으로 복원 됩니다.       WindowState 속성이 변경 되 면 <xref:System.Windows.Window.StateChanged>발생 합니다.</xref:System.Windows.Window.StateChanged>      > [!NOTE] > 설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.      <a name=&quot;dependencyPropertyInfo_WindowWindowState&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.Window.WindowStateProperty>|   | 메타 데이터 속성이 `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|</xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A> </xref:System.Windows.Window.WindowStateProperty>"
  syntax:
    content: public System.Windows.WindowState WindowState { get; set; }
    return:
      type: System.Windows.WindowState
      description: "A <xref href=&quot;System.Windows.WindowState&quot;> </xref> 결정 하는 창을 복원, 최소화, 또는 최대화 합니다. 기본값은 <xref href=&quot;System.Windows.WindowState&quot;> </xref> (복원 됨)."
  overload: System.Windows.Window.WindowState*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.WindowStateProperty
  id: WindowStateProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: WindowStateProperty
  nameWithType: Window.WindowStateProperty
  fullName: System.Windows.Window.WindowStateProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.Window.WindowState*>종속성 속성입니다.</xref:System.Windows.Window.WindowState*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty WindowStateProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.WindowStyle
  id: WindowStyle
  parent: System.Windows.Window
  langs:
  - csharp
  name: WindowStyle
  nameWithType: Window.WindowStyle
  fullName: System.Windows.Window.WindowStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "창의 테두리 스타일을 가져오거나 설정 합니다."
  remarks: "WindowStyle 중 하나일 수 있습니다는 <xref:System.Windows.WindowStyle>열거 값을 포함 하 여 <xref:System.Windows.WindowStyle>, <xref:System.Windows.WindowStyle>, <xref:System.Windows.WindowStyle>(기본값), 및 <xref:System.Windows.WindowStyle>.</xref:System.Windows.WindowStyle> </xref:System.Windows.WindowStyle> </xref:System.Windows.WindowStyle> </xref:System.Windows.WindowStyle> </xref:System.Windows.WindowStyle>       다음 그림에 창 스타일은 [!INCLUDE[TLA#tla_longhorn](~/add/includes/ajax-current-ext-md.md)] (투명 효과 사용 하도록 설정 된 Windows Vista Aero 테마): ![창 스타일](~/add/media/windowoverviewfigure6.PNG &quot;창 스타일&quot;)       >  [!NOTE] > 설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.      <a name=&quot;dependencyPropertyInfo_WindowWindowStyle&quot;></a># # 종속성 속성 정보 | | |   |-|-|   | 식별자 필드 | <xref:System.Windows.Window.WindowStyleProperty>|   | 메타 데이터 속성이 `true`| None |</xref:System.Windows.Window.WindowStyleProperty>"
  syntax:
    content: public System.Windows.WindowStyle WindowStyle { get; set; }
    return:
      type: System.Windows.WindowStyle
      description: "A <xref href=&quot;System.Windows.WindowStyle&quot;> </xref> 창의 테두리 스타일을 지정 하는 합니다. 기본값은 <xref href=&quot;System.Windows.WindowStyle&quot;> </xref>합니다."
  overload: System.Windows.Window.WindowStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.WindowStyleProperty
  id: WindowStyleProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: WindowStyleProperty
  nameWithType: Window.WindowStyleProperty
  fullName: System.Windows.Window.WindowStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "식별 된 <xref:System.Windows.Window.WindowStyle*>종속성 속성입니다.</xref:System.Windows.Window.WindowStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty WindowStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Controls.ContentControl
  isExternal: false
  name: System.Windows.Controls.ContentControl
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.Window.#ctor
  parent: System.Windows.Window
  isExternal: false
  name: Window()
  nameWithType: Window.Window()
  fullName: System.Windows.Window.Window()
- uid: System.Windows.Window.Activate
  parent: System.Windows.Window
  isExternal: false
  name: Activate()
  nameWithType: Window.Activate()
  fullName: System.Windows.Window.Activate()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Window.Activated
  parent: System.Windows.Window
  isExternal: false
  name: Activated
  nameWithType: Window.Activated
  fullName: System.Windows.Window.Activated
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.Window.AllowsTransparency
  parent: System.Windows.Window
  isExternal: false
  name: AllowsTransparency
  nameWithType: Window.AllowsTransparency
  fullName: System.Windows.Window.AllowsTransparency
- uid: System.Windows.Window.AllowsTransparencyProperty
  parent: System.Windows.Window
  isExternal: false
  name: AllowsTransparencyProperty
  nameWithType: Window.AllowsTransparencyProperty
  fullName: System.Windows.Window.AllowsTransparencyProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.Window.ArrangeOverride(System.Windows.Size)
  parent: System.Windows.Window
  isExternal: false
  name: ArrangeOverride(Size)
  nameWithType: Window.ArrangeOverride(Size)
  fullName: System.Windows.Window.ArrangeOverride(Size)
- uid: System.Windows.Size
  parent: System.Windows
  isExternal: false
  name: Size
  nameWithType: Size
  fullName: System.Windows.Size
- uid: System.Windows.Window.Close
  parent: System.Windows.Window
  isExternal: false
  name: Close()
  nameWithType: Window.Close()
  fullName: System.Windows.Window.Close()
- uid: System.Windows.Window.Closed
  parent: System.Windows.Window
  isExternal: false
  name: Closed
  nameWithType: Window.Closed
  fullName: System.Windows.Window.Closed
- uid: System.Windows.Window.Closing
  parent: System.Windows.Window
  isExternal: false
  name: Closing
  nameWithType: Window.Closing
  fullName: System.Windows.Window.Closing
- uid: System.ComponentModel.CancelEventHandler
  parent: System.ComponentModel
  isExternal: false
  name: CancelEventHandler
  nameWithType: CancelEventHandler
  fullName: System.ComponentModel.CancelEventHandler
- uid: System.Windows.Window.ContentRendered
  parent: System.Windows.Window
  isExternal: false
  name: ContentRendered
  nameWithType: Window.ContentRendered
  fullName: System.Windows.Window.ContentRendered
- uid: System.Windows.Window.Deactivated
  parent: System.Windows.Window
  isExternal: false
  name: Deactivated
  nameWithType: Window.Deactivated
  fullName: System.Windows.Window.Deactivated
- uid: System.Windows.Window.DialogResult
  parent: System.Windows.Window
  isExternal: false
  name: DialogResult
  nameWithType: Window.DialogResult
  fullName: System.Windows.Window.DialogResult
- uid: System.Nullable{System.Boolean}
  parent: System
  isExternal: true
  name: Nullable<Boolean>
  nameWithType: Nullable<Boolean>
  fullName: System.Nullable<System.Boolean>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: Nullable<System.Boolean>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: Boolean
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.Window.DpiChanged
  parent: System.Windows.Window
  isExternal: false
  name: DpiChanged
  nameWithType: Window.DpiChanged
  fullName: System.Windows.Window.DpiChanged
- uid: System.Windows.DpiChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DpiChangedEventHandler
  nameWithType: DpiChangedEventHandler
  fullName: System.Windows.DpiChangedEventHandler
- uid: System.Windows.Window.DpiChangedEvent
  parent: System.Windows.Window
  isExternal: false
  name: DpiChangedEvent
  nameWithType: Window.DpiChangedEvent
  fullName: System.Windows.Window.DpiChangedEvent
- uid: System.Windows.RoutedEvent
  parent: System.Windows
  isExternal: false
  name: RoutedEvent
  nameWithType: RoutedEvent
  fullName: System.Windows.RoutedEvent
- uid: System.Windows.Window.DragMove
  parent: System.Windows.Window
  isExternal: false
  name: DragMove()
  nameWithType: Window.DragMove()
  fullName: System.Windows.Window.DragMove()
- uid: System.Windows.Window.GetWindow(System.Windows.DependencyObject)
  parent: System.Windows.Window
  isExternal: false
  name: GetWindow(DependencyObject)
  nameWithType: Window.GetWindow(DependencyObject)
  fullName: System.Windows.Window.GetWindow(DependencyObject)
- uid: System.Windows.Window
  parent: System.Windows
  isExternal: false
  name: Window
  nameWithType: Window
  fullName: System.Windows.Window
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.Window.Hide
  parent: System.Windows.Window
  isExternal: false
  name: Hide()
  nameWithType: Window.Hide()
  fullName: System.Windows.Window.Hide()
- uid: System.Windows.Window.Icon
  parent: System.Windows.Window
  isExternal: false
  name: Icon
  nameWithType: Window.Icon
  fullName: System.Windows.Window.Icon
- uid: System.Windows.Media.ImageSource
  parent: System.Windows.Media
  isExternal: false
  name: ImageSource
  nameWithType: ImageSource
  fullName: System.Windows.Media.ImageSource
- uid: System.Windows.Window.IconProperty
  parent: System.Windows.Window
  isExternal: false
  name: IconProperty
  nameWithType: Window.IconProperty
  fullName: System.Windows.Window.IconProperty
- uid: System.Windows.Window.IsActive
  parent: System.Windows.Window
  isExternal: false
  name: IsActive
  nameWithType: Window.IsActive
  fullName: System.Windows.Window.IsActive
- uid: System.Windows.Window.IsActiveProperty
  parent: System.Windows.Window
  isExternal: false
  name: IsActiveProperty
  nameWithType: Window.IsActiveProperty
  fullName: System.Windows.Window.IsActiveProperty
- uid: System.Windows.Window.Left
  parent: System.Windows.Window
  isExternal: false
  name: Left
  nameWithType: Window.Left
  fullName: System.Windows.Window.Left
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Windows.Window.LeftProperty
  parent: System.Windows.Window
  isExternal: false
  name: LeftProperty
  nameWithType: Window.LeftProperty
  fullName: System.Windows.Window.LeftProperty
- uid: System.Windows.Window.LocationChanged
  parent: System.Windows.Window
  isExternal: false
  name: LocationChanged
  nameWithType: Window.LocationChanged
  fullName: System.Windows.Window.LocationChanged
- uid: System.Windows.Window.LogicalChildren
  parent: System.Windows.Window
  isExternal: false
  name: LogicalChildren
  nameWithType: Window.LogicalChildren
  fullName: System.Windows.Window.LogicalChildren
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Windows.Window.MeasureOverride(System.Windows.Size)
  parent: System.Windows.Window
  isExternal: false
  name: MeasureOverride(Size)
  nameWithType: Window.MeasureOverride(Size)
  fullName: System.Windows.Window.MeasureOverride(Size)
- uid: System.Windows.Window.OnActivated(System.EventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnActivated(EventArgs)
  nameWithType: Window.OnActivated(EventArgs)
  fullName: System.Windows.Window.OnActivated(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.Window.OnClosed(System.EventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnClosed(EventArgs)
  nameWithType: Window.OnClosed(EventArgs)
  fullName: System.Windows.Window.OnClosed(EventArgs)
- uid: System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnClosing(CancelEventArgs)
  nameWithType: Window.OnClosing(CancelEventArgs)
  fullName: System.Windows.Window.OnClosing(CancelEventArgs)
- uid: System.ComponentModel.CancelEventArgs
  parent: System.ComponentModel
  isExternal: true
  name: CancelEventArgs
  nameWithType: CancelEventArgs
  fullName: System.ComponentModel.CancelEventArgs
- uid: System.Windows.Window.OnContentChanged(System.Object,System.Object)
  parent: System.Windows.Window
  isExternal: false
  name: OnContentChanged(Object,Object)
  nameWithType: Window.OnContentChanged(Object,Object)
  fullName: System.Windows.Window.OnContentChanged(Object,Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.Window.OnContentRendered(System.EventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnContentRendered(EventArgs)
  nameWithType: Window.OnContentRendered(EventArgs)
  fullName: System.Windows.Window.OnContentRendered(EventArgs)
- uid: System.Windows.Window.OnCreateAutomationPeer
  parent: System.Windows.Window
  isExternal: false
  name: OnCreateAutomationPeer()
  nameWithType: Window.OnCreateAutomationPeer()
  fullName: System.Windows.Window.OnCreateAutomationPeer()
- uid: System.Windows.Automation.Peers.AutomationPeer
  parent: System.Windows.Automation.Peers
  isExternal: false
  name: AutomationPeer
  nameWithType: AutomationPeer
  fullName: System.Windows.Automation.Peers.AutomationPeer
- uid: System.Windows.Window.OnDeactivated(System.EventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnDeactivated(EventArgs)
  nameWithType: Window.OnDeactivated(EventArgs)
  fullName: System.Windows.Window.OnDeactivated(EventArgs)
- uid: System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)
  parent: System.Windows.Window
  isExternal: false
  name: OnDpiChanged(DpiScale,DpiScale)
  nameWithType: Window.OnDpiChanged(DpiScale,DpiScale)
  fullName: System.Windows.Window.OnDpiChanged(DpiScale,DpiScale)
- uid: System.Windows.DpiScale
  parent: System.Windows
  isExternal: false
  name: DpiScale
  nameWithType: DpiScale
  fullName: System.Windows.DpiScale
- uid: System.Windows.Window.OnLocationChanged(System.EventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnLocationChanged(EventArgs)
  nameWithType: Window.OnLocationChanged(EventArgs)
  fullName: System.Windows.Window.OnLocationChanged(EventArgs)
- uid: System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
  nameWithType: Window.OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
  fullName: System.Windows.Window.OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
- uid: System.Windows.Input.ManipulationBoundaryFeedbackEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: ManipulationBoundaryFeedbackEventArgs
  nameWithType: ManipulationBoundaryFeedbackEventArgs
  fullName: System.Windows.Input.ManipulationBoundaryFeedbackEventArgs
- uid: System.Windows.Window.OnSourceInitialized(System.EventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnSourceInitialized(EventArgs)
  nameWithType: Window.OnSourceInitialized(EventArgs)
  fullName: System.Windows.Window.OnSourceInitialized(EventArgs)
- uid: System.Windows.Window.OnStateChanged(System.EventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnStateChanged(EventArgs)
  nameWithType: Window.OnStateChanged(EventArgs)
  fullName: System.Windows.Window.OnStateChanged(EventArgs)
- uid: System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)
  parent: System.Windows.Window
  isExternal: false
  name: OnVisualParentChanged(DependencyObject)
  nameWithType: Window.OnVisualParentChanged(DependencyObject)
  fullName: System.Windows.Window.OnVisualParentChanged(DependencyObject)
- uid: System.Windows.Window.OwnedWindows
  parent: System.Windows.Window
  isExternal: false
  name: OwnedWindows
  nameWithType: Window.OwnedWindows
  fullName: System.Windows.Window.OwnedWindows
- uid: System.Windows.WindowCollection
  parent: System.Windows
  isExternal: false
  name: WindowCollection
  nameWithType: WindowCollection
  fullName: System.Windows.WindowCollection
- uid: System.Windows.Window.Owner
  parent: System.Windows.Window
  isExternal: false
  name: Owner
  nameWithType: Window.Owner
  fullName: System.Windows.Window.Owner
- uid: System.Windows.Window.ResizeMode
  parent: System.Windows.Window
  isExternal: false
  name: ResizeMode
  nameWithType: Window.ResizeMode
  fullName: System.Windows.Window.ResizeMode
- uid: System.Windows.ResizeMode
  parent: System.Windows
  isExternal: false
  name: ResizeMode
  nameWithType: ResizeMode
  fullName: System.Windows.ResizeMode
- uid: System.Windows.Window.ResizeModeProperty
  parent: System.Windows.Window
  isExternal: false
  name: ResizeModeProperty
  nameWithType: Window.ResizeModeProperty
  fullName: System.Windows.Window.ResizeModeProperty
- uid: System.Windows.Window.RestoreBounds
  parent: System.Windows.Window
  isExternal: false
  name: RestoreBounds
  nameWithType: Window.RestoreBounds
  fullName: System.Windows.Window.RestoreBounds
- uid: System.Windows.Rect
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect
- uid: System.Windows.Window.Show
  parent: System.Windows.Window
  isExternal: false
  name: Show()
  nameWithType: Window.Show()
  fullName: System.Windows.Window.Show()
- uid: System.Windows.Window.ShowActivated
  parent: System.Windows.Window
  isExternal: false
  name: ShowActivated
  nameWithType: Window.ShowActivated
  fullName: System.Windows.Window.ShowActivated
- uid: System.Windows.Window.ShowActivatedProperty
  parent: System.Windows.Window
  isExternal: false
  name: ShowActivatedProperty
  nameWithType: Window.ShowActivatedProperty
  fullName: System.Windows.Window.ShowActivatedProperty
- uid: System.Windows.Window.ShowDialog
  parent: System.Windows.Window
  isExternal: false
  name: ShowDialog()
  nameWithType: Window.ShowDialog()
  fullName: System.Windows.Window.ShowDialog()
- uid: System.Windows.Window.ShowInTaskbar
  parent: System.Windows.Window
  isExternal: false
  name: ShowInTaskbar
  nameWithType: Window.ShowInTaskbar
  fullName: System.Windows.Window.ShowInTaskbar
- uid: System.Windows.Window.ShowInTaskbarProperty
  parent: System.Windows.Window
  isExternal: false
  name: ShowInTaskbarProperty
  nameWithType: Window.ShowInTaskbarProperty
  fullName: System.Windows.Window.ShowInTaskbarProperty
- uid: System.Windows.Window.SizeToContent
  parent: System.Windows.Window
  isExternal: false
  name: SizeToContent
  nameWithType: Window.SizeToContent
  fullName: System.Windows.Window.SizeToContent
- uid: System.Windows.SizeToContent
  parent: System.Windows
  isExternal: false
  name: SizeToContent
  nameWithType: SizeToContent
  fullName: System.Windows.SizeToContent
- uid: System.Windows.Window.SizeToContentProperty
  parent: System.Windows.Window
  isExternal: false
  name: SizeToContentProperty
  nameWithType: Window.SizeToContentProperty
  fullName: System.Windows.Window.SizeToContentProperty
- uid: System.Windows.Window.SourceInitialized
  parent: System.Windows.Window
  isExternal: false
  name: SourceInitialized
  nameWithType: Window.SourceInitialized
  fullName: System.Windows.Window.SourceInitialized
- uid: System.Windows.Window.StateChanged
  parent: System.Windows.Window
  isExternal: false
  name: StateChanged
  nameWithType: Window.StateChanged
  fullName: System.Windows.Window.StateChanged
- uid: System.Windows.Window.TaskbarItemInfo
  parent: System.Windows.Window
  isExternal: false
  name: TaskbarItemInfo
  nameWithType: Window.TaskbarItemInfo
  fullName: System.Windows.Window.TaskbarItemInfo
- uid: System.Windows.Shell.TaskbarItemInfo
  parent: System.Windows.Shell
  isExternal: false
  name: TaskbarItemInfo
  nameWithType: TaskbarItemInfo
  fullName: System.Windows.Shell.TaskbarItemInfo
- uid: System.Windows.Window.TaskbarItemInfoProperty
  parent: System.Windows.Window
  isExternal: false
  name: TaskbarItemInfoProperty
  nameWithType: Window.TaskbarItemInfoProperty
  fullName: System.Windows.Window.TaskbarItemInfoProperty
- uid: System.Windows.Window.Title
  parent: System.Windows.Window
  isExternal: false
  name: Title
  nameWithType: Window.Title
  fullName: System.Windows.Window.Title
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Window.TitleProperty
  parent: System.Windows.Window
  isExternal: false
  name: TitleProperty
  nameWithType: Window.TitleProperty
  fullName: System.Windows.Window.TitleProperty
- uid: System.Windows.Window.Top
  parent: System.Windows.Window
  isExternal: false
  name: Top
  nameWithType: Window.Top
  fullName: System.Windows.Window.Top
- uid: System.Windows.Window.Topmost
  parent: System.Windows.Window
  isExternal: false
  name: Topmost
  nameWithType: Window.Topmost
  fullName: System.Windows.Window.Topmost
- uid: System.Windows.Window.TopmostProperty
  parent: System.Windows.Window
  isExternal: false
  name: TopmostProperty
  nameWithType: Window.TopmostProperty
  fullName: System.Windows.Window.TopmostProperty
- uid: System.Windows.Window.TopProperty
  parent: System.Windows.Window
  isExternal: false
  name: TopProperty
  nameWithType: Window.TopProperty
  fullName: System.Windows.Window.TopProperty
- uid: System.Windows.Window.WindowStartupLocation
  parent: System.Windows.Window
  isExternal: false
  name: WindowStartupLocation
  nameWithType: Window.WindowStartupLocation
  fullName: System.Windows.Window.WindowStartupLocation
- uid: System.Windows.WindowStartupLocation
  parent: System.Windows
  isExternal: false
  name: WindowStartupLocation
  nameWithType: WindowStartupLocation
  fullName: System.Windows.WindowStartupLocation
- uid: System.Windows.Window.WindowState
  parent: System.Windows.Window
  isExternal: false
  name: WindowState
  nameWithType: Window.WindowState
  fullName: System.Windows.Window.WindowState
- uid: System.Windows.WindowState
  parent: System.Windows
  isExternal: false
  name: WindowState
  nameWithType: WindowState
  fullName: System.Windows.WindowState
- uid: System.Windows.Window.WindowStateProperty
  parent: System.Windows.Window
  isExternal: false
  name: WindowStateProperty
  nameWithType: Window.WindowStateProperty
  fullName: System.Windows.Window.WindowStateProperty
- uid: System.Windows.Window.WindowStyle
  parent: System.Windows.Window
  isExternal: false
  name: WindowStyle
  nameWithType: Window.WindowStyle
  fullName: System.Windows.Window.WindowStyle
- uid: System.Windows.WindowStyle
  parent: System.Windows
  isExternal: false
  name: WindowStyle
  nameWithType: WindowStyle
  fullName: System.Windows.WindowStyle
- uid: System.Windows.Window.WindowStyleProperty
  parent: System.Windows.Window
  isExternal: false
  name: WindowStyleProperty
  nameWithType: Window.WindowStyleProperty
  fullName: System.Windows.Window.WindowStyleProperty
- uid: System.Windows.Window.#ctor*
  parent: System.Windows.Window
  isExternal: false
  name: Window
  nameWithType: Window.Window
- uid: System.Windows.Window.Activate*
  parent: System.Windows.Window
  isExternal: false
  name: Activate
  nameWithType: Window.Activate
- uid: System.Windows.Window.AllowsTransparency*
  parent: System.Windows.Window
  isExternal: false
  name: AllowsTransparency
  nameWithType: Window.AllowsTransparency
- uid: System.Windows.Window.ArrangeOverride*
  parent: System.Windows.Window
  isExternal: false
  name: ArrangeOverride
  nameWithType: Window.ArrangeOverride
- uid: System.Windows.Window.Close*
  parent: System.Windows.Window
  isExternal: false
  name: Close
  nameWithType: Window.Close
- uid: System.Windows.Window.DialogResult*
  parent: System.Windows.Window
  isExternal: false
  name: DialogResult
  nameWithType: Window.DialogResult
- uid: System.Windows.Window.DragMove*
  parent: System.Windows.Window
  isExternal: false
  name: DragMove
  nameWithType: Window.DragMove
- uid: System.Windows.Window.GetWindow*
  parent: System.Windows.Window
  isExternal: false
  name: GetWindow
  nameWithType: Window.GetWindow
- uid: System.Windows.Window.Hide*
  parent: System.Windows.Window
  isExternal: false
  name: Hide
  nameWithType: Window.Hide
- uid: System.Windows.Window.Icon*
  parent: System.Windows.Window
  isExternal: false
  name: Icon
  nameWithType: Window.Icon
- uid: System.Windows.Window.IsActive*
  parent: System.Windows.Window
  isExternal: false
  name: IsActive
  nameWithType: Window.IsActive
- uid: System.Windows.Window.Left*
  parent: System.Windows.Window
  isExternal: false
  name: Left
  nameWithType: Window.Left
- uid: System.Windows.Window.LogicalChildren*
  parent: System.Windows.Window
  isExternal: false
  name: LogicalChildren
  nameWithType: Window.LogicalChildren
- uid: System.Windows.Window.MeasureOverride*
  parent: System.Windows.Window
  isExternal: false
  name: MeasureOverride
  nameWithType: Window.MeasureOverride
- uid: System.Windows.Window.OnActivated*
  parent: System.Windows.Window
  isExternal: false
  name: OnActivated
  nameWithType: Window.OnActivated
- uid: System.Windows.Window.OnClosed*
  parent: System.Windows.Window
  isExternal: false
  name: OnClosed
  nameWithType: Window.OnClosed
- uid: System.Windows.Window.OnClosing*
  parent: System.Windows.Window
  isExternal: false
  name: OnClosing
  nameWithType: Window.OnClosing
- uid: System.Windows.Window.OnContentChanged*
  parent: System.Windows.Window
  isExternal: false
  name: OnContentChanged
  nameWithType: Window.OnContentChanged
- uid: System.Windows.Window.OnContentRendered*
  parent: System.Windows.Window
  isExternal: false
  name: OnContentRendered
  nameWithType: Window.OnContentRendered
- uid: System.Windows.Window.OnCreateAutomationPeer*
  parent: System.Windows.Window
  isExternal: false
  name: OnCreateAutomationPeer
  nameWithType: Window.OnCreateAutomationPeer
- uid: System.Windows.Window.OnDeactivated*
  parent: System.Windows.Window
  isExternal: false
  name: OnDeactivated
  nameWithType: Window.OnDeactivated
- uid: System.Windows.Window.OnDpiChanged*
  parent: System.Windows.Window
  isExternal: false
  name: OnDpiChanged
  nameWithType: Window.OnDpiChanged
- uid: System.Windows.Window.OnLocationChanged*
  parent: System.Windows.Window
  isExternal: false
  name: OnLocationChanged
  nameWithType: Window.OnLocationChanged
- uid: System.Windows.Window.OnManipulationBoundaryFeedback*
  parent: System.Windows.Window
  isExternal: false
  name: OnManipulationBoundaryFeedback
  nameWithType: Window.OnManipulationBoundaryFeedback
- uid: System.Windows.Window.OnSourceInitialized*
  parent: System.Windows.Window
  isExternal: false
  name: OnSourceInitialized
  nameWithType: Window.OnSourceInitialized
- uid: System.Windows.Window.OnStateChanged*
  parent: System.Windows.Window
  isExternal: false
  name: OnStateChanged
  nameWithType: Window.OnStateChanged
- uid: System.Windows.Window.OnVisualParentChanged*
  parent: System.Windows.Window
  isExternal: false
  name: OnVisualParentChanged
  nameWithType: Window.OnVisualParentChanged
- uid: System.Windows.Window.OwnedWindows*
  parent: System.Windows.Window
  isExternal: false
  name: OwnedWindows
  nameWithType: Window.OwnedWindows
- uid: System.Windows.Window.Owner*
  parent: System.Windows.Window
  isExternal: false
  name: Owner
  nameWithType: Window.Owner
- uid: System.Windows.Window.ResizeMode*
  parent: System.Windows.Window
  isExternal: false
  name: ResizeMode
  nameWithType: Window.ResizeMode
- uid: System.Windows.Window.RestoreBounds*
  parent: System.Windows.Window
  isExternal: false
  name: RestoreBounds
  nameWithType: Window.RestoreBounds
- uid: System.Windows.Window.Show*
  parent: System.Windows.Window
  isExternal: false
  name: Show
  nameWithType: Window.Show
- uid: System.Windows.Window.ShowActivated*
  parent: System.Windows.Window
  isExternal: false
  name: ShowActivated
  nameWithType: Window.ShowActivated
- uid: System.Windows.Window.ShowDialog*
  parent: System.Windows.Window
  isExternal: false
  name: ShowDialog
  nameWithType: Window.ShowDialog
- uid: System.Windows.Window.ShowInTaskbar*
  parent: System.Windows.Window
  isExternal: false
  name: ShowInTaskbar
  nameWithType: Window.ShowInTaskbar
- uid: System.Windows.Window.SizeToContent*
  parent: System.Windows.Window
  isExternal: false
  name: SizeToContent
  nameWithType: Window.SizeToContent
- uid: System.Windows.Window.TaskbarItemInfo*
  parent: System.Windows.Window
  isExternal: false
  name: TaskbarItemInfo
  nameWithType: Window.TaskbarItemInfo
- uid: System.Windows.Window.Title*
  parent: System.Windows.Window
  isExternal: false
  name: Title
  nameWithType: Window.Title
- uid: System.Windows.Window.Top*
  parent: System.Windows.Window
  isExternal: false
  name: Top
  nameWithType: Window.Top
- uid: System.Windows.Window.Topmost*
  parent: System.Windows.Window
  isExternal: false
  name: Topmost
  nameWithType: Window.Topmost
- uid: System.Windows.Window.WindowStartupLocation*
  parent: System.Windows.Window
  isExternal: false
  name: WindowStartupLocation
  nameWithType: Window.WindowStartupLocation
- uid: System.Windows.Window.WindowState*
  parent: System.Windows.Window
  isExternal: false
  name: WindowState
  nameWithType: Window.WindowState
- uid: System.Windows.Window.WindowStyle*
  parent: System.Windows.Window
  isExternal: false
  name: WindowStyle
  nameWithType: Window.WindowStyle
