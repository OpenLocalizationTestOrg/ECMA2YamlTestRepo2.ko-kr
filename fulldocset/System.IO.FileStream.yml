### YamlMime:ManagedReference
items:
- uid: System.IO.FileStream
  id: FileStream
  children:
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.CanRead
  - System.IO.FileStream.CanSeek
  - System.IO.FileStream.CanWrite
  - System.IO.FileStream.Dispose(System.Boolean)
  - System.IO.FileStream.EndRead(System.IAsyncResult)
  - System.IO.FileStream.EndWrite(System.IAsyncResult)
  - System.IO.FileStream.Finalize
  - System.IO.FileStream.Flush
  - System.IO.FileStream.Flush(System.Boolean)
  - System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.FileStream.GetAccessControl
  - System.IO.FileStream.Handle
  - System.IO.FileStream.IsAsync
  - System.IO.FileStream.Length
  - System.IO.FileStream.Lock(System.Int64,System.Int64)
  - System.IO.FileStream.Name
  - System.IO.FileStream.Position
  - System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.ReadByte
  - System.IO.FileStream.SafeFileHandle
  - System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.SetLength(System.Int64)
  - System.IO.FileStream.Unlock(System.Int64,System.Int64)
  - System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: FileStream
  nameWithType: FileStream
  fullName: System.IO.FileStream
  type: Class
  summary: "제공 된 <xref:System.IO.Stream>읽기 / 쓰기 작업 둘 다 동기 및 비동기 지원 하는 파일에 대 한.</xref:System.IO.Stream>       이 형식에 대 한.NET Framework 소스 코드를 찾아보려면 참조는 [참조 소스](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3)합니다."
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n Use the FileStream class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output. You can use the [Read(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), [Write(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), <xref:System.IO.Stream.CopyTo%2A>, and <xref:System.IO.FileStream.Flush%2A> methods to perform synchronous operations, or the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A> methods to perform asynchronous operations. Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread. This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working. FileStream buffers input and output for better performance.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n The <xref:System.IO.FileStream.IsAsync%2A> property detects whether the file handle was opened asynchronously. You specify this value when you create an instance of the FileStream class using a constructor that has an `isAsync`, `useAsync`, or `options` parameter. When the property is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously. However, the <xref:System.IO.FileStream.IsAsync%2A> property does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method. When the <xref:System.IO.FileStream.IsAsync%2A> property is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.  \n  \n The <xref:System.IO.FileStream.Seek%2A> method supports random access to files. <xref:System.IO.FileStream.Seek%2A> allows the read/write position to be moved to any position within the file. This is done with byte offset reference point parameters. The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <xref:System.IO.SeekOrigin> enumeration.  \n  \n> [!NOTE]\n>  Disk files always support random access. At the time of construction, the <xref:System.IO.FileStream.CanSeek%2A> property value is set to `true` or `false` depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <xref:System.IO.FileStream.CanSeek%2A> property value is `true`. Otherwise, the <xref:System.IO.FileStream.CanSeek%2A> property value is `false`.  \n  \n If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.  \n  \n For directory operations and other file operations, see the <xref:System.IO.File>, <xref:System.IO.Directory>, and <xref:System.IO.Path> classes. The <xref:System.IO.File> class is a utility class that has static methods primarily for the creation of FileStream objects based on file paths. The <xref:System.IO.MemoryStream> class creates a stream from a byte array and is similar to the FileStream class.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md).  \n  \n## Detection of Stream Position Changes  \n When a FileStream object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle. In this case, the cached position in the FileStream object and the cached data in the buffer could be compromised. The FileStream object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the FileStream object.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Read%2A> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again. This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Write%2A> method, the contents of the buffer are discarded and an <xref:System.IO.IOException> exception is thrown.  \n  \n A FileStream object will not have an exclusive hold on its handle when either the <xref:System.IO.FileStream.SafeFileHandle%2A> property is accessed to expose the handle or the FileStream object is given the <xref:System.IO.FileStream.SafeFileHandle%2A> property in its constructor."
  example:
  - "The following example demonstrates some of the FileStream constructors.  \n  \n [!code-cs[fstream class#1](~/add/codesnippet/csharp/t-system.io.filestream_1.cs)]\n [!code-vb[fstream class#1](~/add/codesnippet/visualbasic/t-system.io.filestream_1.vb)]\n [!code-cpp[fstream class#1](~/add/codesnippet/cpp/t-system.io.filestream_1.cpp)]  \n  \n The following example shows how to write to a file asynchronously. This code runs in a WPF app that has a TextBlock named UserInput and a button hooked up to a Click event handler that is named Button_Click. The file path needs to be changed to a file than exits on the computer.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/t-system.io.filestream_2.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/t-system.io.filestream_2.cs)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class FileStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.FileStream&quot;> </xref> 지정 된 읽기/쓰기 권한이 있는 지정 된 파일 핸들에 대 한 클래스입니다."
  remarks: "때 <xref:System.IO.Stream.Close%2A>은 호출, 핸들 닫히며 파일의 핸들 수가 감소 됩니다.</xref:System.IO.Stream.Close%2A>       `FileStream`핸들에 대 한 독점적인 제어권 있음을 가정 합니다. 읽기, 쓰기 또는 검색 하는 동안 한 `FileStream` 유지 되는 핸들 데이터 손상 될 수 있습니다. 데이터 보안을 위해 호출 <xref:System.IO.FileStream.Flush%2A>핸들을 사용 하 여 전과 이외의 다른 모든 메서드를 호출 하지 마십시오. `Close` 완료 한 후 핸들을 사용 하 여.</xref:System.IO.FileStream.Flush%2A>      > [!CAUTION] > 문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색은 해석할 수 없어 문자와를 throw 하면 예외가 발생 합니다.       `FileShare.Read`기본은 사용자 용 <xref:System.IO.FileStream>없는 생성자는 `FileShare` 매개 변수.</xref:System.IO.FileStream>       일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "파일에 대 한 파일 핸들은 현재 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체가 캡슐화 됩니다."
    - id: access
      type: System.IO.FileAccess
      description: "설정 하는 상수는 <> </> *> 및 <> </> *>의 속성은 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체입니다."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>필드가 아닙니다 <xref href=&quot;System.IO.FileAccess&quot;> </xref>합니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "디스크 오류와 같은 I/O 오류가 발생 했습니다.       -또는-스트림이 닫혔습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> 요청 된 경우와 같이 지정 된 파일 핸들에 대 한 운영 체제에서 허용 되지 않는 <code> access </code> 은 <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> 파일 핸들이 읽기 전용 액세스로 설정 되어 합니다."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  id: '#ctor(System.IntPtr,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.FileStream&quot;> </xref> 지정 된 읽기/쓰기 권한이 있는 지정 된 파일 핸들에 대 한 클래스입니다."
  remarks: "때 <xref:System.IO.Stream.Close%2A>은 호출, 핸들 닫히며 파일의 핸들 수가 감소 됩니다.</xref:System.IO.Stream.Close%2A>       `FileStream`핸들에 대 한 독점적인 제어권 있음을 가정 합니다. 읽기, 쓰기 또는 검색 하는 동안 한 `FileStream` 유지 되는 핸들 데이터 손상 될 수 있습니다. 데이터 보안을 위해 호출 <xref:System.IO.FileStream.Flush%2A>핸들을 사용 하 여 전과 이외의 다른 모든 메서드를 호출 하지 마십시오. `Close` 완료 한 후 핸들을 사용 하 여.</xref:System.IO.FileStream.Flush%2A>      > [!CAUTION] > 문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색은 해석할 수 없어 문자와를 throw 하면 예외가 발생 합니다.       `FileShare.Read`기본은 사용자 용 <xref:System.IO.FileStream>없는 생성자는 `FileShare` 매개 변수.</xref:System.IO.FileStream>       일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "파일에 대 한 파일 핸들은 현재 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체가 캡슐화 됩니다."
    - id: access
      type: System.IO.FileAccess
      description: "설정 하는 상수는 <> </> *> 및 <> </> *>의 속성은 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체입니다."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>필드가 아닙니다 <xref href=&quot;System.IO.FileAccess&quot;> </xref>합니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "디스크 오류와 같은 I/O 오류가 발생 했습니다.       -또는-스트림이 닫혔습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> 요청 된 경우와 같이 지정 된 파일 핸들에 대 한 운영 체제에서 허용 되지 않는 <code> access </code> 은 <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> 파일 핸들이 읽기 전용 액세스로 설정 되어 합니다."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.FileStream&quot;> </xref> 지정된 된 경로 및 생성 모드를 사용 하 여 클래스입니다."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).  \n  \n You cannot use this constructor to open read-only files; instead, you must use a constructor that accepts a `FileAccess` parameter with the value set to `FileAccess.Read`.  \n  \n The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n For constructors without a <xref:System.IO.FileAccess> parameter, if the `mode` parameter is set to <xref:System.IO.FileMode>, <xref:System.IO.FileAccess> is the default access. Otherwise, the access is set to <xref:System.IO.FileAccess>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_0_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "파일에 대 한 상대 또는 절대 경로 현재 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체가 캡슐화 됩니다."
    - id: mode
      type: System.IO.FileMode
      description: "열거나 파일을 만들 방법을 결정 하는 상수입니다."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>빈 문자열 (&quot;&quot;) 공백만 포함 하거나 하나 이상의 잘못 된 문자를 포함 합니다.       -또는- <code>path</code> 같은 파일이 아닌 장치를 참조 &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;는 NTFS 환경에서 등입니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>과 같은 파일이 아닌 장치 참조 &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, 비 NTFS 환경 내에서 등입니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "파일이 없거나 예를 들어 <code> mode </code> 은 <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>로 지정 된 파일 및 <code> path </code> 존재 하지 않습니다. 이러한 모드에 파일이 이미 있어야 합니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "지정 하는 등의 I/O 오류가 <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> 하 여 지정 된 파일이 <code> path </code> 이미 있으면 오류가 발생 했습니다.       -또는-스트림이 닫혔습니다."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "지정된 된 경로 예: 매핑되지 않은 드라이브에 올바르지 않습니다."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "지정된 된 경로, 파일 이름 또는 둘 다에 시스템 정의 최대 길이 초과 합니다. 예를 들어 Windows 기반 플랫폼에서 경로 248 자 미만, 이어야 하 고 파일 이름은 260 자 미만 이어야 합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>잘못 된 값을 포함합니다."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.FileStream&quot;> </xref> 지정 된 읽기/쓰기 권한이 있는 지정 된 파일 핸들에 대 한 클래스 및 버퍼 크기입니다."
  remarks: "`FileStream`핸들에 대 한 독점적인 제어권 있음을 가정 합니다. 읽기, 쓰기 또는 검색 하는 동안 한 `FileStream` 유지 되는 핸들 데이터 손상 될 수 있습니다. 데이터 보안을 위해 호출 <xref:System.IO.FileStream.Flush%2A>핸들을 사용 하 여 전과 이외의 다른 모든 메서드를 호출 하지 마십시오. `Close` 완료 한 후 핸들을 사용 하 여.</xref:System.IO.FileStream.Flush%2A> 또는 읽고이 호출 하기 전에 핸들에 쓰는 `FileStream` 생성자입니다.       `FileShare.Read`기본은 사용자 용 <xref:System.IO.FileStream>없는 생성자는 `FileShare` 매개 변수.</xref:System.IO.FileStream>      > [!CAUTION] > 문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색은 해석할 수 없어 문자와를 throw 하면 예외가 발생 합니다.       일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "파일에 대 한 파일 핸들은 현재 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체가 캡슐화 됩니다."
    - id: access
      type: System.IO.FileAccess
      description: "A <xref href=&quot;System.IO.FileAccess&quot;> </xref> 설정 하는 상수는 <> </> *> 및 <> </> *>의 속성은 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체입니다."
    - id: bufferSize
      type: System.Int32
      description: "양수 <xref:System.Int32>버퍼 크기를 나타내는 0 보다 큰 값입니다.</xref:System.Int32> 기본 버퍼 크기는 4, 096입니다."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> handle </code> 매개 변수가 잘못 된 핸들입니다.       -또는- <code> handle </code> 매개 변수는 동기 핸들 인데 비동기적으로 사용 되었습니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> bufferSize </code> 매개 변수가 음수입니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "디스크 오류와 같은 I/O 오류가 발생 했습니다.       -또는-스트림이 닫혔습니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> 요청 된 경우와 같이 지정 된 파일 핸들에 대 한 운영 체제에서 허용 되지 않는 <code> access </code> 은 <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> 파일 핸들이 읽기 전용 액세스로 설정 되어 합니다."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.FileStream&quot;> </xref> 지정 된 읽기/쓰기 권한으로 지정 된 파일 핸들에 대 한 클래스 및 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 인스턴스 소유권 합니다."
  remarks: "`FileStream` 개체 파일에 지정된 된 액세스를 제공 됩니다. 핸들의 소유권 됩니다. 지정 된 대로 합니다. 이 프로세스에 대 한 호출 핸들을 소유 하는 경우는 <xref:System.IO.Stream.Close%2A>메서드 핸들이 닫힙니다 및 파일의 핸들 수가 감소 됩니다.</xref:System.IO.Stream.Close%2A> `FileStream` 개체는 4096 바이트의 기본 버퍼 크기를 지정 합니다.       `FileStream`핸들에 대 한 독점적인 제어권 있음을 가정 합니다. 읽기, 쓰기 또는 검색 하는 동안 한 `FileStream` 유지 되는 핸들 데이터 손상 될 수 있습니다. 데이터 보안을 위해 호출 <xref:System.IO.FileStream.Flush%2A>핸들을 사용 하 여 전과 이외의 메서드를 호출 하지 마십시오. `Close` 완료 한 후 핸들을 사용 하 여.</xref:System.IO.FileStream.Flush%2A>       `FileShare.Read`기본은 사용자 용 <xref:System.IO.FileStream>없는 생성자는 `FileShare` 매개 변수.</xref:System.IO.FileStream>      > [!CAUTION] > 문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색은 해석할 수 없어 문자와를 throw 하면 예외가 발생 합니다.       일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "파일에 대 한 파일 핸들은 현재 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체가 캡슐화 됩니다."
    - id: access
      type: System.IO.FileAccess
      description: "설정 하는 상수는 <> </> *> 및 <> </> *>의 속성은 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체입니다."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>이 파일 핸들을 소유 하는 경우 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 인스턴스이거나, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>필드가 아닙니다 <xref href=&quot;System.IO.FileAccess&quot;> </xref>합니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "디스크 오류와 같은 I/O 오류가 발생 했습니다.       -또는-스트림이 닫혔습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> 요청 된 경우와 같이 지정 된 파일 핸들에 대 한 운영 체제에서 허용 되지 않는 <code> access </code> 은 <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> 파일 핸들이 읽기 전용 액세스로 설정 되어 합니다."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.FileStream&quot;> </xref> 된 지정된 된 경로, 생성 모드 및 읽기/쓰기 권한을 사용 합니다."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "파일에 대 한 상대 또는 절대 경로 현재 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체가 캡슐화 됩니다."
    - id: mode
      type: System.IO.FileMode
      description: "열거나 파일을 만들 방법을 결정 하는 상수입니다."
    - id: access
      type: System.IO.FileAccess
      description: "파일에 액세스할 수 있는 방법을 결정 하는 상수는 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체입니다. 반환 값도 결정는 <> </> *> 및 <> </> *>의 속성은 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체입니다. <xref:System.IO.FileStream.CanSeek*><xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> 경우 `path` 디스크 파일을 지정 합니다.</xref:System.IO.FileStream.CanSeek*>"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>빈 문자열 (&quot;&quot;) 공백만 포함 하거나 하나 이상의 잘못 된 문자를 포함 합니다.       -또는- <code>path</code> 같은 파일이 아닌 장치를 참조 &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;는 NTFS 환경에서 등입니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>과 같은 파일이 아닌 장치 참조 &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, 비 NTFS 환경 내에서 등입니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "파일이 없거나 예를 들어 <code> mode </code> 은 <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>로 지정 된 파일 및 <code> path </code> 존재 하지 않습니다. 이러한 모드에 파일이 이미 있어야 합니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "지정 하는 등의 I/O 오류가 <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> 하 여 지정 된 파일이 <code> path </code> 이미 있으면 오류가 발생 했습니다.       -또는-스트림이 닫혔습니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "지정된 된 경로 예: 매핑되지 않은 드라이브에 올바르지 않습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> 요청에서 지정 된 운영 체제에서 허용 되지 않는 <code> path </code>, 예를 들어 <code> access </code> 은 <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> 파일 또는 디렉터리가 읽기 전용 액세스를 위해 설정 됩니다."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "지정된 된 경로, 파일 이름 또는 둘 다에 시스템 정의 최대 길이 초과 합니다. 예를 들어 Windows 기반 플랫폼에서 경로 248 자 미만, 이어야 하 고 파일 이름은 260 자 미만 이어야 합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>잘못 된 값을 포함합니다."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.FileStream&quot;> </xref> 지정 된 읽기/쓰기 권한, 버퍼 크기 및 동기 / 비동기 상태와 지정 된 파일 핸들에 대 한 클래스입니다."
  remarks: "설정한는 `isAsync` 매개 변수를 `true` 를 비동기적으로 파일 핸들을 엽니다. 이 매개 변수는 경우 `true`, 스트림 겹쳐 있는 I/O 파일 작업을 비동기적으로 수행 하는 사용 하 여 합니다. 그러나 매개 변수가 있어서는 안 될 `true` 호출 하 여 <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, 또는 <xref:System.IO.Stream.CopyToAsync%2A>메서드.</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> 경우는 `isAsync` 매개 변수는 `false` 및 비동기 읽기를 호출 하 고 쓰기 작업, UI 스레드는 여전히 수는 있지만 실제 I/O 작업이 동기적으로 수행 됩니다.       `FileStream`핸들에 대 한 독점적인 제어권 있음을 가정 합니다. 읽기, 쓰기 또는 검색 하는 동안 한 `FileStream` 유지 되는 핸들 데이터 손상 될 수 있습니다. 데이터 보안을 위해 호출 <xref:System.IO.FileStream.Flush%2A>핸들을 사용 하 여 전과 이외의 다른 모든 메서드를 호출 하지 마십시오. `Close` 완료 한 후 핸들을 사용 하 여.</xref:System.IO.FileStream.Flush%2A> 또는 읽고이 호출 하기 전에 핸들에 쓰는 `FileStream` 생성자입니다.       `FileShare.Read`기본은 사용자 용 <xref:System.IO.FileStream>없는 생성자는 `FileShare` 매개 변수.</xref:System.IO.FileStream>      > [!CAUTION] > 문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색은 해석할 수 없어 문자와를 throw 하면 예외가 발생 합니다.       일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "이 파일에 대 한 파일 핸들 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체가 캡슐화 됩니다."
    - id: access
      type: System.IO.FileAccess
      description: "설정 하는 상수는 <> </> *> 및 <> </> *>의 속성은 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체입니다."
    - id: bufferSize
      type: System.Int32
      description: "양수 <xref:System.Int32>버퍼 크기를 나타내는 0 보다 큰 값입니다.</xref:System.Int32> 기본 버퍼 크기는 4, 096입니다."
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>핸들이 비동기적으로 열린 경우 (즉, 겹쳐진 I/O 모드에서); 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> handle </code> 매개 변수가 잘못 된 핸들입니다.       -또는- <code> handle </code> 매개 변수는 동기 핸들 인데 비동기적으로 사용 되었습니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> bufferSize </code> 매개 변수가 음수입니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "디스크 오류와 같은 I/O 오류가 발생 했습니다.       -또는-스트림이 닫혔습니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> 요청 된 경우와 같이 지정 된 파일 핸들에 대 한 운영 체제에서 허용 되지 않는 <code> access </code> 은 <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> 파일 핸들이 읽기 전용 액세스로 설정 되어 합니다."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.FileStream&quot;> </xref> 지정 된 읽기/쓰기 권한이 있는 지정 된 파일 핸들에 대 한 클래스 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 인스턴스 소유권 및 버퍼 크기입니다."
  remarks: "`FileStream` 개체 파일에 지정된 된 액세스를 제공 됩니다. 핸들의 소유권 됩니다. 지정 된 대로 합니다. 이 경우 `FileStream` 핸들에 대 한 호출을 소유는 <xref:System.IO.Stream.Close%2A>메서드 핸들이 닫힙니다.</xref:System.IO.Stream.Close%2A> 특히, 파일의 핸들 수는 감소 합니다. `FileStream` 개체는 지정 된 버퍼 크기를 지정 합니다.       `FileStream`핸들에 대 한 독점적인 제어권 있음을 가정 합니다. 읽기, 쓰기 또는 검색 하는 동안 한 `FileStream` 유지 되는 핸들 데이터 손상 될 수 있습니다. 데이터 보안을 위해 호출 <xref:System.IO.FileStream.Flush%2A>핸들을 사용 하 여 전과 이외의 다른 모든 메서드를 호출 하지 마십시오. `Close` 완료 한 후 핸들을 사용 하 여.</xref:System.IO.FileStream.Flush%2A> 또는 읽고이 호출 하기 전에 핸들에 쓰는 `FileStream` 생성자입니다.       `FileShare.Read`기본은 사용자 용 <xref:System.IO.FileStream>없는 생성자는 `FileShare` 매개 변수.</xref:System.IO.FileStream>      > [!CAUTION] > 문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색은 해석할 수 없어 문자와를 throw 하면 예외가 발생 합니다.       일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "이 파일에 대 한 파일 핸들 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체가 캡슐화 됩니다."
    - id: access
      type: System.IO.FileAccess
      description: "설정 하는 상수는 <> </> *> 및 <> </> *>의 속성은 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체입니다."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>이 파일 핸들을 소유 하는 경우 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 인스턴스이거나, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
    - id: bufferSize
      type: System.Int32
      description: "양수 <xref:System.Int32>버퍼 크기를 나타내는 0 보다 큰 값입니다.</xref:System.Int32> 기본 버퍼 크기는 4, 096입니다."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>가 음수입니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "디스크 오류와 같은 I/O 오류가 발생 했습니다.       -또는-스트림이 닫혔습니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> 요청 된 경우와 같이 지정 된 파일 핸들에 대 한 운영 체제에서 허용 되지 않는 <code> access </code> 은 <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> 파일 핸들이 읽기 전용 액세스로 설정 되어 합니다."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.FileStream&quot;> </xref> 클래스 지정 된 경로, 생성 모드, 읽기/쓰기 권한 및 공유 권한을 사용 합니다."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#2](~/add/codesnippet/csharp/904a8302-b9b6-44f1-89c4-_1.cs)]\n [!code-cpp[System.IO.FileStream3#2](~/add/codesnippet/cpp/904a8302-b9b6-44f1-89c4-_1.cpp)]\n [!code-vb[System.IO.FileStream3#2](~/add/codesnippet/visualbasic/904a8302-b9b6-44f1-89c4-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "파일에 대 한 상대 또는 절대 경로 현재 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체가 캡슐화 됩니다."
    - id: mode
      type: System.IO.FileMode
      description: "열거나 파일을 만들 방법을 결정 하는 상수입니다."
    - id: access
      type: System.IO.FileAccess
      description: "파일에 액세스할 수 있는 방법을 결정 하는 상수는 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체입니다. 반환 값도 결정는 <> </> *> 및 <> </> *>의 속성은 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체입니다. <xref:System.IO.FileStream.CanSeek*><xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> 경우 `path` 디스크 파일을 지정 합니다.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "프로세스에서 파일을 공유 하는 방법을 결정 하는 상수입니다."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>빈 문자열 (&quot;&quot;) 공백만 포함 하거나 하나 이상의 잘못 된 문자를 포함 합니다.       -또는- <code>path</code> 같은 파일이 아닌 장치를 참조 &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;는 NTFS 환경에서 등입니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>과 같은 파일이 아닌 장치 참조 &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, 비 NTFS 환경 내에서 등입니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "파일이 없거나 예를 들어 <code> mode </code> 은 <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>로 지정 된 파일 및 <code> path </code> 존재 하지 않습니다. 이러한 모드에 파일이 이미 있어야 합니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "지정 하는 등의 I/O 오류가 <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> 하 여 지정 된 파일이 <code> path </code> 이미 있으면 오류가 발생 했습니다.       -또는-Windows 98 또는 Windows 98 Second Edition 시스템이 실행 되 고 <code> share </code> 로 설정 된 <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>합니다.       -또는-스트림이 닫혔습니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "지정된 된 경로 예: 매핑되지 않은 드라이브에 올바르지 않습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> 요청에서 지정 된 운영 체제에서 허용 되지 않는 <code> path </code>, 예를 들어 <code> access </code> 은 <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> 파일 또는 디렉터리가 읽기 전용 액세스를 위해 설정 됩니다."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "지정된 된 경로, 파일 이름 또는 둘 다에 시스템 정의 최대 길이 초과 합니다. 예를 들어 Windows 기반 플랫폼에서 경로 248 자 미만, 이어야 하 고 파일 이름은 260 자 미만 이어야 합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>잘못 된 값을 포함합니다."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.FileStream&quot;> </xref> 지정 된 읽기/쓰기 권한이 있는 지정 된 파일 핸들에 대 한 클래스 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 인스턴스 소유권, 버퍼 크기 및 동기 / 비동기 상태입니다."
  remarks: "`FileStream` 개체 파일에 지정된 된 액세스를 제공 됩니다. 핸들의 소유권 됩니다. 지정 된 대로 합니다. 이 경우 `FileStream` 핸들에 대 한 호출을 소유는 <xref:System.IO.Stream.Close%2A>메서드 핸들이 닫힙니다.</xref:System.IO.Stream.Close%2A> 특히, 파일의 핸들 수는 감소 합니다. `FileStream` 개체는 지정 된 버퍼 크기를 지정 합니다.       `FileStream`핸들에 대 한 독점적인 제어권 있음을 가정 합니다. 읽기, 쓰기 또는 검색 하는 동안 한 `FileStream` 유지 되는 핸들 데이터 손상 될 수 있습니다. 데이터 보안을 위해 호출 <xref:System.IO.FileStream.Flush%2A>핸들을 사용 하 여 전과 이외의 다른 모든 메서드를 호출 하지 마십시오. `Close` 완료 한 후 핸들을 사용 하 여.</xref:System.IO.FileStream.Flush%2A> 또는 읽고이 호출 하기 전에 핸들에 쓰는 `FileStream` 생성자입니다.       `FileShare.Read`기본은 사용자 용 <xref:System.IO.FileStream>없는 생성자는 `FileShare` 매개 변수.</xref:System.IO.FileStream>      > [!CAUTION] > 문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색은 해석할 수 없어 문자와를 throw 하면 예외가 발생 합니다.       일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "이 파일에 대 한 파일 핸들 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체가 캡슐화 됩니다."
    - id: access
      type: System.IO.FileAccess
      description: "설정 하는 상수는 <> </> *> 및 <> </> *>의 속성은 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체입니다."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>이 파일 핸들을 소유 하는 경우 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 인스턴스이거나, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
    - id: bufferSize
      type: System.Int32
      description: "양수 <xref:System.Int32>버퍼 크기를 나타내는 0 보다 큰 값입니다.</xref:System.Int32> 기본 버퍼 크기는 4, 096입니다."
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>핸들이 비동기적으로 열린 경우 (즉, 겹쳐진 I/O 모드에서); 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>access</code>보다 작은 <xref uid=&quot;langword_csharp_FileAccess.Read&quot; name=&quot;FileAccess.Read&quot; href=&quot;&quot;> </xref> 보다 큰 <xref uid=&quot;langword_csharp_FileAccess.ReadWrite&quot; name=&quot;FileAccess.ReadWrite&quot; href=&quot;&quot;> </xref> 또는 <code>bufferSize</code> 가 0 보다 작거나 같음."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "핸들이 잘못 되었습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "디스크 오류와 같은 I/O 오류가 발생 했습니다.       -또는-스트림이 닫혔습니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> 요청 된 경우와 같이 지정 된 파일 핸들에 대 한 운영 체제에서 허용 되지 않는 <code> access </code> 은 <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> 파일 핸들이 읽기 전용 액세스로 설정 되어 합니다."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.FileStream&quot;> </xref> 된 지정 된 경로, 생성 모드, 읽기/쓰기 및 공유 권한, 버퍼 크기입니다."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);
    parameters:
    - id: path
      type: System.String
      description: "파일에 대 한 상대 또는 절대 경로 현재 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체가 캡슐화 됩니다."
    - id: mode
      type: System.IO.FileMode
      description: "열거나 파일을 만들 방법을 결정 하는 상수입니다."
    - id: access
      type: System.IO.FileAccess
      description: "파일에 액세스할 수 있는 방법을 결정 하는 상수는 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체입니다. 반환 값도 결정는 <> </> *> 및 <> </> *>의 속성은 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체입니다. <xref:System.IO.FileStream.CanSeek*><xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> 경우 `path` 디스크 파일을 지정 합니다.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "프로세스에서 파일을 공유 하는 방법을 결정 하는 상수입니다."
    - id: bufferSize
      type: System.Int32
      description: "양수 <xref:System.Int32>버퍼 크기를 나타내는 0 보다 큰 값입니다.</xref:System.Int32> 기본 버퍼 크기는 4, 096입니다."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>빈 문자열 (&quot;&quot;) 공백만 포함 하거나 하나 이상의 잘못 된 문자를 포함 합니다.       -또는- <code>path</code> 같은 파일이 아닌 장치를 참조 &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;는 NTFS 환경에서 등입니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>과 같은 파일이 아닌 장치 참조 &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, 비 NTFS 환경 내에서 등입니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>가 음수 이거나&0;입니다.       -또는- <code>mode</code>, <code>access</code>, 또는 <code>share</code> 잘못 된 값을 포함 합니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "파일이 없거나 예를 들어 <code> mode </code> 은 <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>로 지정 된 파일 및 <code> path </code> 존재 하지 않습니다. 이러한 모드에 파일이 이미 있어야 합니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "지정 하는 등의 I/O 오류가 <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> 하 여 지정 된 파일이 <code> path </code> 이미 있으면 오류가 발생 했습니다.       -또는-Windows 98 또는 Windows 98 Second Edition 시스템이 실행 되 고 <code> share </code> 로 설정 된 <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>합니다.       -또는-스트림이 닫혔습니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "지정된 된 경로 예: 매핑되지 않은 드라이브에 올바르지 않습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> 요청에서 지정 된 운영 체제에서 허용 되지 않는 <code> path </code>, 예를 들어 <code> access </code> 은 <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> 파일 또는 디렉터리가 읽기 전용 액세스를 위해 설정 됩니다."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "지정된 된 경로, 파일 이름 또는 둘 다에 시스템 정의 최대 길이 초과 합니다. 예를 들어 Windows 기반 플랫폼에서 경로 248 자 미만, 이어야 하 고 파일 이름은 260 자 미만 이어야 합니다."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.FileStream&quot;> </xref> 된 지정 된 경로, 생성 모드, 읽기/쓰기 및 공유 권한, 버퍼 크기 및 동기 / 비동기 상태입니다."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to asynchronously write data to a file and then verify that the data was written correctly. A `State` object is created to pass information from the main thread to the `EndReadCallback` and `EndWriteCallback` methods.  \n  \n [!code-cs[System.IO.FileStream2#1](~/add/codesnippet/csharp/ff94fabb-a26d-4ac2-a74e-_1.cs)]\n [!code-vb[System.IO.FileStream2#1](~/add/codesnippet/visualbasic/ff94fabb-a26d-4ac2-a74e-_1.vb)]\n [!code-cpp[System.IO.FileStream2#1](~/add/codesnippet/cpp/ff94fabb-a26d-4ac2-a74e-_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);
    parameters:
    - id: path
      type: System.String
      description: "파일에 대 한 상대 또는 절대 경로 현재 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체가 캡슐화 됩니다."
    - id: mode
      type: System.IO.FileMode
      description: "열거나 파일을 만들 방법을 결정 하는 상수입니다."
    - id: access
      type: System.IO.FileAccess
      description: "파일에 액세스할 수 있는 방법을 결정 하는 상수는 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체입니다. 반환 값도 결정는 <> </> *> 및 <> </> *>의 속성은 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체입니다. <xref:System.IO.FileStream.CanSeek*><xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> 경우 `path` 디스크 파일을 지정 합니다.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "프로세스에서 파일을 공유 하는 방법을 결정 하는 상수입니다."
    - id: bufferSize
      type: System.Int32
      description: "양수 <xref:System.Int32>버퍼 크기를 나타내는 0 보다 큰 값입니다.</xref:System.Int32> 기본 버퍼 크기는 4, 096입니다."
    - id: useAsync
      type: System.Boolean
      description: "비동기 I/O 또는 동기 I/O를 사용할지 여부를 지정 합니다. 그러나 기본 운영 체제 비동기 I/O를 지원 하지 않을 수 있습니다를 메모를 지정 하는 경우 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, 플랫폼에 따라 핸들이 동기적으로 열릴 수 있습니다. 비동기적으로 열린 경우는 <> </> *> 및 <> </> *> 메서드는 대량의 데이터를 읽거나 쓸 더 잘 수행 이지만 작은 읽기 또는 쓰기에 대 한 훨씬 더 느리기 수 있습니다. 응용 프로그램이 비동기 I/O를 활용 하도록 디자인 된, 경우에 설정 된 `useAsync` 매개 변수를 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>합니다. 비동기 I/O를 올바르게 사용 속도를 높일 수 하 여 응용 프로그램 배 10, 하지만 비동기 I/O 위해 응용 프로그램을 다시 디자인 하지 않고 사용 하면 성능이 저하 될 수 만큼의 10 배입니다."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>빈 문자열 (&quot;&quot;) 공백만 포함 하거나 하나 이상의 잘못 된 문자를 포함 합니다.       -또는- <code>path</code> 같은 파일이 아닌 장치를 참조 &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;는 NTFS 환경에서 등입니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>과 같은 파일이 아닌 장치 참조 &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, 비 NTFS 환경 내에서 등입니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>가 음수 이거나&0;입니다.       -또는- <code>mode</code>, <code>access</code>, 또는 <code>share</code> 잘못 된 값을 포함 합니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "파일이 없거나 예를 들어 <code> mode </code> 은 <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>로 지정 된 파일 및 <code> path </code> 존재 하지 않습니다. 이러한 모드에 파일이 이미 있어야 합니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "지정 하는 등의 I/O 오류가 <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> 하 여 지정 된 파일이 <code> path </code> 이미 있으면 오류가 발생 했습니다.       -또는-Windows 98 또는 Windows 98 Second Edition 시스템이 실행 되 고 <code> share </code> 로 설정 된 <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>합니다.       -또는-스트림이 닫혔습니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "지정된 된 경로 예: 매핑되지 않은 드라이브에 올바르지 않습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> 요청에서 지정 된 운영 체제에서 허용 되지 않는 <code> path </code>, 예를 들어 <code> access </code> 은 <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> 파일 또는 디렉터리가 읽기 전용 액세스를 위해 설정 됩니다."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "지정된 된 경로, 파일 이름 또는 둘 다에 시스템 정의 최대 길이 초과 합니다. 예를 들어 Windows 기반 플랫폼에서 경로 248 자 미만, 이어야 하 고 파일 이름은 260 자 미만 이어야 합니다."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.FileStream&quot;> </xref> 클래스 된 지정 된 경로, 생성 모드, 읽기/쓰기 및 공유 권한, 액세스가 다른 Filestream 같은 파일, 버퍼 크기 및 추가 파일 옵션입니다."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor1#1](~/add/codesnippet/cpp/53f739ba-7c4d-43ff-a387-_1.cpp)]\n [!code-vb[IO.FileStream.ctor1#1](~/add/codesnippet/visualbasic/53f739ba-7c4d-43ff-a387-_1.vb)]\n [!code-cs[IO.FileStream.ctor1#1](~/add/codesnippet/csharp/53f739ba-7c4d-43ff-a387-_1.cs)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "파일에 대 한 상대 또는 절대 경로 현재 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체가 캡슐화 됩니다."
    - id: mode
      type: System.IO.FileMode
      description: "열거나 파일을 만들 방법을 결정 하는 상수입니다."
    - id: access
      type: System.IO.FileAccess
      description: "파일에 액세스할 수 있는 방법을 결정 하는 상수는 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체입니다. 반환 값도 결정는 <> </> *> 및 <> </> *>의 속성은 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체입니다. <xref:System.IO.FileStream.CanSeek*><xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> 경우 `path` 디스크 파일을 지정 합니다.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "프로세스에서 파일을 공유 하는 방법을 결정 하는 상수입니다."
    - id: bufferSize
      type: System.Int32
      description: "양수 <xref:System.Int32>버퍼 크기를 나타내는 0 보다 큰 값입니다.</xref:System.Int32> 기본 버퍼 크기는 4, 096입니다."
    - id: options
      type: System.IO.FileOptions
      description: "추가 파일 옵션을 지정 하는 값입니다."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>빈 문자열 (&quot;&quot;) 공백만 포함 하거나 하나 이상의 잘못 된 문자를 포함 합니다.       -또는- <code>path</code> 같은 파일이 아닌 장치를 참조 &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;는 NTFS 환경에서 등입니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>과 같은 파일이 아닌 장치 참조 &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, 비 NTFS 환경 내에서 등입니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>가 음수 이거나&0;입니다.       -또는- <code>mode</code>, <code>access</code>, 또는 <code>share</code> 잘못 된 값을 포함 합니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "파일이 없거나 예를 들어 <code> mode </code> 은 <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>로 지정 된 파일 및 <code> path </code> 존재 하지 않습니다. 이러한 모드에 파일이 이미 있어야 합니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "지정 하는 등의 I/O 오류가 <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> 하 여 지정 된 파일이 <code> path </code> 이미 있으면 오류가 발생 했습니다.       -또는-스트림이 닫혔습니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "지정된 된 경로 예: 매핑되지 않은 드라이브에 올바르지 않습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> 요청에서 지정 된 운영 체제에서 허용 되지 않는 <code> path </code>, 예를 들어 <code> access </code> 은 <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> 파일 또는 디렉터리가 읽기 전용 액세스를 위해 설정 됩니다.       -또는- <xref href=&quot;System.IO.FileOptions&quot;> </xref> 에 대해 지정 된 <code> options </code>, 하지만 파일 암호화 현재 플랫폼에서 지원 되지 않습니다."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "지정된 된 경로, 파일 이름 또는 둘 다에 시스템 정의 최대 길이 초과 합니다. 예를 들어 Windows 기반 플랫폼에서 경로 248 자 미만, 이어야 하 고 파일 이름은 260 자 미만 이어야 합니다."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.FileStream&quot;> </xref> 지정 된 경로, 생성 모드, 액세스 권한 및 공유 권한, 버퍼 크기 및 추가 파일 옵션을 사용 하 여 클래스입니다."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "파일에 대 한 상대 또는 절대 경로 현재 <xref href=&quot;System.IO.FileStream&quot;> </xref> 개체가 캡슐화 됩니다."
    - id: mode
      type: System.IO.FileMode
      description: "열거나 파일을 만들 방법을 결정 하는 상수입니다."
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "파일에 대 한 액세스 및 감사 규칙을 만들 때 사용할 수 있는 액세스 권한을 결정 하는 상수입니다."
    - id: share
      type: System.IO.FileShare
      description: "프로세스에서 파일을 공유 하는 방법을 결정 하는 상수입니다."
    - id: bufferSize
      type: System.Int32
      description: "양수 <xref:System.Int32>버퍼 크기를 나타내는 0 보다 큰 값입니다.</xref:System.Int32> 기본 버퍼 크기는 4, 096입니다."
    - id: options
      type: System.IO.FileOptions
      description: "추가 파일 옵션을 지정 하는 상수입니다."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>빈 문자열 (&quot;&quot;) 공백만 포함 하거나 하나 이상의 잘못 된 문자를 포함 합니다.       -또는- <code>path</code> 같은 파일이 아닌 장치를 참조 &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;는 NTFS 환경에서 등입니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>과 같은 파일이 아닌 장치 참조 &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, 비 NTFS 환경 내에서 등입니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>가 음수 이거나&0;입니다.       -또는- <code>mode</code>, <code>access</code>, 또는 <code>share</code> 잘못 된 값을 포함 합니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "파일이 없거나 예를 들어 <code> mode </code> 은 <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>로 지정 된 파일 및 <code> path </code> 존재 하지 않습니다. 이러한 모드에 파일이 이미 있어야 합니다."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "현재 운영 체제가 지원 되지 않은 Windows NT 이상입니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "지정 하는 등의 I/O 오류가 <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> 하 여 지정 된 파일이 <code> path </code> 이미 있으면 오류가 발생 했습니다.       -또는-스트림이 닫혔습니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "지정된 된 경로 예: 매핑되지 않은 드라이브에 올바르지 않습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> 요청에서 지정 된 운영 체제에서 허용 되지 않는 <code> path </code>, 예를 들어 <code> access </code> 은 <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> 파일 또는 디렉터리가 읽기 전용 액세스를 위해 설정 됩니다.       -또는- <xref href=&quot;System.IO.FileOptions&quot;> </xref> 에 대해 지정 된 <code> options </code>, 하지만 파일 암호화 현재 플랫폼에서 지원 되지 않습니다."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "지정 된 <code> path </code>, 파일 이름 또는 둘 다 시스템 정의 최대 길이 초과 합니다. 예를 들어 Windows 기반 플랫폼에서 경로 248 자 미만, 이어야 하 고 파일 이름은 260 자 미만 이어야 합니다."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.IO.FileStream&quot;> </xref> 된 지정 된 경로, 생성 모드, 액세스 권한 및 공유 권한, 버퍼 크기, 추가 파일 옵션, 액세스 제어 및 감사 보안 합니다."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor2#1](~/add/codesnippet/cpp/7f323125-1dac-495a-a4ee-_1.cpp)]\n [!code-cs[IO.FileStream.ctor2#1](~/add/codesnippet/csharp/7f323125-1dac-495a-a4ee-_1.cs)]\n [!code-vb[IO.FileStream.ctor2#1](~/add/codesnippet/visualbasic/7f323125-1dac-495a-a4ee-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "파일에 대 한 상대 또는 절대 경로 현재 <xref href=&quot;System.IO.FileStream&quot;> </xref> 개체가 캡슐화 됩니다."
    - id: mode
      type: System.IO.FileMode
      description: "열거나 파일을 만들 방법을 결정 하는 상수입니다."
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "파일에 대 한 액세스 및 감사 규칙을 만들 때 사용할 수 있는 액세스 권한을 결정 하는 상수입니다."
    - id: share
      type: System.IO.FileShare
      description: "프로세스에서 파일을 공유 하는 방법을 결정 하는 상수입니다."
    - id: bufferSize
      type: System.Int32
      description: "양수 <xref:System.Int32>버퍼 크기를 나타내는 0 보다 큰 값입니다.</xref:System.Int32> 기본 버퍼 크기는 4, 096입니다."
    - id: options
      type: System.IO.FileOptions
      description: "추가 파일 옵션을 지정 하는 상수입니다."
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "액세스 제어를 결정 하는 상수 및 파일에 대 한 보안 감사 합니다."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>빈 문자열 (&quot;&quot;) 공백만 포함 하거나 하나 이상의 잘못 된 문자를 포함 합니다.       -또는- <code>path</code> 같은 파일이 아닌 장치를 참조 &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;는 NTFS 환경에서 등입니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>과 같은 파일이 아닌 장치 참조 &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, 비 NTFS 환경 내에서 등입니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>가 음수 이거나&0;입니다.       -또는- <code>mode</code>, <code>access</code>, 또는 <code>share</code> 잘못 된 값을 포함 합니다."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "파일이 없거나 예를 들어 <code> mode </code> 은 <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>로 지정 된 파일 및 <code> path </code> 존재 하지 않습니다. 이러한 모드에 파일이 이미 있어야 합니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "지정 하는 등의 I/O 오류가 <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> 하 여 지정 된 파일이 <code> path </code> 이미 있으면 오류가 발생 했습니다.       -또는-스트림이 닫혔습니다."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "지정된 된 경로 예: 매핑되지 않은 드라이브에 올바르지 않습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> 요청에서 지정 된 운영 체제에서 허용 되지 않는 <code> path </code>, 예를 들어 <code> access </code> 은 <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> 또는 <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> 파일 또는 디렉터리가 읽기 전용 액세스를 위해 설정 됩니다.       -또는- <xref href=&quot;System.IO.FileOptions&quot;> </xref> 에 대해 지정 된 <code> options </code>, 하지만 파일 암호화 현재 플랫폼에서 지원 되지 않습니다."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "지정 된 <code> path </code>, 파일 이름 또는 둘 다 시스템 정의 최대 길이 초과 합니다. 예를 들어 Windows 기반 플랫폼에서 경로 248 자 미만, 이어야 하 고 파일 이름은 260 자 미만 이어야 합니다."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "현재 운영 체제가 지원 되지 않은 Windows NT 이상입니다."
  platform:
  - net462
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "비동기 읽기 작업을 시작합니다. (사용 하는 것이 좋습니다 <xref:System.IO.FileStream.ReadAsync*>대신 설명 섹션을 참조 합니다.)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: ".NET Framework 4 및 이전 버전에서 BeginRead와 같은 메서드를 사용 해야 하 고 <xref:System.IO.FileStream.EndRead%2A>비동기 파일 작업을 구현 합니다.</xref:System.IO.FileStream.EndRead%2A> 그러나 이러한 메서드는에서 계속 사용할 수는 [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] 레거시 코드를 지원 하기 위해 새로운 비동기 메서드 같은 <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, 및 <xref:System.IO.FileStream.FlushAsync%2A>, 비동기 파일 작업을 보다 쉽게 구현 도움말.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndRead%2A>BeginRead 호출할 때마다 한 번만 호출 되어야 합니다.</xref:System.IO.FileStream.EndRead%2A> 다른 읽기를 시작 하기 전에 읽기 프로세스를 종료 하지 못하면 교착 상태와 같이 원하지 않는 동작이 발생할 수 있습니다.       <xref:System.IO.FileStream>작업의 두 가지 모드를 제공 합니다: 동기 I/O와 비동기 I/O입니다.</xref:System.IO.FileStream> 하거나 사용할 수 있지만, 기본 운영 체제 리소스는 다음이 모드 중 하나 에서만 액세스를 통합할 수 있습니다. 기본적으로 <xref:System.IO.FileStream>운영 체제 핸들을 동기적으로 열립니다.</xref:System.IO.FileStream> Windows에서는 다운 비동기 메서드에서 느려집니다. 사용 하 여 비동기 메서드를 사용 하는 경우는 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>생성자.</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>      > [!NOTE] > 사용은 <xref:System.IO.FileStream.CanRead%2A>속성을 현재 인스턴스에 읽기를 지원 하는지를 확인 합니다.</xref:System.IO.FileStream.CanRead%2A> 자세한 내용은 <xref:System.IO.Stream.CanRead%2A>.</xref:System.IO.Stream.CanRead%2A> 을 참조 하십시오.       스트림이 닫혀 있거나를 잘못 된 인수를 전달 하는 경우 BeginRead에서 즉시 예외가 throw 됩니다. IO 요청 중의 디스크 오류와 같은 비동기 읽기 요청 하는 동안 발생 하는 오류는 스레드 풀 스레드에서 발생 하며 <xref:System.IO.FileStream.EndRead%2A>.</xref:System.IO.FileStream.EndRead%2A> 를 호출 하면 표시 됩니다.       <xref:System.IO.Stream.EndRead%2A>이 호출 해야 <xref:System.IAsyncResult>읽은 바이트 수를 찾으려고 합니다.</xref:System.IAsyncResult></xref:System.IO.Stream.EndRead%2A>       여러 개의 비동기 요청 렌더링 요청 완료 순서 불확실 합니다.       일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/82be2bd0-0603-4287-b351-_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/82be2bd0-0603-4287-b351-_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/82be2bd0-0603-4287-b351-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "데이터를 읽어올 버퍼입니다."
    - id: offset
      type: System.Int32
      description: "바이트 오프셋 `array` 읽기를 시작할입니다."
    - id: numBytes
      type: System.Int32
      description: "읽을 바이트 수의 최대 수입니다."
    - id: userCallback
      type: System.AsyncCallback
      description: "완료 되 면 비동기 읽기 작업이 호출 될 메서드입니다."
    - id: stateObject
      type: System.Object
      description: "이 특정 비동기 읽기 요청을 다른 요청과 구별 하는 사용자 제공 개체입니다."
    return:
      type: System.IAsyncResult
      description: "비동기 읽기를 참조 하는 개체입니다."
  overload: System.IO.FileStream.BeginRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "배열 길이에서 <code> offset </code> 는 보다 작은 <code> numBytes </code>합니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>또는 <code>numBytes</code> 음수입니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "파일의 끝을 지 나 비동기 읽기를 시도 했습니다."
  platform:
  - net462
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "비동기 쓰기 작업을 시작합니다. (사용 하는 것이 좋습니다 <xref:System.IO.FileStream.WriteAsync*>대신 설명 섹션을 참조 합니다.)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: ".NET Framework 4 및 이전 버전에서 BeginWrite와 같은 메서드를 사용 해야 하 고 <xref:System.IO.FileStream.EndWrite%2A>비동기 파일 작업을 구현 합니다.</xref:System.IO.FileStream.EndWrite%2A> 그러나 이러한 메서드는에서 계속 사용할 수는 [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] 레거시 코드를 지원 하기 위해 새로운 비동기 메서드 같은 <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, 및 <xref:System.IO.FileStream.FlushAsync%2A>, 비동기 파일 작업을 보다 쉽게 구현 도움말.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndWrite%2A>정확히 한 번만 호출 해야 모든 <xref:System.IAsyncResult>BeginWrite에서.</xref:System.IAsyncResult></xref:System.IO.FileStream.EndWrite%2A> <xref:System.IO.FileStream.EndWrite%2A>I/O 작업이 완료 될 때까지 차단 됩니다.</xref:System.IO.FileStream.EndWrite%2A>       이 메서드를 재정의 <xref:System.IO.Stream.BeginWrite%2A>.</xref:System.IO.Stream.BeginWrite%2A>       <xref:System.IO.FileStream>작업의 두 가지 모드를 제공 합니다: 동기 I/O와 비동기 I/O입니다.</xref:System.IO.FileStream> 하거나 사용할 수 있지만, 기본 운영 체제 리소스는 다음이 모드 중 하나 에서만 액세스를 통합할 수 있습니다. 기본적으로 <xref:System.IO.FileStream>운영 체제 핸들을 동기적으로 열립니다.</xref:System.IO.FileStream> Windows에서는 다운 비동기 메서드에서 느려집니다. 사용 하 여 비동기 메서드를 사용 하는 경우는 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>생성자.</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>       스트림이 닫혀 있거나를 잘못 된 인수를 전달 하는 경우 BeginWrite에서 즉시 예외가 throw 됩니다. IO 요청 중의 디스크 오류와 같은 비동기 쓰기 요청을 하는 동안 발생 하는 오류는 스레드 풀 스레드에서 발생 하며 <xref:System.IO.FileStream.EndWrite%2A>.</xref:System.IO.FileStream.EndWrite%2A> 를 호출 하면 표시 됩니다.       여러 개의 비동기 요청 렌더링 요청 완료 순서 불확실 합니다.       일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/439bdb1f-5241-4046-a4ad-_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/439bdb1f-5241-4046-a4ad-_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/439bdb1f-5241-4046-a4ad-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "현재 스트림에 쓸 데이터를 포함 하는 버퍼입니다."
    - id: offset
      type: System.Int32
      description: "0부터 시작 하는 바이트 오프셋 `array` 를 현재 스트림에 바이트 복사를 시작 하는 합니다."
    - id: numBytes
      type: System.Int32
      description: "쓸 바이트의 최대 수입니다."
    - id: userCallback
      type: System.AsyncCallback
      description: "비동기 쓰기 작업이 완료 될 때 호출 될 메서드."
    - id: stateObject
      type: System.Object
      description: "다른 요청에서 특정 비동기 쓰기 요청을 구별 하는 사용자 제공 개체입니다."
    return:
      type: System.IAsyncResult
      description: "비동기 쓰기를 참조 하는 개체입니다."
  overload: System.IO.FileStream.BeginWrite*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>길이에서 <code>offset</code> 는 보다 작은 <code>numBytes</code>합니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>또는 <code>numBytes</code> 음수입니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 쓰기를 지원 하지 않습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 닫혀 있습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/O 오류가 발생 했습니다."
  platform:
  - net462
- uid: System.IO.FileStream.CanRead
  id: CanRead
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "현재 스트림이 읽기를 지원 하는지 여부를 나타내는 값을 가져옵니다."
  remarks: "클래스에서 파생 하는 경우 <xref:System.IO.Stream>읽기를 지원 하지 않습니다에 대 한 호출이 <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>, <xref:System.IO.FileStream.BeginRead%2A>메서드는 <xref:System.NotSupportedException>.</xref:System.NotSupportedException> throw</xref:System.IO.FileStream.BeginRead%2A> 및</xref:System.IO.FileStream.ReadByte%2A> </xref:System.IO.FileStream.Read%2A> </xref:System.IO.Stream>       이 속성은 반환 된 스트림이 닫혀 있는지 `false`합니다."
  example:
  - "The following example demonstrates a use of the `CanRead` property. The output of this code is \"MyFile.txt is not writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanRead Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_1_1.cs)]\n [!code-cpp[Classic FileStream.CanRead Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_1_1.cpp)]\n [!code-vb[Classic FileStream.CanRead Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_1_1.vb)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>스트림이 읽기를 지원 합니다. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 스트림이 닫혀 있거나 쓰기 전용 권한으로 열렸으면 경우."
  overload: System.IO.FileStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanSeek
  id: CanSeek
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "현재 스트림이 검색을 지원 하는지 여부를 나타내는 값을 가져옵니다."
  remarks: "클래스에서 파생 하는 경우 <xref:System.IO.Stream>찾기를 지원 하지 않습니다에 대 한 호출이 <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>를 선언 하 고 <xref:System.IO.FileStream.Seek%2A>throw에 <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.Seek%2A> </xref:System.IO.FileStream.Position%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.FileStream.Length%2A> </xref:System.IO.Stream>       이 속성은 반환 된 스트림이 닫혀 있는지 `false`합니다."
  example:
  - "The following example uses the `CanSeek` property to check whether a stream supports seeking.  \n  \n [!code-cpp[fstream canseek#1](~/add/codesnippet/cpp/p-system.io.filestream.c_0_1.cpp)]\n [!code-vb[fstream canseek#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_0_1.vb)]\n [!code-cs[fstream canseek#1](~/add/codesnippet/csharp/p-system.io.filestream.c_0_1.cs)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>스트림이 검색을 지원 하면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 스트림이 닫혀 또는 경우는 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 콘솔에 출력 또는 파이프와 같은 운영 체제 핸들에서 생성 되었습니다."
  overload: System.IO.FileStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanWrite
  id: CanWrite
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "현재 스트림이 쓰기를 지원 하는지 여부를 나타내는 값을 가져옵니다."
  remarks: "클래스에서 파생 하는 경우 <xref:System.IO.Stream>쓰기 호출을 지원 하지 않는 <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A> <xref:System.IO.FileStream.WriteByte%2A>에 <xref:System.NotSupportedException>.</xref:System.NotSupportedException> throw</xref:System.IO.FileStream.WriteByte%2A> 또는</xref:System.IO.FileStream.BeginWrite%2A> </xref:System.IO.FileStream.Write%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.Stream>       이 속성은 반환 된 스트림이 닫혀 있는지 `false`합니다."
  example:
  - "The following example uses the `CanWrite` property to check whether a stream supports writing.  \n  \n [!code-cs[fstream canwrite#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_1.cs)]\n [!code-cpp[fstream canwrite#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_1.cpp)]\n [!code-vb[fstream canwrite#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_1.vb)]  \n  \n The following is an example using the `CanWrite` property. The output of this code is \"MyFile.txt is writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanWrite Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_2.cs)]\n [!code-vb[Classic FileStream.CanWrite Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_2.vb)]\n [!code-cpp[Classic FileStream.CanWrite Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_2.cpp)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>스트림이 쓰기를 지원 합니다. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 스트림이 닫혀 있거나 읽기 전용 권한으로 열렸으면 경우."
  overload: System.IO.FileStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "사용 하는 관리 되지 않는 리소스를 해제는 <xref href=&quot;System.IO.FileStream&quot;> </xref> 관리 되는 리소스를 선택적으로 해제 합니다."
  remarks: "이 메서드는 public <xref:System.ComponentModel.Component.Dispose%2A>메서드 및 <xref:System.Object.Finalize%2A>메서드.</xref:System.Object.Finalize%2A> </xref:System.ComponentModel.Component.Dispose%2A> <xref:System.ComponentModel.Component.Dispose%2A>보호 된 Dispose 메서드를 호출 하는 `disposing` 매개 변수 설정 `true`합니다.</xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A>Dispose를 호출 `disposing` 로 설정 `false`합니다.</xref:System.Object.Finalize%2A>       경우는 `disposing` 매개 변수는 `true`,이 메서드는 관리 개체가 보유 하는 모든 리소스를 해제 합니다.이 <xref:System.IO.FileStream>참조.</xref:System.IO.FileStream> 이 메서드 호출의 <xref:System.ComponentModel.Component.Dispose%2A>각 참조 된 개체의.</xref:System.ComponentModel.Component.Dispose%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>관리 되는 관리 되지 않는 리소스만 해제 하려면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 만 관리 되지 않는 리소스를 해제 합니다."
  overload: System.IO.FileStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "보류 중인 비동기 읽기 작업이 완료 되기를 기다립니다. (사용 하는 것이 좋습니다 <xref:System.IO.FileStream.ReadAsync*>대신 설명 섹션을 참조 합니다.)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: ".NET Framework 4 및 이전 버전에서와 같은 메서드를 사용 해야 <xref:System.IO.FileStream.BeginRead%2A>및 EndRead 비동기 파일 작업을 구현 합니다.</xref:System.IO.FileStream.BeginRead%2A> 그러나 이러한 메서드는에서 계속 사용할 수는 [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] 레거시 코드를 지원 하기 위해 새로운 비동기 메서드 같은 <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, 및 <xref:System.IO.FileStream.FlushAsync%2A>, 비동기 파일 작업을 보다 쉽게 구현 도움말.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       EndRead <xref:System.IO.FileStream.BeginRead%2A>.</xref:System.IO.FileStream.BeginRead%2A> 를 호출할 때마다 한 번씩 호출 해야 합니다. 다른 읽기를 시작 하기 전에 읽기 프로세스를 종료 하지 못하면 교착 상태와 같이 원하지 않는 동작이 발생할 수 있습니다.       이 메서드를 재정의 <xref:System.IO.Stream.EndRead%2A>.</xref:System.IO.Stream.EndRead%2A>       모든 <xref:System.IAsyncResult> <xref:System.IO.FileStream.BeginRead%2A>.</xref:System.IO.FileStream.BeginRead%2A> </xref:System.IAsyncResult> 에 EndRead는 호출할 수 있습니다. EndRead 호출을 알려 스트림에서 읽을 바이트 수입니다. EndRead는 I/O 작업이 완료 될 때까지 차단 됩니다."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/m-system.io.filestream.e_0_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/m-system.io.filestream.e_0_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/m-system.io.filestream.e_0_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "기다리는 보류 중인 비동기 요청에 대 한 참조입니다."
    return:
      type: System.Int32
      description: "0과 요청한 바이트 수 사이의 스트림에서 읽은 바이트 수입니다. 스트림은 스트림의 끝에서 0만을 반환, 그렇지 않으면 최소한 1 바이트 있을 때까지 하며 차단 됩니다."
  overload: System.IO.FileStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "이 <xref:System.IAsyncResult>개체가 <xref:System.IO.FileStream.BeginRead*>이 클래스에서</xref:System.IO.FileStream.BeginRead*> 호출 하 여 만들어진 개체가 아닙니다</xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndRead는 여러 번 호출 됩니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "스트림이 닫혔거나 내부 오류가 발생 했습니다."
  platform:
  - net462
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "I/O 작업이 완료 될 때까지 비동기 쓰기 작업 및 블록을 종료 합니다. (사용 하는 것이 좋습니다 <xref:System.IO.FileStream.WriteAsync*>대신 설명 섹션을 참조 합니다.)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: ".NET Framework 4 및 이전 버전에서와 같은 메서드를 사용 해야 <xref:System.IO.FileStream.BeginWrite%2A>및 EndWrite 비동기 파일 작업을 구현 합니다.</xref:System.IO.FileStream.BeginWrite%2A> 그러나 이러한 메서드는에서 계속 사용할 수는 [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] 레거시 코드를 지원 하기 위해 새로운 비동기 메서드 같은 <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, 및 <xref:System.IO.FileStream.FlushAsync%2A>, 비동기 파일 작업을 보다 쉽게 구현 도움말.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       이 메서드를 재정의 <xref:System.IO.Stream.EndWrite%2A>.</xref:System.IO.Stream.EndWrite%2A>       모든 <xref:System.IAsyncResult> <xref:System.IO.FileStream.BeginWrite%2A>.</xref:System.IO.FileStream.BeginWrite%2A> </xref:System.IAsyncResult> 에 EndWrite는 한 번만 호출 해야 합니다. EndWrite는 I/O 작업이 완료 될 때까지 차단 됩니다."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/m-system.io.filestream.e_1_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/m-system.io.filestream.e_1_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/m-system.io.filestream.e_1_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "보류 중인 비동기 I/O 요청입니다."
  overload: System.IO.FileStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "이 <xref:System.IAsyncResult>개체가 <xref:System.IO.Stream.BeginWrite*>이 클래스에서</xref:System.IO.Stream.BeginWrite*> 호출 하 여 만들어진 개체가 아닙니다</xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndWrite는 여러 번 라고 합니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "스트림이 닫혔거나 내부 오류가 발생 했습니다."
  platform:
  - net462
- uid: System.IO.FileStream.Finalize
  id: Finalize
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "리소스가 해제 되 고 가비지 수집기가 회수 하는 경우 다른 정리 작업이 수행 되도록는 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "가비지 컬렉션이 `Finalize` 현재 개체를 종료 될 경우. `Finalize`닫습니다는 `FileStream`합니다."
  syntax:
    content: ~FileStream ();
    parameters: []
  overload: System.IO.FileStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Flush
  id: Flush
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "이 스트림의 버퍼를 지우고 버퍼링 된 모든 데이터가 파일에 기록 합니다."
  remarks: "이 메서드를 재정의 <xref:System.IO.Stream.Flush%2A?displayProperty=fullName>.</xref:System.IO.Stream.Flush%2A?displayProperty=fullName>       Flush 메서드를 호출 하는 경우에 운영 체제 I/O 버퍼도 플러시됩니다.       명시적으로 플러시를 호출 하거나 개체를 삭제 하지 않는 한 스트림 인코더 플러시되지 않습니다. 설정 <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName>를 `true` 스트림 버퍼에서 데이터를 플러시할 수는 있지만 인코더 상태 플러시되지 것입니다 있다는 것을 의미 합니다.</xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName> 따라서 올바르게 문자의 다음 블록을 인코딩할 수 있도록 (부분 문자)의 상태를 유지 하기 위해 인코더 수 있습니다. 이 시나리오는 u t f&8;와 UTF7 인코더는 인접 한 문자를 받은 후 특정 문자를 인코딩할만 수 있는 위치에 적용 됩니다.       플러시는 다음 두 가지 기능을 수행 읽기 또는 쓰기에 대 한 버퍼를 사용할 수 있으므로:-이전에 버퍼에 쓴 데이터는 파일에 복사 되 고 인코더 상태로 제외 하 고 버퍼의 선택을 취소 합니다.      -If <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName>은 `true` 및 데이터를 읽기 위해 파일에서 복사한 이전에, 파일 내에서 현재 위치가 버퍼에서 읽지 않은 바이트 수로 감소 합니다.</xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName> 버퍼가 지워집니다.       사용 하 여는 <xref:System.IO.FileStream.Flush%28System.Boolean%29>중간 파일 버퍼에서 버퍼링 된 모든 데이터를 확인 하려는 경우이 메서드 오버 로드는 작성 된 디스크에.</xref:System.IO.FileStream.Flush%28System.Boolean%29>"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#4](~/add/codesnippet/csharp/m-system.io.filestream.f_1.cs)]\n [!code-cpp[System.IO.FileStream3#4](~/add/codesnippet/cpp/m-system.io.filestream.f_1.cpp)]\n [!code-vb[System.IO.FileStream3#4](~/add/codesnippet/visualbasic/m-system.io.filestream.f_1.vb)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.FileStream.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/O 오류가 발생 했습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 닫혀 있습니다."
  platform:
  - net462
- uid: System.IO.FileStream.Flush(System.Boolean)
  id: Flush(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "이 스트림에 대 한 버퍼를 지우고 버퍼링 된 모든 데이터는 파일에 쓸 수를 하 고 모든 중간 파일 버퍼도 지웁니다."
  remarks: "작성 된 중간 파일 버퍼에서 버퍼링 된 모든 데이터를 확인 하려는 경우이 오버 로드를 사용 하 여 디스크에 있습니다.       Flush 메서드를 호출 하는 경우에 운영 체제 I/O 버퍼도 플러시됩니다."
  syntax:
    content: public virtual void Flush (bool flushToDisk);
    parameters:
    - id: flushToDisk
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>모든 중간 파일 버퍼를 플러시할 수 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.IO.FileStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "비동기적으로이 스트림에 대 한 모든 버퍼를 지우고 버퍼링 된 모든 데이터가 내부 장치에 쓰여지도록 하 고 취소 요청을 모니터링 합니다."
  remarks: "FlushAsync 메서드를 호출 하면 운영 체제 I/O 버퍼는도 플러시됩니다.       반환된 된 작업에 포함 된 완료 되기 전에 작업이 취소 되는 경우는 <xref:System.Threading.Tasks.TaskStatus>에 대 한 값은 <xref:System.Threading.Tasks.Task.Status%2A>속성.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> 반환된 된 작업에 포함 된 파일에 대 한 핸들을 삭제 하는 경우는 <xref:System.ObjectDisposedException>에서 예외는 <xref:System.Threading.Tasks.Task.Exception%2A>속성.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "취소 요청을 모니터링할 토큰입니다."
    return:
      type: System.Threading.Tasks.Task
      description: "비동기 플러시 작업을 나타내는 작업입니다."
  overload: System.IO.FileStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 삭제 되었습니다."
  platform:
  - net462
- uid: System.IO.FileStream.GetAccessControl
  id: GetAccessControl
  parent: System.IO.FileStream
  langs:
  - csharp
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "가져옵니다는 <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> 현재 설명 하는 파일에 대 한 액세스 제어 목록 (ACL) 항목을 캡슐화 하는 개체 <xref href=&quot;System.IO.FileStream&quot;> </xref> 개체입니다."
  remarks: "반면는 <xref:System.IO.FileStream>클래스와 두 개의 새로운 메서드는 기존 파일의 액세스 제어 목록 (ACL) 항목을 검색 하려면 사용 사용할 수 <xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName>메서드를 사용 하기 쉽습니다.</xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       파일에 대 한 ACL 항목을 검색 하려면 두 개의 새로운 메서드 메서드를 사용 합니다.       개인 및/또는 나 갖지 않고에 지정된 된 파일에서 특정 작업을 수행할 권한을 그룹이 ACL에 설명 합니다. 자세한 내용은 참조 [하는 방법: 액세스 제어 목록 항목 추가 또는 제거](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public System.Security.AccessControl.FileSecurity GetAccessControl ();
    parameters: []
    return:
      type: System.Security.AccessControl.FileSecurity
      description: "현재 설명 하는 파일에 대 한 액세스 제어 설정을 캡슐화 하는 개체 <xref href=&quot;System.IO.FileStream&quot;> </xref> 개체입니다."
  overload: System.IO.FileStream.GetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "파일이 닫혀 있습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "파일을 여는 동안 I/O 오류가 발생 했습니다."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "파일을 찾을 수 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "이 작업은 현재 플랫폼에서 지원 되지 않습니다.       -또는-호출자에 게는 필요한 사용 권한이 없습니다."
  platform:
  - net462
- uid: System.IO.FileStream.Handle
  id: Handle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "파일에 대 한 운영 체제 파일 핸들을 가져옵니다 현재 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체를 캡슐화 합니다."
  remarks: "이 속성은 운영 체제에서 제공 하는 시스템 호출에 사용할 운영 체제 핸들 (예: `ReadFile` Windows에서). 와 같은 파일 설명자를 예상 하는 C 라이브러리 함수를 작동 하지 것입니다 `fread`합니다.       운영 체제 핸들 수 열린 동기적 또는 비동기적으로 따라 `FileStream` 생성자를 호출 합니다. 사용 하 여 <xref:System.IO.FileStream.IsAsync%2A>이 핸들이 비동기적으로 열렸으면 있는지 여부를 검색 하는 속성.</xref:System.IO.FileStream.IsAsync%2A> Win32, 즉 겹쳐진된 IO에 대 한 핸들이 열린 하 고 다른 매개 변수를 필요한 `ReadFile` 및 `WriteFile`합니다.      > [!CAUTION] > 경우 데이터 손상이 발생할 수 있습니다는 `FileStream` 는 해당 핸들을 전달, 핸들의 파일 포인터를 이동 하는 일부 작업을 만든 다음는 `FileStream` 다시 사용 됩니다. 여러 스레드에서 안전 하 게 파일에 쓸 수는 동일한 동시에, 및 `FileStream` 버퍼링 코드 핸들을 단독으로 제어 하는 것으로 가정 합니다. `FileStream`throw 할 수 있습니다는 <xref:System.IO.IOException>경우 `FileStream` 감지 다른 프로세스가 파일 포인터를 이동 되었습니다.</xref:System.IO.IOException> 이 방지 하려면 쓰지 마십시오. 모든 데이터 파일의 부분에 있는 `FileStream` 수 버퍼링 했 고 파일 포인터 위치에 복원에 마지막으로 메서드가 호출 되었을 때 `FileStream`합니다."
  syntax:
    content: public virtual IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "이 캡슐화 할 파일에 대 한 운영 체제 파일 핸들 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 개체나 경우-1은 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 닫혔습니다."
  overload: System.IO.FileStream.Handle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "호출자에 게 필요한 권한이 없습니다."
  platform:
  - net462
- uid: System.IO.FileStream.IsAsync
  id: IsAsync
  parent: System.IO.FileStream
  langs:
  - csharp
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "나타내는 값을 가져옵니다 여부는 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 열렸는지 비동기적 또는 동기적으로 처리 합니다."
  remarks: "`IsAsync` 속성 검색 여부는 `FileStream` 핸들이 비동기적으로 열렸으면를 사용 하 여 코드를 사용 하도록 설정는 <xref:System.IO.FileStream.Handle%2A>속성 올바르게.</xref:System.IO.FileStream.Handle%2A> Win32에서 `IsAsync` 핸들 겹쳐진된 I/O에 대 한 열린으로 필요한 다른 매개 변수를 true로 설정 되 고 `ReadFile` 및 `WriteFile`합니다.       인스턴스를 만들 때이 값을 지정 하는 <xref:System.IO.FileStream>변수가 있는 생성자를 사용 하 여 클래스는 `isAsync`, `useAsync`, 또는 `options` 매개 변수.</xref:System.IO.FileStream> 속성이 `true`, 스트림 파일 작업을 비동기적으로 수행 하려면 겹쳐 있는 I/O를 활용 합니다. 그러나 IsAsync 속성 있어서는 안 될 `true` 호출 하는 <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, 또는 <xref:System.IO.Stream.CopyToAsync%2A>메서드.</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> IsAsync 속성이 `false` 및 비동기 읽기를 호출 하 고 쓰기 작업, UI 스레드는 여전히 수는 있지만 실제 I/O 작업이 동기적으로 수행 됩니다."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/p-system.io.filestream.i_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/p-system.io.filestream.i_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/p-system.io.filestream.i_1.cpp)]"
  syntax:
    content: public virtual bool IsAsync { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우는 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> , 그러지 않으면 비동기적으로 열렸으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.IO.FileStream.IsAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Length
  id: Length
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "스트림의 바이트 길이 가져옵니다."
  remarks: "일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.l_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.l_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.l_1.vb)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "바이트 스트림 길이 나타내는 long 값입니다."
  overload: System.IO.FileStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref:System.IO.FileStream.CanSeek*>이 스트림에 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다.</xref:System.IO.FileStream.CanSeek*>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "파일 닫기 같은 I/O 오류가 발생 했습니다."
  platform:
  - net462
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  id: Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "다른 프로세스가 읽거나 쓰려는 <xref href=&quot;System.IO.FileStream&quot;> </xref>합니다."
  remarks: "파일 스트림의 범위를 잠그면 파일 시스템의 해당 범위에 잠금 프로세스 단독의 스레드를 제공 합니다.       일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file. Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.l_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.l_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.l_1.vb)]"
  syntax:
    content: public virtual void Lock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "잠글 범위의 시작 합니다. 이 매개 변수 값은&0; 보다 크거나 같은 이어야 합니다."
    - id: length
      type: System.Int64
      description: "잠글 범위입니다."
  overload: System.IO.FileStream.Lock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>또는 <code>length</code> 음수입니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "파일이 닫혀 있습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "프로세스가 다른 프로세스에서 파일의 일부를 잠 궜 파일을 액세스할 수 없습니다."
  platform:
  - net462
- uid: System.IO.FileStream.Name
  id: Name
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "이름을 가져옵니다는 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 생성자에 전달 된입니다."
  remarks: "일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/p-system.io.filestream.n_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/p-system.io.filestream.n_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/p-system.io.filestream.n_1.cpp)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "이름 문자열은 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.IO.FileStream.Name*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Position
  id: Position
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "이 스트림의 현재 위치를 가져오거나 설정 합니다."
  remarks: "스트림의 길이 초과 하는 위치에 검색을 지원 됩니다.  파일의 길이 초과 검색 하면 파일 크기가 증가 합니다.  Microsoft Windows NT 이상 버전에서는 파일의 끝에 추가 된 모든 데이터를&0;으로 설정 됩니다.  또는 이전 버전, Microsoft Windows 98에서 파일의 끝에 추가 된 데이터는 이전에 데이터를 삭제 했습니다.을 의미 하는 스트림에 표시는 0으로 설정 되지 않았습니다. Windows 98에서 또는 이전 스트림의 끝을 넘어 큰 값으로 스트림 위치를 설정 하면 예외가 발생 될 수 있습니다.       일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.p_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.p_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.p_1.vb)]"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "이 스트림의 현재 위치입니다."
  overload: System.IO.FileStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 찾기를 지원 하지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n The position was set to a very large value beyond the end of the stream in Windows 98 or earlier."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "위치는 음수 값으로 설정 하려고 했습니다."
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "이 지원 하지 않는 스트림의 끝을 벗어나는 검색을 시도 합니다."
  platform:
  - net462
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "스트림에서 바이트 블록을 읽어서 하 고 해당 데이터를 제공 된 버퍼에 씁니다."
  remarks: "이 메서드를 재정의 <xref:System.IO.Stream.Read%2A>.</xref:System.IO.Stream.Read%2A>       `offset` 의 바이트 오프셋을 제공 하는 매개 변수 `array` (버퍼 인덱스) 읽기를 시작 하는 고 `count` 매개 변수는이 스트림에서 읽을 바이트의 최대 수를 제공 합니다. 반환 된 값은 스트림의 끝에 도달 하면&0; 또는 읽은 바이트의 실제 수 합니다. 읽기 작업이 성공한 경우 스트림의 현재 위치는 읽은 바이트 수 만큼 앞 합니다. 예외가 발생 하면 스트림의 현재 위치는 변경 되지 않습니다.       Read 메서드 스트림의 끝에 도달한 후에&0;을 반환 합니다. 그렇지 않으면 읽기 항상 적어도&1; 바이트 스트림에서 반환 하기 전에 읽습니다. 읽기에 대 한 호출 시 스트림에서 사용할 수 있는 데이터가 없는 경우 메서드는 최소한&1; 바이트의 데이터를 반환 될 때까지 차단 됩니다. 구현을 스트림의 끝에 도달 하지 하는 경우에 요청 된 것 보다 적은 바이트를 반환할 수 있습니다.       사용 하 여 <xref:System.IO.BinaryReader>기본 데이터 형식을 읽기 위한.</xref:System.IO.BinaryReader>       읽기 작업을 수행 하는 스레드를 중단 하지 마십시오. 스레드가 차단 되 후 성공적으로 실행 되도록 응용 프로그램 처럼 보일 수, 있지만 응용 프로그램의 성능 및 안정성 중단 줄일 수 있습니다.       일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following example reads the contents from a <xref:System.IO.FileStream> and writes it into another <xref:System.IO.FileStream>.  \n  \n [!code-vb[FSRead#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_1_1.vb)]\n [!code-cs[FSRead#1](~/add/codesnippet/csharp/m-system.io.filestream.r_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "이 메서드가 반환 될 때 포함 사이의 값을 가진 지정 된 바이트 배열 `offset` 및 (`offset`  +  `count` -1`)` 현재 원본 으로부터 읽어온 바이트로 교체 합니다."
    - id: offset
      type: System.Int32
      description: "바이트 오프셋 `array` 에서 읽은 바이트 배치할 수 있습니다."
    - id: count
      type: System.Int32
      description: "읽을 바이트 수의 최대 수입니다."
    return:
      type: System.Int32
      description: "바이트은 버퍼 안으로 읽어들인 총 수입니다. 이 바이트 수를 현재 사용할 수 없는 경우 또는 스트림의 끝에 도달 하면&0;이 바이트 수가 요청 된 수보다 작을 수 있습니다."
  overload: System.IO.FileStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>또는 <code>count</code> 음수입니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 읽기를 지원 하지 않습니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/O 오류가 발생 했습니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>및 <code>count</code> 에서 잘못 된 범위에 설명 <code>array</code>합니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 닫힌 후에 메서드가 호출 되었습니다."
  platform:
  - net462
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "현재 스트림에서 바이트 시퀀스를 비동기적으로 읽고 읽은 바이트 수 만큼 스트림 내 위치를 이동 하 고 취소 요청을 모니터링 합니다."
  remarks: "ReadAsync 메서드를 사용 하면 주 스레드를 차단 하지 않고 리소스 집중형 파일 작업을 수행할 수 있습니다. 이 성능 고려 사항은 특히 중요 한 [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] 응용 프로그램 또는 [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] 시간이 많이 걸리는 스트림 작업이 UI 스레드를 차단 하 고 응용 프로그램이 작동 하지 않는 것 처럼 표시할 수 있는 응용 프로그램입니다. 비동기 메서드에와 함께 사용 되는 `async` 및 `await` Visual Basic 및 C# 키워드.       사용 하 여는 <xref:System.IO.FileStream.CanRead%2A>속성을 현재 인스턴스에 읽기를 지원 하는지를 확인 합니다.</xref:System.IO.FileStream.CanRead%2A>       반환된 된 작업에 포함 된 완료 되기 전에 작업이 취소 되는 경우는 <xref:System.Threading.Tasks.TaskStatus>에 대 한 값은 <xref:System.Threading.Tasks.Task.Status%2A>속성.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> 반환된 된 작업에 포함 된 파일에 대 한 핸들을 삭제 하는 경우는 <xref:System.ObjectDisposedException>에서 예외는 <xref:System.Threading.Tasks.Task.Exception%2A>속성.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to read from a file asynchronously.  \n  \n [!code-vb[Asynchronous_File_IO_async#4](~/add/codesnippet/visualbasic/9c5ba435-5f90-4f89-b415-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#4](~/add/codesnippet/csharp/9c5ba435-5f90-4f89-b415-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "데이터를 쓸 버퍼입니다."
    - id: offset
      type: System.Int32
      description: "바이트 오프셋 `buffer` 데이터 스트림에서 쓰기를 시작할입니다."
    - id: count
      type: System.Int32
      description: "읽을 바이트 수의 최대 수입니다."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "취소 요청을 모니터링할 토큰입니다."
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "나타내는 비동기 읽기 작업입니다. 값은 <code> TResult </code> 바이트은 버퍼 안으로 읽어들인 총 수를 포함 하는 매개 변수입니다. 결과 값에는 현재 사용할 수 있는 바이트 수가 요청 된 수보다 작으면 하거나 스트림의 끝에 도달한 경우 0 (영) 수 바이트 수가 요청 된 수보다 작을 수 있습니다."
  overload: System.IO.FileStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>또는 <code>count</code> 음수입니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "총 <code> offset </code> 및 <code> count </code> 버퍼 길이 보다 큽니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 읽기를 지원 하지 않습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 삭제 되었습니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "스트림을 현재 이전 읽기 작업에서 사용 중입니다."
  platform:
  - net462
- uid: System.IO.FileStream.ReadByte
  id: ReadByte
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "파일에서 바이트를 읽고 읽기 위치를&1; 바이트 앞으로 이동 합니다."
  remarks: "이 메서드를 재정의 <xref:System.IO.Stream.ReadByte%2A>.</xref:System.IO.Stream.ReadByte%2A>      > [!NOTE] > 사용은 <xref:System.IO.FileStream.CanRead%2A>속성을 현재 인스턴스에 읽기를 지원 하는지를 확인 합니다.</xref:System.IO.FileStream.CanRead%2A> 자세한 내용은 <xref:System.IO.Stream.CanRead%2A>.</xref:System.IO.Stream.CanRead%2A> 을 참조 하십시오."
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.r_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.r_0_1.cpp)]"
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "로 캐스팅 된 바이트는 <xref:System.Int32>, 스트림의 끝에 도달한 경우-1.</xref:System.Int32>"
  overload: System.IO.FileStream.ReadByte*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "현재 스트림이 읽기를 지원 하지 않습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "현재 스트림이 닫혀 있습니다."
  platform:
  - net462
- uid: System.IO.FileStream.SafeFileHandle
  id: SafeFileHandle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "가져옵니다는 <xref href=&quot;Microsoft.Win32.SafeHandles.SafeFileHandle&quot;> </xref> 파일에 대 한 운영 체제 파일 핸들을 나타내는 개체는 현재 <xref href=&quot;System.IO.FileStream&quot;> </xref> 개체를 캡슐화 합니다."
  remarks: "SafeFileHandle 속성 스트림을 자동으로 플러시하고 현재 스트림 위치를 0으로 설정 합니다.  이렇게 하면 이동할 파일 또는 스트림 위치를이 속성에서 반환 된 SafeFileHandle를 사용 하 여 다른 스트림에으로 다시 설정할 수 있습니다."
  syntax:
    content: public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "파일에 대 한 운영 체제 파일 핸들을 나타내는 개체를 현재 <xref href=&quot;System.IO.FileStream&quot;> </xref> 개체를 캡슐화 합니다."
  overload: System.IO.FileStream.SafeFileHandle*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "이 스트림의 현재 위치를 지정한 값으로 설정합니다."
  remarks: "이 메서드를 재정의 <xref:System.IO.Stream.Seek%2A?displayProperty=fullName>.</xref:System.IO.Stream.Seek%2A?displayProperty=fullName>      > [!NOTE] > 사용은 <xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName>속성을 현재 인스턴스 검색을 지원 하는지 여부를 결정 합니다.</xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName> 자세한 내용은 <xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>.</xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName> 을 참조 하십시오.       스트림의 길이 초과 하는 위치를 찾을 수 있습니다. 파일의 길이 초과 검색 하면 파일 크기가 증가 합니다. Windows NT 이상 버전에서 파일의 끝에 추가 된 데이터를&0;으로 설정 됩니다. Windows 98 또는 이전 버전에서 파일의 끝에 추가 된 데이터를 이전에 데이터를 삭제 했습니다.을 의미 하는 스트림에 표시는 0으로 설정 되지 않았습니다.       일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_1_1.cpp)]  \n  \n The following example reads text in the reverse direction, from the end of file to the beginning of the file, by using the various <xref:System.IO.SeekOrigin> values with the Seek method.  \n  \n [!code-vb[System.IO.FileStream.Seek#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_2.vb)]\n [!code-cs[System.IO.FileStream.Seek#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_2.cs)]"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "에 상대적인 위치 `origin` 검색을 시작할입니다."
    - id: origin
      type: System.IO.SeekOrigin
      description: "시작, 끝 또는 현재 위치에 대 한 참조 지점으로 지정 `offset`, <xref:System.IO.SeekOrigin>.</xref:System.IO.SeekOrigin> 형식의 값을 사용 하 여"
    return:
      type: System.Int64
      description: "스트림 내의 새 위치입니다."
  overload: System.IO.FileStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/O 오류가 발생 했습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 검색을 등을 지원 하지 않습니다는 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> 파이프 또는 콘솔 출력에서 생성 합니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "스트림의 시작 하기 전에 검색이 시도 되었습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 닫힌 후에 메서드가 호출 되었습니다."
  platform:
  - net462
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  id: SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "설명 하는 액세스 제어 목록 (ACL) 항목을 적용 한 <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> 현재에서 설명 하는 파일에 개체 <xref href=&quot;System.IO.FileStream&quot;> </xref> 개체입니다."
  remarks: "반면는 <xref:System.IO.FileStream>기존 파일에서 사용할 수 있습니다, 사용 하는 것이 좋습니다. 클래스를 가집니다는 <xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName>메서드를 사용 하기 쉽습니다.</xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       가집니다 메서드는 상속 되지 않은 ACL 목록을 표시 하는 파일에 액세스 제어 목록 (ACL) 항목을 적용 됩니다.      > [!CAUTION] > The ACL에 지정 된 된 `fileSecurity` 매개 변수는 파일에 대 한 기존 ACL을 대체 합니다. 새 사용자에 대 한 권한을 추가 하려면 사용 된 <xref:System.IO.FileStream.GetAccessControl%2A>메서드를 추가 하려면 수정 하 고 다음 가집니다를 사용 하 여 적용 하는 파일에 다시.</xref:System.IO.FileStream.GetAccessControl%2A>       개인 및/또는 나 갖지 않고에 지정된 된 파일에서 특정 작업을 수행할 권한을 그룹이 ACL에 설명 합니다. 자세한 내용은 참조 [하는 방법: 액세스 제어 목록 항목 추가 또는 제거](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "현재 파일에 적용할 ACL 항목을 설명 하는 개체입니다."
  overload: System.IO.FileStream.SetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "파일이 닫혀 있습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>fileSecurity</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "파일을 찾을 또는 수정할 수 없습니다."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "현재 프로세스에는 파일을 열 수 있는 권한이 없습니다."
  platform:
  - net462
- uid: System.IO.FileStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "이 스트림의 길이 지정한 값으로 설정합니다."
  remarks: "이 메서드를 재정의 <xref:System.IO.Stream.SetLength%2A>.</xref:System.IO.Stream.SetLength%2A>       지정된 된 값은 스트림의 현재 길이 보다 작은 경우는 스트림이 잘렸습니다. 이 시나리오에서는 현재 위치에 새 길이 보다 큰 경우 스트림의 마지막 바이트 까지의 현재 위치 이동 됩니다. 지정된 된 값은 스트림의 현재 길이 보다 큰 경우 스트림이 확장 되 고 현재 위치 동일 하 게 유지 합니다. 스트림을 확장 이전부터 새 길이 스트림의 내용을 정의 되지 않습니다.       스트림이 쓰기와 검색을 모두 지원 해야 `SetLength` 에서 실행 되도록 합니다.      > [!NOTE] > 사용은 <xref:System.IO.FileStream.CanWrite%2A>현재 인스턴스가 쓰기를 지원 하는지 여부를 결정 하는 속성 및 <xref:System.IO.FileStream.CanSeek%2A>속성 검색을 지원 하는지 여부를 확인 하.</xref:System.IO.FileStream.CanSeek%2A> </xref:System.IO.FileStream.CanWrite%2A> 추가 정보 <xref:System.IO.Stream.CanWrite%2A>및 <xref:System.IO.Stream.CanSeek%2A>.</xref:System.IO.Stream.CanSeek%2A> </xref:System.IO.Stream.CanWrite%2A> 를 참조 하십시오.       일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "스트림의 새 길이입니다."
  overload: System.IO.FileStream.SetLength*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/O 오류가 발생 했습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 쓰기 및 검색을 모두 지원 하지 않습니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "설정 하려고 했습니다.는 <code> value </code> 매개 변수를 0 미만입니다."
  platform:
  - net462
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  id: Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "다른 프로세스에서 이전에 잠근 파일의 일부나 전부에 액세스할 수 있습니다."
  remarks: "일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file, and then unlock the specified part of the file . Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.u_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.u_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.u_1.vb)]"
  syntax:
    content: public virtual void Unlock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "잠금을 해제할 범위의 시작 부분입니다."
    - id: length
      type: System.Int64
      description: "잠금을 해제할 범위입니다."
  overload: System.IO.FileStream.Unlock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>또는 <code>length</code> 음수입니다."
  platform:
  - net462
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "파일 스트림에 바이트 블록을 씁니다."
  remarks: "이 메서드를 재정의 <xref:System.IO.Stream.Write%2A>.</xref:System.IO.Stream.Write%2A>       `offset` 의 바이트 오프셋을 제공 하는 매개 변수 `array` (버퍼 인덱스)는 복사를 시작할 및 `count` 매개 변수를 스트림에 쓸 바이트 수를 제공 합니다. 쓰기 작업을 완료 하는 경우 쓴 바이트 수 만큼 스트림의 현재 위치는 앞 합니다. 예외가 발생 하면 스트림의 현재 위치는 변경 되지 않습니다.      > [!NOTE] > 사용은 <xref:System.IO.FileStream.CanWrite%2A>속성을 현재 인스턴스가 쓰기를 지원 하는지 여부를 결정 합니다.</xref:System.IO.FileStream.CanWrite%2A> 자세한 내용은 <xref:System.IO.Stream.CanWrite%2A>.</xref:System.IO.Stream.CanWrite%2A> 을 참조 하십시오.       쓰기 작업을 수행 하는 스레드를 중단 하지 마십시오. 스레드가 차단 되 후 성공적으로 실행 되도록 응용 프로그램 처럼 보일 수, 있지만 응용 프로그램의 성능 및 안정성 중단 줄일 수 있습니다.       일반 파일 및 디렉터리 작업 목록에 대 한 참조 [공통적인 I/O 작업](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#3](~/add/codesnippet/csharp/m-system.io.filestream.w_1_1.cs)]\n [!code-cpp[System.IO.FileStream3#3](~/add/codesnippet/cpp/m-system.io.filestream.w_1_1.cpp)]\n [!code-vb[System.IO.FileStream3#3](~/add/codesnippet/visualbasic/m-system.io.filestream.w_1_1.vb)]"
  syntax:
    content: public override void Write (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "스트림에 쓸 데이터를 포함 하는 버퍼입니다."
    - id: offset
      type: System.Int32
      description: "0부터 시작 하는 바이트 오프셋 `array` 스트림에 바이트 복사를 시작 하는 합니다."
    - id: count
      type: System.Int32
      description: "쓸 바이트의 최대 수입니다."
  overload: System.IO.FileStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>및 <code>count</code> 에서 잘못 된 범위에 설명 <code>array</code>합니다."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>또는 <code>count</code> 음수입니다."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n Another thread may have caused an unexpected change in the position of the operating system's file handle."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 닫혀 있습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "현재 스트림 인스턴스가 쓰기를 지원 하지 않습니다."
  platform:
  - net462
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "비동기적으로 현재 스트림에 바이트 시퀀스를 쓰고 쓰여진 바이트 수 만큼이 스트림 내의 현재 위치를 이동 하 고 취소 요청을 모니터링 합니다."
  remarks: "WriteAsync 메서드를 사용 하면 주 스레드를 차단 하지 않고 리소스 집중형 파일 작업을 수행할 수 있습니다. 이 성능 고려 사항은 특히 중요 한 [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] 응용 프로그램 또는 [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] 시간이 많이 걸리는 스트림 작업이 UI 스레드를 차단 하 고 응용 프로그램이 작동 하지 않는 것 처럼 표시할 수 있는 응용 프로그램입니다. 비동기 메서드에와 함께 사용 되는 `async` 및 `await` Visual Basic 및 C# 키워드.       사용 하 여는 <xref:System.IO.FileStream.CanWrite%2A>속성을 현재 인스턴스에 읽기를 지원 하는지를 확인 합니다.</xref:System.IO.FileStream.CanWrite%2A>       반환된 된 작업에 포함 된 완료 되기 전에 작업이 취소 되는 경우는 <xref:System.Threading.Tasks.TaskStatus>에 대 한 값은 <xref:System.Threading.Tasks.Task.Status%2A>속성.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> 반환된 된 작업에 포함 된 파일에 대 한 핸들을 삭제 하는 경우는 <xref:System.ObjectDisposedException>에서 예외는 <xref:System.Threading.Tasks.Task.Exception%2A>속성.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to write asynchronously to a file.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/7726d527-d678-42ba-9864-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/7726d527-d678-42ba-9864-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "데이터를 쓸 버퍼입니다."
    - id: offset
      type: System.Int32
      description: "0부터 시작 하는 바이트 오프셋 `buffer` 스트림에 바이트 복사를 시작 하는 합니다."
    - id: count
      type: System.Int32
      description: "쓸 바이트의 최대 수입니다."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "취소 요청을 모니터링할 토큰입니다."
    return:
      type: System.Threading.Tasks.Task
      description: "비동기 쓰기 작업을 나타내는 작업입니다."
  overload: System.IO.FileStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>또는 <code>count</code> 음수입니다."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "총 <code> offset </code> 및 <code> count </code> 버퍼 길이 보다 큽니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 쓰기를 지원 하지 않습니다."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 삭제 되었습니다."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "스트림을 현재 이전 쓰기 작업에서 사용 중입니다."
  platform:
  - net462
- uid: System.IO.FileStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "파일 스트림의 현재 위치에 바이트를 씁니다."
  remarks: "이 메서드를 재정의 <xref:System.IO.Stream.WriteByte%2A>.</xref:System.IO.Stream.WriteByte%2A>       사용 하 여 `WriteByte` 바이트를 쓸 수는 `FileStream` 효율적으로 합니다. 스트림이 닫혀 있는 경우 쓸 수 없는 예외가 throw 됩니다.      > [!NOTE] > 사용은 <xref:System.IO.FileStream.CanWrite%2A>속성을 현재 인스턴스가 쓰기를 지원 하는지 여부를 결정 합니다.</xref:System.IO.FileStream.CanWrite%2A> 자세한 내용은 <xref:System.IO.Stream.CanWrite%2A>.</xref:System.IO.Stream.CanWrite%2A> 을 참조 하십시오."
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.w_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.w_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.w_0_1.cpp)]"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "스트림에 쓸 바이트입니다."
  overload: System.IO.FileStream.WriteByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "스트림이 닫혀 있습니다."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "스트림이 쓰기를 지원 하지 않습니다."
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.DirectoryNotFoundException
  isExternal: true
  name: System.IO.DirectoryNotFoundException
- uid: System.IO.PathTooLongException
  isExternal: true
  name: System.IO.PathTooLongException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
- uid: Microsoft.Win32.SafeHandles.SafeFileHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeFileHandle
  nameWithType: SafeFileHandle
  fullName: Microsoft.Win32.SafeHandles.SafeFileHandle
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
- uid: System.IO.FileOptions
  parent: System.IO
  isExternal: false
  name: FileOptions
  nameWithType: FileOptions
  fullName: System.IO.FileOptions
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
- uid: System.Security.AccessControl.FileSystemRights
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSystemRights
  nameWithType: FileSystemRights
  fullName: System.Security.AccessControl.FileSystemRights
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.FileStream.CanRead
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
- uid: System.IO.FileStream.CanSeek
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
- uid: System.IO.FileStream.Dispose(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
- uid: System.IO.FileStream.Finalize
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
- uid: System.IO.FileStream.Flush
  parent: System.IO.FileStream
  isExternal: false
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
- uid: System.IO.FileStream.Flush(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.FileStream.GetAccessControl
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
- uid: System.IO.FileStream.Handle
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
- uid: System.IO.FileStream.IsAsync
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
- uid: System.IO.FileStream.Length
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
- uid: System.IO.FileStream.Name
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
- uid: System.IO.FileStream.Position
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.FileStream.ReadByte
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
- uid: System.IO.FileStream.SafeFileHandle
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
- uid: System.IO.FileStream.SetLength(System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.FileStream.WriteByte(System.Byte)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.FileStream.#ctor*
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream
  nameWithType: FileStream.FileStream
- uid: System.IO.FileStream.BeginRead*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead
  nameWithType: FileStream.BeginRead
- uid: System.IO.FileStream.BeginWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite
  nameWithType: FileStream.BeginWrite
- uid: System.IO.FileStream.CanRead*
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
- uid: System.IO.FileStream.CanSeek*
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
- uid: System.IO.FileStream.Dispose*
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose
  nameWithType: FileStream.Dispose
- uid: System.IO.FileStream.EndRead*
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead
  nameWithType: FileStream.EndRead
- uid: System.IO.FileStream.EndWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite
  nameWithType: FileStream.EndWrite
- uid: System.IO.FileStream.Finalize*
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize
  nameWithType: FileStream.Finalize
- uid: System.IO.FileStream.Flush*
  parent: System.IO.FileStream
  isExternal: false
  name: Flush
  nameWithType: FileStream.Flush
- uid: System.IO.FileStream.FlushAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync
  nameWithType: FileStream.FlushAsync
- uid: System.IO.FileStream.GetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl
  nameWithType: FileStream.GetAccessControl
- uid: System.IO.FileStream.Handle*
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
- uid: System.IO.FileStream.IsAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
- uid: System.IO.FileStream.Length*
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
- uid: System.IO.FileStream.Lock*
  parent: System.IO.FileStream
  isExternal: false
  name: Lock
  nameWithType: FileStream.Lock
- uid: System.IO.FileStream.Name*
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
- uid: System.IO.FileStream.Position*
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
- uid: System.IO.FileStream.Read*
  parent: System.IO.FileStream
  isExternal: false
  name: Read
  nameWithType: FileStream.Read
- uid: System.IO.FileStream.ReadAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync
  nameWithType: FileStream.ReadAsync
- uid: System.IO.FileStream.ReadByte*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte
  nameWithType: FileStream.ReadByte
- uid: System.IO.FileStream.SafeFileHandle*
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek*
  parent: System.IO.FileStream
  isExternal: false
  name: Seek
  nameWithType: FileStream.Seek
- uid: System.IO.FileStream.SetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl
  nameWithType: FileStream.SetAccessControl
- uid: System.IO.FileStream.SetLength*
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength
  nameWithType: FileStream.SetLength
- uid: System.IO.FileStream.Unlock*
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock
  nameWithType: FileStream.Unlock
- uid: System.IO.FileStream.Write*
  parent: System.IO.FileStream
  isExternal: false
  name: Write
  nameWithType: FileStream.Write
- uid: System.IO.FileStream.WriteAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync
  nameWithType: FileStream.WriteAsync
- uid: System.IO.FileStream.WriteByte*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte
  nameWithType: FileStream.WriteByte
