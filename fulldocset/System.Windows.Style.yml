### YamlMime:ManagedReference
items:
- uid: System.Windows.Style
  id: Style
  children:
  - System.Windows.Style.#ctor
  - System.Windows.Style.#ctor(System.Type)
  - System.Windows.Style.#ctor(System.Type,System.Windows.Style)
  - System.Windows.Style.BasedOn
  - System.Windows.Style.GetHashCode
  - System.Windows.Style.IsSealed
  - System.Windows.Style.RegisterName(System.String,System.Object)
  - System.Windows.Style.Resources
  - System.Windows.Style.Seal
  - System.Windows.Style.Setters
  - System.Windows.Style.System#Windows#Markup#IAddChild#AddChild(System.Object)
  - System.Windows.Style.System#Windows#Markup#IAddChild#AddText(System.String)
  - System.Windows.Style.System#Windows#Markup#INameScope#FindName(System.String)
  - System.Windows.Style.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.Style.TargetType
  - System.Windows.Style.Triggers
  - System.Windows.Style.UnregisterName(System.String)
  langs:
  - csharp
  name: Style
  nameWithType: Style
  fullName: System.Windows.Style
  type: Class
  summary: "속성, 리소스 및 이벤트 처리기에서 형식의 인스턴스 간에 공유할 수 있도록 합니다."
  remarks: "<xref:System.Windows.FrameworkElement>또는 <xref:System.Windows.FrameworkContentElement>.</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.FrameworkElement> 에서 파생 된 모든 요소에 스타일을 설정할 수 있습니다. 내에 리소스로 스타일 선언 가장 일반적으로 <xref:System.Windows.Application.Resources%2A>섹션.</xref:System.Windows.Application.Resources%2A> 모든 리소스에 적용 되는 동일한 범위 지정 규칙을 따르며 스타일 리소스 이기 때문에 적용할 수 있는 위치에 영향을 줍니다. 스타일 선언 하 합니다. 예를 들어, 응용 프로그램 정의의 루트 요소에 스타일 선언 하는 경우 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 파일을 응용 프로그램에서 아무 곳 이나 사용할 수 있습니다. 탐색 응용 프로그램을 만드는 경우에 응용 프로그램의 중 하나에 선언 된 스타일 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 하에 사용할 수 파일 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 파일입니다. 범위 지정 리소스에 대 한 규칙에 대 한 자세한 내용은 참조 하십시오. [XAML 리소스](~/add/includes/ajax-current-ext-md.md)합니다.       하나 이상의 컬렉션을 포함 하는 스타일 개체 스타일 선언은 이어지고 <xref:System.Windows.Setter>개체입니다.</xref:System.Windows.Setter> 각 <xref:System.Windows.Setter> <xref:System.Windows.Setter.Property%2A>및 <xref:System.Windows.Setter.Value%2A>.</xref:System.Windows.Setter.Value%2A> </xref:System.Windows.Setter.Property%2A> 구성 됩니다.</xref:System.Windows.Setter> 속성이 요소의 스타일 속성의 이름에 적용 하는 것입니다. 스타일 리소스로 선언한 후에 다른 리소스와 마찬가지로 다음 참조할 수 있습니다.      > [!NOTE] >가 동일한 setter 컬렉션에 둘 이상의 setter 경우 <xref:System.Windows.Setter.Property%2A>마지막 속성 값을 선언 하는 setter가 사용 됩니다.</xref:System.Windows.Setter.Property%2A> 마찬가지로,로 설정 하면 동일한 속성에 대 한 값 및 요소 스타일에서 직접 요소에 직접 설정 값 우선 합니다.       [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] 스타일 및 템플릿 모델 유지 관리 및 확인 표시와 논리 분리의 공유를 허용 합니다. 스타일 및 템플릿 모델을 사용자 지정할 수 있도록 기능 집합이 포함 되어 프로그램 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]합니다. 이 기능 집합을 다음 뿐만 아니라 스타일 클래스를 포함:- <xref:System.Windows.Trigger>- <xref:System.Windows.EventTrigger>및 <xref:System.Windows.Media.Animation.Storyboard>- <xref:System.Windows.Controls.ControlTemplate>- <xref:System.Windows.DataTemplate>자세한 내용은 참조 [스타일 및 템플릿](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.DataTemplate> </xref:System.Windows.Controls.ControlTemplate> </xref:System.Windows.Media.Animation.Storyboard> </xref:System.Windows.EventTrigger> </xref:System.Windows.Trigger>"
  example:
  - "The following example shows a style declaration that will affect the <xref:System.Windows.Controls.Control.Background%2A> property of a <xref:System.Windows.Controls.Control>.  \n  \n [!code-xml[StyleOvw01#StyleSimple](~/add/codesnippet/xaml/StyleOvw1/Page1.xaml#stylesimple)]\n [!code-xml[StyleOvw01#StyleSimple](~/add/codesnippet/xaml/t-system.windows.style_1.xaml)]  \n  \n To apply the above style, do the following:  \n  \n [!code-xml[StyleOvw01#StyleSimpleApplied](~/add/codesnippet/xaml/StyleOvw1/Page1.xaml#stylesimpleapplied)]\n [!code-xml[StyleOvw01#StyleSimpleApplied](~/add/codesnippet/xaml/t-system.windows.style_2.xaml)]  \n  \n You can also apply styles to all elements of a given type by using the <xref:System.Windows.Style.TargetType%2A> property. Adding the target type to the style means that you no longer have to fully qualify the property you are setting with the `ClassName.PropertyName` syntax. The following example defines a style that will be applied to every <xref:System.Windows.Controls.TextBlock> element.  \n  \n [!code-xml[PhotoStoreDemoStyled#1](~/add/codesnippet/xaml/photostore/window1.xaml#1)]\n [!code-xml[PhotoStoreDemoStyled#1](~/add/codesnippet/xaml/t-system.windows.style_3.xaml)]  \n  \n> [!NOTE]\n>  Many [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] controls consist of a combination of other [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] controls, so creating a style that applies to all controls of a type can have broad impact. For instance, if you create a style that targets the <xref:System.Windows.Controls.TextBlock> controls in a <xref:System.Windows.Controls.Canvas>, the style is applied to all <xref:System.Windows.Controls.TextBlock> controls in the canvas, even if the <xref:System.Windows.Controls.TextBlock> is part of another control, such as a <xref:System.Windows.Controls.ListBox>.  \n  \n For information on how to extend or inherit from a defined style, see the <xref:System.Windows.Style.BasedOn%2A> page."
  syntax:
    content: >-
      [System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)]

      [System.Windows.Markup.ContentProperty("Setters")]

      [System.Windows.Markup.DictionaryKeyProperty("TargetType")]

      public class Style : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IAddChild, System.Windows.Markup.INameScope, System.Windows.Markup.IQueryAmbient
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  implements:
  - System.Windows.Markup.IAddChild
  - System.Windows.Markup.INameScope
  - System.Windows.Markup.IQueryAmbient
  inheritedMembers:
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.Style.#ctor
  id: '#ctor'
  parent: System.Windows.Style
  langs:
  - csharp
  name: Style()
  nameWithType: Style.Style()
  fullName: System.Windows.Style.Style()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Windows.Style&quot;> </xref> 클래스입니다."
  remarks: "이 생성자를 호출의 지연 된 유효성 검사를 요구 <xref:System.Windows.Style.TargetType%2A>및 <xref:System.Windows.Style.BasedOn%2A>스타일 형식.</xref:System.Windows.Style.BasedOn%2A> </xref:System.Windows.Style.TargetType%2A> 파서가의 컨텍스트 외부에서 사용 하는이 경우 동작이 정의 되지 않습니다."
  syntax:
    content: public Style ();
    parameters: []
  overload: System.Windows.Style.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Style.#ctor(System.Type)
  id: '#ctor(System.Type)'
  parent: System.Windows.Style
  langs:
  - csharp
  name: Style(Type)
  nameWithType: Style.Style(Type)
  fullName: System.Windows.Style.Style(Type)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Windows.Style&quot;> </xref> <xref:System.Type>.</xref:System.Type> 지정된에 사용할 클래스"
  syntax:
    content: public Style (Type targetType);
    parameters:
    - id: targetType
      type: System.Type
      description: "스타일을 적용할 형식입니다."
  overload: System.Windows.Style.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Style.#ctor(System.Type,System.Windows.Style)
  id: '#ctor(System.Type,System.Windows.Style)'
  parent: System.Windows.Style
  langs:
  - csharp
  name: Style(Type,Style)
  nameWithType: Style.Style(Type,Style)
  fullName: System.Windows.Style.Style(Type,Style)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Windows.Style&quot;> </xref> 사용할 지정 된 클래스를 <xref:System.Type>기반으로 지정 하 고 <xref href=&quot;System.Windows.Style&quot;> </xref>.</xref:System.Type>"
  syntax:
    content: public Style (Type targetType, System.Windows.Style basedOn);
    parameters:
    - id: targetType
      type: System.Type
      description: "스타일을 적용할 형식입니다."
    - id: basedOn
      type: System.Windows.Style
      description: "이 스타일의 기반이 스타일입니다."
  overload: System.Windows.Style.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Style.BasedOn
  id: BasedOn
  parent: System.Windows.Style
  langs:
  - csharp
  name: BasedOn
  nameWithType: Style.BasedOn
  fullName: System.Windows.Style.BasedOn
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "현재 스타일의 기준이 되는 정의 된 스타일을 가져오거나 설정 합니다."
  remarks: "각 스타일 BasedOn 값이 두 개 지원합니다.      <a name=&quot;xamlAttributeUsage_BasedOn&quot;></a># # XAML 특성 사용 ```   <object BasedOn=&quot;myStyle&quot; .../>   ``` <a name=&quot;xamlValues_BasedOn&quot;> </a> # # XAML 값 *myStyle* 기존 스타일입니다.       일반적으로 사용는 [태그 확장명 및 WPF XAML](~/add/includes/ajax-current-ext-md.md) 기존 스타일으로 참조 합니다."
  example:
  - "There are several ways that styles in [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] can be extended or inherited. Styles can be based on other styles through this property. When you use this property, the new style will inherit the values of the original style that are not explicitly redefined in the new style. In the following example, `Style2` inherits the <xref:System.Windows.Controls.Control.Background%2A?displayProperty=fullName>value of `Yellow`, and adds a <xref:System.Windows.Controls.Control.Foreground%2A?displayProperty=fullName>value of `Blue`.  \n  \n [!code-xml[StyleOvw01#ExtendingStyle](~/add/codesnippet/xaml/StyleOvw1/Page1.xaml#extendingstyle)]\n [!code-xml[StyleOvw01#ExtendingStyle](~/add/codesnippet/xaml/p-system.windows.style.b_1.xaml)]  \n  \n Similarly, styles can be based on the style of an existing [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] element, as in the following example where the new style is based on the style of a <xref:System.Windows.Controls.TextBlock> element.  \n  \n [!code-xml[PhotoStoreDemoStyled#2](~/add/codesnippet/xaml/photostore/window1.xaml#2)]\n [!code-xml[PhotoStoreDemoStyled#2](~/add/codesnippet/xaml/p-system.windows.style.b_2.xaml)]  \n  \n> [!NOTE]\n>  If you create a style with a <xref:System.Windows.Style.TargetType%2A> property and base it on another style that also defines a <xref:System.Windows.Style.TargetType%2A> property, the target type of the derived style must be the same as or be derived from the type of the base style.  \n  \n Styles defined for specific types can also be based on other styles, as in the following example.  \n  \n [!code-xml[StyleOvw01#ExtendingStyleTargetType](~/add/codesnippet/xaml/StyleOvw1/Page1.xaml#extendingstyletargettype)]\n [!code-xml[StyleOvw01#ExtendingStyleTargetType](~/add/codesnippet/xaml/p-system.windows.style.b_3.xaml)]"
  syntax:
    content: public System.Windows.Style BasedOn { get; set; }
    return:
      type: System.Windows.Style
      description: "현재 스타일의 기준이 되는 정의 된 스타일입니다. 기본값은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.Style.BasedOn*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Style.GetHashCode
  id: GetHashCode
  parent: System.Windows.Style
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: Style.GetHashCode()
  fullName: System.Windows.Style.GetHashCode()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 대 한 해시 코드를 반환 합니다. <xref href=&quot;System.Windows.Style&quot;> </xref>합니다."
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "이 대 한 해시 코드 <xref href=&quot;System.Windows.Style&quot;> </xref>합니다."
  overload: System.Windows.Style.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Style.IsSealed
  id: IsSealed
  parent: System.Windows.Style
  langs:
  - csharp
  name: IsSealed
  nameWithType: Style.IsSealed
  fullName: System.Windows.Style.IsSealed
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "스타일은 읽기 전용 이며 변경할 수 없는 여부를 나타내는 값을 가져옵니다."
  remarks: "처음으로 적용 될 때 또는 다른 스타일 기반으로 할 때 스타일 봉인 되어 있습니다."
  syntax:
    content: public bool IsSealed { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>스타일은 봉인 하는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.Style.IsSealed*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Style.RegisterName(System.String,System.Object)
  id: RegisterName(System.String,System.Object)
  parent: System.Windows.Style
  langs:
  - csharp
  name: RegisterName(String,Object)
  nameWithType: Style.RegisterName(String,Object)
  fullName: System.Windows.Style.RegisterName(String,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "현재 네임 스페이스에 새 이름-개체 쌍을 등록 합니다."
  syntax:
    content: public void RegisterName (string name, object scopedElement);
    parameters:
    - id: name
      type: System.String
      description: "등록할 이름입니다."
    - id: scopedElement
      type: System.Object
      description: "지정 된에 매핑할 개체 `name`합니다."
  overload: System.Windows.Style.RegisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Style.Resources
  id: Resources
  parent: System.Windows.Style
  langs:
  - csharp
  name: Resources
  nameWithType: Style.Resources
  fullName: System.Windows.Style.Resources
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 스타일의 범위 내에서 사용할 수 있는 리소스의 컬렉션을 가져오거나 설정 합니다."
  remarks: "<a name=\"xamlPropertyElementUsage_Resources\"></a>   \n## XAML Property Element Usage  \n  \n```  \n<object>  \n  <object.Resources>  \n    oneOrMoreResourceElements  \n  </object.Resources>  \n</object>  \n- or -   \n<object>  \n  <object.Resources>  \n    <ResourceDictionary Source=\"externalDictionarySource\"/>  \n  </object.Resources>  \n</object>  \n```  \n  \n<a name=\"xamlValues_Resources\"></a>   \n## XAML Values  \n *oneOrMoreResourceElements*  \n One or more resource elements. To be referenced later in either [StaticResource Markup Extension](~/add/includes/ajax-current-ext-md.md) or [DynamicResource Markup Extension](~/add/includes/ajax-current-ext-md.md) syntax in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], a resource element must have an `x:Key` attribute.  \n  \n \\<ResourceDictionary Source=\" *externalDictionarySource*\"/>  \n An external dictionary source. For details, see [Merged Resource Dictionaries](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.ResourceDictionary Resources { get; set; }
    return:
      type: System.Windows.ResourceDictionary
      description: "이 스타일의 범위 내에서 사용할 수 있는 리소스입니다."
  overload: System.Windows.Style.Resources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Style.Seal
  id: Seal
  parent: System.Windows.Style
  langs:
  - csharp
  name: Seal()
  nameWithType: Style.Seal()
  fullName: System.Windows.Style.Seal()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "변경할 수 없는 않도록이 스타일 모든 팩터리 및 트리거를 잠급니다."
  syntax:
    content: public void Seal ();
    parameters: []
  overload: System.Windows.Style.Seal*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Style.Setters
  id: Setters
  parent: System.Windows.Style
  langs:
  - csharp
  name: Setters
  nameWithType: Style.Setters
  fullName: System.Windows.Style.Setters
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "컬렉션을 가져옵니다 <xref href=&quot;System.Windows.Setter&quot;> </xref> 및 <xref href=&quot;System.Windows.EventSetter&quot;> </xref> 개체입니다."
  remarks: "<xref:System.Windows.Style>개체 <xref:System.Windows.SetterBase>.</xref:System.Windows.SetterBase> 에 할당할 수 있는 개체로 구성 될 수</xref:System.Windows.Style> 의 Setter 속성 추가 <xref:System.Windows.SetterBase>에 자식은 <xref:System.Windows.Style>개체가 암시적으로 추가 된 <xref:System.Windows.SetterBaseCollection>에 대 한는 <xref:System.Windows.Style>개체.</xref:System.Windows.Style> </xref:System.Windows.SetterBaseCollection> </xref:System.Windows.Style> </xref:System.Windows.SetterBase>       Setter가 명시적 속성 요소 사용 상대적으로 일반적인 이기도합니다. 이것은 경우에 따라의 Setter를 구분할 수 있는 태그 스타일 결정 <xref:System.Windows.Style.Resources%2A>및 <xref:System.Windows.Style.Triggers%2A>복잡 한 스타일의 항목입니다.</xref:System.Windows.Style.Triggers%2A> </xref:System.Windows.Style.Resources%2A> 예를 들어: ```   <Style>     <Style.Setters>       <!--one or more SetterBase derived object elements here-->     </Style.Setters>   </Style>   ``` <a name=&quot;xamlPropertyElementUsage_Setters&quot;> </a> # # XAML 속성 요소 사용 ```   <object>     oneOrMoreSetters   </object>   ``` <a name=&quot;xamlValues_Setters&quot;> </a> # # XAML 값 *oneOrMoreSetters* 하나 이상의 <xref:System.Windows.Setter>또는 <xref:System.Windows.EventSetter>개체.</xref:System.Windows.EventSetter> </xref:System.Windows.Setter>            "
  example:
  - "The following example shows how to use this property.  \n  \n [!code-vb[listboxitemstyle#1](~/add/codesnippet/visualbasic/ListBoxItemStyle/Pane1.xaml.vb#1)]\n [!code-cs[listboxitemstyle#1](~/add/codesnippet/csharp/ListBoxItemStyle/Pane1.xaml.cs#1)]  \n  \n Adding a <xref:System.Windows.SetterBase> child to a <xref:System.Windows.Style> object implicitly adds it to the <xref:System.Windows.SetterBaseCollection> for the <xref:System.Windows.Style> object. The following <xref:System.Windows.EventSetter> is implicitly added to the <xref:System.Windows.SetterBaseCollection> of the style:  \n  \n [!code-xml[eventovwsupport#XAML2](~/add/codesnippet/xaml/EventOvwSupport/page2.xaml#xaml2)]"
  syntax:
    content: public System.Windows.SetterBaseCollection Setters { get; }
    return:
      type: System.Windows.SetterBaseCollection
      description: "컬렉션 <xref href=&quot;System.Windows.Setter&quot;> </xref> 및 <xref href=&quot;System.Windows.EventSetter&quot;> </xref> 개체입니다. 기본값은 빈 컬렉션입니다."
  overload: System.Windows.Style.Setters*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Style.System#Windows#Markup#IAddChild#AddChild(System.Object)
  id: System#Windows#Markup#IAddChild#AddChild(System.Object)
  isEii: true
  parent: System.Windows.Style
  langs:
  - csharp
  name: System.Windows.Markup.IAddChild.AddChild(Object)
  nameWithType: Style.System.Windows.Markup.IAddChild.AddChild(Object)
  fullName: System.Windows.Style.System.Windows.Markup.IAddChild.AddChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "자식 개체를 추가 합니다."
  remarks: "이 멤버는 명시적 인터페이스 멤버 구현 이며 사용할 수 있습니다 경우에만 <xref:System.Windows.Style>인스턴스로 캐스팅 되는 <xref:System.Windows.Markup.IAddChild>인터페이스.</xref:System.Windows.Markup.IAddChild> </xref:System.Windows.Style>"
  syntax:
    content: void IAddChild.AddChild (object value);
    parameters:
    - id: value
      type: System.Object
      description: "추가할 자식 개체입니다."
  overload: System.Windows.Style.System#Windows#Markup#IAddChild#AddChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Style.System#Windows#Markup#IAddChild#AddText(System.String)
  id: System#Windows#Markup#IAddChild#AddText(System.String)
  isEii: true
  parent: System.Windows.Style
  langs:
  - csharp
  name: System.Windows.Markup.IAddChild.AddText(String)
  nameWithType: Style.System.Windows.Markup.IAddChild.AddText(String)
  fullName: System.Windows.Style.System.Windows.Markup.IAddChild.AddText(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "개체에 있는 노드의 텍스트 콘텐츠를 추가합니다."
  remarks: "이 멤버는 명시적 인터페이스 멤버 구현 이며 사용할 수 있습니다 경우에만 <xref:System.Windows.Style>인스턴스로 캐스팅 되는 <xref:System.Windows.Markup.IAddChild>인터페이스.</xref:System.Windows.Markup.IAddChild> </xref:System.Windows.Style>"
  syntax:
    content: void IAddChild.AddText (string text);
    parameters:
    - id: text
      type: System.String
      description: "개체에 추가할 텍스트입니다."
  overload: System.Windows.Style.System#Windows#Markup#IAddChild#AddText*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Style.System#Windows#Markup#INameScope#FindName(System.String)
  id: System#Windows#Markup#INameScope#FindName(System.String)
  isEii: true
  parent: System.Windows.Style
  langs:
  - csharp
  name: System.Windows.Markup.INameScope.FindName(String)
  nameWithType: Style.System.Windows.Markup.INameScope.FindName(String)
  fullName: System.Windows.Style.System.Windows.Markup.INameScope.FindName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "제공된 된 식별 이름이 있는 개체를 반환 합니다."
  remarks: "이 멤버는 명시적 인터페이스 멤버 구현 이며 사용할 수 있습니다 경우에만 <xref:System.Windows.Style>인스턴스로 캐스팅 되는 <xref:System.Windows.Markup.INameScope>인터페이스.</xref:System.Windows.Markup.INameScope> </xref:System.Windows.Style>"
  syntax:
    content: object INameScope.FindName (string name);
    parameters:
    - id: name
      type: System.String
      description: "요청 된 개체에 대 한 이름 식별자입니다."
    return:
      type: System.Object
      description: "개체를 경우 찾을 수 있습니다. 반환 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> 해당 이름의 개체가 발견 되었습니다."
  overload: System.Windows.Style.System#Windows#Markup#INameScope#FindName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Style.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  id: System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  isEii: true
  parent: System.Windows.Style
  langs:
  - csharp
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: Style.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.Style.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "현재 범위에서 지정된 된 앰비언트 속성을 사용할 수 있는지 여부를 쿼리 합니다."
  syntax:
    content: bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);
    parameters:
    - id: propertyName
      type: System.String
      description: "요청된 된 앰비언트 속성의 이름입니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>요청 된 앰비언트 속성을 사용할 수 있습니다. 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Windows.Style.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Style.TargetType
  id: TargetType
  parent: System.Windows.Style
  langs:
  - csharp
  name: TargetType
  nameWithType: Style.TargetType
  fullName: System.Windows.Style.TargetType
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이 스타일을 사용할 형식을 가져오거나 설정 합니다."
  remarks: "<xref:System.Windows.FrameworkElement>또는 <xref:System.Windows.FrameworkContentElement>.</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.FrameworkElement> 에서 파생 된 모든 요소에 스타일을 설정할 수 있습니다. 따라서 대상 유형이 이러한 모든 요소를 수 있습니다. 그러나의 TargetType 속성으로 스타일을 만들 TargetType 속성을 정의 하는 다른 스타일을 기반으로 하는 경우 파생된 스타일의 대상 형식이 동일 해야 또는 기본 스타일의 대상 형식에서 파생 되어야 합니다.       TargetType을 지정 하지 않은 경우 지정 해야 합니다는 `x:Key` 에 대 한 프로그램 <xref:System.Windows.Style>및 클래스 이름으로 스타일의 속성을 정규화 해야 합니다.</xref:System.Windows.Style>      <a name=&quot;xamlAttributeUsage_TargetType&quot;></a># # XAML 특성 사용 ```   <object  TargetType=&quot;{x:Type typeName}&quot;/>   -or-   <object  TargetType=&quot;typeName&quot;/>   ``` <a name=&quot;xamlValues_TargetType&quot;> </a> # # XAML 값 `{x:Type ...}` 는 [X:type 태그 확장](~/add/includes/ajax-current-ext-md.md) 태그 확장 사용 합니다.             *typeName* 클래스의 형식 이름입니다."
  example:
  - "The following example defines a style that will be applied to all instances of the <xref:System.Windows.Controls.TextBlock> element.  \n  \n [!code-xml[PhotoStoreDemoStyled#1](~/add/codesnippet/xaml/photostore/window1.xaml#1)]\n [!code-xml[PhotoStoreDemoStyled#1](~/add/codesnippet/xaml/p-system.windows.style.t_0_1.xaml)]  \n  \n Setting the TargetType property to the <xref:System.Windows.Controls.TextBlock> type without setting an `x:Key` implicitly sets the `x:Key` to `{x:Type TextBlock}`. This also means that if you give the above <xref:System.Windows.Style> an `x:Key` value of anything other than `{x:Type TextBlock}`, the <xref:System.Windows.Style> would not be applied to all <xref:System.Windows.Controls.TextBlock> elements automatically. Instead, you need to apply the style to the <xref:System.Windows.Controls.TextBlock> elements explicitly.  \n  \n Many [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] controls consist of a combination of other [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] controls, so creating a style that applies to all controls of a type can have broad impact. For instance, if you create a style that targets the <xref:System.Windows.Controls.TextBox> controls in a <xref:System.Windows.Controls.Canvas>, the style is applied to all <xref:System.Windows.Controls.TextBox> controls in the canvas, even if the <xref:System.Windows.Controls.TextBox> is part of another control, such as a <xref:System.Windows.Controls.ComboBox>."
  syntax:
    content: public Type TargetType { get; set; }
    return:
      type: System.Type
      description: "이 스타일에 대 한 대상 형식입니다."
  overload: System.Windows.Style.TargetType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Style.Triggers
  id: Triggers
  parent: System.Windows.Style
  langs:
  - csharp
  name: Triggers
  nameWithType: Style.Triggers
  fullName: System.Windows.Style.Triggers
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "컬렉션을 가져옵니다 <xref href=&quot;System.Windows.TriggerBase&quot;> </xref> 지정 된 조건에 따라 속성 값을 적용 하는 개체입니다."
  remarks: "[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] 스타일 및 템플릿 모델 <xref:System.Windows.Style>.</xref:System.Windows.Style> 내에서 트리거를 지정할 수 있습니다. 트리거의 경우 특정 변경 내용을 적용할 수 있도록 하는 개체는 기본적으로, 조건 (특정는 속성 값이 같은 `true`, 이벤트가 발생할 때 또는) 만족 합니다.      <a name=&quot;xamlPropertyElementUsage_Triggers&quot;></a># # XAML 속성 요소 사용 ```   <object>     <object.Triggers>       oneOrMoreTriggers     </object.Triggers>   </object>   ``` <a name=&quot;xamlValues_Triggers&quot;> </a> # # XAML 값 *oneOrMoreTriggers* <xref:System.Windows.TriggerBase>.</xref:System.Windows.TriggerBase> 에서 파생 된 클래스는&0; 개 이상의 개체 요소      "
  example:
  - "The following example shows a named <xref:System.Windows.Style> available to <xref:System.Windows.Controls.Button> controls. The <xref:System.Windows.Style> defines a <xref:System.Windows.Trigger> element that changes the <xref:System.Windows.Controls.Control.Foreground%2A> property of a button when the <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> property is `true`.  \n  \n [!code-xml[BtnStyles#2](~/add/codesnippet/xaml/ButtonStyles2/app.xaml#2)]"
  syntax:
    content: public System.Windows.TriggerCollection Triggers { get; }
    return:
      type: System.Windows.TriggerCollection
      description: "컬렉션 <xref href=&quot;System.Windows.TriggerBase&quot;> </xref> 개체입니다. 기본값은 빈 컬렉션입니다."
  overload: System.Windows.Style.Triggers*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Style.UnregisterName(System.String)
  id: UnregisterName(System.String)
  parent: System.Windows.Style
  langs:
  - csharp
  name: UnregisterName(String)
  nameWithType: Style.UnregisterName(String)
  fullName: System.Windows.Style.UnregisterName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "이름 범위에서 이름-개체 매핑을 제거합니다."
  syntax:
    content: public void UnregisterName (string name);
    parameters:
    - id: name
      type: System.String
      description: "제거할 매핑의 이름입니다."
  overload: System.Windows.Style.UnregisterName*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Threading.DispatcherObject
  isExternal: false
  name: System.Windows.Threading.DispatcherObject
- uid: System.Windows.Style.#ctor
  parent: System.Windows.Style
  isExternal: false
  name: Style()
  nameWithType: Style.Style()
  fullName: System.Windows.Style.Style()
- uid: System.Windows.Style.#ctor(System.Type)
  parent: System.Windows.Style
  isExternal: false
  name: Style(Type)
  nameWithType: Style.Style(Type)
  fullName: System.Windows.Style.Style(Type)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Windows.Style.#ctor(System.Type,System.Windows.Style)
  parent: System.Windows.Style
  isExternal: false
  name: Style(Type,Style)
  nameWithType: Style.Style(Type,Style)
  fullName: System.Windows.Style.Style(Type,Style)
- uid: System.Windows.Style
  parent: System.Windows
  isExternal: false
  name: Style
  nameWithType: Style
  fullName: System.Windows.Style
- uid: System.Windows.Style.BasedOn
  parent: System.Windows.Style
  isExternal: false
  name: BasedOn
  nameWithType: Style.BasedOn
  fullName: System.Windows.Style.BasedOn
- uid: System.Windows.Style.GetHashCode
  parent: System.Windows.Style
  isExternal: false
  name: GetHashCode()
  nameWithType: Style.GetHashCode()
  fullName: System.Windows.Style.GetHashCode()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Style.IsSealed
  parent: System.Windows.Style
  isExternal: false
  name: IsSealed
  nameWithType: Style.IsSealed
  fullName: System.Windows.Style.IsSealed
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Style.RegisterName(System.String,System.Object)
  parent: System.Windows.Style
  isExternal: false
  name: RegisterName(String,Object)
  nameWithType: Style.RegisterName(String,Object)
  fullName: System.Windows.Style.RegisterName(String,Object)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.Style.Resources
  parent: System.Windows.Style
  isExternal: false
  name: Resources
  nameWithType: Style.Resources
  fullName: System.Windows.Style.Resources
- uid: System.Windows.ResourceDictionary
  parent: System.Windows
  isExternal: false
  name: ResourceDictionary
  nameWithType: ResourceDictionary
  fullName: System.Windows.ResourceDictionary
- uid: System.Windows.Style.Seal
  parent: System.Windows.Style
  isExternal: false
  name: Seal()
  nameWithType: Style.Seal()
  fullName: System.Windows.Style.Seal()
- uid: System.Windows.Style.Setters
  parent: System.Windows.Style
  isExternal: false
  name: Setters
  nameWithType: Style.Setters
  fullName: System.Windows.Style.Setters
- uid: System.Windows.SetterBaseCollection
  parent: System.Windows
  isExternal: false
  name: SetterBaseCollection
  nameWithType: SetterBaseCollection
  fullName: System.Windows.SetterBaseCollection
- uid: System.Windows.Style.System#Windows#Markup#IAddChild#AddChild(System.Object)
  parent: System.Windows.Style
  isExternal: false
  name: System.Windows.Markup.IAddChild.AddChild(Object)
  nameWithType: Style.System.Windows.Markup.IAddChild.AddChild(Object)
  fullName: System.Windows.Style.System.Windows.Markup.IAddChild.AddChild(Object)
- uid: System.Windows.Style.System#Windows#Markup#IAddChild#AddText(System.String)
  parent: System.Windows.Style
  isExternal: false
  name: System.Windows.Markup.IAddChild.AddText(String)
  nameWithType: Style.System.Windows.Markup.IAddChild.AddText(String)
  fullName: System.Windows.Style.System.Windows.Markup.IAddChild.AddText(String)
- uid: System.Windows.Style.System#Windows#Markup#INameScope#FindName(System.String)
  parent: System.Windows.Style
  isExternal: false
  name: System.Windows.Markup.INameScope.FindName(String)
  nameWithType: Style.System.Windows.Markup.INameScope.FindName(String)
  fullName: System.Windows.Style.System.Windows.Markup.INameScope.FindName(String)
- uid: System.Windows.Style.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  parent: System.Windows.Style
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: Style.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.Style.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
- uid: System.Windows.Style.TargetType
  parent: System.Windows.Style
  isExternal: false
  name: TargetType
  nameWithType: Style.TargetType
  fullName: System.Windows.Style.TargetType
- uid: System.Windows.Style.Triggers
  parent: System.Windows.Style
  isExternal: false
  name: Triggers
  nameWithType: Style.Triggers
  fullName: System.Windows.Style.Triggers
- uid: System.Windows.TriggerCollection
  parent: System.Windows
  isExternal: false
  name: TriggerCollection
  nameWithType: TriggerCollection
  fullName: System.Windows.TriggerCollection
- uid: System.Windows.Style.UnregisterName(System.String)
  parent: System.Windows.Style
  isExternal: false
  name: UnregisterName(String)
  nameWithType: Style.UnregisterName(String)
  fullName: System.Windows.Style.UnregisterName(String)
- uid: System.Windows.Style.#ctor*
  parent: System.Windows.Style
  isExternal: false
  name: Style
  nameWithType: Style.Style
- uid: System.Windows.Style.BasedOn*
  parent: System.Windows.Style
  isExternal: false
  name: BasedOn
  nameWithType: Style.BasedOn
- uid: System.Windows.Style.GetHashCode*
  parent: System.Windows.Style
  isExternal: false
  name: GetHashCode
  nameWithType: Style.GetHashCode
- uid: System.Windows.Style.IsSealed*
  parent: System.Windows.Style
  isExternal: false
  name: IsSealed
  nameWithType: Style.IsSealed
- uid: System.Windows.Style.RegisterName*
  parent: System.Windows.Style
  isExternal: false
  name: RegisterName
  nameWithType: Style.RegisterName
- uid: System.Windows.Style.Resources*
  parent: System.Windows.Style
  isExternal: false
  name: Resources
  nameWithType: Style.Resources
- uid: System.Windows.Style.Seal*
  parent: System.Windows.Style
  isExternal: false
  name: Seal
  nameWithType: Style.Seal
- uid: System.Windows.Style.Setters*
  parent: System.Windows.Style
  isExternal: false
  name: Setters
  nameWithType: Style.Setters
- uid: System.Windows.Style.System#Windows#Markup#IAddChild#AddChild*
  parent: System.Windows.Style
  isExternal: false
  name: System.Windows.Markup.IAddChild.AddChild
  nameWithType: Style.System.Windows.Markup.IAddChild.AddChild
- uid: System.Windows.Style.System#Windows#Markup#IAddChild#AddText*
  parent: System.Windows.Style
  isExternal: false
  name: System.Windows.Markup.IAddChild.AddText
  nameWithType: Style.System.Windows.Markup.IAddChild.AddText
- uid: System.Windows.Style.System#Windows#Markup#INameScope#FindName*
  parent: System.Windows.Style
  isExternal: false
  name: System.Windows.Markup.INameScope.FindName
  nameWithType: Style.System.Windows.Markup.INameScope.FindName
- uid: System.Windows.Style.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  parent: System.Windows.Style
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
  nameWithType: Style.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
- uid: System.Windows.Style.TargetType*
  parent: System.Windows.Style
  isExternal: false
  name: TargetType
  nameWithType: Style.TargetType
- uid: System.Windows.Style.Triggers*
  parent: System.Windows.Style
  isExternal: false
  name: Triggers
  nameWithType: Style.Triggers
- uid: System.Windows.Style.UnregisterName*
  parent: System.Windows.Style
  isExternal: false
  name: UnregisterName
  nameWithType: Style.UnregisterName
