### YamlMime:ManagedReference
items:
- uid: System.Data.DataSet
  id: DataSet
  children:
  - System.Data.DataSet.#ctor
  - System.Data.DataSet.#ctor(System.String)
  - System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)
  - System.Data.DataSet.AcceptChanges
  - System.Data.DataSet.BeginInit
  - System.Data.DataSet.CaseSensitive
  - System.Data.DataSet.Clear
  - System.Data.DataSet.Clone
  - System.Data.DataSet.Copy
  - System.Data.DataSet.CreateDataReader
  - System.Data.DataSet.CreateDataReader(System.Data.DataTable[])
  - System.Data.DataSet.DataSetName
  - System.Data.DataSet.DefaultViewManager
  - System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)
  - System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataSet.EndInit
  - System.Data.DataSet.EnforceConstraints
  - System.Data.DataSet.ExtendedProperties
  - System.Data.DataSet.GetChanges
  - System.Data.DataSet.GetChanges(System.Data.DataRowState)
  - System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)
  - System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataSet.GetSchemaSerializable
  - System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataSet.GetXml
  - System.Data.DataSet.GetXmlSchema
  - System.Data.DataSet.HasChanges
  - System.Data.DataSet.HasChanges(System.Data.DataRowState)
  - System.Data.DataSet.HasErrors
  - System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])
  - System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])
  - System.Data.DataSet.InferXmlSchema(System.String,System.String[])
  - System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])
  - System.Data.DataSet.Initialized
  - System.Data.DataSet.InitializeDerivedDataSet
  - System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataSet.IsInitialized
  - System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])
  - System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])
  - System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])
  - System.Data.DataSet.Locale
  - System.Data.DataSet.Merge(System.Data.DataRow[])
  - System.Data.DataSet.Merge(System.Data.DataSet)
  - System.Data.DataSet.Merge(System.Data.DataTable)
  - System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)
  - System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)
  - System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)
  - System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  - System.Data.DataSet.MergeFailed
  - System.Data.DataSet.Namespace
  - System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  - System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)
  - System.Data.DataSet.OnRemoveTable(System.Data.DataTable)
  - System.Data.DataSet.Prefix
  - System.Data.DataSet.RaisePropertyChanging(System.String)
  - System.Data.DataSet.ReadXml(System.IO.Stream)
  - System.Data.DataSet.ReadXml(System.IO.TextReader)
  - System.Data.DataSet.ReadXml(System.String)
  - System.Data.DataSet.ReadXml(System.Xml.XmlReader)
  - System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)
  - System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)
  - System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)
  - System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)
  - System.Data.DataSet.ReadXmlSchema(System.IO.Stream)
  - System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)
  - System.Data.DataSet.ReadXmlSchema(System.String)
  - System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)
  - System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)
  - System.Data.DataSet.RejectChanges
  - System.Data.DataSet.Relations
  - System.Data.DataSet.RemotingFormat
  - System.Data.DataSet.Reset
  - System.Data.DataSet.SchemaSerializationMode
  - System.Data.DataSet.ShouldSerializeRelations
  - System.Data.DataSet.ShouldSerializeTables
  - System.Data.DataSet.Site
  - System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection
  - System.Data.DataSet.System#ComponentModel#IListSource#GetList
  - System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema
  - System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  - System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  - System.Data.DataSet.Tables
  - System.Data.DataSet.WriteXml(System.IO.Stream)
  - System.Data.DataSet.WriteXml(System.IO.TextWriter)
  - System.Data.DataSet.WriteXml(System.String)
  - System.Data.DataSet.WriteXml(System.Xml.XmlWriter)
  - System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  - System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  - System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)
  - System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  - System.Data.DataSet.WriteXmlSchema(System.IO.Stream)
  - System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)
  - System.Data.DataSet.WriteXmlSchema(System.String)
  - System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)
  - System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})
  - System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})
  - System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})
  - System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})
  langs:
  - csharp
  name: DataSet
  nameWithType: DataSet
  fullName: System.Data.DataSet
  type: Class
  summary: "데이터의 메모리에 캐시를 나타냅니다."
  remarks: "데이터 원본에서 검색 된 데이터의 메모리에 캐시 인 데이터 집합은 ADO.NET 아키텍처의 주요 구성 요소입니다. 데이터 집합의 컬렉션으로 이루어져 <xref:System.Data.DataTable>개체를 통해 서로 연결할 수 있습니다 <xref:System.Data.DataRelation>개체.</xref:System.Data.DataRelation> </xref:System.Data.DataTable> 사용 하 여 데이터 집합의 데이터 무결성을 적용할 수도 있습니다는 <xref:System.Data.UniqueConstraint>및 <xref:System.Data.ForeignKeyConstraint>개체.</xref:System.Data.ForeignKeyConstraint> </xref:System.Data.UniqueConstraint> 데이터 집합 개체를 사용 하는 방법에 대 한 자세한 내용은 참조 하십시오. [데이터 집합, Datatable 및 Dataview](~/add/includes/ajax-current-ext-md.md)합니다.       반면 <xref:System.Data.DataTable>개체 데이터가 <xref:System.Data.DataRelationCollection>테이블 계층 구조를 탐색할 수 있습니다.</xref:System.Data.DataRelationCollection> </xref:System.Data.DataTable> 테이블에 포함 된 한 <xref:System.Data.DataTableCollection>를 통해 액세스는 <xref:System.Data.DataSet.Tables%2A>속성.</xref:System.Data.DataSet.Tables%2A> </xref:System.Data.DataTableCollection> 에 액세스할 때 <xref:System.Data.DataTable>개체, 조건에 따라 대/소문자 구분 되는지 확인 합니다.</xref:System.Data.DataTable> 예를 들어 하나의 <xref:System.Data.DataTable>&quot;mydatatable&quot; 라고 하 고 &quot;Mydatatable&quot; 라는 다른, 테이블 중 하나를 검색 하는 데 사용 하는 문자열 같이 대/소문자 구분 간주 됩니다.</xref:System.Data.DataTable> 그러나 &quot;mydatatable&quot; 있으며 &quot;Mydatatable&quot; 하지 않는 경우 검색 문자열 소문자 간주 됩니다. 작업에 대 한 자세한 내용은 <xref:System.Data.DataTable>개체 참조 [DataTable 만들기](~/add/includes/ajax-current-ext-md.md).</xref:System.Data.DataTable>       데이터 집합을 읽고 XML 문서로 데이터와 스키마를 쓸 수 있습니다. 데이터 및 스키마 다음 전체 HTTP 전송 및 사용할 수는 XML을 사용 하도록 설정 하는 모든 플랫폼에서 모든 응용 프로그램에서 합니다. 스키마와 XML 스키마로 저장할 수 있습니다는 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드, 및 스키마와 데이터 모두를 사용 하 여 저장할 수는 <xref:System.Data.DataSet.WriteXml%2A>메서드.</xref:System.Data.DataSet.WriteXml%2A> </xref:System.Data.DataSet.WriteXmlSchema%2A> 사용 하 여 스키마와 데이터 모두 포함 하는 XML 문서를 읽으려면는 <xref:System.Data.DataSet.ReadXml%2A>메서드.</xref:System.Data.DataSet.ReadXml%2A>       일반적인 다중 계층 구현에서 원래 데이터를 업데이트 하는 단계 그리고 나아가서는 만들고 데이터 집합을 새로에: 1입니다.  빌드 및 각 <xref:System.Data.DataTable> <xref:System.Data.Common.DataAdapter>.</xref:System.Data.Common.DataAdapter> 를 사용 하 여 데이터 원본의 데이터로 데이터 집합에서</xref:System.Data.DataTable> 채우기      2.  개인의 데이터 변경 <xref:System.Data.DataTable>추가, 업데이트 또는 삭제 하 여 개체 <xref:System.Data.DataRow>개체.</xref:System.Data.DataRow> </xref:System.Data.DataTable>      3.  호출의 <xref:System.Data.DataSet.GetChanges%2A>방법을 변경한 데이터는 두 번째 데이터 집합을 만들 수 있습니다.</xref:System.Data.DataSet.GetChanges%2A>      4.  호출 된 <xref:System.Data.Common.DataAdapter.Update%2A>의 메서드는 <xref:System.Data.Common.DataAdapter>, 두 번째 데이터 집합을 인수로 전달 합니다.</xref:System.Data.Common.DataAdapter> </xref:System.Data.Common.DataAdapter.Update%2A>      5.  호출 된 <xref:System.Data.DataSet.Merge%2A>첫 번째에 두 번째 데이터 집합에서 변경 내용을 병합 하는 메서드.</xref:System.Data.DataSet.Merge%2A>      6.  호출 된 <xref:System.Data.DataSet.AcceptChanges%2A>데이터 집합에.</xref:System.Data.DataSet.AcceptChanges%2A> 또는, 호출 <xref:System.Data.DataSet.RejectChanges%2A>변경을 취소 하.</xref:System.Data.DataSet.RejectChanges%2A>      > [!NOTE] > 데이터 집합 및 <xref:System.Data.DataTable>개체에서 상속 <xref:System.ComponentModel.MarshalByValueComponent>, 및 지원에서 <xref:System.Runtime.Serialization.ISerializable>원격에 대 한 인터페이스입니다.</xref:System.Runtime.Serialization.ISerializable> </xref:System.ComponentModel.MarshalByValueComponent> </xref:System.Data.DataTable> 이들은 원격으로 연결할 수 있는 유일한 ADO.NET 개체입니다.      > [!NOTE] > 데이터 집합에서 상속 된 클래스 종료 자가 데이터 집합에 표시 되지 않았습니다. 때문에 가비지 수집기에 의해 종료 되지 않습니다. 파생된 클래스를 호출할 수는 <xref:System.GC.ReRegisterForFinalize%2A>해당 생성자를 클래스에는 가비지 수집기에 의해 종료 될 수 있도록 합니다.</xref:System.GC.ReRegisterForFinalize%2A>"
  example:
  - "The following example consists of several methods that, combined, create and fill a DataSet from the **Northwind** database.  \n  \n [!code-cs[Classic WebData DataSet Example#1](~/add/codesnippet/csharp/t-system.data.dataset_1.cs)]\n [!code-vb[Classic WebData DataSet Example#1](~/add/codesnippet/visualbasic/t-system.data.dataset_1.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultProperty("DataSetName")]

      [System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Xml.Serialization.XmlRoot("DataSet")]

      [System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")]

      public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable
  inheritance:
  - System.Object
  - System.ComponentModel.MarshalByValueComponent
  implements:
  - System.ComponentModel.IListSource
  - System.ComponentModel.ISupportInitializeNotification
  - System.Runtime.Serialization.ISerializable
  - System.Xml.Serialization.IXmlSerializable
  inheritedMembers:
  - System.ComponentModel.MarshalByValueComponent.Container
  - System.ComponentModel.MarshalByValueComponent.DesignMode
  - System.ComponentModel.MarshalByValueComponent.Dispose
  - System.ComponentModel.MarshalByValueComponent.Dispose(System.Boolean)
  - System.ComponentModel.MarshalByValueComponent.Disposed
  - System.ComponentModel.MarshalByValueComponent.Events
  - System.ComponentModel.MarshalByValueComponent.GetService(System.Type)
  - System.ComponentModel.MarshalByValueComponent.ToString
  platform:
  - net462
- uid: System.Data.DataSet.#ctor
  id: '#ctor'
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DataSet()
  nameWithType: DataSet.DataSet()
  fullName: System.Data.DataSet.DataSet()
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 클래스입니다."
  remarks: "이 구현에서 <xref:System.Data.DataSet>생성자 매개 변수를 하 고 새 인스턴스에 대 한 기본 이름이 &quot;NewDataSet&quot;를 만듭니다.</xref:System.Data.DataSet>       에 대 한 이름을 <xref:System.Data.DataSet>의 XML 표현이 있는지 확인 하는 데 필요한는 <xref:System.Data.DataSet>항상 스키마 정의에 최상위 요소가 문서 요소에 대 한 이름을 가집니다.</xref:System.Data.DataSet> </xref:System.Data.DataSet>"
  example:
  - "The following example creates a new <xref:System.Data.DataSet>, and adds two <xref:System.Data.DataTable> objects to it.  \n  \n [!code-vb[Classic WebData DataSet.DataSet Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.sh_1_1.vb)]"
  syntax:
    content: public DataSet ();
    parameters: []
  overload: System.Data.DataSet.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DataSet(String)
  nameWithType: DataSet.DataSet(String)
  fullName: System.Data.DataSet.DataSet(String)
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "새 인스턴스를 초기화 한 <xref href=&quot;System.Data.DataSet&quot;> </xref> 지정 된 이름의 클래스입니다."
  remarks: "에 대 한 이름을 <xref:System.Data.DataSet>의 XML 표현이 있는지 확인 하는 데 필요한는 <xref:System.Data.DataSet>항상 스키마 정의에서 가장 높은 수준의 요소가 있는 문서 요소에 대 한 이름을 가집니다.</xref:System.Data.DataSet> </xref:System.Data.DataSet>"
  example:
  - "The following example creates a new <xref:System.Data.DataSet>, to which two <xref:System.Data.DataTable> objects are added.  \n  \n [!code-vb[Classic WebData DataSet.DataSet1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.sh_0_1.vb)]"
  syntax:
    content: public DataSet (string dataSetName);
    parameters:
    - id: dataSetName
      type: System.String
      description: "이름에서 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  overload: System.Data.DataSet.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: '#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)'
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DataSet(SerializationInfo,StreamingContext)
  nameWithType: DataSet.DataSet(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.DataSet(SerializationInfo,StreamingContext)
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "새 인스턴스를 초기화 한 <xref href=&quot;System.Data.DataSet&quot;> </xref> 를 가진 지정 된 serialization 정보와 컨텍스트."
  syntax:
    content: protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "Serialize 하거나 개체를 역직렬화 하는 데 필요한 데이터입니다."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "원본 및 대상 지정 된 직렬화 된 스트림의 합니다."
  overload: System.Data.DataSet.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)
  id: '#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)'
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DataSet(SerializationInfo,StreamingContext,Boolean)
  nameWithType: DataSet.DataSet(SerializationInfo,StreamingContext,Boolean)
  fullName: System.Data.DataSet.DataSet(SerializationInfo,StreamingContext,Boolean)
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 클래스입니다."
  syntax:
    content: protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> 개체입니다."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "<xref:System.Runtime.Serialization.StreamingContext>개체입니다.</xref:System.Runtime.Serialization.StreamingContext>"
    - id: ConstructSchema
      type: System.Boolean
      description: "부울 값입니다."
  overload: System.Data.DataSet.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.AcceptChanges
  id: AcceptChanges
  parent: System.Data.DataSet
  langs:
  - csharp
  name: AcceptChanges()
  nameWithType: DataSet.AcceptChanges()
  fullName: System.Data.DataSet.AcceptChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이에 대 한 모든 변경 내용을 커밋합니다 <xref href=&quot;System.Data.DataSet&quot;> </xref> 로드 된 이후 이후 또는 마지막으로 AcceptChanges를 호출 했습니다."
  remarks: "둘 다는 <xref:System.Data.DataRow>및 <xref:System.Data.DataTable>클래스는 AcceptChanges 메서드가.</xref:System.Data.DataTable> </xref:System.Data.DataRow> 호출 <xref:System.Data.DataTable.AcceptChanges%2A>에 <xref:System.Data.DataTable>원인을 수준는 <xref:System.Data.DataRow.AcceptChanges%2A>메서드 각각에 대해 <xref:System.Data.DataRow>를 호출할 수 있습니다.</xref:System.Data.DataRow> </xref:System.Data.DataRow.AcceptChanges%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.AcceptChanges%2A> 마찬가지로, <xref:System.Data.DataSet> <xref:System.Data.DataTable.AcceptChanges%2A> <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 내에서 각 테이블에 호출</xref:System.Data.DataTable.AcceptChanges%2A> 되도록</xref:System.Data.DataSet> 에 AcceptChanges를 호출 이러한 방식으로 메서드를 호출할 수 있는 여러 수준을 사용할 수 있습니다. AcceptChanges를 호출는 <xref:System.Data.DataSet>호출 하 여 모든 하위 개체 (예: 테이블 및 행)에 대 한 메서드를 호출할 수 있습니다.</xref:System.Data.DataSet>       호출 하는 경우 `AcceptChanges` 에 `DataSet`있으면 모든 <xref:System.Data.DataRow>아직 편집 모드에에서는 개체의 편집을 성공적으로 완료 합니다.</xref:System.Data.DataRow> 각 <xref:System.Data.DataRow> <xref:System.Data.DataRow.RowState%2A>속성도 변경 됩니다. `Added` 및 `Modified` 될 행 `Unchanged`, 및 `Deleted` 행이 제거 됩니다. </xref:System.Data.DataRow.RowState%2A></xref:System.Data.DataRow>       경우는 `DataSet` 포함 <xref:System.Data.ForeignKeyConstraint>개체를 호출 하는 `AcceptChanges` 메서드는 <xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A>적용 됩니다.</xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A> </xref:System.Data.ForeignKeyConstraint>      > [!NOTE]  >   `AcceptChanges` 및 `RejectChanges` 에 적용 `DataRow` 관련 변경 내용 (즉, 추가, 제거, 삭제 및 수정). 스키마 나 구조 변경 내용을 적용 되지 않습니다.   >> 호출 AcceptChanges DataAdapter를 사용 하 여 데이터 집합 채워진 경우 이러한 변경 내용을 데이터 소스에 다시 복제 되지 않습니다. 이러한 상황에서는 호출 <xref:System.Data.Common.DataAdapter.Update%2A>대신.</xref:System.Data.Common.DataAdapter.Update%2A> 참조 [Dataadapter로 데이터 원본 업데이트](http://msdn.microsoft.com/library/33y2221y.aspx) 자세한 정보에 대 한 합니다."
  example:
  - "The following example adds a <xref:System.Data.DataRow> to a <xref:System.Data.DataTable> in a <xref:System.Data.DataSet>. The AcceptChanges method is then called on the <xref:System.Data.DataSet>, which cascades to all <xref:System.Data.DataTable> objects that it contains.  \n  \n [!code-vb[Classic WebData DataSet.AcceptChanges#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ac_1.vb)]\n [!code-cs[Classic WebData DataSet.AcceptChanges#1](~/add/codesnippet/csharp/m-system.data.dataset.ac_1.cs)]"
  syntax:
    content: public void AcceptChanges ();
    parameters: []
  overload: System.Data.DataSet.AcceptChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.BeginInit
  id: BeginInit
  parent: System.Data.DataSet
  langs:
  - csharp
  name: BeginInit()
  nameWithType: DataSet.BeginInit()
  fullName: System.Data.DataSet.BeginInit()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "초기화를 시작는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 폼에 사용 되거나 다른 구성 요소에서 사용 하 합니다. 초기화는 런타임에 발생 합니다."
  remarks: "Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소 초기화를 시작 합니다. <xref:System.Data.DataSet.EndInit%2A>메서드 초기화를 끝냅니다.</xref:System.Data.DataSet.EndInit%2A> BeginInit를 사용 하 여 및 <xref:System.Data.DataSet.EndInit%2A>메서드는 컨트롤이 완전히 초기화 되기 전에 사용 되지 않습니다.</xref:System.Data.DataSet.EndInit%2A>"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Data.DataSet.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.CaseSensitive
  id: CaseSensitive
  parent: System.Data.DataSet
  langs:
  - csharp
  name: CaseSensitive
  nameWithType: DataSet.CaseSensitive
  fullName: System.Data.DataSet.CaseSensitive
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "문자열을 나타내는 값 내에서 비교 하는지 여부를 가져오거나 <xref href=&quot;System.Data.DataTable&quot;> </xref> 개체는 대/소문자 구분 합니다."
  remarks: "CaseSensitive 속성 정렬, 검색 및 필터링 작업도 각에서 수행 하는 방법에 영향을 줍니다. <xref:System.Data.DataTable>에 포함 된 개체는 <xref:System.Data.DataSet>사용 하는 경우는 <xref:System.Data.DataTable.Select%2A>메서드.</xref:System.Data.DataTable.Select%2A> </xref:System.Data.DataSet> </xref:System.Data.DataTable>       CaseSensitive 속성을 설정 해도 기본적으로는 <xref:System.Data.DataSet>도 설정 하는 <xref:System.Data.DataTable.CaseSensitive%2A>의 연결 된 각 속성 <xref:System.Data.DataTable>동일한 값으로.</xref:System.Data.DataTable> </xref:System.Data.DataTable.CaseSensitive%2A> </xref:System.Data.DataSet>"
  example:
  - "The following example toggles the CaseSensitive property.  \n  \n [!code-vb[Classic WebData DataSet.CaseSensitive Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.ca_1.vb)]"
  syntax:
    content: public bool CaseSensitive { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>문자열 비교는 대/소문자 구분; 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataSet.CaseSensitive*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Clear
  id: Clear
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Clear()
  nameWithType: DataSet.Clear()
  fullName: System.Data.DataSet.Clear()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "지웁니다는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 모든 테이블의 모든 행을 제거 하 여 데이터의 합니다."
  remarks: "경우 <xref:System.Data.DataSet>에 <xref:System.Xml.XmlDataDocument>, 지우기 또는 <xref:System.Data.DataTable.Clear%2A?displayProperty=fullName> <xref:System.NotSupportedException>.</xref:System.NotSupportedException> 발생</xref:System.Data.DataTable.Clear%2A?displayProperty=fullName> 호출</xref:System.Xml.XmlDataDocument> 바인딩되어</xref:System.Data.DataSet> 이러한 상황을 방지 하려면 한 번에 하나씩 행을 제거, 각 테이블을 이동 합니다."
  example:
  - "The following example clears the <xref:System.Data.DataSet> of all rows in all tables.  \n  \n [!code-vb[Classic WebData DataSet.Clear Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.cl_1_1.vb)]\n [!code-cs[Classic WebData DataSet.Clear Example#1](~/add/codesnippet/csharp/m-system.data.dataset.cl_1_1.cs)]"
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.Data.DataSet.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Clone
  id: Clone
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Clone()
  nameWithType: DataSet.Clone()
  fullName: System.Data.DataSet.Clone()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "구조를 복사는 <xref href=&quot;System.Data.DataSet&quot;> </xref>, 모든 포함 하 여 <xref href=&quot;System.Data.DataTable&quot;> </xref> 스키마, 관계 및 제약 조건입니다. 모든 데이터를 복사 하지 않습니다."
  remarks: >-
    > [!NOTE]

    >  If these classes have been subclassed, the clone will also be of the same subclasses.
  example:
  - "The following example creates a clone of a <xref:System.Data.DataSet> object's schema.  \n  \n [!code-cs[Classic WebData DataSet.Clone Example#1](~/add/codesnippet/csharp/m-system.data.dataset.cl_0_1.cs)]\n [!code-vb[Classic WebData DataSet.Clone Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.cl_0_1.vb)]"
  syntax:
    content: public virtual System.Data.DataSet Clone ();
    parameters: []
    return:
      type: System.Data.DataSet
      description: "새 <xref href=&quot;System.Data.DataSet&quot;> </xref> 현재 스키마 같은 <xref href=&quot;System.Data.DataSet&quot;> </xref>, 되지만 데이터입니다."
  overload: System.Data.DataSet.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Copy
  id: Copy
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Copy()
  nameWithType: DataSet.Copy()
  fullName: System.Data.DataSet.Copy()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 구조와 데이터를 모두 복사 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  remarks: ''
  example:
  - "The following example uses the Copy method to create a copy of the original <xref:System.Data.DataSet>.  \n  \n [!code-cs[Classic WebData DataSet.Copy Example#1](~/add/codesnippet/csharp/m-system.data.dataset.copy_1.cs)]\n [!code-vb[Classic WebData DataSet.Copy Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.copy_1.vb)]"
  syntax:
    content: public System.Data.DataSet Copy ();
    parameters: []
    return:
      type: System.Data.DataSet
      description: "새 <xref href=&quot;System.Data.DataSet&quot;> </xref> 구조 (테이블 스키마, 관계 및 제약 조건) 및 데이터 이와 동일한 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다.       <div class=&quot;alert NOTE&quot;>    이러한 클래스 서브클래싱된 복사본 서브 클래스 수도 있습니다.      </div>"
  overload: System.Data.DataSet.Copy*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.CreateDataReader
  id: CreateDataReader
  parent: System.Data.DataSet
  langs:
  - csharp
  name: CreateDataReader()
  nameWithType: DataSet.CreateDataReader()
  fullName: System.Data.DataSet.CreateDataReader()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "반환 된 <xref href=&quot;System.Data.DataTableReader&quot;> </xref> 결과 집합이 당 하나씩 있는 <xref href=&quot;System.Data.DataTable&quot;> </xref>에 순서에 테이블이 나타나는 대로 <xref:System.Data.DataSet.Tables*>컬렉션.</xref:System.Data.DataSet.Tables*>"
  remarks: "반환 된 결과 집합의 순서를 보장 하기 위해 <xref:System.Data.DataTableReader>경우는 <xref:System.Data.DataTable>내에서 <xref:System.Data.DataSet>는 빈 결과 반환 된 집합으로 표현 비어 됩니다 `DataTableReader`.</xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.DataTableReader>"
  example:
  - "The following example creates three <xref:System.Data.DataTable> instances, and adds each to a <xref:System.Data.DataSet>. The example then passes the filled `DataSet` to a procedure that calls the CreateDataReader method, and proceeds to iterate through all the result sets contained within the <xref:System.Data.DataTableReader>. The example displays the results in the Console window.  \n  \n [!code-vb[DataWorks DataSet.DataTableReader#1](~/add/codesnippet/visualbasic/m-system.data.dataset.cr_0_1.vb)]\n [!code-cs[DataWorks DataSet.DataTableReader#1](~/add/codesnippet/csharp/m-system.data.dataset.cr_0_1.cs)]"
  syntax:
    content: public System.Data.DataTableReader CreateDataReader ();
    parameters: []
    return:
      type: System.Data.DataTableReader
      description: "A <xref href=&quot;System.Data.DataTableReader&quot;> </xref> 에 해당 하 하나 이상의 결과 집합을 포함 하는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 원본 내에 포함 된 인스턴스 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  overload: System.Data.DataSet.CreateDataReader*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.CreateDataReader(System.Data.DataTable[])
  id: CreateDataReader(System.Data.DataTable[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: CreateDataReader(DataTable[])
  nameWithType: DataSet.CreateDataReader(DataTable[])
  fullName: System.Data.DataSet.CreateDataReader(DataTable[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "반환 된 <xref href=&quot;System.Data.DataTableReader&quot;> </xref> 결과 집합이 당 하나씩 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  remarks: "반환 된 결과의 순서를 설정 한다는 보장 하기 위해 <xref:System.Data.DataTableReader>경우는 <xref:System.Data.DataTable>내에서 <xref:System.Data.DataSet>는 빈 결과 반환 된 집합으로 표현 비어 됩니다 `DataTableReader`.</xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.DataTableReader> 이 오버 로드 된 버전의 목록을 제공할 수 있으므로 `DataTable` 인스턴스 매개 변수로 반환 된 결과 집합을 나타나는 순서를 지정할 수 있습니다 `DataTableReader`합니다."
  example:
  - "This example, a Console application, creates three <xref:System.Data.DataTable> instances and adds each to a <xref:System.Data.DataSet>. The example calls the CreateDataReader method and displays the contents of the returned <xref:System.Data.DataTableReader>. Note that the order of the result sets in the `DataTableReader` is controlled by the order of the `DataTable` instances passed as parameters. The example displays the results in the Console window.  \n  \n [!code-vb[DataWorks DataSet.DataTableReaderTables#1](~/add/codesnippet/visualbasic/m-system.data.dataset.cr_1_1.vb)]\n [!code-cs[DataWorks DataSet.DataTableReaderTables#1](~/add/codesnippet/csharp/m-system.data.dataset.cr_1_1.cs)]"
  syntax:
    content: public System.Data.DataTableReader CreateDataReader (System.Data.DataTable[] dataTables);
    parameters:
    - id: dataTables
      type: System.Data.DataTable[]
      description: "에 반환 될 결과의 순서를 제공 하는 Datatable의 배열을 설정는 <xref href=&quot;System.Data.DataTableReader&quot;> </xref>합니다."
    return:
      type: System.Data.DataTableReader
      description: "A <xref href=&quot;System.Data.DataTableReader&quot;> </xref> 에 해당 하 하나 이상의 결과 집합을 포함 하는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 원본 내에 포함 된 인스턴스 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다. 반환 된 결과 집합은 지정 된 순서에는 <code> dataTables </code> 매개 변수입니다."
  overload: System.Data.DataSet.CreateDataReader*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.DataSetName
  id: DataSetName
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DataSetName
  nameWithType: DataSet.DataSetName
  fullName: System.Data.DataSet.DataSetName
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재의 이름을 가져오거나 설정 합니다. <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  remarks: ''
  example:
  - "The following example creates a new <xref:System.Data.DataSet> with the given DataSetName.  \n  \n [!code-vb[Classic WebData DataSet.DataSetName Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.da_1.vb)]\n [!code-cs[Classic WebData DataSet.DataSetName Example#1](~/add/codesnippet/csharp/p-system.data.dataset.da_1.cs)]"
  syntax:
    content: public string DataSetName { get; set; }
    return:
      type: System.String
      description: "이름에서 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  overload: System.Data.DataSet.DataSetName*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.DefaultViewManager
  id: DefaultViewManager
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DefaultViewManager
  nameWithType: DataSet.DefaultViewManager
  fullName: System.Data.DataSet.DefaultViewManager
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "사용자 지정 보기에 포함 된 데이터를 가져옵니다는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 필터링, 검색 및 사용자 지정을 사용 하 여 탐색을 허용 하도록 <xref href=&quot;System.Data.DataViewManager&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataViewManager>속성을 사용 하면 각 <xref:System.Data.DataTable> <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataTable> 에 대 한 사용자 지정 설정을 만들려면 DefaultViewManager 반환한</xref:System.Data.DataViewManager>       가져올 때 한 <xref:System.Data.DataView>에서 <xref:System.Data.DataTable>, 필터링, 정렬 순서 및 <xref:System.Data.DataViewRowState>DefaultViewManager 속성의 설정에 따라 구성 됩니다.</xref:System.Data.DataViewRowState> </xref:System.Data.DataTable> </xref:System.Data.DataView>"
  example:
  - "The following example gets the default <xref:System.Data.DataViewManager> for a <xref:System.Data.DataSet>, and adds a <xref:System.Data.DataTable> to the <xref:System.Data.DataTableCollection>.  \n  \n [!code-vb[Classic WebData DataSet.DefaultViewManager Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.de_1.vb)]"
  syntax:
    content: public System.Data.DataViewManager DefaultViewManager { get; }
    return:
      type: System.Data.DataViewManager
      description: "A <xref href=&quot;System.Data.DataViewManager&quot;></xref> object."
  overload: System.Data.DataSet.DefaultViewManager*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)
  id: DetermineSchemaSerializationMode(System.Xml.XmlReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DetermineSchemaSerializationMode(XmlReader)
  nameWithType: DataSet.DetermineSchemaSerializationMode(XmlReader)
  fullName: System.Data.DataSet.DetermineSchemaSerializationMode(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "결정는 <xref:System.Data.DataSet.SchemaSerializationMode*>에 대 한는 <xref href=&quot;System.Data.DataSet&quot;> </xref>.</xref:System.Data.DataSet.SchemaSerializationMode*>"
  remarks: "이 메서드는 형식화 된 <xref:System.Data.DataSet>해당 <xref:System.Data.DataSet.SchemaSerializationMode%2A>.</xref:System.Data.DataSet.SchemaSerializationMode%2A> 확인 하려면</xref:System.Data.DataSet> 를 역직렬화 할 때"
  syntax:
    content: protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>역직렬화 하는 동안 전달 되는 인스턴스는 <xref href=&quot;System.Data.DataSet&quot;> </xref>.</xref:System.Xml.XmlReader>"
    return:
      type: System.Data.SchemaSerializationMode
      description: "<xref href=&quot;System.Data.SchemaSerializationMode&quot;> </xref> 스키마 정보 페이로드에서 생략 되었는지 여부를 나타내는 열거형입니다."
  overload: System.Data.DataSet.DetermineSchemaSerializationMode*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
  nameWithType: DataSet.DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "결정는 <xref:System.Data.DataSet.SchemaSerializationMode*>에 대 한는 <xref href=&quot;System.Data.DataSet&quot;> </xref>.</xref:System.Data.DataSet.SchemaSerializationMode*>"
  remarks: "이 메서드는 형식화 된 <xref:System.Data.DataSet>해당 <xref:System.Data.DataSet.SchemaSerializationMode%2A>.</xref:System.Data.DataSet.SchemaSerializationMode%2A> 확인 하려면</xref:System.Data.DataSet> 를 역직렬화 할 때"
  syntax:
    content: protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> 하는 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>보호 된 생성자의 &lt;xref:System.Data.DataSet.%23ctor%2A&gt; 원격 시나리오에서 역직렬화 하는 동안 사용 하 여 호출 합니다."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "<xref:System.Runtime.Serialization.StreamingContext>하는 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>보호 된 생성자의 &lt;xref:System.Data.DataSet.%23ctor%2A&gt; 와 함께 원격 시나리오에서 역직렬화 하는 동안 호출 됩니다.</xref:System.Runtime.Serialization.StreamingContext>"
    return:
      type: System.Data.SchemaSerializationMode
      description: "<xref href=&quot;System.Data.SchemaSerializationMode&quot;> </xref> 스키마 정보 페이로드에서 생략 되었는지 여부를 나타내는 열거형입니다."
  overload: System.Data.DataSet.DetermineSchemaSerializationMode*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.EndInit
  id: EndInit
  parent: System.Data.DataSet
  langs:
  - csharp
  name: EndInit()
  nameWithType: DataSet.EndInit()
  fullName: System.Data.DataSet.EndInit()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "초기화를 종료 한 <xref href=&quot;System.Data.DataSet&quot;> </xref> 폼에 사용 되거나 다른 구성 요소에서 사용 하 합니다. 초기화는 런타임에 발생 합니다."
  remarks: "Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소 초기화를 끝냅니다. <xref:System.Data.DataSet.BeginInit%2A>메서드 초기화를 시작 합니다.</xref:System.Data.DataSet.BeginInit%2A> 사용 하 여 <xref:System.Data.DataSet.BeginInit%2A>하 고 컨트롤을 완전히 초기화 되기 전에 사용 되지 않도록 하 EndInit 메서드.</xref:System.Data.DataSet.BeginInit%2A>"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Data.DataSet.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.EnforceConstraints
  id: EnforceConstraints
  parent: System.Data.DataSet
  langs:
  - csharp
  name: EnforceConstraints
  nameWithType: DataSet.EnforceConstraints
  fullName: System.Data.DataSet.EnforceConstraints
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "업데이트 작업을 수행할 때 제약 조건 규칙을 따르는지 여부를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "제약 조건에 설정 되 고 <xref:System.Data.DataTable>수준 (<xref:System.Data.DataTable.Constraints%2A> 속성).</xref:System.Data.DataTable.Constraints%2A> </xref:System.Data.DataTable> 제약 조건을 만드는 방법에 대 한 자세한 내용은 참조 [DataTable 제약 조건](~/add/includes/ajax-current-ext-md.md)합니다."
  example:
  - "The following example creates a <xref:System.Data.DataSet> with one table, one column, five rows, and one <xref:System.Data.UniqueConstraint>. The EnforceConstraints property is set to `false` and the values of each row are set to the same value. When the EnforceConstraints property is reset to `true`, a <xref:System.Data.ConstraintException> is generated.  \n  \n [!code-cs[Classic WebData DataSet.EnforceConstraints Example#1](~/add/codesnippet/csharp/p-system.data.dataset.en_1.cs)]\n [!code-vb[Classic WebData DataSet.EnforceConstraints Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.en_1.vb)]"
  syntax:
    content: public bool EnforceConstraints { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>규칙이; 적용 하는 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataSet.EnforceConstraints*
  exceptions:
  - type: System.Data.ConstraintException
    commentId: T:System.Data.ConstraintException
    description: "하나 이상의 제약 조건은 적용할 수 없습니다."
  platform:
  - net462
- uid: System.Data.DataSet.ExtendedProperties
  id: ExtendedProperties
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ExtendedProperties
  nameWithType: DataSet.ExtendedProperties
  fullName: System.Data.DataSet.ExtendedProperties
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "연결 된 사용자 지정 된 사용자 정보 컬렉션을 가져옵니다는 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "ExtendedProperties 속성을 사용 하 여 사용자 지정 정보를 저장할 수는 `DataSet`합니다. 예를 들어 데이터를 새로 고쳐야 할 시간을 저장할 수 있습니다.       확장된 속성 형식 이어야 합니다 <xref:System.String>파일과 유지는 <xref:System.Data.DataSet>XML로 기록 됩니다.</xref:System.Data.DataSet> </xref:System.String>"
  example:
  - "The following example adds a custom property to the <xref:System.Data.PropertyCollection> returned by the <xref:System.Data.DataColumn.ExtendedProperties%2A> property. The second example retrieves the custom property.  \n  \n [!code-cs[Classic WebData DataColumn.ExtendedProperties Example#1](~/add/codesnippet/csharp/p-system.data.dataset.ex_1.cs)]\n [!code-vb[Classic WebData DataColumn.ExtendedProperties Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.ex_1.vb)]"
  syntax:
    content: public System.Data.PropertyCollection ExtendedProperties { get; }
    return:
      type: System.Data.PropertyCollection
      description: "A <xref href=&quot;System.Data.PropertyCollection&quot;> </xref> 모든 사용자 지정 사용자 정보로 합니다."
  overload: System.Data.DataSet.ExtendedProperties*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetChanges
  id: GetChanges
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetChanges()
  nameWithType: DataSet.GetChanges()
  fullName: System.Data.DataSet.GetChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "복사본을 가져옵니다는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 내용을 로드 된 이후 또는 이후 모든 변경 내용이 들어 있는 <xref:System.Data.DataSet.AcceptChanges*>마지막으로 호출한.</xref:System.Data.DataSet.AcceptChanges*>"
  remarks: "원본 또는 <xref:System.Data.DataSet>원래에 모든 행의 복사본이 포함 된 <xref:System.Data.DataSet>보류 중인 변경 내용이 있는.</xref:System.Data.DataSet> </xref:System.Data.DataSet> 관계 제약 조건으로 인해 새에 추가할 추가 변경 되지 않은 행 <xref:System.Data.DataSet>변경 되지 않은 행에는 변경 된 행에서 외래 키에 해당 하는 기본 키를 포함 하는 경우.</xref:System.Data.DataSet> 메서드가 반환 `null` 원래에서 행이 없는 경우 <xref:System.Data.DataSet>보류 중인 변경 내용이 있는.</xref:System.Data.DataSet>"
  example:
  - "The following example creates a simple <xref:System.Data.DataSet> with one table, two columns, and ten rows. Two values are changed, and one row is added. A subset of the changed data is created using the GetChanges method. After reconciling errors, a new column is added to the subset, changing the schema. When the <xref:System.Data.DataSet.Merge%2A> method is called with the `missingSchemaAction` set to `MissingSchemaAction.Add`, the new column is added to the original <xref:System.Data.DataSet> object's schema.  \n  \n [!code-cs[Classic WebData DataSet.GetChanges Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ge_0_1.cs)]\n [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ge_0_1.vb)]"
  syntax:
    content: public System.Data.DataSet GetChanges ();
    parameters: []
    return:
      type: System.Data.DataSet
      description: "이 변경의 복사본 <xref href=&quot;System.Data.DataSet&quot;> </xref> <xref:System.Data.DataSet.Merge*>.</xref:System.Data.DataSet.Merge*> 를 사용 하 여에 다시 병합 될 작업을 수행할 수 있는 메서드가 반환 하는 경우 변경 된 행이 발견 되 면 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataSet.GetChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetChanges(System.Data.DataRowState)
  id: GetChanges(System.Data.DataRowState)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetChanges(DataRowState)
  nameWithType: DataSet.GetChanges(DataRowState)
  fullName: System.Data.DataSet.GetChanges(DataRowState)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "복사본을 가져옵니다는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 내용을 마지막 로드 된 이후 또는 이후 모든 변경 내용이 포함 된 <xref:System.Data.DataSet.AcceptChanges*>호출을 기준으로 필터링 <xref href=&quot;System.Data.DataRowState&quot;> </xref>.</xref:System.Data.DataSet.AcceptChanges*>"
  remarks: "<xref:System.Data.DataSet.GetChanges%2A>초를 생성 하기 위해 메서드를 사용 하는 <xref:System.Data.DataSet>원래에 도입 된 변경 내용만 포함 하는 개체입니다.</xref:System.Data.DataSet> </xref:System.Data.DataSet.GetChanges%2A> 사용 하 여는 `rowStates` 인수를 새 개체에 포함 될 변경 유형을 지정 합니다.       이 반환 된 복사본을이에 다시 병합 될 하도록 되어 원래 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 관계 제약 조건으로 표시 된 부모 행 않을 `Unchanged` 포함 되도록 합니다. 원하는 행이 없으면 <xref:System.Data.DataRowState>발견 되는 <xref:System.Data.DataSet.GetChanges%2A>메서드 반환 `null`.</xref:System.Data.DataSet.GetChanges%2A> </xref:System.Data.DataRowState>"
  example:
  - "The following example uses the <xref:System.Data.DataSet.GetChanges%2A> method to create a second <xref:System.Data.DataSet> object, which is then used to update a data source.  \n  \n [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ge_2_1.vb)]\n [!code-cs[Classic WebData DataSet.GetChanges1 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ge_2_1.cs)]"
  syntax:
    content: public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);
    parameters:
    - id: rowStates
      type: System.Data.DataRowState
      description: "중 하나는 <xref href=&quot;System.Data.DataRowState&quot;> </xref> 값입니다."
    return:
      type: System.Data.DataSet
      description: "필터링 된 복사본은 <xref href=&quot;System.Data.DataSet&quot;> </xref> <xref:System.Data.DataSet.Merge*>.</xref:System.Data.DataSet.Merge*> 를 사용 하 여에 다시 병합 될을 이후에 수행 된 작업에 있는 원하는 행이 없으면 <xref href=&quot;System.Data.DataRowState&quot;> </xref> 발견 되 면 메서드가 반환 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataSet.GetChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)
  id: GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetDataSetSchema(XmlSchemaSet)
  nameWithType: DataSet.GetDataSetSchema(XmlSchemaSet)
  fullName: System.Data.DataSet.GetDataSetSchema(XmlSchemaSet)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "복사본을 가져옵니다 <xref href=&quot;System.Xml.Schema.XmlSchemaSet&quot;> </xref> 데이터 집합에 대 한 합니다."
  syntax:
    content: public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);
    parameters:
    - id: schemaSet
      type: System.Xml.Schema.XmlSchemaSet
      description: "지정 된 스키마 집합입니다."
    return:
      type: System.Xml.Schema.XmlSchemaComplexType
      description: "A copy of <xref href=&quot;System.Xml.Schema.XmlSchemaSet&quot;></xref>."
  overload: System.Data.DataSet.GetDataSetSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: DataSet.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.GetObjectData(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Serialization 정보 개체를 serialize 하는 데 필요한 데이터로 채우는 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  syntax:
    content: public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "A <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> 와 관련 된 serialize 된 데이터를 보유 하는 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "A <xref:System.Runtime.Serialization.StreamingContext>와 관련 된 serialize 된 스트림의 대상이 및 원본을 포함 하는 <xref href=&quot;System.Data.DataSet&quot;> </xref>.</xref:System.Runtime.Serialization.StreamingContext>"
  overload: System.Data.DataSet.GetObjectData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>info</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Data.DataSet.GetSchemaSerializable
  id: GetSchemaSerializable
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetSchemaSerializable()
  nameWithType: DataSet.GetSchemaSerializable()
  fullName: System.Data.DataSet.GetSchemaSerializable()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "반환 된 직렬화 가능 <xref:System.Xml.Schema.XMLSchema>인스턴스.</xref:System.Xml.Schema.XMLSchema>"
  syntax:
    content: protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();
    parameters: []
    return:
      type: System.Xml.Schema.XmlSchema
      description: "<xref:System.Xml.Schema.XMLSchema>인스턴스.</xref:System.Xml.Schema.XMLSchema>"
  overload: System.Data.DataSet.GetSchemaSerializable*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetSerializationData(SerializationInfo,StreamingContext)
  nameWithType: DataSet.GetSerializationData(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.GetSerializationData(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이진 또는 XML 스트림에서 테이블 데이터를 역직렬화합니다."
  syntax:
    content: protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> 인스턴스."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "스트리밍 컨텍스트입니다."
  overload: System.Data.DataSet.GetSerializationData*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetXml
  id: GetXml
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetXml()
  nameWithType: DataSet.GetXml()
  fullName: System.Data.DataSet.GetXml()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 저장 된 데이터의 XML 표현을 반환는 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  remarks: "이 메서드를 호출 하는 호출 <xref:System.Data.DataSet.WriteXml%2A> <xref:System.Data.XmlWriteMode> <xref:System.Data.XmlWriteMode>.</xref:System.Data.XmlWriteMode> </xref:System.Data.XmlWriteMode> 와</xref:System.Data.DataSet.WriteXml%2A> 동일       GetXml XML는 문자열을 반환 하므로 보다 더 많은 오버 헤드가 <xref:System.Data.DataSet.WriteXml%2A>XML 파일에 쓸 수 있습니다.</xref:System.Data.DataSet.WriteXml%2A>       작성 하는 경우는 <xref:System.Data.DataSet>스키마 유추를 사용 하 고 serialize XML 또는 웹 서비스를 사용 하 고, 열 순서 변경 될 수 있습니다.</xref:System.Data.DataSet>"
  example:
  - "The following example creates a <xref:System.Data.DataSet> and <xref:System.Data.DataTable>, adds sample data, and then displays the data in XML format.  \n  \n [!code-cs[Classic WebData DataSet.GetXml Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ge_1_1.cs)]\n [!code-vb[Classic WebData DataSet.GetXml Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ge_1_1.vb)]  \n  \n This sample demonstrates how to write data into an XML file from a DataSet and read data into DataSet from XML. This sample will create one dataset with two tables, use two ways to export a dataset into the XML files (WriteXml and GetXml), and use two ways (ReadXml and InferXmlSchema) to import a dataset from the XML files.  \n  \n Before you compile and run the sample, you need to create four XML files in the sample directory. First, create ElementsWithAttributes.xml:  \n  \n```  \n<MySchool>  \n  <Course CourseID=\"C1045\" Year=\"2012\"  Title=\"Calculus\" Credits=\"4\" DepartmentID=\"7\">New</Course>  \n  <Course CourseID=\"C1061\" Year=\"2012\"  Title=\"Physics\" Credits=\"4\" DepartmentID=\"1\" />  \n  <Department DepartmentID=\"1\" Name=\"Engineering\" Budget=\"350000\" StartDate=\"2007-09-01T00:00:00+08:00\" Administrator=\"2\" />  \n  <Department DepartmentID=\"7\" Name=\"Mathematics\" Budget=\"250024\" StartDate=\"2007-09-01T00:00:00+08:00\" Administrator=\"3\">Cancelled</Department>  \n</MySchool>  \n```  \n  \n Next, create ElementsWithChildElementsxml.xml:  \n  \n```  \n<MySchool>  \n  <Course>  \n    <CourseID>C1045</CourseID>  \n    <Year>2012</Year>  \n    <Title>Calculus</Title>  \n    <Credits>4</Credits>  \n    <DepartmentID>7</DepartmentID>  \n  </Course>  \n  <Course>  \n    <CourseID>C1061</CourseID>  \n    <Year>2012</Year>  \n    <Title>Physics</Title>  \n    <Credits>4</Credits>  \n    <DepartmentID>1</DepartmentID>  \n  </Course>  \n  <Course>  \n    <CourseID>C2021</CourseID>  \n    <Year>2012</Year>  \n    <Title>Composition</Title>  \n    <Credits>3</Credits>  \n    <DepartmentID>2</DepartmentID>  \n  </Course>  \n  <Course>  \n    <CourseID>C2042</CourseID>  \n    <Year>2012</Year>  \n    <Title>Literature</Title>  \n    <Credits>4</Credits>  \n    <DepartmentID>2</DepartmentID>  \n  </Course>  \n  <Department>  \n    <DepartmentID>1</DepartmentID>  \n    <Name>Engineering</Name>  \n    <Budget>350000</Budget>  \n    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  \n    <Administrator>2</Administrator>  \n  </Department>  \n  <Department>  \n    <DepartmentID>2</DepartmentID>  \n    <Name>English</Name>  \n    <Budget>120000</Budget>  \n    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  \n    <Administrator>6</Administrator>  \n  </Department>  \n  <Department>  \n    <DepartmentID>4</DepartmentID>  \n    <Name>Economics</Name>  \n    <Budget>200000</Budget>  \n    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  \n    <Administrator>4</Administrator>  \n  </Department>  \n  <Department>  \n    <DepartmentID>7</DepartmentID>  \n    <Name>Mathematics</Name>  \n    <Budget>250024</Budget>  \n    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  \n    <Administrator>3</Administrator>  \n  </Department>  \n</MySchool>  \n```  \n  \n Now create ElementsWithOnlyAttributes.xml:  \n  \n```  \n<MySchool>  \n  <Course CourseID=\"C1045\" Year=\"2012\"  Title=\"Calculus\" Credits=\"4\" DepartmentID=\"7\" />  \n  <Course CourseID=\"C1061\" Year=\"2012\"  Title=\"Physics\" Credits=\"4\" DepartmentID=\"1\" />  \n  <Department DepartmentID=\"1\" Name=\"Engineering\" Budget=\"350000\" StartDate=\"2007-09-01T00:00:00+08:00\" Administrator=\"2\" />  \n  <Department DepartmentID=\"7\" Name=\"Mathematics\" Budget=\"250024\" StartDate=\"2007-09-01T00:00:00+08:00\" Administrator=\"3\" />  \n</MySchool>  \n```  \n  \n And finally, create RepeatingElements.xml:  \n  \n```  \n<MySchool>  \n  <Course>C1045</Course>  \n  <Course>C1061</Course>  \n  <Department>Engineering</Department>   \n  <Department>Mathematics</Department>  \n</MySchool>  \n```  \n  \n Now you can compile and run the following source code.  [How to Store Data of DataSet into XML File](http://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3) has Visual Basic and C# projects for this sample.  \n  \n```  \nusing System;  \nusing System.Data;  \nusing System.IO;  \nusing System.Text;  \nusing System.Xml;  \n  \n// Use WriteXml method to export the dataset.  \nstatic class DataTableHelper {  \n   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  \n      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  \n         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  \n            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  \n            Console.WriteLine(\"Write {0} to the File {1}.\", dataset.DataSetName, xmlFileName);  \n            Console.WriteLine();  \n         }  \n      }  \n   }  \n  \n   // Use GetXml method to get the XML data of the dataset and then export to the file.  \n   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  \n      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  \n         writer.WriteLine(dataset.GetXml());  \n         Console.WriteLine(\"Get Xml data from {0} and write to the File {1}.\", dataset.DataSetName, xmlFileName);  \n         Console.WriteLine();  \n      }  \n   }  \n  \n   // Use ReadXml method to import the dataset from the dataset.  \n   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  \n      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  \n         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  \n            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  \n         }  \n      }  \n   }  \n  \n   // Display the columns and value of DataSet.  \n   public static void ShowDataSet(DataSet dataset) {  \n      foreach (DataTable table in dataset.Tables) {  \n         Console.WriteLine(\"Table {0}:\", table.TableName);  \n         ShowDataTable(table);  \n      }  \n   }  \n  \n   // Display the columns and value of DataTable.  \n   private static void ShowDataTable(DataTable table) {  \n      foreach (DataColumn col in table.Columns) {  \n         Console.Write(\"{0,-14}\", col.ColumnName);  \n      }  \n      Console.WriteLine(\"{0,-14}\", \"\");  \n  \n      foreach (DataRow row in table.Rows) {  \n         if (row.RowState == DataRowState.Deleted) {  \n            foreach (DataColumn col in table.Columns) {  \n               if (col.DataType.Equals(typeof(DateTime))) {  \n                  Console.Write(\"{0,-14:d}\", row[col, DataRowVersion.Original]);  \n               }  \n               else if (col.DataType.Equals(typeof(Decimal))) {  \n                  Console.Write(\"{0,-14:C}\", row[col, DataRowVersion.Original]);  \n               }  \n               else {  \n                  Console.Write(\"{0,-14}\", row[col, DataRowVersion.Original]);  \n               }  \n            }  \n         }  \n         else {  \n            foreach (DataColumn col in table.Columns) {  \n               if (col.DataType.Equals(typeof(DateTime))) {  \n                  Console.Write(\"{0,-14:d}\", row[col]);  \n               }  \n               else if (col.DataType.Equals(typeof(Decimal))) {  \n                  Console.Write(\"{0,-14:C}\", row[col]);  \n               }  \n               else {  \n                  Console.Write(\"{0,-14}\", row[col]);  \n               }  \n            }  \n         }  \n         Console.WriteLine(\"{0,-14}\", \"\");  \n      }  \n   }  \n  \n   // Display the columns of DataSet.  \n   public static void ShowDataSetSchema(DataSet dataSet) {  \n      Console.WriteLine(\"{0} contains the following tables:\", dataSet.DataSetName);  \n      foreach (DataTable table in dataSet.Tables) {  \n         Console.WriteLine(\"   Table {0} contains the following columns:\", table.TableName);  \n         ShowDataTableSchema(table);  \n      }  \n   }  \n  \n   // Display the columns of DataTable  \n   private static void ShowDataTableSchema(DataTable table) {  \n      String columnString = \"\";  \n      foreach (DataColumn col in table.Columns) {  \n         columnString += col.ColumnName + \"   \";  \n      }  \n      Console.WriteLine(columnString);  \n   }  \n}  \n  \nclass Program {  \n   static void Main(string[] args) {  \n      // Create the DataSet  \n      DataSet school = new DataSet(\"MySchool\");  \n      DataTable course = CreateCourse();  \n      DataTable department = CreateDepartment();  \n      school.Tables.Add(course);  \n      school.Tables.Add(department);  \n  \n      // Define the constraint between the tables.  \n      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint(\"CourseDepartFK\", department.Columns[\"DepartmentID\"], course.Columns[\"DepartmentID\"]);  \n      courseDepartFK.DeleteRule = Rule.Cascade;  \n      courseDepartFK.UpdateRule = Rule.Cascade;  \n      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  \n      course.Constraints.Add(courseDepartFK);  \n  \n      InsertDepartments(department);  \n      InsertCourses(course);  \n  \n      // Export the dataset to the XML file.  \n      Console.WriteLine(\"Data of the whole DataSet {0}\", school.DataSetName);  \n      DataTableHelper.ShowDataSet(school);  \n  \n      String xmlWithSchemaFileName = \"WriterXMLWithSchema.xml\";  \n      String xmlGetDataFileName = \"GetXML.xml\";  \n  \n      // Use two ways to export the dataset to the Xml file.  \n      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  \n      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  \n  \n      // Import the dataset from the XML file.  \n      // Use two ways to import the dataset from the Xml file.  \n      Console.WriteLine(\"Read Xml document into a new DataSet:\");  \n      DataSet newSchool = new DataSet(\"NewSchool\");  \n      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  \n      DataTableHelper.ShowDataSetSchema(newSchool);  \n      Console.WriteLine();  \n  \n      Console.WriteLine(\"Infer a schema for a DataSet from an XML document:\");  \n      InferDataSetSchemaFromXml();  \n  \n      Console.WriteLine(\"Press any key to exit.\");  \n      Console.ReadKey();  \n   }  \n  \n   static DataTable CreateCourse() {  \n      DataTable course = new DataTable(\"Course\");  \n      DataColumn[] cols ={  \n                              new DataColumn(\"CourseID\",typeof(String)),  \n                              new DataColumn(\"Year\",typeof(Int32)),  \n                              new DataColumn(\"Title\",typeof(String)),  \n                              new DataColumn(\"Credits\",typeof(Int32)),  \n                              new DataColumn(\"DepartmentID\",typeof(Int32))};  \n      course.Columns.AddRange(cols);  \n  \n      course.PrimaryKey = new DataColumn[] { course.Columns[\"CourseID\"], course.Columns[\"Year\"] };  \n  \n      return course;  \n   }  \n  \n   static DataTable CreateDepartment() {  \n      DataTable department = new DataTable(\"Department\");  \n      DataColumn[] cols = {   \n                                new DataColumn(\"DepartmentID\", typeof(Int32)),  \n                                new DataColumn(\"Name\",typeof(String)),  \n                                new DataColumn(\"Budget\",typeof(Decimal)),  \n                                new DataColumn(\"StartDate\",typeof(DateTime)),  \n                                new DataColumn(\"Administrator\",typeof(Int32))};  \n      department.Columns.AddRange(cols);  \n  \n      department.PrimaryKey = new DataColumn[] { department.Columns[\"DepartmentID\"] };  \n  \n      return department;  \n   }  \n  \n   static void InsertDepartments(DataTable department) {  \n      Object[] rows = {   \n                            new Object[]{1,\"Engineering\",350000.00,new DateTime(2007,9,1),2},  \n                            new Object[]{2,\"English\",120000.00,new DateTime(2007,9,1),6},  \n                            new Object[]{4,\"Economics\",200000.00,new DateTime(2007,9,1),4},  \n                            new Object[]{7,\"Mathematics\",250024.00,new DateTime(2007,9,1),3}};  \n  \n      foreach (Object[] row in rows) {  \n         department.Rows.Add(row);  \n      }  \n   }  \n  \n   static void InsertCourses(DataTable course) {  \n      Object[] rows ={  \n                               new Object[]{\"C1045\",2012,\"Calculus\",4,7},  \n                               new Object[]{\"C1061\",2012,\"Physics\",4,1},  \n                               new Object[]{\"C2021\",2012,\"Composition\",3,2},  \n                               new Object[]{\"C2042\",2012,\"Literature\",4,2}};  \n  \n      foreach (Object[] row in rows) {  \n         course.Rows.Add(row);  \n      }  \n   }  \n  \n   // Display the results of inferring schema from four types of XML structures  \n   private static void InferDataSetSchemaFromXml() {  \n      String[] xmlFileNames = {   \n  \n                                    @\"ElementsWithOnlyAttributes.xml\",   \n                                    @\"ElementsWithAttributes.xml\",  \n                                    @\"RepeatingElements.xml\",   \n                                    @\"ElementsWithChildElements.xml\" };  \n  \n      foreach (String xmlFileName in xmlFileNames) {  \n         Console.WriteLine(\"Result of {0}\", Path.GetFileNameWithoutExtension(xmlFileName));  \n         DataSet newSchool = new DataSet();  \n         newSchool.InferXmlSchema(xmlFileName, null);  \n         DataTableHelper.ShowDataSetSchema(newSchool);  \n         Console.WriteLine();  \n      }  \n   }  \n}  \n```"
  syntax:
    content: public string GetXml ();
    parameters: []
    return:
      type: System.String
      description: "에 저장 된 데이터의 표현 되는 문자열은 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  overload: System.Data.DataSet.GetXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetXmlSchema
  id: GetXmlSchema
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetXmlSchema()
  nameWithType: DataSet.GetXmlSchema()
  fullName: System.Data.DataSet.GetXmlSchema()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 저장 된 데이터의 XML 표현에 대 한 XML 스키마를 반환 된 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  remarks: "이 메서드를 호출 하는 것은 호출 동일 <xref:System.Data.DataSet.WriteXmlSchema%2A>한다는 점을 제외 하는 기본 스키마만 기록 됩니다.</xref:System.Data.DataSet.WriteXmlSchema%2A>       GetXmlSchema XML는 문자열을 반환 하므로 보다 더 많은 오버 헤드가 <xref:System.Data.DataSet.WriteXmlSchema%2A>XML 파일에 쓸 수 있습니다.</xref:System.Data.DataSet.WriteXmlSchema%2A>       작성 하는 경우는 <xref:System.Data.DataSet>스키마 유추를 사용 하 고 serialize XML 또는 웹 서비스를 사용 하 고, 열 순서 변경 될 수 있습니다.</xref:System.Data.DataSet>"
  example:
  - "The following example creates a <xref:System.Data.DataSet> and <xref:System.Data.DataTable>, and then displays the schema in XML format.  \n  \n [!code-cs[Classic WebData DataSet.GetXmlSchema Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ge_3_1.cs)]\n [!code-vb[Classic WebData DataSet.GetXmlSchema Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ge_3_1.vb)]"
  syntax:
    content: public string GetXmlSchema ();
    parameters: []
    return:
      type: System.String
      description: "문자열에 저장 된 데이터의 XML 표현에 대 한 XML 스키마는 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  overload: System.Data.DataSet.GetXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.HasChanges
  id: HasChanges
  parent: System.Data.DataSet
  langs:
  - csharp
  name: HasChanges()
  nameWithType: DataSet.HasChanges()
  fullName: System.Data.DataSet.HasChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "나타내는 값을 가져옵니다 여부는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 새, 삭제 또는 수정 된 행을 포함 하 여 변경 내용이 있습니다."
  remarks: ''
  example:
  - "The following example uses the <xref:System.Data.DataSet.GetChanges%2A> method to create a second <xref:System.Data.DataSet> object that is then used to update a data source.  \n  \n [!code-vb[Classic WebData DataSet.HasChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ha_0_1.vb)]\n [!code-cs[Classic WebData DataSet.HasChanges Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ha_0_1.cs)]"
  syntax:
    content: public bool HasChanges ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 에 변경 내용이 고, 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataSet.HasChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.HasChanges(System.Data.DataRowState)
  id: HasChanges(System.Data.DataRowState)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: HasChanges(DataRowState)
  nameWithType: DataSet.HasChanges(DataRowState)
  fullName: System.Data.DataSet.HasChanges(DataRowState)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "나타내는 값을 가져옵니다 여부는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 기준으로 필터링, 삭제 또는 수정 된 행을 포함 하 여 변경 내용이 <xref href=&quot;System.Data.DataRowState&quot;> </xref>합니다."
  remarks: "검사는 <xref:System.Data.DataSet.HasChanges%2A>의 속성은 `DataSet` 호출 하기 전에 <xref:System.Data.DataSet.GetChanges%2A>메서드.</xref:System.Data.DataSet.GetChanges%2A> </xref:System.Data.DataSet.HasChanges%2A>"
  example:
  - "The following example uses the <xref:System.Data.DataSet.GetChanges%2A> method to create a second <xref:System.Data.DataSet> object, which is then used to update a data source.  \n  \n [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ha_1_1.vb)]\n [!code-cs[Classic WebData DataSet.GetChanges1 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ha_1_1.cs)]"
  syntax:
    content: public bool HasChanges (System.Data.DataRowState rowStates);
    parameters:
    - id: rowStates
      type: System.Data.DataRowState
      description: "중 하나는 <xref href=&quot;System.Data.DataRowState&quot;> </xref> 값입니다."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>경우는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 에 변경 내용이 고, 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataSet.HasChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.HasErrors
  id: HasErrors
  parent: System.Data.DataSet
  langs:
  - csharp
  name: HasErrors
  nameWithType: DataSet.HasErrors
  fullName: System.Data.DataSet.HasErrors
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "중에 오류가 있는지 여부를 나타내는 값을 가져옵니다는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 이 내의 개체 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  remarks: "각 <xref:System.Data.DataTable>에 <xref:System.Data.DataSet>역시는 <xref:System.Data.DataTable.HasErrors%2A>속성.</xref:System.Data.DataTable.HasErrors%2A> </xref:System.Data.DataSet> </xref:System.Data.DataTable> 사용 하 여는 `HasErrors` 의 속성은 `DataSet` 테이블 개별 검사 하기 전에 오류를에 있는지 확인 하려면 첫 번째 <xref:System.Data.DataTable>개체.</xref:System.Data.DataTable> 경우는 `DataTable` 에 오류가 <xref:System.Data.DataTable.GetErrors%2A>메서드 배열을 반환 <xref:System.Data.DataRow>오류를 포함 하는 개체입니다.</xref:System.Data.DataRow> </xref:System.Data.DataTable.GetErrors%2A>"
  example:
  - "The following example uses the HasErrors property to determine whether a <xref:System.Data.DataSet> object contains errors. If so, the errors for each <xref:System.Data.DataRow> in each <xref:System.Data.DataTable> are printed.  \n  \n [!code-cs[Classic WebData DataSet.HasErrors Example#1](~/add/codesnippet/csharp/p-system.data.dataset.ha_1.cs)]\n [!code-vb[Classic WebData DataSet.HasErrors Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.ha_1.vb)]"
  syntax:
    content: public bool HasErrors { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>테이블에 오류가 있습니다; 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataSet.HasErrors*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])
  id: InferXmlSchema(System.IO.Stream,System.String[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: InferXmlSchema(Stream,String[])
  nameWithType: DataSet.InferXmlSchema(Stream,String[])
  fullName: System.Data.DataSet.InferXmlSchema(Stream,String[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "지정 된 위치에서 XML 스키마를 적용 <xref:System.IO.Stream>에 <xref href=&quot;System.Data.DataSet&quot;> </xref>.</xref:System.IO.Stream>"
  syntax:
    content: public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "<xref uid=&quot;langword_csharp_Stream&quot; name=&quot;Stream&quot; href=&quot;&quot;> </xref> 스키마를 읽을입니다."
    - id: nsArray
      type: System.String[]
      description: "스키마 유추에서 제외 될 네임 스페이스 식별자 URI (Uniform Resource) 문자열의 배열입니다."
  overload: System.Data.DataSet.InferXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])
  id: InferXmlSchema(System.IO.TextReader,System.String[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: InferXmlSchema(TextReader,String[])
  nameWithType: DataSet.InferXmlSchema(TextReader,String[])
  fullName: System.Data.DataSet.InferXmlSchema(TextReader,String[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "지정 된 위치에서 XML 스키마를 적용 <xref:System.IO.TextReader>에 <xref href=&quot;System.Data.DataSet&quot;> </xref>.</xref:System.IO.TextReader>"
  syntax:
    content: public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);
    parameters:
    - id: reader
      type: System.IO.TextReader
      description: "<xref uid=&quot;langword_csharp_TextReader&quot; name=&quot;TextReader&quot; href=&quot;&quot;> </xref> 스키마를 읽을입니다."
    - id: nsArray
      type: System.String[]
      description: "스키마 유추에서 제외 될 네임 스페이스 식별자 URI (Uniform Resource) 문자열의 배열입니다."
  overload: System.Data.DataSet.InferXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.InferXmlSchema(System.String,System.String[])
  id: InferXmlSchema(System.String,System.String[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: InferXmlSchema(String,String[])
  nameWithType: DataSet.InferXmlSchema(String,String[])
  fullName: System.Data.DataSet.InferXmlSchema(String,String[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 지정된 된 파일에서 XML 스키마를 적용 된 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  syntax:
    content: public void InferXmlSchema (string fileName, string[] nsArray);
    parameters:
    - id: fileName
      type: System.String
      description: "스키마를 읽을 (경로 포함) 파일의 이름입니다."
    - id: nsArray
      type: System.String[]
      description: "스키마 유추에서 제외 될 네임 스페이스 식별자 URI (Uniform Resource) 문자열의 배열입니다."
  overload: System.Data.DataSet.InferXmlSchema*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>로 설정 되지 않은 <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])
  id: InferXmlSchema(System.Xml.XmlReader,System.String[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: InferXmlSchema(XmlReader,String[])
  nameWithType: DataSet.InferXmlSchema(XmlReader,String[])
  fullName: System.Data.DataSet.InferXmlSchema(XmlReader,String[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "지정 된 위치에서 XML 스키마를 적용 <xref:System.Xml.XmlReader>에 <xref href=&quot;System.Data.DataSet&quot;> </xref>.</xref:System.Xml.XmlReader>"
  syntax:
    content: public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref uid=&quot;langword_csharp_XMLReader&quot; name=&quot;XMLReader&quot; href=&quot;&quot;> </xref> 스키마를 읽을입니다."
    - id: nsArray
      type: System.String[]
      description: "스키마 유추에서 제외 될 네임 스페이스 식별자 URI (Uniform Resource) 문자열의 배열입니다."
  overload: System.Data.DataSet.InferXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Initialized
  id: Initialized
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Initialized
  nameWithType: DataSet.Initialized
  fullName: System.Data.DataSet.Initialized
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "뒤에 오는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 초기화 됩니다."
  remarks: "자세한 내용은 <xref:System.Data.DataSet.IsInitialized%2A>.</xref:System.Data.DataSet.IsInitialized%2A> 을 참조 하십시오."
  syntax:
    content: public event EventHandler Initialized;
    return:
      type: System.EventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.InitializeDerivedDataSet
  id: InitializeDerivedDataSet
  parent: System.Data.DataSet
  langs:
  - csharp
  name: InitializeDerivedDataSet()
  nameWithType: DataSet.InitializeDerivedDataSet()
  fullName: System.Data.DataSet.InitializeDerivedDataSet()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "모든 이진 또는 XML 스트림에서 데이터 집합의 테이블 데이터를 deserialize 합니다."
  syntax:
    content: protected virtual void InitializeDerivedDataSet ();
    parameters: []
  overload: System.Data.DataSet.InitializeDerivedDataSet*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: IsBinarySerialized(SerializationInfo,StreamingContext)
  nameWithType: DataSet.IsBinarySerialized(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.IsBinarySerialized(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "serialize 된 표현 형식을 검사는 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "이 멤버는.NET Framework 인프라를 지원 하며 사용자 코드에서 직접 사용할 수 없습니다."
  syntax:
    content: protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> 개체입니다."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "<xref:System.Runtime.Serialization.StreamingContext>개체입니다.</xref:System.Runtime.Serialization.StreamingContext>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>하는 경우 지정 된 <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> 나타냅니다는 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref> 이진 형식으로 직렬화 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 그렇지 않은 경우."
  overload: System.Data.DataSet.IsBinarySerialized*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.IsInitialized
  id: IsInitialized
  parent: System.Data.DataSet
  langs:
  - csharp
  name: IsInitialized
  nameWithType: DataSet.IsInitialized
  fullName: System.Data.DataSet.IsInitialized
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "나타내는 값을 가져옵니다 여부는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 초기화 됩니다."
  remarks: "상태를 반환 하는 <xref:System.Data.DataSet>것은 생성 되 고, 예를 들어 Visual Studio에서 동안.</xref:System.Data.DataSet> <xref:System.Data.DataSet.BeginInit%2A>메서드를 설정 `false` 및 <xref:System.Data.DataSet.EndInit%2A>메서드를 설정 `true`.</xref:System.Data.DataSet.EndInit%2A> </xref:System.Data.DataSet.BeginInit%2A>"
  syntax:
    content: public bool IsInitialized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>초기화가 완료를 나타내는 구성 요소 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataSet.IsInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])
  id: Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Load(IDataReader,LoadOption,DataTable[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,DataTable[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,DataTable[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "채웁니다는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 사용 하 여 제공 된 데이터 원본의 값으로 <xref href=&quot;System.Data.IDataReader&quot;> </xref>, 배열을 사용 하 여 <xref href=&quot;System.Data.DataTable&quot;> </xref> 인스턴스 스키마 및 네임 스페이스 정보를 제공 합니다."
  remarks: "<xref:System.Data.DataTable.Load%2A>메서드는 단일을 채우기 위한 수 있는 방법을 제공 <xref:System.Data.DataTable>에서 검색 된 데이터와는 <xref:System.Data.IDataReader>인스턴스.</xref:System.Data.IDataReader> </xref:System.Data.DataTable> </xref:System.Data.DataTable.Load%2A> 이 메서드는 동일한 기능을 제공 하지만 <xref:System.Data.IDataReader>를 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 내에서 여러 테이블에</xref:System.Data.IDataReader> 에서 여러 결과 집합을 로드할 수 있습니다.      > [!NOTE] > 로드 작업이 실패 하며는 <xref:System.InvalidOperationException>경우 들어오는 원본 데이터 열 `reader` 계산 된 열인.</xref:System.InvalidOperationException>       `loadOption` 매개 변수를 사용 하면 가져온 데이터를 기존 데이터와 상호 작용 및의 값 중 하나일 수 있습니다 방법을 지정할 수 있습니다는 <xref:System.Data.LoadOption>열거형.</xref:System.Data.LoadOption> <xref:System.Data.DataTable>에 대 한 설명서를 참조 하십시오. <xref:System.Data.DataTable.Load%2A>이 매개 변수를 사용 하 여 대 한 자세한 내용은 메서드.</xref:System.Data.DataTable.Load%2A></xref:System.Data.DataTable>       `tables` 매개 변수 배열을 지정할 수 있습니다 <xref:System.Data.DataTable>해당 각 결과 집합 판독기에서 로드 하는 테이블의 순서를 나타내는 인스턴스.</xref:System.Data.DataTable> Loadmethod 채우기 각 제공 <xref:System.Data.DataTable>단일 결과 집합에서 원본 데이터 판독기에서에서 데이터를 사용 하 여 인스턴스.</xref:System.Data.DataTable> 각 결과 집합 후 Loadmethod는 다음 결과 결과 집합이 더 이상 없을 때까지 판독기 내에서 집합으로 이동 합니다.       이 메서드에 대 한 이름 확인 스키마 <xref:System.Data.Common.DbDataAdapter.Fill%2A> <xref:System.Data.Common.DbDataAdapter>클래스</xref:System.Data.Common.DbDataAdapter> 의 메서드</xref:System.Data.Common.DbDataAdapter.Fill%2A> 뒤와 같습니다."
  example:
  - "The following example creates a new <xref:System.Data.DataSet>, adds two <xref:System.Data.DataTable> instances to the <xref:System.Data.DataSet>, and then fills the <xref:System.Data.DataSet> using the Load method, retrieving data from a <xref:System.Data.DataTableReader> that contains two result sets. Finally, the example displays the contents of the tables in the console window.  \n  \n [!code-vb[DataWorks DataSet.LoadTables#1](~/add/codesnippet/visualbasic/54dbea54-b320-4c41-9f97-_1.vb)]\n [!code-cs[DataWorks DataSet.LoadTables#1](~/add/codesnippet/csharp/54dbea54-b320-4c41-9f97-_1.cs)]"
  syntax:
    content: public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.DataTable[] tables);
    parameters:
    - id: reader
      type: System.Data.IDataReader
      description: "<xref href=&quot;System.Data.IDataReader&quot;> </xref> 하나 이상의 결과 집합을 제공 하는 합니다."
    - id: loadOption
      type: System.Data.LoadOption
      description: "값은 <xref href=&quot;System.Data.LoadOption&quot;> </xref> 를 나타내는 열거형입니다 방법을 있는 행의 <xref href=&quot;System.Data.DataTable&quot;> </xref> 인스턴스에 <xref href=&quot;System.Data.DataSet&quot;> </xref> 동일한 기본 키를 공유 하는 들어오는 행과 결합 되는 합니다."
    - id: tables
      type: System.Data.DataTable[]
      description: "배열을 <xref href=&quot;System.Data.DataTable&quot;> </xref> 인스턴스, Load 메서드를 이름 및 네임 스페이스 정보를 검색 합니다. 이러한 테이블의 각의 구성원 이어야 합니다는 <xref href=&quot;System.Data.DataTableCollection&quot;> </xref> 이 포함 된 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  overload: System.Data.DataSet.Load*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])
  id: Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Load(IDataReader,LoadOption,String[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,String[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,String[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "채웁니다는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 사용 하 여 제공 된 데이터 원본의 값으로 <xref href=&quot;System.Data.IDataReader&quot;> </xref>, 문자열의 배열을 사용 하 여 내에 있는 테이블에 대 한 이름을 제공 하는 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataTable.Load%2A>메서드는 단일을 채우기 위한 수 있는 방법을 제공 <xref:System.Data.DataTable>에서 검색 된 데이터와는 <xref:System.Data.IDataReader>인스턴스.</xref:System.Data.IDataReader> </xref:System.Data.DataTable> </xref:System.Data.DataTable.Load%2A> 여러 결과 집합을 로드할 수 있습니다, 동일한 기능을 제공 하는이 메서드는 `IDataReader` 내에서 여러 테이블에는 `DataSet`합니다.      > [!NOTE] > 로드 작업이 실패 하며는 <xref:System.InvalidOperationException>경우 들어오는 원본 데이터 열 `reader` 계산 된 열인.</xref:System.InvalidOperationException>       `loadOption` 매개 변수를 사용 하면 가져온 데이터를 기존 데이터와 상호 작용 및의 값 중 하나일 수 있습니다 방법을 지정할 수 있습니다는 <xref:System.Data.LoadOption>열거형.</xref:System.Data.LoadOption> 에 대 한 설명서를 참조 하십시오.는 <xref:System.Data.DataTable.Load%2A>이 매개 변수를 사용 하 여 대 한 자세한 내용은 메서드.</xref:System.Data.DataTable.Load%2A>       `tables` 매개 변수를 사용 하면 해당 각 결과 집합 판독기에서 로드 하는 테이블의 순서를 나타내는 테이블 이름의 배열을 지정 지정할 수 있습니다. `Load` 메서드 내에서 테이블을 찾으려고는 `DataSet` 이름과 일치 하는 순서로 테이블 이름의 배열에서 찾을 수 있습니다. 일치 하는 테이블 발견 되 면 해당 테이블은 현재 결과 집합의 내용을 사용 하 여 로드 됩니다. 일치 하는 테이블이 있으면 테이블 이름의 배열에 제공 된 이름을 사용 하 여 테이블을 만들 하 고 새 테이블의 스키마는 결과 집합에서 유추 됩니다. 각 결과 집합 후의 `Load` 메서드 다음 결과 결과 집합이 더 이상 없을 때까지 판독기 내에서 집합으로 이동 합니다.       와 연결 된 기본 네임 스페이스 `DataSet`있는 경우 새로 만든 각와 연결 된 경우, `DataTable`합니다. 이 메서드에 대 한 이름 확인 스키마 <xref:System.Data.Common.DbDataAdapter.Fill%2A> <xref:System.Data.Common.DbDataAdapter>클래스</xref:System.Data.Common.DbDataAdapter> 의 메서드</xref:System.Data.Common.DbDataAdapter.Fill%2A> 뒤와 같습니다."
  example:
  - "The following Console application example first creates tables and loads data from a reader into a <xref:System.Data.DataSet>, using the `Load` method. The example then adds tables to a <xref:System.Data.DataSet> and attempts to fill the tables with data from a <xref:System.Data.DataTableReader>. In this example, because the parameters passed to the `Load` method indicate a table name that does not exist, the `Load` method creates a new table to match the name passed as a parameter. Once the data has been loaded, the example displays the contents of all its tables in the Console window.  \n  \n [!code-vb[DataWorks DataSet.LoadString#1](~/add/codesnippet/visualbasic/f903cc41-1885-430a-b43a-_1.vb)]\n [!code-cs[DataWorks DataSet.LoadString#1](~/add/codesnippet/csharp/f903cc41-1885-430a-b43a-_1.cs)]"
  syntax:
    content: public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, string[] tables);
    parameters:
    - id: reader
      type: System.Data.IDataReader
      description: "<xref href=&quot;System.Data.IDataReader&quot;> </xref> 하나 이상의 결과 집합을 제공 하는 합니다."
    - id: loadOption
      type: System.Data.LoadOption
      description: "값은 <xref href=&quot;System.Data.LoadOption&quot;> </xref> 를 나타내는 열거형입니다 방법을 있는 행의 <xref href=&quot;System.Data.DataTable&quot;> </xref> 인스턴스에 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref> 동일한 기본 키를 공유 하는 들어오는 행과 결합 되는 합니다."
    - id: tables
      type: System.String[]
      description: "문자열의 배열을 <xref uid=&quot;langword_csharp_Load&quot; name=&quot;Load&quot; href=&quot;&quot;> </xref> 메서드 테이블 이름 정보를 검색 합니다."
  overload: System.Data.DataSet.Load*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])
  id: Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "채웁니다는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 사용 하 여 제공 된 데이터 원본의 값으로 <xref href=&quot;System.Data.IDataReader&quot;> </xref>, 배열을 사용 하 여 <xref href=&quot;System.Data.DataTable&quot;> </xref> 인스턴스 스키마 및 네임 스페이스 정보를 제공 합니다."
  remarks: "<xref:System.Data.DataTable.Load%2A>메서드는 단일을 채우기 위한 수 있는 방법을 제공 <xref:System.Data.DataTable>에서 검색 된 데이터와는 <xref:System.Data.IDataReader>인스턴스.</xref:System.Data.IDataReader> </xref:System.Data.DataTable> </xref:System.Data.DataTable.Load%2A> 이 메서드는 동일한 기능을 제공 하지만 <xref:System.Data.IDataReader>를 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 내에서 여러 테이블에</xref:System.Data.IDataReader> 에서 여러 결과 집합을 로드할 수 있습니다.      > [!NOTE] > 로드 작업이 실패 하며는 <xref:System.InvalidOperationException>경우 들어오는 원본 데이터 열 `reader` 계산 된 열인.</xref:System.InvalidOperationException>       `loadOption` 매개 변수를 사용 하면 가져온 데이터를 기존 데이터와 상호 작용 및의 값 중 하나일 수 있습니다 방법을 지정할 수 있습니다는 <xref:System.Data.LoadOption>열거형.</xref:System.Data.LoadOption> <xref:System.Data.DataTable>에 대 한 설명서를 참조 하십시오. <xref:System.Data.DataTable.Load%2A>이 매개 변수를 사용 하 여 대 한 자세한 내용은 메서드.</xref:System.Data.DataTable.Load%2A></xref:System.Data.DataTable>       `errorHandler` 매개 변수는 한 <xref:System.Data.FillErrorEventHandler>데이터를 로드 하는 동안 오류가 발생할 때 호출 되는 프로시저를 참조 하는 대리자입니다.</xref:System.Data.FillErrorEventHandler> <xref:System.Data.FillErrorEventArgs>발생 한 오류, 데이터의 현재 행에 대 한 정보를 검색할 수 있도록 하는 속성을 제공 하는 프로시저에 전달 된 매개 변수 및 <xref:System.Data.DataTable>채워지고.</xref:System.Data.DataTable> </xref:System.Data.FillErrorEventArgs> 이 대리자 메커니즘을 사용 하 여, 대신 간단한 try/catch 블록을 오류를 확인할 수 있습니다 상황을 처리을 원하는 경우 처리를 계속 합니다. <xref:System.Data.FillErrorEventArgs>매개 변수를 제공는 <xref:System.Data.FillErrorEventArgs.Continue%2A>속성:이 속성을 설정 `true` 오류 및; 처리를 계속 하려는 처리 했음을 나타내기 위해 속성을 설정 `false` 처리를 중단 하려면 나타냅니다.</xref:System.Data.FillErrorEventArgs.Continue%2A> </xref:System.Data.FillErrorEventArgs> 주의 해당 속성을 설정 `false` 하면 예외를 throw 하는 문제를 발생 시킨 코드가 있습니다.       `tables` 매개 변수 배열을 지정할 수 있습니다 <xref:System.Data.DataTable>해당 각 결과 집합 판독기에서 로드 하는 테이블의 순서를 나타내는 인스턴스.</xref:System.Data.DataTable> Loadmethod 채우기 각 제공 <xref:System.Data.DataTable>단일 결과 집합에서 원본 데이터 판독기에서에서 데이터를 사용 하 여 인스턴스.</xref:System.Data.DataTable> 각 결과 집합 후 Loadmethod는 다음 결과 결과 집합이 더 이상 없을 때까지 판독기 내에서 집합으로 이동 합니다.       이 메서드에 대 한 이름 확인 스키마 <xref:System.Data.Common.DbDataAdapter.Fill%2A> <xref:System.Data.Common.DbDataAdapter>클래스</xref:System.Data.Common.DbDataAdapter> 의 메서드</xref:System.Data.Common.DbDataAdapter.Fill%2A> 뒤와 같습니다."
  example:
  - "The following example adds a table to a <xref:System.Data.DataSet>, and then attempts to use the Load method to load data from a <xref:System.Data.DataTableReader> that contains an incompatible schema. Rather than trapping the error, this example uses a <xref:System.Data.FillErrorEventHandler> delegate to investigate and handle the error. The output is displayed in the console window.  \n  \n [!code-vb[DataWorks DataSet.Load#1](~/add/codesnippet/visualbasic/a22aaabc-2cbb-4c1f-aa4e-_1.vb)]\n [!code-cs[DataWorks DataSet.Load#1](~/add/codesnippet/csharp/a22aaabc-2cbb-4c1f-aa4e-_1.cs)]"
  syntax:
    content: public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, System.Data.DataTable[] tables);
    parameters:
    - id: reader
      type: System.Data.IDataReader
      description: "<xref href=&quot;System.Data.IDataReader&quot;> </xref> 하나 이상의 결과 집합을 제공 하는 합니다."
    - id: loadOption
      type: System.Data.LoadOption
      description: "값은 <xref href=&quot;System.Data.LoadOption&quot;> </xref> 를 나타내는 열거형입니다 방법을 있는 행의 <xref href=&quot;System.Data.DataTable&quot;> </xref> 인스턴스에 <xref href=&quot;System.Data.DataSet&quot;> </xref> 동일한 기본 키를 공유 하는 들어오는 행과 결합 되는 합니다."
    - id: errorHandler
      type: System.Data.FillErrorEventHandler
      description: "A <xref href=&quot;System.Data.FillErrorEventHandler&quot;> </xref> 데이터를 로드 하는 동안 오류가 발생할 때 호출할 대리자입니다."
    - id: tables
      type: System.Data.DataTable[]
      description: "배열을 <xref href=&quot;System.Data.DataTable&quot;> </xref> 인스턴스, Load 메서드를 이름 및 네임 스페이스 정보를 검색 합니다."
  overload: System.Data.DataSet.Load*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Locale
  id: Locale
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Locale
  nameWithType: DataSet.Locale
  fullName: System.Data.DataSet.Locale
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "테이블 내의 문자열을 비교 하는 데 로캘 정보를 가져오거나 설정 합니다."
  remarks: "Locale 속성에는 로캘을 지정 정렬을 적용할 합니다.       기본적으로 설정에 대 한 로캘을 <xref:System.Data.DataSet>도 각각에 대 한 로캘을 설정 <xref:System.Data.DataTable>개체의 `DataSet` 동일한 값으로.</xref:System.Data.DataTable> </xref:System.Data.DataSet>      > [!NOTE] > 식이 포함 된 열에는 <xref:System.StringComparison>사용 됩니다.</xref:System.StringComparison> <xref:System.StringComparison>는 무시 됩니다.</xref:System.StringComparison>"
  example:
  - "The following example gets the <xref:System.Globalization.CultureInfo> for a <xref:System.Data.DataSet> and prints the <xref:System.Globalization.CultureInfo.DisplayName%2A> and <xref:System.Globalization.CultureInfo.EnglishName%2A> properties.  \n  \n [!code-vb[Classic WebData DataSet.Locale Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.lo_1.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo Locale { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "A <xref:System.Globalization.CultureInfo>사용자의 컴퓨터 로캘에 대 한 데이터가 들어 있는.</xref:System.Globalization.CultureInfo> 기본값은 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataSet.Locale*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataRow[])
  id: Merge(System.Data.DataRow[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataRow[])
  nameWithType: DataSet.Merge(DataRow[])
  fullName: System.Data.DataSet.Merge(DataRow[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "배열을 병합 <xref href=&quot;System.Data.DataRow&quot;> </xref> 개체를 현재 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataSet.Merge%2A>병합할 두 개의 메서드를 사용 하는 <xref:System.Data.DataSet>비슷하긴 하지만 스키마가 포함 된 개체입니다.</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 데이터 원본에서 최신 변경 내용을 기존 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 에 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataSet>데이터 원본에서 최신 데이터로.</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용 사용 하 여 데이터 소스를 업데이트 하 고 있는 기존 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 새로 고침을 포함 하는 절차의 끝에 호출</xref:System.Data.DataSet.Merge%2A>       클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다. 이 시나리오는 <xref:System.Data.DataSet.GetChanges%2A>메서드가 먼저 호출 됩니다.</xref:System.Data.DataSet.GetChanges%2A> 이 메서드는 두 번째 <xref:System.Data.DataSet>유효성 검사 및 병합에 대 한 액세스에 최적화 된.</xref:System.Data.DataSet> 이 두 번째 <xref:System.Data.DataSet>개체는 포함 <xref:System.Data.DataTable>하 고 <xref:System.Data.DataRow>원래 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 의 하위 집합을 변경 된 개체</xref:System.Data.DataRow> </xref:System.Data.DataTable> </xref:System.Data.DataSet> 이 하위 집합은 일반적으로 더 작은 때문에 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet>(다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.</xref:System.Data.DataSet> (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet>클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataSet>와 <xref:System.Data.DataSet.Merge%2A>메서드.</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       경우는 <xref:System.Data.DataSet.Merge%2A>메서드가 호출 되 면 두 스키마 <xref:System.Data.DataSet>개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다.</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다. 경우 소스 <xref:System.Data.DataSet>스키마 요소를 포함 (추가 <xref:System.Data.DataColumn>개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 `missingSchemaAction` 인수 `MissingSchemaAction.Add`.</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 병합 된 경우에서 <xref:System.Data.DataSet>추가 된 스키마와 데이터를 포함 합니다.</xref:System.Data.DataSet>       스키마를 병합 한 후 데이터를 병합 합니다.       새 소스를 병합할 때 <xref:System.Data.DataSet>대상에 모든 소스 행 한 <xref:System.Data.DataRowState>값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 소스 행 한 <xref:System.Data.DataRowState>값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.</xref:System.Data.DataRowState>       병합 하는 동안 제약 조건이 비활성화 됩니다. 병합의 끝에 모든 제약 조건을 사용할 수 없으면는 <xref:System.Data.ConstraintException>생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다.</xref:System.Data.ConstraintException> 이 경우는 <xref:System.Data.DataSet.EnforceConstraints%2A>속성이 `false`, 오류에서 유효 하지 않은 모든 행을 표시 합니다.</xref:System.Data.DataSet.EnforceConstraints%2A> 다시 설정 하기 전에 오류를 해결 해야 합니다는 <xref:System.Data.DataSet.EnforceConstraints%2A>속성을 `true`.</xref:System.Data.DataSet.EnforceConstraints%2A>"
  syntax:
    content: public void Merge (System.Data.DataRow[] rows);
    parameters:
    - id: rows
      type: System.Data.DataRow[]
      description: "배열 <xref uid=&quot;langword_csharp_DataRow&quot; name=&quot;DataRow&quot; href=&quot;&quot;> </xref> 개체를 병합할 수는 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataSet.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataSet)
  id: Merge(System.Data.DataSet)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataSet)
  nameWithType: DataSet.Merge(DataSet)
  fullName: System.Data.DataSet.Merge(DataSet)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "지정 된 병합 <xref href=&quot;System.Data.DataSet&quot;> </xref> 및 스키마를 현재 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "Merge 메서드 두 개를 병합 하는 데는 <xref:System.Data.DataSet>비슷하긴 하지만 스키마가 포함 된 개체입니다.</xref:System.Data.DataSet> 데이터 원본에서 최신 변경 내용을 기존 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 에 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataSet>데이터 원본에서 최신 데이터로.</xref:System.Data.DataSet>       Merge 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 새로 고침 관련 된 절차의 끝에 호출       클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다. 이 시나리오는 <xref:System.Data.DataSet.GetChanges%2A>메서드가 먼저 호출 됩니다.</xref:System.Data.DataSet.GetChanges%2A> 이 메서드는 두 번째 <xref:System.Data.DataSet>유효성 검사 및 병합에 대 한 액세스에 최적화 된.</xref:System.Data.DataSet> 이 두 번째 <xref:System.Data.DataSet>개체는 포함 <xref:System.Data.DataTable>하 고 <xref:System.Data.DataRow>원래 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 의 하위 집합을 변경 된 개체</xref:System.Data.DataRow> </xref:System.Data.DataTable> </xref:System.Data.DataSet> 이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet>(다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.</xref:System.Data.DataSet> (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet>클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataSet>병합 메서드로.</xref:System.Data.DataSet> </xref:System.Data.DataSet>       Merge 메서드 호출 될 때 두 개의 스키마 <xref:System.Data.DataSet>개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다.</xref:System.Data.DataSet> 예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다. 경우 소스 <xref:System.Data.DataSet>스키마 요소를 포함 (추가 <xref:System.Data.DataColumn>개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 `missingSchemaAction` 인수 `MissingSchemaAction.Add`.</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 병합 된 경우에서 <xref:System.Data.DataSet>추가 된 스키마와 데이터를 포함 합니다.</xref:System.Data.DataSet>       스키마를 병합 한 후 데이터를 병합 합니다.       새 소스를 병합할 때 <xref:System.Data.DataSet>대상에 모든 소스 행 한 <xref:System.Data.DataRowState>값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 소스 행 한 `DataRowState` 값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.       병합 하는 동안 제약 조건이 비활성화 됩니다. 병합의 끝에 모든 제약 조건을 사용할 수 없으면는 <xref:System.Data.ConstraintException>생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다.</xref:System.Data.ConstraintException> 이 경우는 <xref:System.Data.DataSet.EnforceConstraints%2A>속성이 `false`, 오류에서 유효 하지 않은 모든 행을 표시 합니다.</xref:System.Data.DataSet.EnforceConstraints%2A> 다시 설정 하기 전에 오류를 해결 해야 합니다는 <xref:System.Data.DataSet.EnforceConstraints%2A>속성을 `true`.</xref:System.Data.DataSet.EnforceConstraints%2A>"
  example:
  - "The following example uses the <xref:System.Data.DataSet.GetChanges%2A>, Update, and Merge methods on a <xref:System.Data.DataSet>.  \n  \n [!code-vb[Classic WebData DataSet.Merge Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.me_2_1.vb)]\n [!code-cs[Classic WebData DataSet.Merge Example#1](~/add/codesnippet/csharp/m-system.data.dataset.me_2_1.cs)]"
  syntax:
    content: public void Merge (System.Data.DataSet dataSet);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref> 해당 데이터와 스키마를 병합 됩니다."
  overload: System.Data.DataSet.Merge*
  exceptions:
  - type: System.Data.ConstraintException
    commentId: T:System.Data.ConstraintException
    description: "하나 이상의 제약 조건은 사용할 수 없습니다."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>dataSet</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataTable)
  id: Merge(System.Data.DataTable)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataTable)
  nameWithType: DataSet.Merge(DataTable)
  fullName: System.Data.DataSet.Merge(DataTable)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "지정 된 병합 <xref href=&quot;System.Data.DataTable&quot;> </xref> 및 스키마를 현재 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataSet.Merge%2A>병합할 두 개의 메서드를 사용 하는 <xref:System.Data.DataSet>비슷하긴 하지만 스키마가 포함 된 개체입니다.</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 데이터 원본에서 최신 변경 내용을 기존 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 에 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataSet>데이터 원본에서 최신 데이터로.</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용 사용 하 여 데이터 소스를 업데이트 하 고 있는 기존 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 새로 고침을 포함 하는 절차의 끝에 호출</xref:System.Data.DataSet.Merge%2A>       클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다. 이 시나리오는 <xref:System.Data.DataSet.GetChanges%2A>메서드가 먼저 호출 됩니다.</xref:System.Data.DataSet.GetChanges%2A> 이 메서드는 두 번째 <xref:System.Data.DataSet>유효성 검사 및 병합에 대 한 액세스에 최적화 된.</xref:System.Data.DataSet> 이 두 번째 <xref:System.Data.DataSet>개체는 포함 <xref:System.Data.DataTable>하 고 <xref:System.Data.DataRow>원래 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 의 하위 집합을 변경 된 개체</xref:System.Data.DataRow> </xref:System.Data.DataTable> </xref:System.Data.DataSet> 이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet>(다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.</xref:System.Data.DataSet> (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet>클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataSet>와 <xref:System.Data.DataSet.Merge%2A>메서드.</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       경우는 <xref:System.Data.DataSet.Merge%2A>메서드가 호출 되 면 두 스키마 <xref:System.Data.DataSet>개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다.</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다. 경우 소스 <xref:System.Data.DataSet>스키마 요소를 포함 (추가 <xref:System.Data.DataColumn>개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 `missingSchemaAction` 인수 `MissingSchemaAction.Add`.</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 병합 된 경우에서 <xref:System.Data.DataSet>추가 된 스키마와 데이터를 포함 합니다.</xref:System.Data.DataSet>       스키마를 병합 한 후 데이터를 병합 합니다.       새 소스를 병합할 때 <xref:System.Data.DataSet>대상에 모든 소스 행 한 <xref:System.Data.DataRowState>값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 소스 행 한 `DataRowState` 값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.       병합 하는 동안 제약 조건이 비활성화 됩니다. 병합의 끝에 모든 제약 조건을 사용할 수 없으면는 <xref:System.Data.ConstraintException>생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다.</xref:System.Data.ConstraintException> 이 경우는 <xref:System.Data.DataSet.EnforceConstraints%2A>속성이 `false`, 오류에서 유효 하지 않은 모든 행을 표시 합니다.</xref:System.Data.DataSet.EnforceConstraints%2A> 다시 설정 하기 전에 오류를 해결 해야 합니다는 <xref:System.Data.DataSet.EnforceConstraints%2A>속성을 `true`.</xref:System.Data.DataSet.EnforceConstraints%2A>"
  example:
  - "The following example creates a simple <xref:System.Data.DataSet> with one table, two columns, and ten rows. A second <xref:System.Data.DataTable> is created that is identical to the first. Two rows are added to the second table, which is then merged into the <xref:System.Data.DataSet>.  \n  \n [!code-vb[Classic WebData DataSet.Merge3 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.me_1_1.vb)]\n [!code-cs[Classic WebData DataSet.Merge3 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.me_1_1.cs)]"
  syntax:
    content: public void Merge (System.Data.DataTable table);
    parameters:
    - id: table
      type: System.Data.DataTable
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref> 해당 데이터와 스키마를 병합 됩니다."
  overload: System.Data.DataSet.Merge*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>table</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)
  id: Merge(System.Data.DataSet,System.Boolean)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataSet,Boolean)
  nameWithType: DataSet.Merge(DataSet,Boolean)
  fullName: System.Data.DataSet.Merge(DataSet,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "지정 된 병합 <xref href=&quot;System.Data.DataSet&quot;> </xref> 및 스키마를 현재 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>이 변경 내용을 합니다 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref> 지정 된 인수에 따라 합니다."
  remarks: "<xref:System.Data.DataSet.Merge%2A>병합할 두 개의 메서드를 사용 하는 <xref:System.Data.DataSet>비슷하긴 하지만 스키마가 포함 된 개체입니다.</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 데이터 원본에서 최신 변경 내용을 기존 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 에 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataSet>데이터 원본에서 최신 데이터로.</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용 사용 하 여 데이터 소스를 업데이트 하 고 있는 기존 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 새로 고침을 포함 하는 절차의 끝에 호출</xref:System.Data.DataSet.Merge%2A>       클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다. 이 시나리오는 <xref:System.Data.DataSet.GetChanges%2A>메서드가 먼저 호출 됩니다.</xref:System.Data.DataSet.GetChanges%2A> 이 메서드는 두 번째 <xref:System.Data.DataSet>유효성 검사 및 병합에 대 한 액세스에 최적화 된.</xref:System.Data.DataSet> 이 두 번째 <xref:System.Data.DataSet>개체는 포함 <xref:System.Data.DataTable>하 고 <xref:System.Data.DataRow>원래 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 의 하위 집합을 변경 된 개체</xref:System.Data.DataRow> </xref:System.Data.DataTable> </xref:System.Data.DataSet> 이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet>(다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.</xref:System.Data.DataSet> (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet>클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataSet>와 <xref:System.Data.DataSet.Merge%2A>메서드.</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       경우는 <xref:System.Data.DataSet.Merge%2A>메서드가 호출 되 면 두 스키마 <xref:System.Data.DataSet>개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다.</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다. 경우 소스 <xref:System.Data.DataSet>스키마 요소를 포함 (추가 <xref:System.Data.DataColumn>개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 `missingSchemaAction` 인수 `MissingSchemaAction.Add`.</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 병합 된 경우에서 <xref:System.Data.DataSet>추가 된 스키마와 데이터를 포함 합니다.</xref:System.Data.DataSet>       스키마를 병합 한 후 데이터를 병합 합니다.       새 소스를 병합할 때 <xref:System.Data.DataSet>대상에 모든 소스 행 한 <xref:System.Data.DataRowState>값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 소스 행 한 `DataRowState` 값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.       병합 하는 동안 제약 조건이 비활성화 됩니다. 병합의 끝에 모든 제약 조건을 사용할 수 없으면는 <xref:System.Data.ConstraintException>생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다.</xref:System.Data.ConstraintException> 이 경우는 <xref:System.Data.DataSet.EnforceConstraints%2A>속성이 `false`, 오류에서 유효 하지 않은 모든 행을 표시 합니다.</xref:System.Data.DataSet.EnforceConstraints%2A> 다시 설정 하기 전에 오류를 해결 해야 합니다는 <xref:System.Data.DataSet.EnforceConstraints%2A>속성을 `true`.</xref:System.Data.DataSet.EnforceConstraints%2A>"
  example:
  - "The following example creates a simple <xref:System.Data.DataSet> with one table, two columns, and ten rows. After adding ten rows, two values are changed, and one row is added. A subset of the changed data is created using the <xref:System.Data.DataSet.GetChanges%2A> method. After reconciling errors, the subset data is merged into the original <xref:System.Data.DataSet>.  \n  \n [!code-cs[Classic WebData DataSet.GetChanges Example#1](~/add/codesnippet/csharp/m-system.data.dataset.me_0_1.cs)]\n [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.me_0_1.vb)]"
  syntax:
    content: public void Merge (System.Data.DataSet dataSet, bool preserveChanges);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref> 해당 데이터와 스키마를 병합 됩니다."
    - id: preserveChanges
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>현재에서 변경 내용을 유지 하려면 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>고, 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataSet.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)
  id: Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataRow[],Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataRow[],Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataRow[],Boolean,MissingSchemaAction)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "배열을 병합 <xref href=&quot;System.Data.DataRow&quot;> </xref> 개체를 현재 <xref href=&quot;System.Data.DataSet&quot;> </xref>변경 합니다는 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref> 된 지정된 된 인수를 처리 합니다."
  remarks: "<xref:System.Data.DataSet.Merge%2A>병합할 두 개의 메서드를 사용 하는 <xref:System.Data.DataSet>비슷하긴 하지만 스키마가 포함 된 개체입니다.</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 데이터 원본에서 최신 변경 내용을 기존 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 에 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataSet>데이터 원본에서 최신 데이터로.</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용 사용 하 여 데이터 소스를 업데이트 하 고 있는 기존 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 새로 고침을 포함 하는 절차의 끝에 호출</xref:System.Data.DataSet.Merge%2A>       클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다. 이 시나리오는 <xref:System.Data.DataSet.GetChanges%2A>메서드가 먼저 호출 됩니다.</xref:System.Data.DataSet.GetChanges%2A> 이 메서드는 두 번째 <xref:System.Data.DataSet>유효성 검사 및 병합에 대 한 액세스에 최적화 된.</xref:System.Data.DataSet> 이 두 번째 <xref:System.Data.DataSet>개체는 포함 <xref:System.Data.DataTable>하 고 <xref:System.Data.DataRow>원래 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 의 하위 집합을 변경 된 개체</xref:System.Data.DataRow> </xref:System.Data.DataTable> </xref:System.Data.DataSet> 이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet>(다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.</xref:System.Data.DataSet> (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet>클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataSet>와 <xref:System.Data.DataSet.Merge%2A>메서드.</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       설명은 용이 하 게 하려면는 <xref:System.Data.DataSet.Merge%2A>메서드를 사용 하 여 &quot;대상&quot; 현재 나타낼 <xref:System.Data.DataSet>, &quot;source&quot; (매개 변수) <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 두 번째 이름을 지정 하 고</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 대상 <xref:System.Data.DataSet>가 의미 하는 동작 (병합) 발생 하는 개체입니다.</xref:System.Data.DataSet> 두 번째 <xref:System.Data.DataSet>포함 된 정보를 변경 되지 않지만 대신 현재 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 에 병합 되 때문에 &quot;source&quot; 라고</xref:System.Data.DataSet>       경우는 <xref:System.Data.DataSet.Merge%2A>메서드가 호출 되 면 두 스키마 <xref:System.Data.DataSet>개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다.</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다. 경우 소스 <xref:System.Data.DataSet>스키마 요소를 포함 (추가 <xref:System.Data.DataColumn>개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 `missingSchemaAction` 인수 `MissingSchemaAction.Add`.</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 병합 된 경우에서 <xref:System.Data.DataSet>추가 된 스키마와 데이터를 포함 합니다.</xref:System.Data.DataSet>       스키마를 병합 한 후 데이터를 병합 합니다.       새 소스를 병합할 때 <xref:System.Data.DataSet>대상에 모든 소스 행 한 <xref:System.Data.DataRowState>값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 소스 행 한 `DataRowState` 값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.       병합 하는 동안 제약 조건이 비활성화 됩니다. 병합의 끝에 모든 제약 조건을 사용할 수 없으면는 <xref:System.Data.ConstraintException>생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다.</xref:System.Data.ConstraintException> 이 경우는 <xref:System.Data.DataSet.EnforceConstraints%2A>속성이 `false`, 오류에서 유효 하지 않은 모든 행을 표시 합니다.</xref:System.Data.DataSet.EnforceConstraints%2A> 다시 설정 하기 전에 오류를 해결 해야 합니다는 <xref:System.Data.DataSet.EnforceConstraints%2A>속성을 `true`.</xref:System.Data.DataSet.EnforceConstraints%2A>"
  syntax:
    content: public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);
    parameters:
    - id: rows
      type: System.Data.DataRow[]
      description: "배열 <xref href=&quot;System.Data.DataRow&quot;> </xref> 개체를 병합할 수는 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>합니다."
    - id: preserveChanges
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>변경 내용을 유지 하는 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>고, 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
    - id: missingSchemaAction
      type: System.Data.MissingSchemaAction
      description: "중 하나는 <xref href=&quot;System.Data.MissingSchemaAction&quot;> </xref> 값입니다."
  overload: System.Data.DataSet.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)
  id: Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataSet,Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataSet,Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataSet,Boolean,MissingSchemaAction)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "지정 된 병합 <xref href=&quot;System.Data.DataSet&quot;> </xref> 및 현재 스키마 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>현재에서 변경 내용을 합니다 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref> 된 지정된 된 인수를 처리 합니다."
  remarks: "<xref:System.Data.DataSet.Merge%2A>병합할 두 개의 메서드를 사용 하는 <xref:System.Data.DataSet>비슷하긴 하지만 스키마가 포함 된 개체입니다.</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 데이터 원본에서 최신 변경 내용을 기존 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 에 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataSet>데이터 원본에서 최신 데이터로.</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용 사용 하 여 데이터 소스를 업데이트 하 고 있는 기존 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 새로 고침을 포함 하는 절차의 끝에 호출</xref:System.Data.DataSet.Merge%2A>       클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다. 이 시나리오는 <xref:System.Data.DataSet.GetChanges%2A>메서드가 먼저 호출 됩니다.</xref:System.Data.DataSet.GetChanges%2A> 이 메서드는 두 번째 <xref:System.Data.DataSet>유효성 검사 및 병합에 대 한 액세스에 최적화 된.</xref:System.Data.DataSet> 이 두 번째 <xref:System.Data.DataSet>개체는 포함 <xref:System.Data.DataTable>하 고 <xref:System.Data.DataRow>원래 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 의 하위 집합을 변경 된 개체</xref:System.Data.DataRow> </xref:System.Data.DataTable> </xref:System.Data.DataSet> 이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet>(다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.</xref:System.Data.DataSet> (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet>클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataSet>와 <xref:System.Data.DataSet.Merge%2A>메서드.</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       설명은 용이 하 게 하려면는 <xref:System.Data.DataSet.Merge%2A>메서드를 사용 하 여 &quot;대상&quot; 현재 나타낼 <xref:System.Data.DataSet>, &quot;source&quot; (매개 변수) <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 두 번째 이름을 지정 하 고</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 대상 <xref:System.Data.DataSet>가 의미 하는 동작 (병합) 발생 하는 개체입니다.</xref:System.Data.DataSet> 두 번째 <xref:System.Data.DataSet>포함 된 정보를 변경 되지 않지만 대신 현재 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 에 병합 되 때문에 &quot;source&quot; 라고</xref:System.Data.DataSet>       경우는 <xref:System.Data.DataSet.Merge%2A>메서드가 호출 되 면 두 스키마 <xref:System.Data.DataSet>개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다.</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다. 경우 소스 <xref:System.Data.DataSet>스키마 요소를 포함 (추가 <xref:System.Data.DataColumn>개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 `missingSchemaAction` 인수 `MissingSchemaAction.Add`.</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 병합 된 경우에서 <xref:System.Data.DataSet>추가 된 스키마와 데이터를 포함 합니다.</xref:System.Data.DataSet>       스키마를 병합 한 후 데이터를 병합 합니다.       새 소스를 병합할 때 <xref:System.Data.DataSet>대상에 모든 소스 행 한 <xref:System.Data.DataRowState>값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 소스 행 한 `DataRowState` 값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.       병합 하는 동안 제약 조건이 비활성화 됩니다. 병합의 끝에 모든 제약 조건을 사용할 수 없으면는 <xref:System.Data.ConstraintException>생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다.</xref:System.Data.ConstraintException> 이 경우는 <xref:System.Data.DataSet.EnforceConstraints%2A>속성이 `false`, 오류에서 유효 하지 않은 모든 행을 표시 합니다.</xref:System.Data.DataSet.EnforceConstraints%2A> 다시 설정 하기 전에 오류를 해결 해야 합니다는 <xref:System.Data.DataSet.EnforceConstraints%2A>속성을 `true`.</xref:System.Data.DataSet.EnforceConstraints%2A>"
  example:
  - "The following example creates a simple <xref:System.Data.DataSet> with one table, two columns, and ten rows. Two values are changed, and one row is added. A subset of the changed data is created using the <xref:System.Data.DataSet.GetChanges%2A> method. After reconciling errors, a new column is added to the subset, changing the schema. When the <xref:System.Data.DataSet.Merge%2A> method is called with the `missingSchemaAction` set to `MissingSchemaAction.Add`, the new column is added to the original <xref:System.Data.DataSet> object's schema.  \n  \n [!code-cs[Classic WebData DataSet.Merge2 Example#1](~/add/codesnippet/csharp/e5f91548-401c-49b5-ab4b-_1.cs)]\n [!code-vb[Classic WebData DataSet.Merge2 Example#1](~/add/codesnippet/visualbasic/e5f91548-401c-49b5-ab4b-_1.vb)]"
  syntax:
    content: public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref> 해당 데이터와 스키마를 병합 됩니다."
    - id: preserveChanges
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>현재에서 변경 내용을 유지 하려면 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>고, 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
    - id: missingSchemaAction
      type: System.Data.MissingSchemaAction
      description: "중 하나는 <xref href=&quot;System.Data.MissingSchemaAction&quot;> </xref> 값입니다."
  overload: System.Data.DataSet.Merge*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>dataSet</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  id: Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataTable,Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataTable,Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataTable,Boolean,MissingSchemaAction)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "지정 된 병합 <xref href=&quot;System.Data.DataTable&quot;> </xref> 및 스키마를 현재 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>, 유지 또는에서 변경 내용 취소는 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref> 된 지정된 된 인수를 처리 합니다."
  remarks: "<xref:System.Data.DataSet.Merge%2A>병합할 두 개의 메서드를 사용 하는 <xref:System.Data.DataSet>비슷하긴 하지만 스키마가 포함 된 개체입니다.</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 데이터 원본에서 최신 변경 내용을 기존 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 에 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataSet>데이터 원본에서 최신 데이터로.</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용 사용 하 여 데이터 소스를 업데이트 하 고 있는 기존 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 새로 고침을 포함 하는 절차의 끝에 호출</xref:System.Data.DataSet.Merge%2A>       일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 클라이언트 응용 프로그램 이온 되었기 합니다. 이 시나리오는 <xref:System.Data.DataSet.GetChanges%2A>메서드가 먼저 호출 됩니다.</xref:System.Data.DataSet.GetChanges%2A> 이 메서드는 두 번째 <xref:System.Data.DataSet>유효성 검사 및 병합에 대 한 액세스에 최적화 된.</xref:System.Data.DataSet> 이 두 번째 <xref:System.Data.DataSet>개체는 포함 <xref:System.Data.DataTable>하 고 <xref:System.Data.DataRow>원래 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 의 하위 집합을 변경 된 개체</xref:System.Data.DataRow> </xref:System.Data.DataTable> </xref:System.Data.DataSet> 이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet>(다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.</xref:System.Data.DataSet> (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet>클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataSet>와 <xref:System.Data.DataSet.Merge%2A>메서드.</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       경우는 <xref:System.Data.DataSet.Merge%2A>메서드가 호출 되 면 두 스키마 <xref:System.Data.DataSet>개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다.</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다. 경우 소스 <xref:System.Data.DataSet>스키마 요소를 포함 (추가 <xref:System.Data.DataColumn>개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 `missingSchemaAction` 인수 `MissingSchemaAction.Add`.</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 병합 된 경우에서 <xref:System.Data.DataSet>추가 된 스키마와 데이터를 포함 합니다.</xref:System.Data.DataSet>       스키마를 병합 한 후 데이터를 병합 합니다.       새 소스를 병합할 때 <xref:System.Data.DataSet>대상에 모든 소스 행 한 <xref:System.Data.DataRowState>값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 소스 행 한 `DataRowState` 값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.       병합 하는 동안 제약 조건이 비활성화 됩니다. 병합의 끝에 모든 제약 조건을 사용할 수 없으면는 <xref:System.Data.ConstraintException>생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다.</xref:System.Data.ConstraintException> 이 경우는 <xref:System.Data.DataSet.EnforceConstraints%2A>속성이 `false`, 오류에서 유효 하지 않은 모든 행을 표시 합니다.</xref:System.Data.DataSet.EnforceConstraints%2A> 다시 설정 하기 전에 오류를 해결 해야 합니다는 <xref:System.Data.DataSet.EnforceConstraints%2A>속성을 `true`.</xref:System.Data.DataSet.EnforceConstraints%2A>"
  example:
  - "The following example creates a simple <xref:System.Data.DataSet> with one table, two columns, and ten rows. A second <xref:System.Data.DataTable> is created that is nearly identical to the first except that a new `DataColumn` is added to the table. Two rows are added to the second table, which is then merged into the <xref:System.Data.DataSet> with the `preserveChanges` argument set to `false`, and the `missingSchemaAction` argument set to `MissingSchemaAction.Add`.  \n  \n [!code-cs[Classic WebData DataSet.Merge4 Example#1](~/add/codesnippet/csharp/a63745f5-1a9e-4fc7-9c61-_1.cs)]\n [!code-vb[Classic WebData DataSet.Merge4 Example#1](~/add/codesnippet/visualbasic/a63745f5-1a9e-4fc7-9c61-_1.vb)]"
  syntax:
    content: public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);
    parameters:
    - id: table
      type: System.Data.DataTable
      description: "<xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref> 해당 데이터와 스키마를 병합 됩니다."
    - id: preserveChanges
      type: System.Boolean
      description: "중 하나는 <xref href=&quot;System.Data.MissingSchemaAction&quot;> </xref> 값입니다."
    - id: missingSchemaAction
      type: System.Data.MissingSchemaAction
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>변경 내용을 유지 하는 <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>고, 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataSet.Merge*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>dataSet</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Data.DataSet.MergeFailed
  id: MergeFailed
  parent: System.Data.DataSet
  langs:
  - csharp
  name: MergeFailed
  nameWithType: DataSet.MergeFailed
  fullName: System.Data.DataSet.MergeFailed
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "대상 및 원본 때 발생 <xref href=&quot;System.Data.DataRow&quot;> </xref> 동일한 기본 키 값 및 <xref:System.Data.DataSet.EnforceConstraints*>설정을 true로.</xref:System.Data.DataSet.EnforceConstraints*>"
  remarks: '이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.'
  example:
  - "The following example demonstrates the use of the MergeFailed event.  \n  \n [!code-vb[Classic WebData DataSet.MergeFailed Example#1](~/add/codesnippet/visualbasic/e-system.data.dataset.me_1.vb)]\n [!code-cs[Classic WebData DataSet.MergeFailed Example#1](~/add/codesnippet/csharp/e-system.data.dataset.me_1.cs)]"
  syntax:
    content: public event System.Data.MergeFailedEventHandler MergeFailed;
    return:
      type: System.Data.MergeFailedEventHandler
      description: "추가할 수 있습니다."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Namespace
  id: Namespace
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Namespace
  nameWithType: DataSet.Namespace
  fullName: System.Data.DataSet.Namespace
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "네임 스페이스를 가져오거나 설정 합니다.는 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  remarks: "Namespace 속성이에 문서를 읽고 XML을 쓸 때 사용 되는 <xref:System.Data.DataSet>를 사용 하는 <xref:System.Data.DataSet.ReadXml%2A>, <xref:System.Data.DataSet.WriteXml%2A>, <xref:System.Data.DataSet.ReadXmlSchema%2A>, 또는 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드.</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet>       XML 문서의 네임 스페이스는 XML 특성 및 요소에 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 으로 읽을 때 범위를 지정 하는 데 사용 예를 들어 경우는 <xref:System.Data.DataSet>스키마가 포함 된 네임 스페이스가 &quot;myCompany&quot; 문서에서 읽은 및만 다른 네임 스페이스를 사용 하 여 문서에서에서 데이터를 읽을 하려고 시도 하 고, 기존 스키마에 해당 하지 않는 모든 데이터는 무시 됩니다.</xref:System.Data.DataSet>"
  example:
  - "The following example sets the <xref:System.Data.DataSet.Prefix%2A> before calling the <xref:System.Data.DataSet.ReadXml%2A> method.  \n  \n [!code-vb[Classic WebData DataSet.Namespace Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.na_1.vb)]\n [!code-cs[Classic WebData DataSet.Namespace Example#1](~/add/codesnippet/csharp/p-system.data.dataset.na_1.cs)]"
  syntax:
    content: public string Namespace { get; set; }
    return:
      type: System.String
      description: "네임 스페이스는 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  overload: System.Data.DataSet.Namespace*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "네임 스페이스에 이미 데이터가 있습니다."
  platform:
  - net462
- uid: System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  id: OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: OnPropertyChanging(PropertyChangedEventArgs)
  nameWithType: DataSet.OnPropertyChanging(PropertyChangedEventArgs)
  fullName: System.Data.DataSet.OnPropertyChanging(PropertyChangedEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "OnPropertyChanging 이벤트를 발생 시킵니다."
  remarks: '이벤트를 발생 시키는 대리자를 통해 이벤트 처리기를 호출 합니다. 에 대 한 개요 [NIB: 이벤트를 발생 시키는](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)합니다.'
  syntax:
    content: protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);
    parameters:
    - id: pcevent
      type: System.ComponentModel.PropertyChangedEventArgs
      description: "A <xref:System.ComponentModel.PropertyChangedEventArgs>이벤트 데이터를 포함 하는.</xref:System.ComponentModel.PropertyChangedEventArgs>"
  overload: System.Data.DataSet.OnPropertyChanging*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)
  id: OnRemoveRelation(System.Data.DataRelation)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: OnRemoveRelation(DataRelation)
  nameWithType: DataSet.OnRemoveRelation(DataRelation)
  fullName: System.Data.DataSet.OnRemoveRelation(DataRelation)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "발생 경우는 <xref href=&quot;System.Data.DataRelation&quot;> </xref> 개체에서 제거 되는 <xref href=&quot;System.Data.DataTable&quot;> </xref>합니다."
  remarks: "이 메서드는 테이블을 제거 하 고 제한 하는 서브 클래스에서 재정의 해야 합니다."
  syntax:
    content: protected virtual void OnRemoveRelation (System.Data.DataRelation relation);
    parameters:
    - id: relation
      type: System.Data.DataRelation
      description: "<xref href=&quot;System.Data.DataRelation&quot;> </xref> 제거 하 고 있습니다."
  overload: System.Data.DataSet.OnRemoveRelation*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.OnRemoveTable(System.Data.DataTable)
  id: OnRemoveTable(System.Data.DataTable)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: OnRemoveTable(DataTable)
  nameWithType: DataSet.OnRemoveTable(DataTable)
  fullName: System.Data.DataSet.OnRemoveTable(DataTable)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "발생 경우는 <xref href=&quot;System.Data.DataTable&quot;> </xref> 에서 제거 되는 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  remarks: "이 메서드는 제거 되지 않도록 테이블을 제한 하는 서브 클래스에서 재정의할 수 있습니다."
  example:
  - "The following example shows a class derived from the <xref:System.Data.DataSet> with the OnRemoveTable method overridden.  \n  \n [!code-vb[Classic WebData DataSet.OnRemoveTable Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.on_1.vb)]\n [!code-cs[Classic WebData DataSet.OnRemoveTable Example#1](~/add/codesnippet/csharp/m-system.data.dataset.on_1.cs)]"
  syntax:
    content: protected virtual void OnRemoveTable (System.Data.DataTable table);
    parameters:
    - id: table
      type: System.Data.DataTable
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref> 제거 하 고 있습니다."
  overload: System.Data.DataSet.OnRemoveTable*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Prefix
  id: Prefix
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Prefix
  nameWithType: DataSet.Prefix
  fullName: System.Data.DataSet.Prefix
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "여부를 가져오거나 설정 XML 접두사의 네임 스페이스를 별칭을 지정 하는 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  remarks: "접두사 속성이의 네임 스페이스에 속한 요소를 식별 하는 XML 문서 전체에서 사용 되는 <xref:System.Data.DataSet>개체 (의해 설정 된 <xref:System.Data.DataSet.Namespace%2A>속성).</xref:System.Data.DataSet.Namespace%2A> </xref:System.Data.DataSet>"
  example:
  - "The following example sets the Prefix before calling the <xref:System.Data.DataSet.ReadXml%2A> method.  \n  \n [!code-vb[Classic WebData DataSet.Namespace Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.pr_1.vb)]\n [!code-cs[Classic WebData DataSet.Namespace Example#1](~/add/codesnippet/csharp/p-system.data.dataset.pr_1.cs)]"
  syntax:
    content: public string Prefix { get; set; }
    return:
      type: System.String
      description: "에 대 한 XML 접두사는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 네임 스페이스입니다."
  overload: System.Data.DataSet.Prefix*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.RaisePropertyChanging(System.String)
  id: RaisePropertyChanging(System.String)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: RaisePropertyChanging(String)
  nameWithType: DataSet.RaisePropertyChanging(String)
  fullName: System.Data.DataSet.RaisePropertyChanging(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "알림을 전송 지정 된 <xref href=&quot;System.Data.DataSet&quot;> </xref> 속성이 변경 되려고 합니다."
  syntax:
    content: protected void RaisePropertyChanging (string name);
    parameters:
    - id: name
      type: System.String
      description: "변경 하는 속성의 이름입니다."
  overload: System.Data.DataSet.RaisePropertyChanging*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.IO.Stream)
  id: ReadXml(System.IO.Stream)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(Stream)
  nameWithType: DataSet.ReadXml(Stream)
  fullName: System.Data.DataSet.ReadXml(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "XML 스키마와 데이터를는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 사용 하 여 지정 된 &lt;xref:System.IO.Stream?displayProperty=fullName&gt;합니다."
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataSet>XML 문서 로부터 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드는 스키마만 읽습니다.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 데이터 및 스미카를 읽으려면 중 하나를 사용는 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`합니다.       동일한은 대 한 적용 된 <xref:System.Data.DataSet.WriteXml%2A>및 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드를 각각.</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>       인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.       인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.      > [!NOTE] >는 `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml (&quot;_&quot;)와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.       경우에 대 한 XML 스키마는 <xref:System.Data.DataSet>포함 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A>로드 하는 <xref:System.Data.DataSet>정규화 네임 스페이스가 없는 요소가 포함 된 XML로.</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 정규화 되지 않은 요소를 읽으려면 설정 `elementFormDefault` 같은를 &quot;qualified&quot; XML 스키마에서 다음 예제에서 보여 주듯이 합니다.      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]> If에 대 한 스키마 프로그램 <xref:System.Data.DataSet>요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 <xref:System.Data.DataSet>와 <xref:System.Data.DataSet.ReadXml%2A>지정 하 여 `XmlReadMode.ReadSchema`.</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다."
  example:
  - "The following example first creates a simple <xref:System.Data.DataSet> with one <xref:System.Data.DataTable>, two columns, and ten rows. The <xref:System.Data.DataSet> schema and data are written to disk by invoking the <xref:System.Data.DataSet.WriteXml%2A> method. A second <xref:System.Data.DataSet> is created and the <xref:System.Data.DataSet.ReadXml%2A> method is used to fill it with schema and data.  \n  \n [!code-cs[Classic WebData DataSet.ReadXml1 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_7_1.cs)]\n [!code-vb[Classic WebData DataSet.ReadXml1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_7_1.vb)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "<xref:System.IO.Stream>.</xref:System.IO.Stream> 에서 파생 되는 개체"
    return:
      type: System.Data.XmlReadMode
      description: "<xref href=&quot;System.Data.XmlReadMode&quot;> </xref> 데이터를 읽는 데 사용 합니다."
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.IO.TextReader)
  id: ReadXml(System.IO.TextReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(TextReader)
  nameWithType: DataSet.ReadXml(TextReader)
  fullName: System.Data.DataSet.ReadXml(TextReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "XML 스키마와 데이터를는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 사용 하 여 지정 된 &lt;xref:System.IO.TextReader?displayProperty=fullName&gt;합니다."
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataSet>XML 문서 로부터 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드는 스키마만 읽습니다.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 데이터 및 스미카를 읽으려면 중 하나를 사용는 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`합니다.       동일한은 대 한 적용 된 <xref:System.Data.DataSet.WriteXml%2A>및 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드를 각각.</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>       인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.       인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.      > [!NOTE] >는 `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml (&quot;_&quot;)와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.       경우에 대 한 XML 스키마는 <xref:System.Data.DataSet>포함 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A>로드 하는 <xref:System.Data.DataSet>정규화 네임 스페이스가 없는 요소가 포함 된 XML로.</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 정규화 되지 않은 요소를 읽으려면 설정 `elementFormDefault` 같은를 &quot;qualified&quot; XML 스키마에서 다음 예제에서 보여 주듯이 합니다.      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```클래스에서 상속 되는 <xref:System.IO.TextReader>클래스에 포함 된 <xref:System.IO.StreamReader>및 <xref:System.IO.StringReader>클래스.</xref:System.IO.StringReader> </xref:System.IO.StreamReader> </xref:System.IO.TextReader>      > [!NOTE] > 하는 경우에 대 한 스키마 프로그램 <xref:System.Data.DataSet>요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 <xref:System.Data.DataSet>와 <xref:System.Data.DataSet.ReadXml%2A>지정 하 여 `XmlReadMode.ReadSchema`.</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다."
  example:
  - "The following example first creates a simple <xref:System.Data.DataSet> with one <xref:System.Data.DataTable>, two columns, and ten rows. The <xref:System.Data.DataSet> schema and data are written to disk by invoking the <xref:System.Data.DataSet.WriteXml%2A> method. A second <xref:System.Data.DataSet> is created and the <xref:System.Data.DataSet.ReadXml%2A> method is used to fill it with schema and data.  \n  \n [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_3_1.vb)]\n [!code-cs[Classic WebData DataSet.ReadXml2 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_3_1.cs)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);
    parameters:
    - id: reader
      type: System.IO.TextReader
      description: "<xref uid=&quot;langword_csharp_TextReader&quot; name=&quot;TextReader&quot; href=&quot;&quot;> </xref> 스키마와 데이터를 읽을 수입니다."
    return:
      type: System.Data.XmlReadMode
      description: "<xref href=&quot;System.Data.XmlReadMode&quot;> </xref> 데이터를 읽는 데 사용 합니다."
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.String)
  id: ReadXml(System.String)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(String)
  nameWithType: DataSet.ReadXml(String)
  fullName: System.Data.DataSet.ReadXml(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "XML 스키마와 데이터를는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 지정된 된 파일을 사용 하 여 합니다."
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataSet>XML 문서 로부터 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드는 스키마만 읽습니다.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 데이터 및 스미카를 읽으려면 중 하나를 사용는 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`합니다.       동일한은 대 한 적용 된 <xref:System.Data.DataSet.WriteXml%2A>및 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드를 각각.</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>       인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.       인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.      > [!NOTE] >는 `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml (&quot;_&quot;)와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.       경우에 대 한 XML 스키마는 <xref:System.Data.DataSet>포함는 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A>로드 하는 <xref:System.Data.DataSet>정규화 네임 스페이스가 없는 요소가 포함 된 XML로.</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 정규화 되지 않은 요소를 읽으려면 설정 `elementFormDefault` 같은를 &quot;qualified&quot; XML 스키마에서 다음 예제에서 보여 주듯이 합니다.      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]> If에 대 한 스키마 프로그램 <xref:System.Data.DataSet>요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 <xref:System.Data.DataSet>와 <xref:System.Data.DataSet.ReadXml%2A>지정 하 여 `XmlReadMode.ReadSchema`.</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다."
  example:
  - "The following example first creates a simple <xref:System.Data.DataSet> with one <xref:System.Data.DataTable>, two columns, and ten rows. The <xref:System.Data.DataSet> schema and data are written to disk by invoking the <xref:System.Data.DataSet.WriteXml%2A> method. A second <xref:System.Data.DataSet> is created and the <xref:System.Data.DataSet.ReadXml%2A> method is used to fill it with schema and data.  \n  \n [!code-cs[Classic WebData DataSet.ReadXml3 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_1_1.cs)]\n [!code-vb[Classic WebData DataSet.ReadXml3 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_1_1.vb)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "파일 이름 (경로 포함) 스트림입니다."
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref> 데이터를 읽는 데 사용 합니다."
  overload: System.Data.DataSet.ReadXml*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>로 설정 되지 않은 <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.Xml.XmlReader)
  id: ReadXml(System.Xml.XmlReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(XmlReader)
  nameWithType: DataSet.ReadXml(XmlReader)
  fullName: System.Data.DataSet.ReadXml(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "XML 스키마와 데이터를는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 사용 하 여 지정 된 &lt;xref:System.Xml.XmlReader?displayProperty=fullName&gt;합니다."
  remarks: "ReadXml 메서드에 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataSet>XML 문서 로부터 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드는 스키마만 읽습니다.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> 데이터 및 스미카를 읽으려면 중 하나를 사용는 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`합니다.       동일한은 대 한 적용 된 <xref:System.Data.DataSet.WriteXml%2A>및 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드를 각각.</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>       인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.       인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.      > [!NOTE] >는 `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml (&quot;_&quot;)와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.       경우에 대 한 XML 스키마는 <xref:System.Data.DataSet>포함 한 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및 ReadXml 로드를 호출할 때 예외가 발생할 수 있습니다는 <xref:System.Data.DataSet>정규화 네임 스페이스가 없는 요소가 포함 된 XML로.</xref:System.Data.DataSet> </xref:System.Data.DataSet> 정규화 되지 않은 요소를 읽으려면 설정 `elementFormDefault` 같은를 &quot;qualified&quot; XML 스키마에서 다음 예제에서 보여 주듯이 합니다.      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```       <xref:System.Xml.XmlTextReader?displayProperty=fullName><xref:System.Xml.XmlReader>.</xref:System.Xml.XmlReader> 에서 상속</xref:System.Xml.XmlTextReader?displayProperty=fullName>      > [!NOTE] > 경우에 대 한 스키마 프로그램 <xref:System.Data.DataSet>요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 <xref:System.Data.DataSet>지정 하 여 ReadXml와 `XmlReadMode.ReadSchema`.</xref:System.Data.DataSet> </xref:System.Data.DataSet> .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다."
  example:
  - "The following example first creates a simple <xref:System.Data.DataSet> with one <xref:System.Data.DataTable>, two columns, and ten rows. The <xref:System.Data.DataSet> schema and data are written to disk by invoking the <xref:System.Data.DataSet.WriteXml%2A> method. A second <xref:System.Data.DataSet> is created and the ReadXml method is used to fill it with schema and data.  \n  \n [!code-cs[Classic WebData DataSet.ReadXml Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_2_1.cs)]\n [!code-vb[Classic WebData DataSet.ReadXml Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_2_1.vb)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>읽을.</xref:System.Xml.XmlReader>"
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref> 데이터를 읽는 데 사용 합니다."
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)
  id: ReadXml(System.IO.Stream,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(Stream,XmlReadMode)
  nameWithType: DataSet.ReadXml(Stream,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(Stream,XmlReadMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "XML 스키마와 데이터를는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 사용 하 여 지정 된 &lt;xref:System.IO.Stream?displayProperty=fullName&gt; 및 <xref href=&quot;System.Data.XmlReadMode&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataSet>XML 문서 로부터 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드는 스키마만 읽습니다.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 데이터 및 스미카를 읽으려면 중 하나를 사용는 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`합니다.       에 마찬가지입니다는 <xref:System.Data.DataSet.WriteXml%2A>및 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드를 각각.</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.      > [!NOTE] > ReadXml을 사용 하 고 설정한 <xref:System.Data.XmlReadMode>를 `Diffgram`, 대상의 내용을 `DataSet` 과 원래 `DataSet` diffgram 생성 되 고 처리 되는 방식으로 인해 달라질 수 있습니다.</xref:System.Data.XmlReadMode> Diffgram에 대 한 자세한 내용은 참조 하십시오. [Diffgram](~/add/includes/ajax-current-ext-md.md)합니다.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>       인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.       인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.      > [!NOTE] >는 `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml (&quot;_&quot;)와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.       경우에 대 한 XML 스키마는 <xref:System.Data.DataSet>포함 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A>로드 하는 <xref:System.Data.DataSet>정규화 네임 스페이스가 없는 요소가 포함 된 XML로.</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 정규화 되지 않은 요소를 읽으려면 설정 `elementFormDefault` 같은를 &quot;qualified&quot; XML 스키마에서 다음 예제에서 보여 주듯이 합니다.      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]> If에 대 한 스키마 프로그램 <xref:System.Data.DataSet>요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 <xref:System.Data.DataSet>와 <xref:System.Data.DataSet.ReadXml%2A>지정 하 여 `XmlReadMode.ReadSchema`.</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다."
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "<xref:System.IO.Stream>읽을.</xref:System.IO.Stream>"
    - id: mode
      type: System.Data.XmlReadMode
      description: "중 하나는 <xref href=&quot;System.Data.XmlReadMode&quot;> </xref> 값입니다."
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref> 데이터를 읽는 데 사용 합니다."
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)
  id: ReadXml(System.IO.TextReader,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(TextReader,XmlReadMode)
  nameWithType: DataSet.ReadXml(TextReader,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(TextReader,XmlReadMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "XML 스키마와 데이터를는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 사용 하 여 지정 된 &lt;xref:System.IO.TextReader?displayProperty=fullName&gt; 및 <xref href=&quot;System.Data.XmlReadMode&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataSet>XML 문서 로부터 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드는 스키마만 읽습니다.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 데이터 및 스미카를 읽으려면 중 하나를 사용는 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`합니다.       동일한은 대 한 적용 된 <xref:System.Data.DataSet.WriteXml%2A>및 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드를 각각.</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>       인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.       인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.      > [!NOTE] >는 `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml (&quot;_&quot;)와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.       경우에 대 한 XML 스키마는 <xref:System.Data.DataSet>포함 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A>로드 하는 <xref:System.Data.DataSet>정규화 네임 스페이스가 없는 요소가 포함 된 XML로.</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 정규화 되지 않은 요소를 읽으려면 설정 `elementFormDefault` 같은를 &quot;qualified&quot; XML 스키마에서 다음 예제에서 보여 주듯이 합니다.      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]> If에 대 한 스키마 프로그램 <xref:System.Data.DataSet>요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 <xref:System.Data.DataSet>와 <xref:System.Data.DataSet.ReadXml%2A>지정 하 여 `XmlReadMode.ReadSchema`.</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다."
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);
    parameters:
    - id: reader
      type: System.IO.TextReader
      description: "<xref:System.IO.TextReader>읽을.</xref:System.IO.TextReader>"
    - id: mode
      type: System.Data.XmlReadMode
      description: "중 하나는 <xref href=&quot;System.Data.XmlReadMode&quot;> </xref> 값입니다."
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref> 데이터를 읽는 데 사용 합니다."
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)
  id: ReadXml(System.String,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(String,XmlReadMode)
  nameWithType: DataSet.ReadXml(String,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(String,XmlReadMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "XML 스키마와 데이터를는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 지정된 된 파일을 사용 하 여 및 <xref href=&quot;System.Data.XmlReadMode&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataSet>XML 문서 로부터 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드는 스키마만 읽습니다.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 데이터 및 스미카를 읽으려면 중 하나를 사용는 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`합니다.       동일한은 대 한 적용 된 <xref:System.Data.DataSet.WriteXml%2A>및 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드를 각각.</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>       인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.       인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.      > [!NOTE] >는 `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml (&quot;_&quot;)와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.       경우에 대 한 XML 스키마는 <xref:System.Data.DataSet>포함는 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A>로드 하는 <xref:System.Data.DataSet>정규화 네임 스페이스가 없는 요소가 포함 된 XML로.</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 정규화 되지 않은 요소를 읽으려면 설정 `elementFormDefault` 같은를 &quot;qualified&quot; XML 스키마에서 다음 예제에서 보여 주듯이 합니다.      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]> If에 대 한 스키마 프로그램 <xref:System.Data.DataSet>요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 <xref:System.Data.DataSet>와 <xref:System.Data.DataSet.ReadXml%2A>지정 하 여 `XmlReadMode.ReadSchema`.</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다."
  syntax:
    content: public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);
    parameters:
    - id: fileName
      type: System.String
      description: "파일 이름 (경로 포함) 스트림입니다."
    - id: mode
      type: System.Data.XmlReadMode
      description: "중 하나는 <xref href=&quot;System.Data.XmlReadMode&quot;> </xref> 값입니다."
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref> 데이터를 읽는 데 사용 합니다."
  overload: System.Data.DataSet.ReadXml*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>로 설정 되지 않은 <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)
  id: ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(XmlReader,XmlReadMode)
  nameWithType: DataSet.ReadXml(XmlReader,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(XmlReader,XmlReadMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "XML 스키마와 데이터를는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 사용 하 여 지정 된 &lt;xref:System.Xml.XmlReader?displayProperty=fullName&gt; 및 <xref href=&quot;System.Data.XmlReadMode&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataSet>XML 문서 로부터 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드는 스키마만 읽습니다.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 데이터 및 스미카를 읽으려면 중 하나를 사용는 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`합니다.       동일한은 대 한 적용 된 <xref:System.Data.DataSet.WriteXml%2A>및 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드를 각각.</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>       인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.       인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.      > [!NOTE] >는 `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml (&quot;_&quot;)와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.       경우에 대 한 XML 스키마는 <xref:System.Data.DataSet>포함는 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A>로드 하는 <xref:System.Data.DataSet>정규화 네임 스페이스가 없는 요소가 포함 된 XML로.</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 정규화 되지 않은 요소를 읽으려면 설정 `elementFormDefault` 같은를 &quot;qualified&quot; XML 스키마에서 다음 예제에서 보여 주듯이 합니다.      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]> If에 대 한 스키마 프로그램 <xref:System.Data.DataSet>요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 <xref:System.Data.DataSet>와 <xref:System.Data.DataSet.ReadXml%2A>지정 하 여 `XmlReadMode.ReadSchema`.</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다."
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>읽을.</xref:System.Xml.XmlReader>"
    - id: mode
      type: System.Data.XmlReadMode
      description: "중 하나는 <xref href=&quot;System.Data.XmlReadMode&quot;> </xref> 값입니다."
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref> 데이터를 읽는 데 사용 합니다."
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXmlSchema(System.IO.Stream)
  id: ReadXmlSchema(System.IO.Stream)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXmlSchema(Stream)
  nameWithType: DataSet.ReadXmlSchema(Stream)
  fullName: System.Data.DataSet.ReadXmlSchema(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "지정 된 위치에서 XML 스키마를 읽고 <xref:System.IO.Stream>에 <xref href=&quot;System.Data.DataSet&quot;> </xref>.</xref:System.IO.Stream>"
  remarks: "<xref:System.Data.DataSet.ReadXmlSchema%2A> <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 에 대 한 스키마를 만드는 메서드를</xref:System.Data.DataSet.ReadXmlSchema%2A> 사용 하 여 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다. 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드.</xref:System.Data.DataSet.WriteXmlSchema%2A>       XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.      > [!NOTE] > Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.       <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드는 일반적으로 <xref:System.Data.DataSet.ReadXml%2A> <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 를 채우는 데 사용 되는 메서드</xref:System.Data.DataSet.ReadXml%2A> 를 호출 하기 전에 호출 됩니다.</xref:System.Data.DataSet.ReadXmlSchema%2A>       파생 된 클래스는 <xref:System.IO.Stream>클래스 포함 <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, 및 <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.MemoryStream> </xref:System.IO.FileStream> </xref:System.IO.BufferedStream> </xref:System.IO.Stream>      > [!NOTE] > 경우 스키마에 대 한 프로그램 <xref:System.Data.DataSet>요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 예외가 throw 스키마는 into <xref:System.Data.DataSet> <xref:System.Data.DataSet.ReadXmlSchema%2A>.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> 읽을 하려고 할 때</xref:System.Data.DataSet> .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다."
  example:
  - "The following example creates a <xref:System.IO.FileStream> object to read an XML schema with, and invokes the <xref:System.Data.DataSet.ReadXmlSchema%2A> method with the object.  \n  \n [!code-cs[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_5_1.cs)]\n [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_5_1.vb)]"
  syntax:
    content: public void ReadXmlSchema (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "<xref:System.IO.Stream>읽을.</xref:System.IO.Stream>"
  overload: System.Data.DataSet.ReadXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)
  id: ReadXmlSchema(System.IO.TextReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXmlSchema(TextReader)
  nameWithType: DataSet.ReadXmlSchema(TextReader)
  fullName: System.Data.DataSet.ReadXmlSchema(TextReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "지정 된 위치에서 XML 스키마를 읽고 <xref:System.IO.TextReader>에 <xref href=&quot;System.Data.DataSet&quot;> </xref>.</xref:System.IO.TextReader>"
  remarks: "<xref:System.Data.DataSet.ReadXmlSchema%2A> <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 에 대 한 스키마를 만드는 메서드를</xref:System.Data.DataSet.ReadXmlSchema%2A> 사용 하 여 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다. 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드.</xref:System.Data.DataSet.WriteXmlSchema%2A>       XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.      > [!NOTE] > Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.       <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드는 일반적으로 <xref:System.Data.DataSet.ReadXml%2A> <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 를 채우는 데 사용 되는 메서드</xref:System.Data.DataSet.ReadXml%2A> 를 호출 하기 전에 호출 됩니다.</xref:System.Data.DataSet.ReadXmlSchema%2A>       클래스에서 상속 되는 <xref:System.IO.TextReader>클래스에 포함 된 <xref:System.IO.StreamReader>및 <xref:System.IO.StringReader>클래스.</xref:System.IO.StringReader> </xref:System.IO.StreamReader> </xref:System.IO.TextReader>      > [!NOTE] > 경우 스키마에 대 한 프로그램 <xref:System.Data.DataSet>요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 예외가 throw 스키마는 into <xref:System.Data.DataSet> <xref:System.Data.DataSet.ReadXmlSchema%2A>.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> 읽을 하려고 할 때</xref:System.Data.DataSet> .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다."
  example:
  - "The following example creates a <xref:System.IO.StreamReader> object to read a schema with, and invokes the <xref:System.Data.DataSet.ReadXmlSchema%2A> method with the object.  \n  \n [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_8_1.vb)]\n [!code-cs[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_8_1.cs)]"
  syntax:
    content: public void ReadXmlSchema (System.IO.TextReader reader);
    parameters:
    - id: reader
      type: System.IO.TextReader
      description: "<xref:System.IO.TextReader>읽을.</xref:System.IO.TextReader>"
  overload: System.Data.DataSet.ReadXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXmlSchema(System.String)
  id: ReadXmlSchema(System.String)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXmlSchema(String)
  nameWithType: DataSet.ReadXmlSchema(String)
  fullName: System.Data.DataSet.ReadXmlSchema(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 지정된 된 파일에서 XML 스키마를 읽고는 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  remarks: "<xref:System.Data.DataSet.ReadXmlSchema%2A> <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 에 대 한 스키마를 만드는 메서드를</xref:System.Data.DataSet.ReadXmlSchema%2A> 사용 하 여 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다. 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드.</xref:System.Data.DataSet.WriteXmlSchema%2A>       XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.      > [!NOTE] > Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.       <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드는 일반적으로 <xref:System.Data.DataSet.ReadXml%2A> <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 를 채우는 데 사용 되는 메서드</xref:System.Data.DataSet.ReadXml%2A> 를 호출 하기 전에 호출 됩니다.</xref:System.Data.DataSet.ReadXmlSchema%2A>      > [!NOTE] > 경우 스키마에 대 한 프로그램 <xref:System.Data.DataSet>요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마는 into <xref:System.Data.DataSet> <xref:System.Data.DataSet.ReadXmlSchema%2A>.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> 읽을 하려고 할 때 예외가 throw 됩니다</xref:System.Data.DataSet> .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다."
  example:
  - >-
    [!code-cs[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_0_1.cs)]
     [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_0_1.vb)]
  syntax:
    content: public void ReadXmlSchema (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "파일을 읽어올 이름 (경로 포함)."
  overload: System.Data.DataSet.ReadXmlSchema*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>로 설정 되지 않은 <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)
  id: ReadXmlSchema(System.Xml.XmlReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXmlSchema(XmlReader)
  nameWithType: DataSet.ReadXmlSchema(XmlReader)
  fullName: System.Data.DataSet.ReadXmlSchema(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "지정 된 위치에서 XML 스키마를 읽고 <xref:System.Xml.XmlReader>에 <xref href=&quot;System.Data.DataSet&quot;> </xref>.</xref:System.Xml.XmlReader>"
  remarks: "ReadXmlSchema 메서드를 사용 하 여에 <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 에 대 한 스키마를 만들려면 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.       XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.      > [!NOTE] > Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.       일반적으로 ReadXmlSchema 메서드 <xref:System.Data.DataSet.ReadXml%2A> <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 를 채우는 데 사용 되는 메서드</xref:System.Data.DataSet.ReadXml%2A> 를 호출 하기 전에 호출       <xref:System.Xml.XmlReader?displayProperty=fullName>클래스는 추상 클래스입니다.</xref:System.Xml.XmlReader?displayProperty=fullName> 상속 되는 클래스는 `XmlReader` <xref:System.Xml.XmlTextReader?displayProperty=fullName>클래스</xref:System.Xml.XmlTextReader?displayProperty=fullName> 입니다.      > [!NOTE] > 하는 경우에 대 한 스키마 프로그램 <xref:System.Data.DataSet>요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 예외가 throw에 스키마를 읽을 때는 <xref:System.Data.DataSet>ReadXmlSchema와.</xref:System.Data.DataSet> </xref:System.Data.DataSet> .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다."
  example:
  - "The following example creates a new <xref:System.Data.DataSet> and <xref:System.IO.FileStream?displayProperty=fullName> object. The <xref:System.IO.FileStream> object, created with a file path and file name, is used to create an <xref:System.Xml.XmlTextReader?displayProperty=fullName> that is passed as an argument to the ReadXmlSchema method.  \n  \n [!code-vb[Classic WebData DataSet.ReadXmlSchema Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_4_1.vb)]\n [!code-cs[Classic WebData DataSet.ReadXmlSchema Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_4_1.cs)]"
  syntax:
    content: public void ReadXmlSchema (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>읽을.</xref:System.Xml.XmlReader>"
  overload: System.Data.DataSet.ReadXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)
  id: ReadXmlSerializable(System.Xml.XmlReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXmlSerializable(XmlReader)
  nameWithType: DataSet.ReadXmlSerializable(XmlReader)
  fullName: System.Data.DataSet.ReadXmlSerializable(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "특성을 무시 하 고 빈 데이터 집합을 반환 합니다."
  syntax:
    content: protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "지정 된 XML 판독기입니다."
  overload: System.Data.DataSet.ReadXmlSerializable*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.RejectChanges
  id: RejectChanges
  parent: System.Data.DataSet
  langs:
  - csharp
  name: RejectChanges()
  nameWithType: DataSet.RejectChanges()
  fullName: System.Data.DataSet.RejectChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 대 한 모든 변경 사항을 롤백합니다는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 만들어진 이후 또는 마지막으로 이후에 &lt;xref:System.Data.DataSet.AcceptChanges%2A?displayProperty=fullName&gt; 호출 되었습니다."
  remarks: "<xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName>모든 <xref:System.Data.DataTable> <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 에 포함 된 개체에서</xref:System.Data.DataTable> 메서드</xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName> 를 호출합니다 하려면 RejectChanges 호출       <xref:System.Data.DataRow>에 포함 된 개체는 <xref:System.Data.DataSet>를 호출 하 여 편집 모드로 설정할 수 있습니다는 <xref:System.Data.DataRow.BeginEdit%2A?displayProperty=fullName>메서드.</xref:System.Data.DataRow.BeginEdit%2A?displayProperty=fullName> </xref:System.Data.DataSet></xref:System.Data.DataRow> 호출 후의 <xref:System.Data.DataRow.EndEdit%2A?displayProperty=fullName>메서드를 호출 하 여 변경 내용이 거부 될 수 있습니다는 <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName>에 <xref:System.Data.DataTable>입니다는 <xref:System.Data.DataRow>개체 속합니다.</xref:System.Data.DataRow> </xref:System.Data.DataTable> </xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName> </xref:System.Data.DataRow.EndEdit%2A?displayProperty=fullName>       경우는 <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName>메서드가 호출 되 면 행이 편집 모드에 계속 편집이 취소 됩니다.</xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName> 새 행이 제거 됩니다. 원래 상태로 다시 수정 및 삭제 된 행을 반환 합니다. (`DataRowState.Unchanged`).       AcceptChanges 및 RejectChanges에만 적용 <xref:System.Data.DataRow>관련 변경 내용 (즉, `Add`, `Remove`, `Delete`, 및 `Modify`).</xref:System.Data.DataRow> 스키마 나 구조 변경 내용을 적용 되지 않습니다."
  example:
  - "The following example shows a class derived from the <xref:System.Data.DataSet> class. The RejectChanges event is invoked from within a function.  \n  \n [!code-cs[Classic WebData DataSet.RejectChanges Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_6_1.cs)]\n [!code-vb[Classic WebData DataSet.RejectChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_6_1.vb)]"
  syntax:
    content: public virtual void RejectChanges ();
    parameters: []
  overload: System.Data.DataSet.RejectChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Relations
  id: Relations
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Relations
  nameWithType: DataSet.Relations
  fullName: System.Data.DataSet.Relations
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "테이블에 연결 하 고 탐색 부모에서 자식 테이블에는 테이블을 허용 하는 관계의 컬렉션을 가져옵니다."
  remarks: ''
  example:
  - "The following example prints the column name of all child tables through the Relations property.  \n  \n [!code-vb[Classic WebData DataSet.Relations Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.re_1.vb)]"
  syntax:
    content: public System.Data.DataRelationCollection Relations { get; }
    return:
      type: System.Data.DataRelationCollection
      description: "A <xref href=&quot;System.Data.DataRelationCollection&quot;> </xref> 의 컬렉션을 포함 하는 <xref href=&quot;System.Data.DataRelation&quot;> </xref> 개체입니다. 없는 경우에 빈 컬렉션이 반환 됩니다 <xref href=&quot;System.Data.DataRelation&quot;> </xref> 개체가 존재 합니다."
  overload: System.Data.DataSet.Relations*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.RemotingFormat
  id: RemotingFormat
  parent: System.Data.DataSet
  langs:
  - csharp
  name: RemotingFormat
  nameWithType: DataSet.RemotingFormat
  fullName: System.Data.DataSet.RemotingFormat
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "가져오거나는 <xref href=&quot;System.Data.SerializationFormat&quot;> </xref> 에 대 한는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 원격 작업 중에 사용 합니다."
  syntax:
    content: public System.Data.SerializationFormat RemotingFormat { get; set; }
    return:
      type: System.Data.SerializationFormat
      description: "A <xref href=&quot;System.Data.SerializationFormat&quot;></xref> object."
  overload: System.Data.DataSet.RemotingFormat*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Reset
  id: Reset
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Reset()
  nameWithType: DataSet.Reset()
  fullName: System.Data.DataSet.Reset()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "모든 테이블을 지우고 모든 관계, 외부 제약 조건 및 테이블에서 제거 된 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다. 서브 클래스를 복원 하려면 다시 설정 재정의 해야는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 원래 상태로 있습니다."
  syntax:
    content: public virtual void Reset ();
    parameters: []
  overload: System.Data.DataSet.Reset*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.SchemaSerializationMode
  id: SchemaSerializationMode
  parent: System.Data.DataSet
  langs:
  - csharp
  name: SchemaSerializationMode
  nameWithType: DataSet.SchemaSerializationMode
  fullName: System.Data.DataSet.SchemaSerializationMode
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Gets or sets a <xref href=&quot;System.Data.SchemaSerializationMode&quot;></xref> for a <xref href=&quot;System.Data.DataSet&quot;></xref>."
  remarks: "A <xref:System.Data.DataSet>웹 서비스 및 원격 시나리오에 기본적으로 해당 스키마 및 인스턴스 데이터를 serialize 합니다.</xref:System.Data.DataSet> 형식화 된 SchemaSerializationMode 속성을 설정 `DataSet` 를 <xref:System.Data.SchemaSerializationMode>serialization 페이로드에서 제외 되어야 하는 스키마 정보로 인해.</xref:System.Data.SchemaSerializationMode>       <xref:System.Data.SchemaSerializationMode>지원 되는 형식화 된에 대해서만 `DataSet`합니다.</xref:System.Data.SchemaSerializationMode> 형식화 되지 않은 `DataSet` 시키면 <xref:System.Data.SchemaSerializationMode>.</xref:System.Data.SchemaSerializationMode> 이 속성       <xref:System.Data.SchemaSerializationMode>기본 스키마 정보를 입력 한 경우에만 사용 해야 `DataTables`, `DataRelations` 및 `Constraints` 수정 되지 않았습니다.</xref:System.Data.SchemaSerializationMode> <xref:System.Data.SchemaSerializationMode>.</xref:System.Data.SchemaSerializationMode> 완료, 오류가 발생 했습니다 스키마 정보를 serialize 해야 수정 작업이 필요한 경우       <xref:System.Data.SchemaSerializationMode>2.0 이상 버전의.NET Framework에서 지원 됩니다.</xref:System.Data.SchemaSerializationMode>       때 <xref:System.Data.SchemaSerializationMode>설정 되어만 최상위 수준 런타임 속성에는 <xref:System.Data.DataSet>serialize 됩니다.</xref:System.Data.DataSet> </xref:System.Data.SchemaSerializationMode> 또한 기본 값과에서 다를 경우에 serialize 됩니다. 중에서 `Tables`, `Relations` 또는 `Constraints` serialize 됩니다. Serialize 된 런타임 속성에 포함 <xref:System.Data.DataSet.DataSetName%2A>, <xref:System.Data.DataSet.Namespace%2A>, <xref:System.Data.DataSet.Prefix%2A>, <xref:System.Data.DataSet.Locale%2A>, <xref:System.Data.DataSet.EnforceConstraints%2A>, 및 <xref:System.Data.DataSet.CaseSensitive%2A>.</xref:System.Data.DataSet.CaseSensitive%2A> </xref:System.Data.DataSet.EnforceConstraints%2A> </xref:System.Data.DataSet.Locale%2A> </xref:System.Data.DataSet.Prefix%2A> </xref:System.Data.DataSet.Namespace%2A> </xref:System.Data.DataSet.DataSetName%2A> 이러한 속성은 전체 런타임 데이터 무결성이 유지 되도록 serialize 됩니다."
  syntax:
    content: public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }
    return:
      type: System.Data.SchemaSerializationMode
      description: "Gets or sets a <xref href=&quot;System.Data.SchemaSerializationMode&quot;></xref> for a <xref href=&quot;System.Data.DataSet&quot;></xref>."
  overload: System.Data.DataSet.SchemaSerializationMode*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ShouldSerializeRelations
  id: ShouldSerializeRelations
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ShouldSerializeRelations()
  nameWithType: DataSet.ShouldSerializeRelations()
  fullName: System.Data.DataSet.ShouldSerializeRelations()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "나타내는 값을 가져옵니다 여부 <xref:System.Data.DataSet.Relations*>속성을 유지 해야 합니다.</xref:System.Data.DataSet.Relations*>"
  remarks: "일반적으로이 방법을 사용 하면 중 하나에 대 한 디자이너를 만드는 경우는 <xref:System.Data.DataSet>, <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 를 통합 하는 사용자 지정 컨트롤 또는</xref:System.Data.DataSet>"
  example:
  - "The following examples show a class derived from the <xref:System.Data.DataSet> class. The <xref:System.Data.DataSet.Reset%2A> and ShouldSerializeRelations methods are invoked from within functions in the derived class.  \n  \n [!code-cs[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/add/codesnippet/csharp/m-system.data.dataset.sh_3_1.cs)]\n [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.sh_3_1.vb)]"
  syntax:
    content: protected virtual bool ShouldSerializeRelations ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>속성 값이 기본값에서 변경 된 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataSet.ShouldSerializeRelations*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ShouldSerializeTables
  id: ShouldSerializeTables
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ShouldSerializeTables()
  nameWithType: DataSet.ShouldSerializeTables()
  fullName: System.Data.DataSet.ShouldSerializeTables()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "나타내는 값을 가져옵니다 여부 <xref:System.Data.DataSet.Tables*>속성을 유지 해야 합니다.</xref:System.Data.DataSet.Tables*>"
  remarks: "에 대 한 디자이너를 만들거나 하는 경우에이 메서드를 일반적으로 사용 된 <xref:System.Data.DataSet>, <xref:System.Data.DataSet>.</xref:System.Data.DataSet> 를 통합 하는 사용자 지정 컨트롤 또는</xref:System.Data.DataSet>"
  example:
  - "The following example shows a class derived from the <xref:System.Data.DataSet> class. The ShouldSerializeTables method is called from within functions in the derived class.  \n  \n [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.sh_2_1.vb)]\n [!code-cs[Classic WebData DataSet.ShouldSerializeTables Example#1](~/add/codesnippet/csharp/m-system.data.dataset.sh_2_1.cs)]"
  syntax:
    content: protected virtual bool ShouldSerializeTables ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>속성 값이 기본값에서 변경 된 경우 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.DataSet.ShouldSerializeTables*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Site
  id: Site
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Site
  nameWithType: DataSet.Site
  fullName: System.Data.DataSet.Site
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "가져오거나는 <xref href=&quot;System.ComponentModel.ISite&quot;> </xref> 에 대 한는 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  remarks: "사이트 바인딩는 <xref:System.ComponentModel.Component>에 <xref:System.ComponentModel.Container>서로 통신할 수 있도록 할 뿐만 아니라 컨테이너에서 해당 구성 요소를 관리할 수 있는 방법을 제공 합니다.</xref:System.ComponentModel.Container> </xref:System.ComponentModel.Component>"
  syntax:
    content: public override System.ComponentModel.ISite Site { get; set; }
    return:
      type: System.ComponentModel.ISite
      description: "An <xref href=&quot;System.ComponentModel.ISite&quot;></xref> for the <xref href=&quot;System.Data.DataSet&quot;></xref>."
  overload: System.Data.DataSet.Site*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection
  id: System#ComponentModel#IListSource#ContainsListCollection
  isEii: true
  parent: System.Data.DataSet
  langs:
  - csharp
  name: System.ComponentModel.IListSource.ContainsListCollection
  nameWithType: DataSet.System.ComponentModel.IListSource.ContainsListCollection
  fullName: System.Data.DataSet.System.ComponentModel.IListSource.ContainsListCollection
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 멤버에 대 한 참조 &lt;xref:System.ComponentModel.IListSource.ContainsListCollection%2A?displayProperty=fullName&gt;합니다."
  remarks: "이 멤버는 명시적 인터페이스 멤버 구현 이며 사용할 수 있습니다 경우에만 <xref:System.Data.DataSet>인스턴스로 캐스팅 되는 <xref:System.ComponentModel.IListSource>인터페이스.</xref:System.ComponentModel.IListSource> </xref:System.Data.DataSet>"
  syntax:
    content: bool System.ComponentModel.IListSource.ContainsListCollection { get; }
    return:
      type: System.Boolean
      description: "이 멤버에 대 한 참조 &lt;xref:System.ComponentModel.IListSource.ContainsListCollection%2A?displayProperty=fullName&gt;합니다."
  overload: System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.System#ComponentModel#IListSource#GetList
  id: System#ComponentModel#IListSource#GetList
  isEii: true
  parent: System.Data.DataSet
  langs:
  - csharp
  name: System.ComponentModel.IListSource.GetList()
  nameWithType: DataSet.System.ComponentModel.IListSource.GetList()
  fullName: System.Data.DataSet.System.ComponentModel.IListSource.GetList()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 멤버에 대 한 참조 &lt;xref:System.ComponentModel.IListSource.GetList%2A?displayProperty=fullName&gt;합니다."
  remarks: "이 멤버는 명시적 인터페이스 멤버 구현 이며 사용할 수 있습니다 경우에만 <xref:System.Data.DataSet>인스턴스로 캐스팅 되는 <xref:System.ComponentModel.IListSource>인터페이스.</xref:System.ComponentModel.IListSource> </xref:System.Data.DataSet>"
  syntax:
    content: System.Collections.IList IListSource.GetList ();
    parameters: []
    return:
      type: System.Collections.IList
      description: "이 멤버에 대 한 참조 &lt;xref:System.ComponentModel.IListSource.GetList%2A?displayProperty=fullName&gt;합니다."
  overload: System.Data.DataSet.System#ComponentModel#IListSource#GetList*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema
  id: System#Xml#Serialization#IXmlSerializable#GetSchema
  isEii: true
  parent: System.Data.DataSet
  langs:
  - csharp
  name: System.Xml.Serialization.IXmlSerializable.GetSchema()
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.GetSchema()
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.GetSchema()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 멤버에 대 한 참조 &lt;xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A?displayProperty=fullName&gt;합니다."
  remarks: "이 멤버는 명시적 인터페이스 멤버 구현 이며 사용할 수 있습니다 경우에만 <xref:System.Data.DataSet>인스턴스로 캐스팅 되는 <xref:System.Xml.Serialization.IXmlSerializable>인터페이스.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Data.DataSet>"
  syntax:
    content: System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();
    parameters: []
    return:
      type: System.Xml.Schema.XmlSchema
      description: "이 멤버에 대 한 참조 &lt;xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A?displayProperty=fullName&gt;합니다."
  overload: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  id: System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  isEii: true
  parent: System.Data.DataSet
  langs:
  - csharp
  name: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 멤버에 대 한 참조 &lt;xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A?displayProperty=fullName&gt;합니다."
  remarks: "이 멤버는 명시적 인터페이스 멤버 구현 이며 사용할 수 있습니다 경우에만 <xref:System.Data.DataSet>인스턴스로 캐스팅 되는 <xref:System.Xml.Serialization.IXmlSerializable>인터페이스.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Data.DataSet>"
  syntax:
    content: void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "A <xref:System.Xml.XmlReader>.</xref:System.Xml.XmlReader>"
  overload: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  id: System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  isEii: true
  parent: System.Data.DataSet
  langs:
  - csharp
  name: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "이 멤버에 대 한 참조 &lt;xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A?displayProperty=fullName&gt;합니다."
  remarks: "이 멤버는 명시적 인터페이스 멤버 구현 이며 사용할 수 있습니다 경우에만 <xref:System.Data.DataSet>인스턴스로 캐스팅 되는 <xref:System.Xml.Serialization.IXmlSerializable>인터페이스.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Data.DataSet>"
  syntax:
    content: void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "A <xref:System.Xml.XmlWriter>.</xref:System.Xml.XmlWriter>"
  overload: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Tables
  id: Tables
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Tables
  nameWithType: DataSet.Tables
  fullName: System.Data.DataSet.Tables
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 포함 된 테이블의 컬렉션을 가져옵니다는 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다."
  remarks: "컬렉션에 테이블을 추가 하려면 <xref:System.Data.DataTableCollection.Add%2A> <xref:System.Data.DataTableCollection>.</xref:System.Data.DataTableCollection> 의 메서드</xref:System.Data.DataTableCollection.Add%2A> 를 사용 합니다. 사용 하 여 테이블을 제거 하려면는 <xref:System.Data.DataTableCollection.Remove%2A>메서드.</xref:System.Data.DataTableCollection.Remove%2A>"
  example:
  - "The following example returns the <xref:System.Data.DataSet> object's <xref:System.Data.DataTableCollection>, and prints the columns and rows in each table.  \n  \n [!code-vb[Classic WebData DataSet.Tables Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.ta_1.vb)]\n [!code-cs[Classic WebData DataSet.Tables Example#1](~/add/codesnippet/csharp/p-system.data.dataset.ta_1.cs)]"
  syntax:
    content: public System.Data.DataTableCollection Tables { get; }
    return:
      type: System.Data.DataTableCollection
      description: "<xref href=&quot;System.Data.DataTableCollection&quot;> </xref> 이 포함 된 <xref href=&quot;System.Data.DataSet&quot;> </xref>합니다. 없는 경우에 빈 컬렉션이 반환 됩니다 <xref href=&quot;System.Data.DataTable&quot;> </xref> 개체가 존재 합니다."
  overload: System.Data.DataSet.Tables*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.IO.Stream)
  id: WriteXml(System.IO.Stream)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(Stream)
  nameWithType: DataSet.WriteXml(Stream)
  fullName: System.Data.DataSet.WriteXml(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 데이터를 씁니다는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 사용 하 여 지정 된 &lt;xref:System.IO.Stream?displayProperty=fullName&gt;합니다."
  remarks: "`WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataSet>XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 `mode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.       동일한은 대 한 적용 된 <xref:System.Data.DataSet.ReadXml%2A>및 <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  example:
  - "The following example creates a <xref:System.IO.FileStream?displayProperty=fullName> object. The object is then used with the WriteXml method to write an XML document.  \n  \n [!code-cs[Classic WebData DataSet.WriteXml Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_2_1.cs)]\n [!code-vb[Classic WebData DataSet.WriteXml Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_2_1.vb)]"
  syntax:
    content: public void WriteXml (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "A <xref:System.IO.Stream>파일에 기록 하는 데 사용 되는 개체입니다.</xref:System.IO.Stream>"
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.IO.TextWriter)
  id: WriteXml(System.IO.TextWriter)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(TextWriter)
  nameWithType: DataSet.WriteXml(TextWriter)
  fullName: System.Data.DataSet.WriteXml(TextWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 데이터를 씁니다는 <xref href=&quot;System.Data.DataSet&quot;> </xref> <xref:System.IO.TextWriter>.</xref:System.IO.TextWriter> 지정된을 사용 하 여"
  remarks: "`WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataSet>XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 `mode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.       동일한은 대 한 적용 된 <xref:System.Data.DataSet.ReadXml%2A>및 <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.TextWriter writer);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>쓰기에 사용할 개체입니다.</xref:System.IO.TextWriter>"
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.String)
  id: WriteXml(System.String)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(String)
  nameWithType: DataSet.WriteXml(String)
  fullName: System.Data.DataSet.WriteXml(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 데이터를 씁니다는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 지정된 된 파일에 있습니다."
  remarks: "`WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataSet>XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 `mode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.       동일한은 대 한 적용 된 <xref:System.Data.DataSet.ReadXml%2A>및 <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "파일 쓰기에 사용할 이름 (경로 포함)."
  overload: System.Data.DataSet.WriteXml*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>로 설정 되지 않은 <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.Xml.XmlWriter)
  id: WriteXml(System.Xml.XmlWriter)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(XmlWriter)
  nameWithType: DataSet.WriteXml(XmlWriter)
  fullName: System.Data.DataSet.WriteXml(XmlWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "현재 데이터를 씁니다는 <xref href=&quot;System.Data.DataSet&quot;> </xref> <xref:System.Xml.XmlWriter>.</xref:System.Xml.XmlWriter> 지정"
  remarks: "`WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataSet>XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 `mode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.       동일한은 대 한 적용 된 <xref:System.Data.DataSet.ReadXml%2A>및 <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.Xml.XmlWriter writer);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>쓰기에 사용할.</xref:System.Xml.XmlWriter>"
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  id: WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(Stream,XmlWriteMode)
  nameWithType: DataSet.WriteXml(Stream,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(Stream,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 대 한 현재 데이터를 쓰고 필요에 따라 스키마를 작성은 <xref href=&quot;System.Data.DataSet&quot;> </xref> 사용 하 여 지정 된 &lt;xref:System.IO.Stream?displayProperty=fullName&gt; 및 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>합니다. 스키마를 작성 하려면 설정에 대 한 값은 <code> mode </code> 매개 변수를 <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "`WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataSet>XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 데이터와 스키마를 작성 하려면 설정는 `mode` 매개 변수를 `WriteSchema`합니다.       동일한은 대 한 적용 된 <xref:System.Data.DataSet.ReadXml%2A>및 <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "A <xref:System.IO.Stream>파일에 기록 하는 데 사용 되는 개체입니다.</xref:System.IO.Stream>"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "중 하나는 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> 값입니다."
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  id: WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(TextWriter,XmlWriteMode)
  nameWithType: DataSet.WriteXml(TextWriter,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(TextWriter,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 대 한 현재 데이터를 쓰고 필요에 따라 스키마를 작성은 <xref href=&quot;System.Data.DataSet&quot;> </xref> 사용 하 여 지정 된 <xref:System.IO.TextWriter>및 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>.</xref:System.IO.TextWriter> 스키마를 작성 하려면 설정에 대 한 값은 <code> mode </code> 매개 변수를 <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "`WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataSet>XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 데이터와 스키마를 작성 하려면 설정는 `mode` 매개 변수를 `WriteSchema`합니다.       동일한은 대 한 적용 된 <xref:System.Data.DataSet.ReadXml%2A>및 <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  example:
  - "The following example first creates a simple <xref:System.Data.DataSet> with one <xref:System.Data.DataTable>, two columns, and ten rows. The <xref:System.Data.DataSet> schema and data are written to disk by invoking the <xref:System.Data.DataSet.WriteXml%2A> method. A second <xref:System.Data.DataSet> is created and the <xref:System.Data.DataSet.ReadXml%2A> method is used to fill it with schema and data.  \n  \n [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_7_1.vb)]\n [!code-cs[Classic WebData DataSet.ReadXml2 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_7_1.cs)]"
  syntax:
    content: public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "A &lt;xref:System.IO.TextWriter?displayProperty=fullName&gt; 문서를 쓰는 데 사용 되는 개체입니다."
    - id: mode
      type: System.Data.XmlWriteMode
      description: "중 하나는 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> 값입니다."
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)
  id: WriteXml(System.String,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(String,XmlWriteMode)
  nameWithType: DataSet.WriteXml(String,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(String,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 대 한 현재 데이터 및 필요에 따라 스키마에 기록 된 <xref href=&quot;System.Data.DataSet&quot;> </xref> 사용 하 여 지정된 된 파일에 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>합니다. 스키마를 작성 하려면 설정에 대 한 값은 <code> mode </code> 매개 변수를 <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "`WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataSet>XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 데이터와 스키마를 작성 하려면 설정는 `mode` 매개 변수를 `WriteSchema`합니다.       동일한은 대 한 적용 된 <xref:System.Data.DataSet.ReadXml%2A>및 <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  example:
  - "The following example uses the <xref:System.Data.DataSet.WriteXml%2A> method to write an XML document.  \n  \n [!code-cs[Classic WebData DataSet.WriteXml7 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_3_1.cs)]\n [!code-vb[Classic WebData DataSet.WriteXml7 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_3_1.vb)]"
  syntax:
    content: public void WriteXml (string fileName, System.Data.XmlWriteMode mode);
    parameters:
    - id: fileName
      type: System.String
      description: "파일 쓰기에 사용할 이름 (경로 포함)."
    - id: mode
      type: System.Data.XmlWriteMode
      description: "중 하나는 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> 값입니다."
  overload: System.Data.DataSet.WriteXml*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>로 설정 되지 않은 <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  id: WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(XmlWriter,XmlWriteMode)
  nameWithType: DataSet.WriteXml(XmlWriter,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(XmlWriter,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "에 대 한 현재 데이터를 쓰고 필요에 따라 스키마를 작성은 <xref href=&quot;System.Data.DataSet&quot;> </xref> 사용 하 여 지정 된 <xref:System.Xml.XmlWriter>및 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>.</xref:System.Xml.XmlWriter> 스키마를 작성 하려면 설정에 대 한 값은 <code> mode </code> 매개 변수를 <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>합니다."
  remarks: "`WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataSet>XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드는 스키마만 씁니다.</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 데이터와 스키마를 작성 하려면 설정는 `mode` 매개 변수를 `WriteSchema`합니다.       동일한은 대 한 적용 된 <xref:System.Data.DataSet.ReadXml%2A>및 <xref:System.Data.DataSet.ReadXmlSchema%2A>메서드를 각각.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.      > [!NOTE] >는 <xref:System.InvalidOperationException>경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 implements <xref:System.Dynamic.IDynamicMetaObjectProvider> <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> 를 구현 하지 않으므로</xref:System.Dynamic.IDynamicMetaObjectProvider> 에 기록 되 고</xref:System.InvalidOperationException>"
  example:
  - "The following example creates a <xref:System.IO.FileStream?displayProperty=fullName> object that is used to create a new <xref:System.Xml.XmlTextWriter?displayProperty=fullName>. The <xref:System.Xml.XmlTextWriter> object is used with the <xref:System.Data.DataSet.WriteXml%2A> method to write an XML document.  \n  \n [!code-cs[Classic WebData DataSet.WriteXml6 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_1_1.cs)]\n [!code-vb[Classic WebData DataSet.WriteXml6 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_1_1.vb)]"
  syntax:
    content: public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>쓰기에 사용할.</xref:System.Xml.XmlWriter>"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "중 하나는 <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> 값입니다."
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.Stream)
  id: WriteXmlSchema(System.IO.Stream)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(Stream)
  nameWithType: DataSet.WriteXmlSchema(Stream)
  fullName: System.Data.DataSet.WriteXmlSchema(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "기록 된 <xref href=&quot;System.Data.DataSet&quot;> </xref> 구조를 지정 된 XML 스키마로 &lt;xref:System.IO.Stream?displayProperty=fullName&gt; 개체입니다."
  remarks: "WriteXmlSchema 메서드를 사용 하 여에 대 한 스키마를 작성 하는 <xref:System.Data.DataSet>XML 문서에.</xref:System.Data.DataSet> 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다. 스키마는 XML 문서를 작성 하려면 WriteXmlSchema 메서드를 사용 합니다.       XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.       XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataSet.WriteXml%2A>메서드.</xref:System.Data.DataSet.WriteXml%2A>       파생 된 클래스는 <xref:System.IO.Stream>클래스 포함 <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, 및 <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.MemoryStream> </xref:System.IO.FileStream> </xref:System.IO.BufferedStream> </xref:System.IO.Stream>"
  example:
  - "The following example creates a new <xref:System.IO.FileStream> object that is passed to the WriteXmlSchema method to write the schema to disk.  \n  \n [!code-vb[Classic WebData DataSet.WriteXmlSchema Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_6_1.vb)]\n [!code-cs[Classic WebData DataSet.WriteXmlSchema Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_6_1.cs)]"
  syntax:
    content: public void WriteXmlSchema (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "A <xref:System.IO.Stream>파일에 기록 하는 데 사용 되는 개체입니다.</xref:System.IO.Stream>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)
  id: WriteXmlSchema(System.IO.TextWriter)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(TextWriter)
  nameWithType: DataSet.WriteXmlSchema(TextWriter)
  fullName: System.Data.DataSet.WriteXmlSchema(TextWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "기록 된 <xref href=&quot;System.Data.DataSet&quot;> </xref> 구조를 지정 된 XML 스키마로 <xref:System.IO.TextWriter>개체입니다.</xref:System.IO.TextWriter>"
  remarks: "사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A>에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataSet>XML 문서에.</xref:System.Data.DataSet> </xref:System.Data.DataSet.WriteXmlSchema%2A> 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다. 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드.</xref:System.Data.DataSet.WriteXmlSchema%2A>       XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.       XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataSet.WriteXml%2A>메서드.</xref:System.Data.DataSet.WriteXml%2A>       파생 되는 클래스는 <xref:System.IO.TextWriter?displayProperty=fullName>클래스에 포함 된 <xref:System.Web.HttpWriter?displayProperty=fullName>, <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=fullName>, <xref:System.Web.UI.HtmlTextWriter?displayProperty=fullName>, <xref:System.IO.StreamWriter?displayProperty=fullName>, 및 <xref:System.IO.StringWriter?displayProperty=fullName>.</xref:System.IO.StringWriter?displayProperty=fullName> </xref:System.IO.StreamWriter?displayProperty=fullName> </xref:System.Web.UI.HtmlTextWriter?displayProperty=fullName> </xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=fullName> </xref:System.Web.HttpWriter?displayProperty=fullName> </xref:System.IO.TextWriter?displayProperty=fullName>"
  example:
  - "The following example creates a <xref:System.Text.StringBuilder?displayProperty=fullName> object to that is used to create a new <xref:System.IO.StringWriter?displayProperty=fullName>. The <xref:System.IO.StringWriter> is passed to the <xref:System.Data.DataSet.WriteXmlSchema%2A> method, and the resulting string is printed to the console window.  \n  \n [!code-cs[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_0_1.cs)]\n [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_0_1.vb)]"
  syntax:
    content: public void WriteXmlSchema (System.IO.TextWriter writer);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>쓰기에 사용할 개체입니다.</xref:System.IO.TextWriter>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.String)
  id: WriteXmlSchema(System.String)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(String)
  nameWithType: DataSet.WriteXmlSchema(String)
  fullName: System.Data.DataSet.WriteXmlSchema(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "기록는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 파일에 XML 스키마로는 구조입니다."
  remarks: "사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A>에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataSet>XML 문서에.</xref:System.Data.DataSet> </xref:System.Data.DataSet.WriteXmlSchema%2A> 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다. 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드.</xref:System.Data.DataSet.WriteXmlSchema%2A>       XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.       XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataSet.WriteXml%2A>메서드.</xref:System.Data.DataSet.WriteXml%2A>"
  example:
  - >-
    [!code-cs[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_4_1.cs)]
     [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_4_1.vb)]
  syntax:
    content: public void WriteXmlSchema (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "파일 쓰기에 사용할 이름 (경로 포함)."
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>로 설정 되지 않은 <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>합니다."
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)
  id: WriteXmlSchema(System.Xml.XmlWriter)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(XmlWriter)
  nameWithType: DataSet.WriteXmlSchema(XmlWriter)
  fullName: System.Data.DataSet.WriteXmlSchema(XmlWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "기록 된 <xref href=&quot;System.Data.DataSet&quot;> </xref> 구조는 XML 스키마로는 <xref:System.Xml.XmlWriter>개체입니다.</xref:System.Xml.XmlWriter>"
  remarks: "사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A>에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataSet>XML 문서에.</xref:System.Data.DataSet> </xref:System.Data.DataSet.WriteXmlSchema%2A> 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다. 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A>메서드.</xref:System.Data.DataSet.WriteXmlSchema%2A>       XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.       XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataSet.WriteXml%2A>메서드.</xref:System.Data.DataSet.WriteXml%2A>       <xref:System.Xml.XmlWriter?displayProperty=fullName>클래스는 <xref:System.Xml.XmlTextWriter?displayProperty=fullName>클래스</xref:System.Xml.XmlTextWriter?displayProperty=fullName> </xref:System.Xml.XmlWriter?displayProperty=fullName> 에서 상속 되는 하나의 클래스"
  example:
  - "The following example creates a new <xref:System.IO.FileStream?displayProperty=fullName> object with the specified path. The <xref:System.IO.FileStream> object is used to create an <xref:System.Xml.XMLTextWriter?displayProperty=fullName> object. The <xref:System.Data.DataSet.WriteXmlSchema%2A> method is then invoked with the <xref:System.Xml.XmlTextWriter> object to write the schema to the disk.  \n  \n [!code-cs[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_5_1.cs)]\n [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_5_1.vb)]"
  syntax:
    content: public void WriteXmlSchema (System.Xml.XmlWriter writer);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>에 쓰려고 합니다.</xref:System.Xml.XmlWriter>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})
  id: WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(Stream,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(Stream,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(Stream,Converter<Type,String>)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "기록 된 <xref href=&quot;System.Data.DataSet&quot;> </xref> 구조를 지정 된 XML 스키마로 &lt;xref:System.IO.Stream?displayProperty=fullName&gt; 개체입니다."
  syntax:
    content: public void WriteXmlSchema (System.IO.Stream stream, Converter<Type,string> multipleTargetConverter);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "A &lt;xref:System.IO.Stream?displayProperty=fullName&gt; 쓸 개체입니다."
    - id: multipleTargetConverter
      type: System.Converter{System.Type,System.String}
      description: "변환 하는 데 사용 되는 대리자 <xref:System.Type>문자열로.</xref:System.Type>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})
  id: WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(TextWriter,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(TextWriter,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(TextWriter,Converter<Type,String>)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "기록 된 <xref href=&quot;System.Data.DataSet&quot;> </xref> 구조 <xref:System.IO.TextWriter>.</xref:System.IO.TextWriter> 지정된는 XML 스키마로"
  syntax:
    content: public void WriteXmlSchema (System.IO.TextWriter writer, Converter<Type,string> multipleTargetConverter);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "A <xref:System.IO.TextWriter>쓸 개체입니다.</xref:System.IO.TextWriter>"
    - id: multipleTargetConverter
      type: System.Converter{System.Type,System.String}
      description: "변환 하는 데 사용 되는 대리자 <xref:System.Type>문자열로.</xref:System.Type>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})
  id: WriteXmlSchema(System.String,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(String,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(String,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(String,Converter<Type,String>)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "기록는 <xref href=&quot;System.Data.DataSet&quot;> </xref> 파일에 XML 스키마로는 구조입니다."
  syntax:
    content: public void WriteXmlSchema (string fileName, Converter<Type,string> multipleTargetConverter);
    parameters:
    - id: fileName
      type: System.String
      description: "쓸 파일의 이름입니다."
    - id: multipleTargetConverter
      type: System.Converter{System.Type,System.String}
      description: "변환 하는 데 사용 되는 대리자 <xref:System.Type>문자열로.</xref:System.Type>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})
  id: WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(XmlWriter,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(XmlWriter,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(XmlWriter,Converter<Type,String>)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "기록 된 <xref href=&quot;System.Data.DataSet&quot;> </xref> 구조 <xref:System.Xml.XmlWriter>.</xref:System.Xml.XmlWriter> 지정된는 XML 스키마로"
  syntax:
    content: public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter<Type,string> multipleTargetConverter);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "A <xref:System.Xml.XmlWriter>쓸 개체입니다.</xref:System.Xml.XmlWriter>"
    - id: multipleTargetConverter
      type: System.Converter{System.Type,System.String}
      description: "변환 하는 데 사용 되는 대리자 <xref:System.Type>문자열로.</xref:System.Type>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ComponentModel.MarshalByValueComponent
  isExternal: false
  name: System.ComponentModel.MarshalByValueComponent
- uid: System.Data.ConstraintException
  parent: System.Data
  isExternal: false
  name: ConstraintException
  nameWithType: ConstraintException
  fullName: System.Data.ConstraintException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Data.DataSet.#ctor
  parent: System.Data.DataSet
  isExternal: false
  name: DataSet()
  nameWithType: DataSet.DataSet()
  fullName: System.Data.DataSet.DataSet()
- uid: System.Data.DataSet.#ctor(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: DataSet(String)
  nameWithType: DataSet.DataSet(String)
  fullName: System.Data.DataSet.DataSet(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  isExternal: false
  name: DataSet(SerializationInfo,StreamingContext)
  nameWithType: DataSet.DataSet(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.DataSet(SerializationInfo,StreamingContext)
- uid: System.Runtime.Serialization.SerializationInfo
  parent: System.Runtime.Serialization
  isExternal: false
  name: SerializationInfo
  nameWithType: SerializationInfo
  fullName: System.Runtime.Serialization.SerializationInfo
- uid: System.Runtime.Serialization.StreamingContext
  parent: System.Runtime.Serialization
  isExternal: true
  name: StreamingContext
  nameWithType: StreamingContext
  fullName: System.Runtime.Serialization.StreamingContext
- uid: System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)
  parent: System.Data.DataSet
  isExternal: false
  name: DataSet(SerializationInfo,StreamingContext,Boolean)
  nameWithType: DataSet.DataSet(SerializationInfo,StreamingContext,Boolean)
  fullName: System.Data.DataSet.DataSet(SerializationInfo,StreamingContext,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Data.DataSet.AcceptChanges
  parent: System.Data.DataSet
  isExternal: false
  name: AcceptChanges()
  nameWithType: DataSet.AcceptChanges()
  fullName: System.Data.DataSet.AcceptChanges()
- uid: System.Data.DataSet.BeginInit
  parent: System.Data.DataSet
  isExternal: false
  name: BeginInit()
  nameWithType: DataSet.BeginInit()
  fullName: System.Data.DataSet.BeginInit()
- uid: System.Data.DataSet.CaseSensitive
  parent: System.Data.DataSet
  isExternal: false
  name: CaseSensitive
  nameWithType: DataSet.CaseSensitive
  fullName: System.Data.DataSet.CaseSensitive
- uid: System.Data.DataSet.Clear
  parent: System.Data.DataSet
  isExternal: false
  name: Clear()
  nameWithType: DataSet.Clear()
  fullName: System.Data.DataSet.Clear()
- uid: System.Data.DataSet.Clone
  parent: System.Data.DataSet
  isExternal: false
  name: Clone()
  nameWithType: DataSet.Clone()
  fullName: System.Data.DataSet.Clone()
- uid: System.Data.DataSet
  parent: System.Data
  isExternal: false
  name: DataSet
  nameWithType: DataSet
  fullName: System.Data.DataSet
- uid: System.Data.DataSet.Copy
  parent: System.Data.DataSet
  isExternal: false
  name: Copy()
  nameWithType: DataSet.Copy()
  fullName: System.Data.DataSet.Copy()
- uid: System.Data.DataSet.CreateDataReader
  parent: System.Data.DataSet
  isExternal: false
  name: CreateDataReader()
  nameWithType: DataSet.CreateDataReader()
  fullName: System.Data.DataSet.CreateDataReader()
- uid: System.Data.DataTableReader
  parent: System.Data
  isExternal: false
  name: DataTableReader
  nameWithType: DataTableReader
  fullName: System.Data.DataTableReader
- uid: System.Data.DataSet.CreateDataReader(System.Data.DataTable[])
  parent: System.Data.DataSet
  isExternal: false
  name: CreateDataReader(DataTable[])
  nameWithType: DataSet.CreateDataReader(DataTable[])
  fullName: System.Data.DataSet.CreateDataReader(DataTable[])
- uid: System.Data.DataTable[]
  parent: System.Data
  isExternal: false
  name: DataTable
  nameWithType: DataTable
  fullName: System.Data.DataTable[]
  spec.csharp:
  - uid: System.Data.DataTable
    name: DataTable
    nameWithType: DataTable
    fullName: DataTable[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.DataSet.DataSetName
  parent: System.Data.DataSet
  isExternal: false
  name: DataSetName
  nameWithType: DataSet.DataSetName
  fullName: System.Data.DataSet.DataSetName
- uid: System.Data.DataSet.DefaultViewManager
  parent: System.Data.DataSet
  isExternal: false
  name: DefaultViewManager
  nameWithType: DataSet.DefaultViewManager
  fullName: System.Data.DataSet.DefaultViewManager
- uid: System.Data.DataViewManager
  parent: System.Data
  isExternal: false
  name: DataViewManager
  nameWithType: DataViewManager
  fullName: System.Data.DataViewManager
- uid: System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)
  parent: System.Data.DataSet
  isExternal: false
  name: DetermineSchemaSerializationMode(XmlReader)
  nameWithType: DataSet.DetermineSchemaSerializationMode(XmlReader)
  fullName: System.Data.DataSet.DetermineSchemaSerializationMode(XmlReader)
- uid: System.Data.SchemaSerializationMode
  parent: System.Data
  isExternal: false
  name: SchemaSerializationMode
  nameWithType: SchemaSerializationMode
  fullName: System.Data.SchemaSerializationMode
- uid: System.Xml.XmlReader
  parent: System.Xml
  isExternal: true
  name: XmlReader
  nameWithType: XmlReader
  fullName: System.Xml.XmlReader
- uid: System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  isExternal: false
  name: DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
  nameWithType: DataSet.DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
- uid: System.Data.DataSet.EndInit
  parent: System.Data.DataSet
  isExternal: false
  name: EndInit()
  nameWithType: DataSet.EndInit()
  fullName: System.Data.DataSet.EndInit()
- uid: System.Data.DataSet.EnforceConstraints
  parent: System.Data.DataSet
  isExternal: false
  name: EnforceConstraints
  nameWithType: DataSet.EnforceConstraints
  fullName: System.Data.DataSet.EnforceConstraints
- uid: System.Data.DataSet.ExtendedProperties
  parent: System.Data.DataSet
  isExternal: false
  name: ExtendedProperties
  nameWithType: DataSet.ExtendedProperties
  fullName: System.Data.DataSet.ExtendedProperties
- uid: System.Data.PropertyCollection
  parent: System.Data
  isExternal: false
  name: PropertyCollection
  nameWithType: PropertyCollection
  fullName: System.Data.PropertyCollection
- uid: System.Data.DataSet.GetChanges
  parent: System.Data.DataSet
  isExternal: false
  name: GetChanges()
  nameWithType: DataSet.GetChanges()
  fullName: System.Data.DataSet.GetChanges()
- uid: System.Data.DataSet.GetChanges(System.Data.DataRowState)
  parent: System.Data.DataSet
  isExternal: false
  name: GetChanges(DataRowState)
  nameWithType: DataSet.GetChanges(DataRowState)
  fullName: System.Data.DataSet.GetChanges(DataRowState)
- uid: System.Data.DataRowState
  parent: System.Data
  isExternal: false
  name: DataRowState
  nameWithType: DataRowState
  fullName: System.Data.DataRowState
- uid: System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)
  parent: System.Data.DataSet
  isExternal: false
  name: GetDataSetSchema(XmlSchemaSet)
  nameWithType: DataSet.GetDataSetSchema(XmlSchemaSet)
  fullName: System.Data.DataSet.GetDataSetSchema(XmlSchemaSet)
- uid: System.Xml.Schema.XmlSchemaComplexType
  parent: System.Xml.Schema
  isExternal: false
  name: XmlSchemaComplexType
  nameWithType: XmlSchemaComplexType
  fullName: System.Xml.Schema.XmlSchemaComplexType
- uid: System.Xml.Schema.XmlSchemaSet
  parent: System.Xml.Schema
  isExternal: false
  name: XmlSchemaSet
  nameWithType: XmlSchemaSet
  fullName: System.Xml.Schema.XmlSchemaSet
- uid: System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  isExternal: false
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: DataSet.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.GetObjectData(SerializationInfo,StreamingContext)
- uid: System.Data.DataSet.GetSchemaSerializable
  parent: System.Data.DataSet
  isExternal: false
  name: GetSchemaSerializable()
  nameWithType: DataSet.GetSchemaSerializable()
  fullName: System.Data.DataSet.GetSchemaSerializable()
- uid: System.Xml.Schema.XmlSchema
  parent: System.Xml.Schema
  isExternal: true
  name: XmlSchema
  nameWithType: XmlSchema
  fullName: System.Xml.Schema.XmlSchema
- uid: System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  isExternal: false
  name: GetSerializationData(SerializationInfo,StreamingContext)
  nameWithType: DataSet.GetSerializationData(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.GetSerializationData(SerializationInfo,StreamingContext)
- uid: System.Data.DataSet.GetXml
  parent: System.Data.DataSet
  isExternal: false
  name: GetXml()
  nameWithType: DataSet.GetXml()
  fullName: System.Data.DataSet.GetXml()
- uid: System.Data.DataSet.GetXmlSchema
  parent: System.Data.DataSet
  isExternal: false
  name: GetXmlSchema()
  nameWithType: DataSet.GetXmlSchema()
  fullName: System.Data.DataSet.GetXmlSchema()
- uid: System.Data.DataSet.HasChanges
  parent: System.Data.DataSet
  isExternal: false
  name: HasChanges()
  nameWithType: DataSet.HasChanges()
  fullName: System.Data.DataSet.HasChanges()
- uid: System.Data.DataSet.HasChanges(System.Data.DataRowState)
  parent: System.Data.DataSet
  isExternal: false
  name: HasChanges(DataRowState)
  nameWithType: DataSet.HasChanges(DataRowState)
  fullName: System.Data.DataSet.HasChanges(DataRowState)
- uid: System.Data.DataSet.HasErrors
  parent: System.Data.DataSet
  isExternal: false
  name: HasErrors
  nameWithType: DataSet.HasErrors
  fullName: System.Data.DataSet.HasErrors
- uid: System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])
  parent: System.Data.DataSet
  isExternal: false
  name: InferXmlSchema(Stream,String[])
  nameWithType: DataSet.InferXmlSchema(Stream,String[])
  fullName: System.Data.DataSet.InferXmlSchema(Stream,String[])
- uid: System.IO.Stream
  parent: System.IO
  isExternal: true
  name: Stream
  nameWithType: Stream
  fullName: System.IO.Stream
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])
  parent: System.Data.DataSet
  isExternal: false
  name: InferXmlSchema(TextReader,String[])
  nameWithType: DataSet.InferXmlSchema(TextReader,String[])
  fullName: System.Data.DataSet.InferXmlSchema(TextReader,String[])
- uid: System.IO.TextReader
  parent: System.IO
  isExternal: true
  name: TextReader
  nameWithType: TextReader
  fullName: System.IO.TextReader
- uid: System.Data.DataSet.InferXmlSchema(System.String,System.String[])
  parent: System.Data.DataSet
  isExternal: false
  name: InferXmlSchema(String,String[])
  nameWithType: DataSet.InferXmlSchema(String,String[])
  fullName: System.Data.DataSet.InferXmlSchema(String,String[])
- uid: System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])
  parent: System.Data.DataSet
  isExternal: false
  name: InferXmlSchema(XmlReader,String[])
  nameWithType: DataSet.InferXmlSchema(XmlReader,String[])
  fullName: System.Data.DataSet.InferXmlSchema(XmlReader,String[])
- uid: System.Data.DataSet.Initialized
  parent: System.Data.DataSet
  isExternal: false
  name: Initialized
  nameWithType: DataSet.Initialized
  fullName: System.Data.DataSet.Initialized
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Data.DataSet.InitializeDerivedDataSet
  parent: System.Data.DataSet
  isExternal: false
  name: InitializeDerivedDataSet()
  nameWithType: DataSet.InitializeDerivedDataSet()
  fullName: System.Data.DataSet.InitializeDerivedDataSet()
- uid: System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  isExternal: false
  name: IsBinarySerialized(SerializationInfo,StreamingContext)
  nameWithType: DataSet.IsBinarySerialized(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.IsBinarySerialized(SerializationInfo,StreamingContext)
- uid: System.Data.DataSet.IsInitialized
  parent: System.Data.DataSet
  isExternal: false
  name: IsInitialized
  nameWithType: DataSet.IsInitialized
  fullName: System.Data.DataSet.IsInitialized
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])
  parent: System.Data.DataSet
  isExternal: false
  name: Load(IDataReader,LoadOption,DataTable[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,DataTable[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,DataTable[])
- uid: System.Data.IDataReader
  parent: System.Data
  isExternal: false
  name: IDataReader
  nameWithType: IDataReader
  fullName: System.Data.IDataReader
- uid: System.Data.LoadOption
  parent: System.Data
  isExternal: false
  name: LoadOption
  nameWithType: LoadOption
  fullName: System.Data.LoadOption
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])
  parent: System.Data.DataSet
  isExternal: false
  name: Load(IDataReader,LoadOption,String[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,String[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,String[])
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])
  parent: System.Data.DataSet
  isExternal: false
  name: Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
- uid: System.Data.FillErrorEventHandler
  parent: System.Data
  isExternal: false
  name: FillErrorEventHandler
  nameWithType: FillErrorEventHandler
  fullName: System.Data.FillErrorEventHandler
- uid: System.Data.DataSet.Locale
  parent: System.Data.DataSet
  isExternal: false
  name: Locale
  nameWithType: DataSet.Locale
  fullName: System.Data.DataSet.Locale
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Data.DataSet.Merge(System.Data.DataRow[])
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataRow[])
  nameWithType: DataSet.Merge(DataRow[])
  fullName: System.Data.DataSet.Merge(DataRow[])
- uid: System.Data.DataRow[]
  parent: System.Data
  isExternal: false
  name: DataRow
  nameWithType: DataRow
  fullName: System.Data.DataRow[]
  spec.csharp:
  - uid: System.Data.DataRow
    name: DataRow
    nameWithType: DataRow
    fullName: DataRow[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.DataSet.Merge(System.Data.DataSet)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataSet)
  nameWithType: DataSet.Merge(DataSet)
  fullName: System.Data.DataSet.Merge(DataSet)
- uid: System.Data.DataSet.Merge(System.Data.DataTable)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataTable)
  nameWithType: DataSet.Merge(DataTable)
  fullName: System.Data.DataSet.Merge(DataTable)
- uid: System.Data.DataTable
  parent: System.Data
  isExternal: false
  name: DataTable
  nameWithType: DataTable
  fullName: System.Data.DataTable
- uid: System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataSet,Boolean)
  nameWithType: DataSet.Merge(DataSet,Boolean)
  fullName: System.Data.DataSet.Merge(DataSet,Boolean)
- uid: System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataRow[],Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataRow[],Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataRow[],Boolean,MissingSchemaAction)
- uid: System.Data.MissingSchemaAction
  parent: System.Data
  isExternal: false
  name: MissingSchemaAction
  nameWithType: MissingSchemaAction
  fullName: System.Data.MissingSchemaAction
- uid: System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataSet,Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataSet,Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataSet,Boolean,MissingSchemaAction)
- uid: System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataTable,Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataTable,Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataTable,Boolean,MissingSchemaAction)
- uid: System.Data.DataSet.MergeFailed
  parent: System.Data.DataSet
  isExternal: false
  name: MergeFailed
  nameWithType: DataSet.MergeFailed
  fullName: System.Data.DataSet.MergeFailed
- uid: System.Data.MergeFailedEventHandler
  parent: System.Data
  isExternal: false
  name: MergeFailedEventHandler
  nameWithType: MergeFailedEventHandler
  fullName: System.Data.MergeFailedEventHandler
- uid: System.Data.DataSet.Namespace
  parent: System.Data.DataSet
  isExternal: false
  name: Namespace
  nameWithType: DataSet.Namespace
  fullName: System.Data.DataSet.Namespace
- uid: System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  parent: System.Data.DataSet
  isExternal: false
  name: OnPropertyChanging(PropertyChangedEventArgs)
  nameWithType: DataSet.OnPropertyChanging(PropertyChangedEventArgs)
  fullName: System.Data.DataSet.OnPropertyChanging(PropertyChangedEventArgs)
- uid: System.ComponentModel.PropertyChangedEventArgs
  parent: System.ComponentModel
  isExternal: true
  name: PropertyChangedEventArgs
  nameWithType: PropertyChangedEventArgs
  fullName: System.ComponentModel.PropertyChangedEventArgs
- uid: System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)
  parent: System.Data.DataSet
  isExternal: false
  name: OnRemoveRelation(DataRelation)
  nameWithType: DataSet.OnRemoveRelation(DataRelation)
  fullName: System.Data.DataSet.OnRemoveRelation(DataRelation)
- uid: System.Data.DataRelation
  parent: System.Data
  isExternal: false
  name: DataRelation
  nameWithType: DataRelation
  fullName: System.Data.DataRelation
- uid: System.Data.DataSet.OnRemoveTable(System.Data.DataTable)
  parent: System.Data.DataSet
  isExternal: false
  name: OnRemoveTable(DataTable)
  nameWithType: DataSet.OnRemoveTable(DataTable)
  fullName: System.Data.DataSet.OnRemoveTable(DataTable)
- uid: System.Data.DataSet.Prefix
  parent: System.Data.DataSet
  isExternal: false
  name: Prefix
  nameWithType: DataSet.Prefix
  fullName: System.Data.DataSet.Prefix
- uid: System.Data.DataSet.RaisePropertyChanging(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: RaisePropertyChanging(String)
  nameWithType: DataSet.RaisePropertyChanging(String)
  fullName: System.Data.DataSet.RaisePropertyChanging(String)
- uid: System.Data.DataSet.ReadXml(System.IO.Stream)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(Stream)
  nameWithType: DataSet.ReadXml(Stream)
  fullName: System.Data.DataSet.ReadXml(Stream)
- uid: System.Data.XmlReadMode
  parent: System.Data
  isExternal: false
  name: XmlReadMode
  nameWithType: XmlReadMode
  fullName: System.Data.XmlReadMode
- uid: System.Data.DataSet.ReadXml(System.IO.TextReader)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(TextReader)
  nameWithType: DataSet.ReadXml(TextReader)
  fullName: System.Data.DataSet.ReadXml(TextReader)
- uid: System.Data.DataSet.ReadXml(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(String)
  nameWithType: DataSet.ReadXml(String)
  fullName: System.Data.DataSet.ReadXml(String)
- uid: System.Data.DataSet.ReadXml(System.Xml.XmlReader)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(XmlReader)
  nameWithType: DataSet.ReadXml(XmlReader)
  fullName: System.Data.DataSet.ReadXml(XmlReader)
- uid: System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(Stream,XmlReadMode)
  nameWithType: DataSet.ReadXml(Stream,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(Stream,XmlReadMode)
- uid: System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(TextReader,XmlReadMode)
  nameWithType: DataSet.ReadXml(TextReader,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(TextReader,XmlReadMode)
- uid: System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(String,XmlReadMode)
  nameWithType: DataSet.ReadXml(String,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(String,XmlReadMode)
- uid: System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(XmlReader,XmlReadMode)
  nameWithType: DataSet.ReadXml(XmlReader,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(XmlReader,XmlReadMode)
- uid: System.Data.DataSet.ReadXmlSchema(System.IO.Stream)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSchema(Stream)
  nameWithType: DataSet.ReadXmlSchema(Stream)
  fullName: System.Data.DataSet.ReadXmlSchema(Stream)
- uid: System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSchema(TextReader)
  nameWithType: DataSet.ReadXmlSchema(TextReader)
  fullName: System.Data.DataSet.ReadXmlSchema(TextReader)
- uid: System.Data.DataSet.ReadXmlSchema(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSchema(String)
  nameWithType: DataSet.ReadXmlSchema(String)
  fullName: System.Data.DataSet.ReadXmlSchema(String)
- uid: System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSchema(XmlReader)
  nameWithType: DataSet.ReadXmlSchema(XmlReader)
  fullName: System.Data.DataSet.ReadXmlSchema(XmlReader)
- uid: System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSerializable(XmlReader)
  nameWithType: DataSet.ReadXmlSerializable(XmlReader)
  fullName: System.Data.DataSet.ReadXmlSerializable(XmlReader)
- uid: System.Data.DataSet.RejectChanges
  parent: System.Data.DataSet
  isExternal: false
  name: RejectChanges()
  nameWithType: DataSet.RejectChanges()
  fullName: System.Data.DataSet.RejectChanges()
- uid: System.Data.DataSet.Relations
  parent: System.Data.DataSet
  isExternal: false
  name: Relations
  nameWithType: DataSet.Relations
  fullName: System.Data.DataSet.Relations
- uid: System.Data.DataRelationCollection
  parent: System.Data
  isExternal: false
  name: DataRelationCollection
  nameWithType: DataRelationCollection
  fullName: System.Data.DataRelationCollection
- uid: System.Data.DataSet.RemotingFormat
  parent: System.Data.DataSet
  isExternal: false
  name: RemotingFormat
  nameWithType: DataSet.RemotingFormat
  fullName: System.Data.DataSet.RemotingFormat
- uid: System.Data.SerializationFormat
  parent: System.Data
  isExternal: false
  name: SerializationFormat
  nameWithType: SerializationFormat
  fullName: System.Data.SerializationFormat
- uid: System.Data.DataSet.Reset
  parent: System.Data.DataSet
  isExternal: false
  name: Reset()
  nameWithType: DataSet.Reset()
  fullName: System.Data.DataSet.Reset()
- uid: System.Data.DataSet.SchemaSerializationMode
  parent: System.Data.DataSet
  isExternal: false
  name: SchemaSerializationMode
  nameWithType: DataSet.SchemaSerializationMode
  fullName: System.Data.DataSet.SchemaSerializationMode
- uid: System.Data.DataSet.ShouldSerializeRelations
  parent: System.Data.DataSet
  isExternal: false
  name: ShouldSerializeRelations()
  nameWithType: DataSet.ShouldSerializeRelations()
  fullName: System.Data.DataSet.ShouldSerializeRelations()
- uid: System.Data.DataSet.ShouldSerializeTables
  parent: System.Data.DataSet
  isExternal: false
  name: ShouldSerializeTables()
  nameWithType: DataSet.ShouldSerializeTables()
  fullName: System.Data.DataSet.ShouldSerializeTables()
- uid: System.Data.DataSet.Site
  parent: System.Data.DataSet
  isExternal: false
  name: Site
  nameWithType: DataSet.Site
  fullName: System.Data.DataSet.Site
- uid: System.ComponentModel.ISite
  parent: System.ComponentModel
  isExternal: false
  name: ISite
  nameWithType: ISite
  fullName: System.ComponentModel.ISite
- uid: System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection
  parent: System.Data.DataSet
  isExternal: false
  name: System.ComponentModel.IListSource.ContainsListCollection
  nameWithType: DataSet.System.ComponentModel.IListSource.ContainsListCollection
  fullName: System.Data.DataSet.System.ComponentModel.IListSource.ContainsListCollection
- uid: System.Data.DataSet.System#ComponentModel#IListSource#GetList
  parent: System.Data.DataSet
  isExternal: false
  name: System.ComponentModel.IListSource.GetList()
  nameWithType: DataSet.System.ComponentModel.IListSource.GetList()
  fullName: System.Data.DataSet.System.ComponentModel.IListSource.GetList()
- uid: System.Collections.IList
  parent: System.Collections
  isExternal: true
  name: IList
  nameWithType: IList
  fullName: System.Collections.IList
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.GetSchema()
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.GetSchema()
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.GetSchema()
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
- uid: System.Xml.XmlWriter
  parent: System.Xml
  isExternal: true
  name: XmlWriter
  nameWithType: XmlWriter
  fullName: System.Xml.XmlWriter
- uid: System.Data.DataSet.Tables
  parent: System.Data.DataSet
  isExternal: false
  name: Tables
  nameWithType: DataSet.Tables
  fullName: System.Data.DataSet.Tables
- uid: System.Data.DataTableCollection
  parent: System.Data
  isExternal: false
  name: DataTableCollection
  nameWithType: DataTableCollection
  fullName: System.Data.DataTableCollection
- uid: System.Data.DataSet.WriteXml(System.IO.Stream)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(Stream)
  nameWithType: DataSet.WriteXml(Stream)
  fullName: System.Data.DataSet.WriteXml(Stream)
- uid: System.Data.DataSet.WriteXml(System.IO.TextWriter)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(TextWriter)
  nameWithType: DataSet.WriteXml(TextWriter)
  fullName: System.Data.DataSet.WriteXml(TextWriter)
- uid: System.IO.TextWriter
  parent: System.IO
  isExternal: true
  name: TextWriter
  nameWithType: TextWriter
  fullName: System.IO.TextWriter
- uid: System.Data.DataSet.WriteXml(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(String)
  nameWithType: DataSet.WriteXml(String)
  fullName: System.Data.DataSet.WriteXml(String)
- uid: System.Data.DataSet.WriteXml(System.Xml.XmlWriter)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(XmlWriter)
  nameWithType: DataSet.WriteXml(XmlWriter)
  fullName: System.Data.DataSet.WriteXml(XmlWriter)
- uid: System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(Stream,XmlWriteMode)
  nameWithType: DataSet.WriteXml(Stream,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(Stream,XmlWriteMode)
- uid: System.Data.XmlWriteMode
  parent: System.Data
  isExternal: false
  name: XmlWriteMode
  nameWithType: XmlWriteMode
  fullName: System.Data.XmlWriteMode
- uid: System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(TextWriter,XmlWriteMode)
  nameWithType: DataSet.WriteXml(TextWriter,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(TextWriter,XmlWriteMode)
- uid: System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(String,XmlWriteMode)
  nameWithType: DataSet.WriteXml(String,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(String,XmlWriteMode)
- uid: System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(XmlWriter,XmlWriteMode)
  nameWithType: DataSet.WriteXml(XmlWriter,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(XmlWriter,XmlWriteMode)
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.Stream)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(Stream)
  nameWithType: DataSet.WriteXmlSchema(Stream)
  fullName: System.Data.DataSet.WriteXmlSchema(Stream)
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(TextWriter)
  nameWithType: DataSet.WriteXmlSchema(TextWriter)
  fullName: System.Data.DataSet.WriteXmlSchema(TextWriter)
- uid: System.Data.DataSet.WriteXmlSchema(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(String)
  nameWithType: DataSet.WriteXmlSchema(String)
  fullName: System.Data.DataSet.WriteXmlSchema(String)
- uid: System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(XmlWriter)
  nameWithType: DataSet.WriteXmlSchema(XmlWriter)
  fullName: System.Data.DataSet.WriteXmlSchema(XmlWriter)
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(Stream,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(Stream,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(Stream,Converter<Type,String>)
- uid: System.Converter{System.Type,System.String}
  parent: System
  isExternal: false
  name: Converter<Type,String>
  nameWithType: Converter<Type,String>
  fullName: System.Converter<System.Type,System.String>
  spec.csharp:
  - uid: System.Converter`2
    name: Converter
    nameWithType: Converter
    fullName: Converter<System.Type,System.String>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Type
    name: Type
    nameWithType: Type
    fullName: Type
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(TextWriter,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(TextWriter,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(TextWriter,Converter<Type,String>)
- uid: System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(String,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(String,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(String,Converter<Type,String>)
- uid: System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(XmlWriter,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(XmlWriter,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(XmlWriter,Converter<Type,String>)
- uid: System.Data.DataSet.#ctor*
  parent: System.Data.DataSet
  isExternal: false
  name: DataSet
  nameWithType: DataSet.DataSet
- uid: System.Data.DataSet.AcceptChanges*
  parent: System.Data.DataSet
  isExternal: false
  name: AcceptChanges
  nameWithType: DataSet.AcceptChanges
- uid: System.Data.DataSet.BeginInit*
  parent: System.Data.DataSet
  isExternal: false
  name: BeginInit
  nameWithType: DataSet.BeginInit
- uid: System.Data.DataSet.CaseSensitive*
  parent: System.Data.DataSet
  isExternal: false
  name: CaseSensitive
  nameWithType: DataSet.CaseSensitive
- uid: System.Data.DataSet.Clear*
  parent: System.Data.DataSet
  isExternal: false
  name: Clear
  nameWithType: DataSet.Clear
- uid: System.Data.DataSet.Clone*
  parent: System.Data.DataSet
  isExternal: false
  name: Clone
  nameWithType: DataSet.Clone
- uid: System.Data.DataSet.Copy*
  parent: System.Data.DataSet
  isExternal: false
  name: Copy
  nameWithType: DataSet.Copy
- uid: System.Data.DataSet.CreateDataReader*
  parent: System.Data.DataSet
  isExternal: false
  name: CreateDataReader
  nameWithType: DataSet.CreateDataReader
- uid: System.Data.DataSet.DataSetName*
  parent: System.Data.DataSet
  isExternal: false
  name: DataSetName
  nameWithType: DataSet.DataSetName
- uid: System.Data.DataSet.DefaultViewManager*
  parent: System.Data.DataSet
  isExternal: false
  name: DefaultViewManager
  nameWithType: DataSet.DefaultViewManager
- uid: System.Data.DataSet.DetermineSchemaSerializationMode*
  parent: System.Data.DataSet
  isExternal: false
  name: DetermineSchemaSerializationMode
  nameWithType: DataSet.DetermineSchemaSerializationMode
- uid: System.Data.DataSet.EndInit*
  parent: System.Data.DataSet
  isExternal: false
  name: EndInit
  nameWithType: DataSet.EndInit
- uid: System.Data.DataSet.EnforceConstraints*
  parent: System.Data.DataSet
  isExternal: false
  name: EnforceConstraints
  nameWithType: DataSet.EnforceConstraints
- uid: System.Data.DataSet.ExtendedProperties*
  parent: System.Data.DataSet
  isExternal: false
  name: ExtendedProperties
  nameWithType: DataSet.ExtendedProperties
- uid: System.Data.DataSet.GetChanges*
  parent: System.Data.DataSet
  isExternal: false
  name: GetChanges
  nameWithType: DataSet.GetChanges
- uid: System.Data.DataSet.GetDataSetSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: GetDataSetSchema
  nameWithType: DataSet.GetDataSetSchema
- uid: System.Data.DataSet.GetObjectData*
  parent: System.Data.DataSet
  isExternal: false
  name: GetObjectData
  nameWithType: DataSet.GetObjectData
- uid: System.Data.DataSet.GetSchemaSerializable*
  parent: System.Data.DataSet
  isExternal: false
  name: GetSchemaSerializable
  nameWithType: DataSet.GetSchemaSerializable
- uid: System.Data.DataSet.GetSerializationData*
  parent: System.Data.DataSet
  isExternal: false
  name: GetSerializationData
  nameWithType: DataSet.GetSerializationData
- uid: System.Data.DataSet.GetXml*
  parent: System.Data.DataSet
  isExternal: false
  name: GetXml
  nameWithType: DataSet.GetXml
- uid: System.Data.DataSet.GetXmlSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: GetXmlSchema
  nameWithType: DataSet.GetXmlSchema
- uid: System.Data.DataSet.HasChanges*
  parent: System.Data.DataSet
  isExternal: false
  name: HasChanges
  nameWithType: DataSet.HasChanges
- uid: System.Data.DataSet.HasErrors*
  parent: System.Data.DataSet
  isExternal: false
  name: HasErrors
  nameWithType: DataSet.HasErrors
- uid: System.Data.DataSet.InferXmlSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: InferXmlSchema
  nameWithType: DataSet.InferXmlSchema
- uid: System.Data.DataSet.InitializeDerivedDataSet*
  parent: System.Data.DataSet
  isExternal: false
  name: InitializeDerivedDataSet
  nameWithType: DataSet.InitializeDerivedDataSet
- uid: System.Data.DataSet.IsBinarySerialized*
  parent: System.Data.DataSet
  isExternal: false
  name: IsBinarySerialized
  nameWithType: DataSet.IsBinarySerialized
- uid: System.Data.DataSet.IsInitialized*
  parent: System.Data.DataSet
  isExternal: false
  name: IsInitialized
  nameWithType: DataSet.IsInitialized
- uid: System.Data.DataSet.Load*
  parent: System.Data.DataSet
  isExternal: false
  name: Load
  nameWithType: DataSet.Load
- uid: System.Data.DataSet.Locale*
  parent: System.Data.DataSet
  isExternal: false
  name: Locale
  nameWithType: DataSet.Locale
- uid: System.Data.DataSet.Merge*
  parent: System.Data.DataSet
  isExternal: false
  name: Merge
  nameWithType: DataSet.Merge
- uid: System.Data.DataSet.Namespace*
  parent: System.Data.DataSet
  isExternal: false
  name: Namespace
  nameWithType: DataSet.Namespace
- uid: System.Data.DataSet.OnPropertyChanging*
  parent: System.Data.DataSet
  isExternal: false
  name: OnPropertyChanging
  nameWithType: DataSet.OnPropertyChanging
- uid: System.Data.DataSet.OnRemoveRelation*
  parent: System.Data.DataSet
  isExternal: false
  name: OnRemoveRelation
  nameWithType: DataSet.OnRemoveRelation
- uid: System.Data.DataSet.OnRemoveTable*
  parent: System.Data.DataSet
  isExternal: false
  name: OnRemoveTable
  nameWithType: DataSet.OnRemoveTable
- uid: System.Data.DataSet.Prefix*
  parent: System.Data.DataSet
  isExternal: false
  name: Prefix
  nameWithType: DataSet.Prefix
- uid: System.Data.DataSet.RaisePropertyChanging*
  parent: System.Data.DataSet
  isExternal: false
  name: RaisePropertyChanging
  nameWithType: DataSet.RaisePropertyChanging
- uid: System.Data.DataSet.ReadXml*
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml
  nameWithType: DataSet.ReadXml
- uid: System.Data.DataSet.ReadXmlSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSchema
  nameWithType: DataSet.ReadXmlSchema
- uid: System.Data.DataSet.ReadXmlSerializable*
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSerializable
  nameWithType: DataSet.ReadXmlSerializable
- uid: System.Data.DataSet.RejectChanges*
  parent: System.Data.DataSet
  isExternal: false
  name: RejectChanges
  nameWithType: DataSet.RejectChanges
- uid: System.Data.DataSet.Relations*
  parent: System.Data.DataSet
  isExternal: false
  name: Relations
  nameWithType: DataSet.Relations
- uid: System.Data.DataSet.RemotingFormat*
  parent: System.Data.DataSet
  isExternal: false
  name: RemotingFormat
  nameWithType: DataSet.RemotingFormat
- uid: System.Data.DataSet.Reset*
  parent: System.Data.DataSet
  isExternal: false
  name: Reset
  nameWithType: DataSet.Reset
- uid: System.Data.DataSet.SchemaSerializationMode*
  parent: System.Data.DataSet
  isExternal: false
  name: SchemaSerializationMode
  nameWithType: DataSet.SchemaSerializationMode
- uid: System.Data.DataSet.ShouldSerializeRelations*
  parent: System.Data.DataSet
  isExternal: false
  name: ShouldSerializeRelations
  nameWithType: DataSet.ShouldSerializeRelations
- uid: System.Data.DataSet.ShouldSerializeTables*
  parent: System.Data.DataSet
  isExternal: false
  name: ShouldSerializeTables
  nameWithType: DataSet.ShouldSerializeTables
- uid: System.Data.DataSet.Site*
  parent: System.Data.DataSet
  isExternal: false
  name: Site
  nameWithType: DataSet.Site
- uid: System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection*
  parent: System.Data.DataSet
  isExternal: false
  name: System.ComponentModel.IListSource.ContainsListCollection
  nameWithType: DataSet.System.ComponentModel.IListSource.ContainsListCollection
- uid: System.Data.DataSet.System#ComponentModel#IListSource#GetList*
  parent: System.Data.DataSet
  isExternal: false
  name: System.ComponentModel.IListSource.GetList
  nameWithType: DataSet.System.ComponentModel.IListSource.GetList
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.GetSchema
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.GetSchema
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml*
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.ReadXml
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.ReadXml
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml*
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.WriteXml
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.WriteXml
- uid: System.Data.DataSet.Tables*
  parent: System.Data.DataSet
  isExternal: false
  name: Tables
  nameWithType: DataSet.Tables
- uid: System.Data.DataSet.WriteXml*
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml
  nameWithType: DataSet.WriteXml
- uid: System.Data.DataSet.WriteXmlSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema
  nameWithType: DataSet.WriteXmlSchema
