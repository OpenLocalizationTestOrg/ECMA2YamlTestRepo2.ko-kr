### YamlMime:ManagedReference
items:
- uid: System.Data.Linq.DataContext
  id: DataContext
  children:
  - System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)
  - System.Data.Linq.DataContext.#ctor(System.String)
  - System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)
  - System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)
  - System.Data.Linq.DataContext.ChangeConflicts
  - System.Data.Linq.DataContext.CommandTimeout
  - System.Data.Linq.DataContext.Connection
  - System.Data.Linq.DataContext.CreateDatabase
  - System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])
  - System.Data.Linq.DataContext.DatabaseExists
  - System.Data.Linq.DataContext.DeferredLoadingEnabled
  - System.Data.Linq.DataContext.DeleteDatabase
  - System.Data.Linq.DataContext.Dispose
  - System.Data.Linq.DataContext.Dispose(System.Boolean)
  - System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])
  - System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)
  - System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)
  - System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)
  - System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])
  - System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])
  - System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])
  - System.Data.Linq.DataContext.GetChangeSet
  - System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)
  - System.Data.Linq.DataContext.GetTable(System.Type)
  - System.Data.Linq.DataContext.GetTable``1
  - System.Data.Linq.DataContext.LoadOptions
  - System.Data.Linq.DataContext.Log
  - System.Data.Linq.DataContext.Mapping
  - System.Data.Linq.DataContext.ObjectTrackingEnabled
  - System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)
  - System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)
  - System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])
  - System.Data.Linq.DataContext.SubmitChanges
  - System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)
  - System.Data.Linq.DataContext.Transaction
  - System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)
  - System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)
  - System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)
  langs:
  - csharp
  name: DataContext
  nameWithType: DataContext
  fullName: System.Data.Linq.DataContext
  type: Class
  summary: "에 대 한 주 진입점을 나타내는 [!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)] 프레임 워크입니다."
  remarks: "DataContext에는 데이터베이스 연결을 통해 매핑된 모든 엔터티의의 원인입니다. 검색 된 모든 엔터티에 대 한 변경 내용을 추적 하 고 여러 번 검색 된 엔터티 보증으로 표현 되는 &quot;id 캐시&quot; 유지 관리 동일한 개체 인스턴스를 사용 합니다.       그러나 일반적으로 DataContext 인스턴스는 응용 프로그램에서 해당 용어를 정의 하는 하나의 &quot;작업 단위&quot; 동안 유지 되도록 설계 되었습니다. DataContext 간단 하며 만들려면 비용이 많이 들지 않습니다. 일반적인 [!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)] 응용 프로그램 관련된 데이터베이스 작업의 논리 집합을 나타내는 수명이 짧은 클래스의 구성원 또는 메서드 범위에서 DataContext 인스턴스를 만듭니다."
  syntax:
    content: 'public class DataContext : IDisposable'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)
  id: '#ctor(System.Data.IDbConnection)'
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: DataContext(IDbConnection)
  nameWithType: DataContext.DataContext(IDbConnection)
  fullName: System.Data.Linq.DataContext.DataContext(IDbConnection)
  type: Constructor
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Data.Linq.DataContext&quot;> </xref> 클래스를 사용 하는 연결을 참조 하 여는 [!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)]합니다."
  remarks: "A <xref:System.Data.Linq.DataContext>열고 닫힌된 연결 또는 연결 문자열을 제공 하는 경우 필요에 따라 데이터베이스 연결을 닫습니다.</xref:System.Data.Linq.DataContext> 일반적으로 필요는 호출할 `Dispose` <xref:System.Data.Linq.DataContext>.</xref:System.Data.Linq.DataContext> <xref:System.Data.Linq.DataContext>합니다.를 닫지 것입니다</xref:System.Data.Linq.DataContext> 열려 있는 연결을 제공 하는 경우 따라서 인스턴스화할 수 없습니다는 <xref:System.Data.Linq.DataContext>열린 연결으로이 작업을 수행 하는 좋은 이유가 없으면.</xref:System.Data.Linq.DataContext> 에 <xref:System.Transactions>트랜잭션에 <xref:System.Data.Linq.DataContext>열거나 승격이 발생 하지 않도록 하는 연결을 닫이 됩니다.</xref:System.Data.Linq.DataContext> </xref:System.Transactions>"
  syntax:
    content: public DataContext (System.Data.IDbConnection connection);
    parameters:
    - id: connection
      type: System.Data.IDbConnection
      description: "사용 되는 연결의 [!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)]합니다."
  overload: System.Data.Linq.DataContext.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: DataContext(String)
  nameWithType: DataContext.DataContext(String)
  fullName: System.Data.Linq.DataContext.DataContext(String)
  type: Constructor
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Data.Linq.DataContext&quot;> </xref> 파일 원본을 참조 하 여 클래스입니다."
  syntax:
    content: public DataContext (string fileOrServerOrConnection);
    parameters:
    - id: fileOrServerOrConnection
      type: System.String
      description: "이 인수는 다음 중 하나가 될 수 있습니다: SQL Server Express 데이터베이스가 있는 파일의 이름입니다.       데이터베이스가 있는 서버의 이름입니다. 이 경우 공급자는 사용자에 대 한 기본 데이터베이스를 사용합니다.       전체 연결 문자열입니다. [!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)]방금 수정 하지 않고 공급자에 문자열을 전달합니다."
  overload: System.Data.Linq.DataContext.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)
  id: '#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)'
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: DataContext(IDbConnection,MappingSource)
  nameWithType: DataContext.DataContext(IDbConnection,MappingSource)
  fullName: System.Data.Linq.DataContext.DataContext(IDbConnection,MappingSource)
  type: Constructor
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Data.Linq.DataContext&quot;> </xref> 연결 및 매핑 소스를 참조 하 여 클래스입니다."
  syntax:
    content: public DataContext (System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mapping);
    parameters:
    - id: connection
      type: System.Data.IDbConnection
      description: ".NET Framework에서 사용 되는 연결 합니다."
    - id: mapping
      type: System.Data.Linq.Mapping.MappingSource
      description: "매핑에 대 한 원본입니다."
  overload: System.Data.Linq.DataContext.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)
  id: '#ctor(System.String,System.Data.Linq.Mapping.MappingSource)'
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: DataContext(String,MappingSource)
  nameWithType: DataContext.DataContext(String,MappingSource)
  fullName: System.Data.Linq.DataContext.DataContext(String,MappingSource)
  type: Constructor
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "새 인스턴스를 초기화는 <xref href=&quot;System.Data.Linq.DataContext&quot;> </xref> 파일 원본과 매핑 소스를 참조 하 여 클래스입니다."
  syntax:
    content: public DataContext (string fileOrServerOrConnection, System.Data.Linq.Mapping.MappingSource mapping);
    parameters:
    - id: fileOrServerOrConnection
      type: System.String
      description: "이 인수는 다음 중 하나가 될 수 있습니다: SQL Server Express 데이터베이스가 있는 파일의 이름입니다.       데이터베이스가 있는 서버의 이름입니다. 이 경우 공급자는 사용자에 대 한 기본 데이터베이스를 사용합니다.       전체 연결 문자열입니다. [!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)]방금 수정 하지 않고 공급자에 문자열을 전달합니다."
    - id: mapping
      type: System.Data.Linq.Mapping.MappingSource
      description: "매핑에 대 한 원본입니다."
  overload: System.Data.Linq.DataContext.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ChangeConflicts
  id: ChangeConflicts
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ChangeConflicts
  nameWithType: DataContext.ChangeConflicts
  fullName: System.Data.Linq.DataContext.ChangeConflicts
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "동시성 충돌이 발생 한 개체의 컬렉션을 가져옵니다 때 <xref:System.Data.Linq.DataContext.SubmitChanges*>호출 되었습니다.</xref:System.Data.Linq.DataContext.SubmitChanges*>"
  remarks: "다음 예제에서는 어떻게 컬렉션을 반복 하 충돌 정보 검색을 보여 줍니다."
  example:
  - >-
    [!code-cs[System.Data.Linq.ObjectChangeConflict#1](~/add/codesnippet/csharp/objconflict/program.cs#1)]
     [!code-vb[System.Data.Linq.ObjectChangeConflict#1](~/add/codesnippet/visualbasic/objconflict/module1.vb#1)]
  syntax:
    content: public System.Data.Linq.ChangeConflictCollection ChangeConflicts { get; }
    return:
      type: System.Data.Linq.ChangeConflictCollection
      description: "동시성 충돌이 발생 한 개체의 컬렉션입니다."
  overload: System.Data.Linq.DataContext.ChangeConflicts*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.CommandTimeout
  id: CommandTimeout
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: CommandTimeout
  nameWithType: DataContext.CommandTimeout
  fullName: System.Data.Linq.DataContext.CommandTimeout
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "기본 제한 시간 동안 시간이 초과 될 수 있는 쿼리에 대 한 제한 시간을 증가 하는 값을 가져오거나 설정 합니다."
  remarks: "이 속성 생성된 명령을 실행 하는 데 사용 하는 명령 제한 시간을 가져오거나 설정 합니다. (`IDbCommands`). 자세한 내용은 <xref:System.Data.IDbCommand.CommandTimeout%2A>.</xref:System.Data.IDbCommand.CommandTimeout%2A> 을 참조 하십시오.       이 속성이 설정 되지 않은 경우, 기본값인 <xref:System.Data.IDbCommand.CommandTimeout%2A>쿼리 명령 실행에 사용 됩니다.</xref:System.Data.IDbCommand.CommandTimeout%2A> 기본 값이 저장소 공급자가 설정 됩니다. 이 값은&0;이 아닌 값으로 설정 하는 경우 일부 공급자가 예외를 throw 할 note 합니다."
  syntax:
    content: public int CommandTimeout { get; set; }
    return:
      type: System.Int32
      description: "기본 제한 시간 동안 시간이 초과 될 수 있는 쿼리에 대 한 제한 시간을 증가 하는 정수 값입니다."
  overload: System.Data.Linq.DataContext.CommandTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Connection
  id: Connection
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Connection
  nameWithType: DataContext.Connection
  fullName: System.Data.Linq.DataContext.Connection
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "프레임 워크에서 사용 되는 연결을 가져옵니다."
  remarks: "관계형 ADO.NET 코드와 상호 운용 하도록이 속성을 사용할 수 있습니다.       사용자가 명시적으로 열 렸 경우가 아니면 반환 된 연결을 닫습니다."
  syntax:
    content: public System.Data.Common.DbConnection Connection { get; }
    return:
      type: System.Data.Common.DbConnection
      description: "프레임 워크에서 사용 되는 연결 합니다."
  overload: System.Data.Linq.DataContext.Connection*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.CreateDatabase
  id: CreateDatabase
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: CreateDatabase()
  nameWithType: DataContext.CreateDatabase()
  fullName: System.Data.Linq.DataContext.CreateDatabase()
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "서버에서 데이터베이스를 만듭니다."
  remarks: "다음 알고리즘을 사용 하 여 데이터베이스의 이름을 파생 시킵니다.-데이터베이스 연결 문자열에 식별 되 면 해당 이름이 사용 됩니다.      If는 <xref:System.Data.Linq.Mapping.DatabaseAttribute>특성이 있으면 해당 <xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A>속성은 데이터베이스의 이름으로 사용 합니다.</xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A> </xref:System.Data.Linq.Mapping.DatabaseAttribute>      -연결 문자열 및 강력한 형식의 데이터베이스 태그가 없는 경우 <xref:System.Data.Linq.DataContext>사용 하는 경우와 동일한 이름을 가진 데이터베이스는 <xref:System.Data.Linq.DataContext>클래스 상속을 선택 합니다.</xref:System.Data.Linq.DataContext> </xref:System.Data.Linq.DataContext>      -는 약하게 형식화 하는 경우 <xref:System.Data.Linq.DataContext>는 사용 하는 예외가 throw 됩니다.</xref:System.Data.Linq.DataContext>      If는 <xref:System.Data.Linq.DataContext>만든 해당 파일 이름에 해당 하는 데이터베이스를 만들 때 파일 이름을 사용 하 여.</xref:System.Data.Linq.DataContext>"
  example:
  - "The following code shows how to set up a temporary database and then remove it.  \n  \n [!code-vb[System.Data.Linq.DataContext#1](~/add/codesnippet/visualbasic/DataContext/Module1.vb#1)]\n [!code-cs[System.Data.Linq.DataContext#1](~/add/codesnippet/csharp/DataContext/Program.cs#1)]"
  syntax:
    content: public void CreateDatabase ();
    parameters: []
  overload: System.Data.Linq.DataContext.CreateDatabase*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])
  id: CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: CreateMethodCallQuery(Object,MethodInfo,Object[])
  nameWithType: DataContext.CreateMethodCallQuery(Object,MethodInfo,Object[])
  fullName: System.Data.Linq.DataContext.CreateMethodCallQuery(Object,MethodInfo,Object[])
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  syntax:
    content: protected System.Linq.IQueryable<TResult> CreateMethodCallQuery<TResult> (object instance, System.Reflection.MethodInfo methodInfo, object[] parameters);
    parameters:
    - id: instance
      type: System.Object
      description: "추가할 수 있습니다."
    - id: methodInfo
      type: System.Reflection.MethodInfo
      description: "추가할 수 있습니다."
    - id: parameters
      type: System.Object[]
      description: "추가할 수 있습니다."
    return:
      type: System.Linq.IQueryable{TResult}
      description: "추가할 수 있습니다."
  overload: System.Data.Linq.DataContext.CreateMethodCallQuery<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.DatabaseExists
  id: DatabaseExists
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: DatabaseExists()
  nameWithType: DataContext.DatabaseExists()
  fullName: System.Data.Linq.DataContext.DatabaseExists()
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "연결된 된 데이터베이스를 열 수 있는지 여부를 결정 합니다."
  remarks: "연결을 사용 하 여이 메서드는 <xref:System.Data.Linq.DataContext.Connection%2A>속성을 연결된 된 데이터베이스를 열려고 시도 합니다.</xref:System.Data.Linq.DataContext.Connection%2A>"
  example:
  - "The following example uses this method to determine whether a database already exists.  \n  \n [!code-vb[System.Data.Linq.DataContext#1](~/add/codesnippet/visualbasic/DataContext/Module1.vb#1)]\n [!code-cs[System.Data.Linq.DataContext#1](~/add/codesnippet/csharp/DataContext/Program.cs#1)]"
  syntax:
    content: public bool DatabaseExists ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>지정된 된 데이터베이스를 열 수 있는; 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.Linq.DataContext.DatabaseExists*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.DeferredLoadingEnabled
  id: DeferredLoadingEnabled
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: DeferredLoadingEnabled
  nameWithType: DataContext.DeferredLoadingEnabled
  fullName: System.Data.Linq.DataContext.DeferredLoadingEnabled
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "지연 로드 대 다 또는 한 일 관계를 여부를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "코드 null 이러한 관계 중 하나에 액세스할 때 관계는 한 일, 다를 경우에 빈 컬렉션이 반환 됩니다 하는 경우 반환 됩니다. 관계 여전히 설정 하 여 채울 수는 <xref:System.Data.Linq.DataContext.LoadOptions%2A>속성.</xref:System.Data.Linq.DataContext.LoadOptions%2A>       이 속성에 대 한 주요 시나리오는 개체 모델의 일부를 추출 하 고 (예를 들어 웹 서비스)에 보낼 수 있습니다.      > [!NOTE] >이 속성을 설정 하는 경우 `false` 쿼리 실행 된 후 예외가 throw 됩니다. 참조는 **유효한 모드** 자세한 내용은 아래 섹션.      ## 지연 된 로드를 사용할 수 있는 모드 개체 추적이 필요합니다. 다음 세 가지 모드는 유효한만:- <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A>= `false`.</xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> DeferredLoadingEnabled은 무시 되 고 것으로 유추 `false`합니다. 이 동작은 읽기 전용 <xref:System.Data.Linq.DataContext>.</xref:System.Data.Linq.DataContext>      -   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `true`.</xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> DeferredLoadingEnabled = `false`합니다. 이 경우에 해당 하는 <xref:System.Data.Linq.DataContext>를 사용 하 여 개체 그래프를 로드, 사용자가 허용 <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>지시문 하지만 지연 된 로드를 사용 하지 않는.</xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> </xref:System.Data.Linq.DataContext>      -둘 다로 설정 된 `true`합니다. 이것이 기본값입니다.       쿼리를 실행 한 후 플래그를 변경할 수 있습니다. 사용 하는 첫 번째 쿼리를 실행 한 후 모든 변경 <xref:System.Data.Linq.DataContext>예외를 throw 합니다.</xref:System.Data.Linq.DataContext>"
  syntax:
    content: public bool DeferredLoadingEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>지연 된 로드를 사용 하면 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.Linq.DataContext.DeferredLoadingEnabled*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.DeleteDatabase
  id: DeleteDatabase
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: DeleteDatabase()
  nameWithType: DataContext.DeleteDatabase()
  fullName: System.Data.Linq.DataContext.DeleteDatabase()
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "연결된 된 데이터베이스를 삭제합니다."
  remarks: "연결을 사용 하 여이 메서드는 <xref:System.Data.Linq.DataContext.Connection%2A>속성을 삭제할 데이터베이스를 식별 합니다.</xref:System.Data.Linq.DataContext.Connection%2A>"
  example:
  - "The following example shows how to delete a database that has been temporarily created.  \n  \n [!code-vb[System.Data.Linq.DataContext#1](~/add/codesnippet/visualbasic/DataContext/Module1.vb#1)]\n [!code-cs[System.Data.Linq.DataContext#1](~/add/codesnippet/csharp/DataContext/Program.cs#1)]"
  syntax:
    content: public void DeleteDatabase ();
    parameters: []
  overload: System.Data.Linq.DataContext.DeleteDatabase*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Dispose
  id: Dispose
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Dispose()
  nameWithType: DataContext.Dispose()
  fullName: System.Data.Linq.DataContext.Dispose()
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "현재 인스턴스에서 사용 하는 모든 리소스를 해제는 <xref href=&quot;System.Data.Linq.DataContext&quot;> </xref> 클래스입니다."
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.Data.Linq.DataContext.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: DataContext.Dispose(Boolean)
  fullName: System.Data.Linq.DataContext.Dispose(Boolean)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "사용 하는 관리 되지 않는 리소스를 해제는 <xref href=&quot;System.Data.Linq.DataContext&quot;> </xref> 클래스 및 관리 되는 리소스를 선택적으로 해제 합니다."
  syntax:
    content: protected virtual void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>관리 되는 관리 되지 않는 리소스만 해제 하려면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> 만 관리 되지 않는 리소스를 해제 합니다."
  overload: System.Data.Linq.DataContext.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])
  id: ExecuteCommand(System.String,System.Object[])
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ExecuteCommand(String,Object[])
  nameWithType: DataContext.ExecuteCommand(String,Object[])
  fullName: System.Data.Linq.DataContext.ExecuteCommand(String,Object[])
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "데이터베이스에서 직접 SQL 명령을 실행합니다."
  remarks: "This method is a pass-through mechanism for cases where [!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)] does not adequately provide for a particular scenario.  \n  \n The syntax for the command is almost the same as the syntax used to create an ADO.NET `DataCommand`. The only difference is in how the parameters are specified. Specifically, you specify parameters by enclosing them in braces ({…}) and enumerate them starting from 0. The parameter is associated with the equally numbered object in the parameters array.  \n  \n `ExecuteQuery` and `ExecuteCommand` allow you to specify a variable number of arguments for parameter substitution. For example, you can specify the parameters when invoking ExecuteQuery\\<TResult>:  \n  \n```  \ndb.ExecuteQuery<Customer>(\"select * from dbo.Customers where City = {0}\", \"London\");  \n```  \n  \n And, another example:  \n  \n```  \ndb.ExecuteCommand(\"UPDATE Products SET QuantityPerUnit = {0} WHERE ProductID = {1}\", \"24 boxes\", 5);  \n```  \n  \n The following example opens a connection and passes a SQL `UPDATE` command to the SQL engine."
  example:
  - >-
    [!code-cs[DLinqCommunicatingWithDatabase#3](~/add/codesnippet/csharp/CommWithDatabase/Program.cs#3)]
     [!code-vb[DLinqCommunicatingWithDatabase#3](~/add/codesnippet/visualbasic/CommWithDatabase/Module1.vb#3)]
  syntax:
    content: public int ExecuteCommand (string command, object[] parameters);
    parameters:
    - id: command
      type: System.String
      description: "실행할 SQL 명령입니다."
    - id: parameters
      type: System.Object[]
      description: "명령에 전달할 매개 변수 배열입니다. 다음과 같은 동작이: 수가 배열의 개체에에서 명령 문자열에 지정 된 최대 개수 보다 작은 경우 예외가 throw 됩니다.       배열에 명령 문자열에서 참조 되지 않는 개체가 포함 되어 있으면 예외가 발생 하지 않습니다.       매개 변수 중 하나가 null 이면 변환할 <xref uid=&quot;langword_csharp_DBNull.Value&quot; name=&quot;DBNull.Value&quot; href=&quot;&quot;> </xref>합니다."
    return:
      type: System.Int32
      description: "명령이 실행된 하 여 수정 된 행 수입니다."
  overload: System.Data.Linq.DataContext.ExecuteCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)
  id: ExecuteDynamicDelete(System.Object)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ExecuteDynamicDelete(Object)
  nameWithType: DataContext.ExecuteDynamicDelete(Object)
  fullName: System.Data.Linq.DataContext.ExecuteDynamicDelete(Object)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "에 다시 위임할 때 삭제 재정의 메서드 내 실행 [!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)] 삭제 작업을 하는 작업을 생성 하 고에 대 한 동적 SQL을 실행 합니다."
  remarks: "<xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.</xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A> 를 참조 하십시오."
  syntax:
    content: protected void ExecuteDynamicDelete (object entity);
    parameters:
    - id: entity
      type: System.Object
      description: "삭제 될 엔터티입니다."
  overload: System.Data.Linq.DataContext.ExecuteDynamicDelete*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)
  id: ExecuteDynamicInsert(System.Object)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ExecuteDynamicInsert(Object)
  nameWithType: DataContext.ExecuteDynamicInsert(Object)
  fullName: System.Data.Linq.DataContext.ExecuteDynamicInsert(Object)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "에 다시 위임할 때 삽입 재정의 메서드 내 실행 [!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)] 삽입 작업을 하는 작업을 생성 하 고에 대 한 동적 SQL을 실행 합니다."
  remarks: "다음 고려 사항을:-메서드는 보호 된 한정자가 있으므로 해야 사용할 <xref:System.Data.Linq.DataContext>.</xref:System.Data.Linq.DataContext> 서브클래싱      -이 작업 내 호출 하지 않은 경우 예외가 throw 됩니다는 <xref:System.Data.Linq.DataContext.SubmitChanges%2A>작업.</xref:System.Data.Linq.DataContext.SubmitChanges%2A> 범위 밖에 서 독립 실행형 작업으로 호출에 적합 하지 않습니다는 <xref:System.Data.Linq.DataContext.SubmitChanges%2A>작업.</xref:System.Data.Linq.DataContext.SubmitChanges%2A> <xref:System.Data.Linq.DataContext.SubmitChanges%2A>자체 호출 메서드를 재정의 구현 하 고 이전 메서드를 재정의 메서드 호출 하도록 되어 있습니다.</xref:System.Data.Linq.DataContext.SubmitChanges%2A>      -것은 올바른 엔터티를 전달 하는 개발자의 책임입니다. 구현에 전달 된 엔터티를 추적 하는 것을 확인 합니다. 그러나 되기 순서 유지 관리 또는 두 번 동일한 엔터티를 전달 하는 개발자의 책임입니다.      -것은 올바른 동적 API를 호출 하는 개발자의 책임입니다. 예를 들어는 `Update` 재정의 메서드에서 <xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A>메서드를 호출할 수 있습니다.</xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A> [!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)]검색 하거나 호출된 된 동적 메서드가 적용 가능한 작업과 일치 하는지 여부를 확인 하지 않습니다. 적용할 수 없는 메서드를 호출 하면 결과가 정의 되지 않습니다 (예를 들어 호출 <xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A>업데이트할 개체에 대 한).</xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A>"
  syntax:
    content: protected void ExecuteDynamicInsert (object entity);
    parameters:
    - id: entity
      type: System.Object
      description: "삽입할 엔터티입니다."
  overload: System.Data.Linq.DataContext.ExecuteDynamicInsert*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)
  id: ExecuteDynamicUpdate(System.Object)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ExecuteDynamicUpdate(Object)
  nameWithType: DataContext.ExecuteDynamicUpdate(Object)
  fullName: System.Data.Linq.DataContext.ExecuteDynamicUpdate(Object)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "에 다시 위임할 때 업데이트 재정의 메서드 내 실행 [!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)] 작업 생성 및 업데이트 작업에 대 한 동적 SQL을 실행 합니다."
  remarks: "<xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.</xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A> 를 참조 하십시오."
  syntax:
    content: protected void ExecuteDynamicUpdate (object entity);
    parameters:
    - id: entity
      type: System.Object
      description: "업데이트할 엔터티입니다."
  overload: System.Data.Linq.DataContext.ExecuteDynamicUpdate*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])
  id: ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ExecuteMethodCall(Object,MethodInfo,Object[])
  nameWithType: DataContext.ExecuteMethodCall(Object,MethodInfo,Object[])
  fullName: System.Data.Linq.DataContext.ExecuteMethodCall(Object,MethodInfo,Object[])
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "데이터베이스 저장된 프로시저 또는 지정 된 연결 된 스칼라 함수를 실행 합니다."
  remarks: "ExecuteMethodCall 메서드 자동으로 생성 된 코드에 사용 되 고 데이터베이스 함수에 대 한 프록시 역할을 합니다."
  syntax:
    content: protected System.Data.Linq.IExecuteResult ExecuteMethodCall (object instance, System.Reflection.MethodInfo methodInfo, object[] parameters);
    parameters:
    - id: instance
      type: System.Object
      description: "메서드 호출 (현재 개체)의 인스턴스."
    - id: methodInfo
      type: System.Reflection.MethodInfo
      description: "데이터베이스 방법에 해당 하는 CLR 메서드를 식별 합니다."
    - id: parameters
      type: System.Object[]
      description: "명령에 전달할 매개 변수 배열입니다."
    return:
      type: System.Data.Linq.IExecuteResult
      description: "결과 (반환 값과 출력 매개 변수)의 지정된 된 메서드를 실행 합니다."
  overload: System.Data.Linq.DataContext.ExecuteMethodCall*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])
  id: ExecuteQuery(System.Type,System.String,System.Object[])
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ExecuteQuery(Type,String,Object[])
  nameWithType: DataContext.ExecuteQuery(Type,String,Object[])
  fullName: System.Data.Linq.DataContext.ExecuteQuery(Type,String,Object[])
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "데이터베이스에서 직접 SQL 쿼리를 실행 합니다."
  syntax:
    content: public System.Collections.IEnumerable ExecuteQuery (Type elementType, string query, object[] parameters);
    parameters:
    - id: elementType
      type: System.Type
      description: "유형의 &lt;xref:System.Collections.Generic.IEnumerable%601&gt; 반환 됩니다.       개체의 속성 또는 필드에 대 한 쿼리의 결과 열을 일치 하는 알고리즘은 다음과 같이 작동: 필드 또는 속성에 특정 열 이름에 매핑되는 경우 해당 열 이름이 결과 집합에 사용할 수 있습니다.       필드 또는 속성이 매핑되지 않은 경우 결과 집합에 열 이름이 같은 필드 또는 속성으로 사용할 수 있습니다.       비교는 대/소문자를 먼저 검색 하 여 수행 됩니다. 이 항목이 발견 되지 않아 다시 검색 일치 하는 대/소문자 구분에 발생 합니다.       모든 추적 된 필드와 속성 (제외 하 고 지연 기준 로드)는 개체의이 쿼리에서 반환 되어야 다음 조건에 모두 해당할: `T` 엔터티 명시적으로에서 추적의 <xref href=&quot;System.Data.Linq.DataContext&quot;> </xref>합니다.       <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled*>is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>.</xref:System.Data.Linq.DataContext.ObjectTrackingEnabled*>       엔터티는 기본 키를 있습니다.       그렇지 않으면 예외가 throw 됩니다."
    - id: query
      type: System.String
      description: "실행할 SQL 쿼리입니다."
    - id: parameters
      type: System.Object[]
      description: "명령에 전달할 매개 변수 배열입니다. 다음과 같은 동작이: 수가 배열의 개체에에서 명령 문자열에 지정 된 최대 개수 보다 작은 경우 예외가 throw 됩니다.       배열에 명령 문자열에서 참조 되지 않는 개체가 포함 되어 있으면 예외가 발생 하지 않습니다.       매개 변수가 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, 변환 된 <xref uid=&quot;langword_csharp_DBNull.Value&quot; name=&quot;DBNull.Value&quot; href=&quot;&quot;> </xref>합니다."
    return:
      type: System.Collections.IEnumerable
      description: "&lt;xref:System.Collections.Generic.IEnumerable%601&gt; 쿼리에 의해 반환 되는 개체의 컬렉션입니다."
  overload: System.Data.Linq.DataContext.ExecuteQuery*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])
  id: ExecuteQuery``1(System.String,System.Object[])
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ExecuteQuery(String,Object[])
  nameWithType: DataContext.ExecuteQuery(String,Object[])
  fullName: System.Data.Linq.DataContext.ExecuteQuery(String,Object[])
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  syntax:
    content: public System.Collections.Generic.IEnumerable<TResult> ExecuteQuery<TResult> (string query, object[] parameters);
    parameters:
    - id: query
      type: System.String
      description: "추가할 수 있습니다."
    - id: parameters
      type: System.Object[]
      description: "추가할 수 있습니다."
    return:
      type: System.Collections.Generic.IEnumerable{TResult}
      description: "추가할 수 있습니다."
  overload: System.Data.Linq.DataContext.ExecuteQuery<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.GetChangeSet
  id: GetChangeSet
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: GetChangeSet()
  nameWithType: DataContext.GetChangeSet()
  fullName: System.Data.Linq.DataContext.GetChangeSet()
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "수정된 된 개체에서 추적 가져옵니다 <xref href=&quot;System.Data.Linq.DataContext&quot;> </xref>합니다."
  remarks: "다음 고려 사항을:-GetChangeSet 유추의 삽입과 같은 부작용 및 삭제 <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</xref:System.Data.Linq.DataContext.SubmitChanges%2A> 시간에서 일반적으로 수행 하는 작업 다음 작업에 사용 되는 개체는 다음 목록에 해당 작업이 유추를 만들 수 예를 들어:- <xref:System.Data.Linq.EntitySet%601.Add%2A> <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>.</xref:System.Data.Linq.Table%601.InsertOnSubmit%2A> </xref:System.Data.Linq.EntitySet%601.Add%2A>          - <xref:System.Data.Linq.EntityRef%601>null 할당 (인해 <xref:System.Data.Linq.EntitySet%601.Remove%2A> <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>.</xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> </xref:System.Data.Linq.EntitySet%601.Remove%2A> </xref:System.Data.Linq.EntityRef%601>      -집합 foreign key 제약 조건에 따라 정렬 되지 않을 수 있습니다.      -데이터베이스에서 생성 된 값 (예를 들어, 기본 및 외래 키 값, 타임 스탬프 등)를 사용할 수 있습니다. 이러한 정보는 데이터베이스 명령 실행 하 고 검색 된 정보 (예를 들어 기본 키에서 외래 키)의 전파 아마도 필요합니다.      -집합이 변경 된 개체 호출 시 계산 됩니다. 에 대 한 후속 호출 <xref:System.Data.Linq.DataContext.SubmitChanges%2A>추가로 변경 내용이 있는 경우 다른 집합을 생성할 수 있습니다.</xref:System.Data.Linq.DataContext.SubmitChanges%2A>       변경 내용을 적용 된 경우의 출력을 다음과 같이 나타납니다.`{Added: 0, Removed: 0, Modified: 0}`"
  example:
  - >-
    [!code-vb[DLinqDebuggingSupport#2](~/add/codesnippet/visualbasic/debuggingsupport/Module1.vb#2)]
     [!code-cs[DLinqDebuggingSupport#2](~/add/codesnippet/csharp/debuggingsupport/Program.cs#2)]
  syntax:
    content: public System.Data.Linq.ChangeSet GetChangeSet ();
    parameters: []
    return:
      type: System.Data.Linq.ChangeSet
      description: "개체 집합을 세 개의 읽기 전용 컬렉션으로 반환 됩니다."
  overload: System.Data.Linq.DataContext.GetChangeSet*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)
  id: GetCommand(System.Linq.IQueryable)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: GetCommand(IQueryable)
  nameWithType: DataContext.GetCommand(IQueryable)
  fullName: System.Data.Linq.DataContext.GetCommand(IQueryable)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "에 의해 생성 된 SQL 명령에 대 한 정보를 가져옵니다 [!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)]합니다."
  remarks: "이 방법은 getter에만 영향을 주지 않습니다 뛰어나며 <xref:System.Data.Linq.DataContext>상태.</xref:System.Data.Linq.DataContext>       다음 고려 사항을:-인수는 null 이어야 합니다. 그렇지 않으면 null 인수 예외가 throw 됩니다.      -일반적인 쿼리 변환 예외 중에 throw [!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)] 쿼리 실행 변환할 수 없는 쿼리에 적용 합니다.      -첫 번째 쿼리는 명령만 반환 됩니다. 즉시 로드에 사용 되는 추가 명령이 특히 (<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>)는 포함 되지 않습니다.</xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>      - <xref:System.Data.Linq.DataContext>명령을 사용 하 여 사용자가을 추적 하지 않습니다.</xref:System.Data.Linq.DataContext> 반환 된 명령을 실행 한 결과 추적 되지 않으며 영향을 주지 않습니다 예를 들어 <xref:System.Data.Linq.DataContext>상태.</xref:System.Data.Linq.DataContext>"
  example:
  - >-
    [!code-vb[DLinqDebuggingSupport#3](~/add/codesnippet/visualbasic/debuggingsupport/Module1.vb#3)]
     [!code-cs[DLinqDebuggingSupport#3](~/add/codesnippet/csharp/debuggingsupport/Program.cs#3)]
  syntax:
    content: public System.Data.Common.DbCommand GetCommand (System.Linq.IQueryable query);
    parameters:
    - id: query
      type: System.Linq.IQueryable
      description: "SQL 명령 정보 쿼리는 검색할 수 있습니다."
    return:
      type: System.Data.Common.DbCommand
      description: "요청 된 명령이 정보 개체입니다."
  overload: System.Data.Linq.DataContext.GetCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.GetTable(System.Type)
  id: GetTable(System.Type)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: GetTable(Type)
  nameWithType: DataContext.GetTable(Type)
  fullName: System.Data.Linq.DataContext.GetTable(Type)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "변수로 정의 된 특정 유형의 개체의 컬렉션을 반환 하는 <code> type </code> 매개 변수입니다."
  remarks: "이 <xref:System.Data.Linq.DataContext.GetTable%2A>.</xref:System.Data.Linq.DataContext.GetTable%2A> 의 약한 형식의 버전 쿼리를 동적으로 생성 하는 상대적으로 일반적인 좋습니다 이기 때문에 약한 형식의 버전을 포함 하는 것이 유용 합니다. 하기란 리플렉션을 사용 하 여 올바른 제네릭 메서드를 호출 하면 응용 프로그램을 편리 하 게 합니다.       특정 형식에 대 한 컬렉션이 없는 경우 예외가 throw 됩니다."
  syntax:
    content: public System.Data.Linq.ITable GetTable (Type type);
    parameters:
    - id: type
      type: System.Type
      description: "반환할 개체의 형식입니다."
    return:
      type: System.Data.Linq.ITable
      description: "에 정의 된 개체의 컬렉션은 <code> type </code> 매개 변수입니다."
  overload: System.Data.Linq.DataContext.GetTable*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.GetTable``1
  id: GetTable``1
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: GetTable()
  nameWithType: DataContext.GetTable()
  fullName: System.Data.Linq.DataContext.GetTable()
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  syntax:
    content: 'public System.Data.Linq.Table<TEntity> GetTable<TEntity> () where TEntity : class;'
    parameters: []
    return:
      type: System.Data.Linq.Table`1
      description: "추가할 수 있습니다."
  overload: System.Data.Linq.DataContext.GetTable<TEntity>*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.LoadOptions
  id: LoadOptions
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: LoadOptions
  nameWithType: DataContext.LoadOptions
  fullName: System.Data.Linq.DataContext.LoadOptions
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "가져오거나는 <xref href=&quot;System.Data.Linq.DataLoadOptions&quot;> </xref> 이 연관 <xref href=&quot;System.Data.Linq.DataContext&quot;> </xref>합니다."
  remarks: "이 속성에는 지연 로드 된 멤버와 관련 된 컬렉션의 멤버 자격에 대 한 사전 인출 동작을 정의 하는 데 사용 되는 옵션을 설정 하거나 가져옵니다."
  syntax:
    content: public System.Data.Linq.DataLoadOptions LoadOptions { get; set; }
    return:
      type: System.Data.Linq.DataLoadOptions
      description: "프리페치는 관련된 데이터에 대 한 옵션을 로드 합니다."
  overload: System.Data.Linq.DataContext.LoadOptions*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Log
  id: Log
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Log
  nameWithType: DataContext.Log
  fullName: System.Data.Linq.DataContext.Log
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "SQL 쿼리 또는 명령에 기록 하도록 대상을 가져오거나 설정 합니다."
  remarks: "이 속성을 설정 `null` 명령 로깅을 사용 하지 않으려면입니다."
  example:
  - "The following example displays generated SQL in the console window before it displays the results of the query.  \n  \n [!code-vb[System.Data.Linq.DataContext#2](~/add/codesnippet/visualbasic/DataContext/Module1.vb#2)]\n [!code-cs[System.Data.Linq.DataContext#2](~/add/codesnippet/csharp/DataContext/Program.cs#2)]"
  syntax:
    content: public System.IO.TextWriter Log { get; set; }
    return:
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextReader>명령을 쓰는 데 사용할.</xref:System.IO.TextReader>"
  overload: System.Data.Linq.DataContext.Log*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Mapping
  id: Mapping
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Mapping
  nameWithType: DataContext.Mapping
  fullName: System.Data.Linq.DataContext.Mapping
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "가져옵니다는 <xref href=&quot;System.Data.Linq.Mapping.MetaModel&quot;> </xref> 매핑을 기반이 되 합니다."
  syntax:
    content: public System.Data.Linq.Mapping.MetaModel Mapping { get; }
    return:
      type: System.Data.Linq.Mapping.MetaModel
      description: "데이터베이스 및 도메인 개체 간의 매핑입니다."
  overload: System.Data.Linq.DataContext.Mapping*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.ObjectTrackingEnabled
  id: ObjectTrackingEnabled
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: ObjectTrackingEnabled
  nameWithType: DataContext.ObjectTrackingEnabled
  fullName: System.Data.Linq.DataContext.ObjectTrackingEnabled
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "개체 추적이 사용 되는지 여부를 나타내는 값을 가져오거나 설정 합니다."
  remarks: "이 속성을 설정 `false` 사용 되므로 적은 추적할 항목을 검색할 때 성능이 향상 됩니다.       예외가 throw 됩니다:-의 속성을로 설정 하는 경우 `false` 쿼리가 실행 된 후입니다.           자세한 내용은 <xref:System.Data.Linq.DataContext>.</xref:System.Data.Linq.DataContext> 유효한 모드 섹션을 참조 하십시오.      -는 속성이로 설정 되어 있으면 `false` 및 <xref:System.Data.Linq.DataContext.SubmitChanges%2A>호출 됩니다.</xref:System.Data.Linq.DataContext.SubmitChanges%2A>       ObjectTrackingEnabled 이면 `false`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A>은 무시 되 고로 처리 `false`.</xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> 이 경우에 <xref:System.Data.Linq.DataContext>읽기 전용입니다.</xref:System.Data.Linq.DataContext>       ObjectTrackingEnabled 이면 `true`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A>은 `false`.</xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> 이 경우 <xref:System.Data.Linq.DataContext>개체 그래프를 사용 하 여 로드할 수 있게 해 <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>지시문 하지만 지연 된 로드를 사용 하지 않습니다.</xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> </xref:System.Data.Linq.DataContext>"
  syntax:
    content: public bool ObjectTrackingEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>개체 추적을 사용 하면 그렇지 않으면 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>합니다. 기본값은 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>합니다."
  overload: System.Data.Linq.DataContext.ObjectTrackingEnabled*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)
  id: Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Refresh(RefreshMode,IEnumerable)
  nameWithType: DataContext.Refresh(RefreshMode,IEnumerable)
  fullName: System.Data.Linq.DataContext.Refresh(RefreshMode,IEnumerable)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "지정된 된 모드에 따라 엔터티 개체의 컬렉션을 새로 고칩니다."
  syntax:
    content: public void Refresh (System.Data.Linq.RefreshMode mode, System.Collections.IEnumerable entities);
    parameters:
    - id: mode
      type: System.Data.Linq.RefreshMode
      description: "어떻게 낙관적 동시성 충돌을 지정 하는 값이 처리 됩니다."
    - id: entities
      type: System.Collections.IEnumerable
      description: "컬렉션 엔터티를 새로 고칠 수입니다."
  overload: System.Data.Linq.DataContext.Refresh*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)
  id: Refresh(System.Data.Linq.RefreshMode,System.Object)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Refresh(RefreshMode,Object)
  nameWithType: DataContext.Refresh(RefreshMode,Object)
  fullName: System.Data.Linq.DataContext.Refresh(RefreshMode,Object)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "지정된 된 모드에 따라 엔터티 개체를 새로 고칩니다."
  syntax:
    content: public void Refresh (System.Data.Linq.RefreshMode mode, object entity);
    parameters:
    - id: mode
      type: System.Data.Linq.RefreshMode
      description: "어떻게 낙관적 동시성 충돌을 지정 하는 값이 처리 됩니다."
    - id: entity
      type: System.Object
      description: "새로 고칠 개체입니다."
  overload: System.Data.Linq.DataContext.Refresh*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])
  id: Refresh(System.Data.Linq.RefreshMode,System.Object[])
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Refresh(RefreshMode,Object[])
  nameWithType: DataContext.Refresh(RefreshMode,Object[])
  fullName: System.Data.Linq.DataContext.Refresh(RefreshMode,Object[])
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "지정된 된 모드에 따라 엔터티 개체의 배열을 새로 고칩니다."
  syntax:
    content: public void Refresh (System.Data.Linq.RefreshMode mode, object[] entities);
    parameters:
    - id: mode
      type: System.Data.Linq.RefreshMode
      description: "어떻게 낙관적 동시성 충돌을 지정 하는 값이 처리 됩니다."
    - id: entities
      type: System.Object[]
      description: "새로 고침 할 엔터티 개체의 배열입니다."
  overload: System.Data.Linq.DataContext.Refresh*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.SubmitChanges
  id: SubmitChanges
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: SubmitChanges()
  nameWithType: DataContext.SubmitChanges()
  fullName: System.Data.Linq.DataContext.SubmitChanges()
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "삽입, 업데이트 또는 삭제, 수정 된 개체의 집합을 계산 하 고 데이터베이스에 변경 내용을 구현 하려면 적절 한 명령을 실행 합니다."
  remarks: "Insert, update 또는 delete에 대 한 재정의 메서드 없으면 <xref:System.Data.Linq.DataContext.SubmitChanges%2A>기본값 대신 이러한 메서드를 실행 [!INCLUDE[vbtecdlinq](~/add/includes/vbtecdlinq-md.md)] 명령입니다.</xref:System.Data.Linq.DataContext.SubmitChanges%2A>"
  syntax:
    content: public void SubmitChanges ();
    parameters: []
  overload: System.Data.Linq.DataContext.SubmitChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)
  id: SubmitChanges(System.Data.Linq.ConflictMode)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: SubmitChanges(ConflictMode)
  nameWithType: DataContext.SubmitChanges(ConflictMode)
  fullName: System.Data.Linq.DataContext.SubmitChanges(ConflictMode)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "에 대 한 변경 내용을 기본 데이터베이스에 개체를 검색 하 고 전송에 실패할 경우에 수행할 동작을 지정 보냅니다."
  remarks: "기본 오류 모드는 <xref:System.Data.Linq.ConflictMode>.</xref:System.Data.Linq.ConflictMode>"
  example:
  - >-
    [!code-cs[System.Data.Linq.ConflictModeEnumeration#1](~/add/codesnippet/csharp/cmodesnip/program.cs#1)]
     [!code-vb[System.Data.Linq.ConflictModeEnumeration#1](~/add/codesnippet/visualbasic/snipdump/module1.vb#1)]
  syntax:
    content: public virtual void SubmitChanges (System.Data.Linq.ConflictMode failureMode);
    parameters:
    - id: failureMode
      type: System.Data.Linq.ConflictMode
      description: "전송에 실패할 경우에 수행할 동작입니다. 올바른 인수는 다음과 같습니다.<xref href=&quot;System.Data.Linq.ConflictMode&quot;></xref><xref href=&quot;System.Data.Linq.ConflictMode&quot;></xref>"
  overload: System.Data.Linq.DataContext.SubmitChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Transaction
  id: Transaction
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Transaction
  nameWithType: DataContext.Transaction
  fullName: System.Data.Linq.DataContext.Transaction
  type: Property
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "에 대 한 로컬 트랜잭션을 가져오거나 설정 합니다.는 [!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)] 데이터베이스에 액세스 하는 데 있습니다."
  remarks: "이 속성에 대 한 기본 시나리오는 관계형와 상호 운용성 [!INCLUDE[vstecado](~/add/includes/vstecado-md.md)] 코드입니다. 직접 작성 하는 경우이 속성을 사용 하 여 예를 들어 `Create` / `Update` / `Delete` 설정 하는 메서드는 `Transaction` ADO 속성 `Command` 개체입니다.       다음 사항에 주의:-getter이이 속성이 명시적으로 설정 되지 않은 경우 null을 반환 합니다.      -코드에서 실행 되는 경우는 <xref:System.Transactions.Transaction>예외를 throw 하는 컨텍스트를이 속성을 설정 합니다.</xref:System.Transactions.Transaction>      -있으면이 속성이 설정 되 고 새 <xref:System.Transactions.Transaction>가 열리고 예외가 쿼리 또는 업데이트가 실행 될 때.</xref:System.Transactions.Transaction>"
  syntax:
    content: public System.Data.Common.DbTransaction Transaction { get; set; }
    return:
      type: System.Data.Common.DbTransaction
      description: "사용 하는 트랜잭션 개체는 <xref href=&quot;System.Data.Linq.DataContext&quot;> </xref> 쿼리와 명령을 실행 합니다."
  overload: System.Data.Linq.DataContext.Transaction*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)
  id: Translate(System.Data.Common.DbDataReader)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Translate(DbDataReader)
  nameWithType: DataContext.Translate(DbDataReader)
  fullName: System.Data.Linq.DataContext.Translate(DbDataReader)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "기존 변환 <xref href=&quot;System.Data.Common.DbDataReader&quot;> </xref> 개체에 있습니다."
  syntax:
    content: public System.Data.Linq.IMultipleResults Translate (System.Data.Common.DbDataReader reader);
    parameters:
    - id: reader
      type: System.Data.Common.DbDataReader
      description: "<xref href=&quot;System.Data.IDataReader&quot;> </xref> 변환 될 수 있습니다."
    return:
      type: System.Data.Linq.IMultipleResults
      description: "변환에 의해 반환 된 개체의 목록입니다."
  overload: System.Data.Linq.DataContext.Translate*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)
  id: Translate(System.Type,System.Data.Common.DbDataReader)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Translate(Type,DbDataReader)
  nameWithType: DataContext.Translate(Type,DbDataReader)
  fullName: System.Data.Linq.DataContext.Translate(Type,DbDataReader)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  summary: "기존 변환 <xref href=&quot;System.Data.Common.DbDataReader&quot;> </xref> 개체에 있습니다."
  syntax:
    content: public System.Collections.IEnumerable Translate (Type elementType, System.Data.Common.DbDataReader reader);
    parameters:
    - id: elementType
      type: System.Type
      description: "유형의 &lt;xref:System.Collections.Generic.IEnumerable%601&gt; 반환 됩니다.       필드에 대 한 결과의 열 및 개체의 속성이 일치 하는 알고리즘은 다음과 같이 작동: 필드 또는 속성에 특정 열 이름에 매핑되는 경우 해당 열 이름이 결과 집합에 사용할 수 있습니다.       필드 또는 속성이 매핑되지 않은 경우 결과 집합에 열 이름이 같은 필드 또는 속성으로 사용할 수 있습니다.       비교는 대/소문자를 먼저 검색 하 여 수행 됩니다. 다시 검색 대/소문자 구분 일치 항목에 대해 발생 하는 경우이 항목이 발견 되지 않아 합니다.       모든 추적 된 필드와 속성 (제외 하 고 지연 기준 로드)는 개체의이 쿼리에서 반환 되어야 다음 조건에 모두 해당할: `T` 엔터티 명시적으로에서 추적의 <xref href=&quot;System.Data.Linq.DataContext&quot;> </xref>합니다.       <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled*>is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>.</xref:System.Data.Linq.DataContext.ObjectTrackingEnabled*>       엔터티는 기본 키를 있습니다.       그렇지 않으면 예외가 throw 됩니다."
    - id: reader
      type: System.Data.Common.DbDataReader
      description: "<xref href=&quot;System.Data.IDataReader&quot;> </xref> 변환 될 수 있습니다."
    return:
      type: System.Collections.IEnumerable
      description: "변환에 의해 반환 된 개체의 목록입니다."
  overload: System.Data.Linq.DataContext.Translate*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)
  id: Translate``1(System.Data.Common.DbDataReader)
  parent: System.Data.Linq.DataContext
  langs:
  - csharp
  name: Translate(DbDataReader)
  nameWithType: DataContext.Translate(DbDataReader)
  fullName: System.Data.Linq.DataContext.Translate(DbDataReader)
  type: Method
  assemblies:
  - System.Data.Linq
  namespace: System.Data.Linq
  syntax:
    content: public System.Collections.Generic.IEnumerable<TResult> Translate<TResult> (System.Data.Common.DbDataReader reader);
    parameters:
    - id: reader
      type: System.Data.Common.DbDataReader
      description: "추가할 수 있습니다."
    return:
      type: System.Collections.Generic.IEnumerable{TResult}
      description: "추가할 수 있습니다."
  overload: System.Data.Linq.DataContext.Translate<TResult>*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DataContext(IDbConnection)
  nameWithType: DataContext.DataContext(IDbConnection)
  fullName: System.Data.Linq.DataContext.DataContext(IDbConnection)
- uid: System.Data.IDbConnection
  parent: System.Data
  isExternal: false
  name: IDbConnection
  nameWithType: IDbConnection
  fullName: System.Data.IDbConnection
- uid: System.Data.Linq.DataContext.#ctor(System.String)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DataContext(String)
  nameWithType: DataContext.DataContext(String)
  fullName: System.Data.Linq.DataContext.DataContext(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DataContext(IDbConnection,MappingSource)
  nameWithType: DataContext.DataContext(IDbConnection,MappingSource)
  fullName: System.Data.Linq.DataContext.DataContext(IDbConnection,MappingSource)
- uid: System.Data.Linq.Mapping.MappingSource
  parent: System.Data.Linq.Mapping
  isExternal: false
  name: MappingSource
  nameWithType: MappingSource
  fullName: System.Data.Linq.Mapping.MappingSource
- uid: System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DataContext(String,MappingSource)
  nameWithType: DataContext.DataContext(String,MappingSource)
  fullName: System.Data.Linq.DataContext.DataContext(String,MappingSource)
- uid: System.Data.Linq.DataContext.ChangeConflicts
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ChangeConflicts
  nameWithType: DataContext.ChangeConflicts
  fullName: System.Data.Linq.DataContext.ChangeConflicts
- uid: System.Data.Linq.ChangeConflictCollection
  parent: System.Data.Linq
  isExternal: false
  name: ChangeConflictCollection
  nameWithType: ChangeConflictCollection
  fullName: System.Data.Linq.ChangeConflictCollection
- uid: System.Data.Linq.DataContext.CommandTimeout
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: CommandTimeout
  nameWithType: DataContext.CommandTimeout
  fullName: System.Data.Linq.DataContext.CommandTimeout
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Data.Linq.DataContext.Connection
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Connection
  nameWithType: DataContext.Connection
  fullName: System.Data.Linq.DataContext.Connection
- uid: System.Data.Common.DbConnection
  parent: System.Data.Common
  isExternal: false
  name: DbConnection
  nameWithType: DbConnection
  fullName: System.Data.Common.DbConnection
- uid: System.Data.Linq.DataContext.CreateDatabase
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: CreateDatabase()
  nameWithType: DataContext.CreateDatabase()
  fullName: System.Data.Linq.DataContext.CreateDatabase()
- uid: System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: CreateMethodCallQuery(Object,MethodInfo,Object[])
  nameWithType: DataContext.CreateMethodCallQuery(Object,MethodInfo,Object[])
  fullName: System.Data.Linq.DataContext.CreateMethodCallQuery(Object,MethodInfo,Object[])
- uid: System.Linq.IQueryable{TResult}
  parent: System.Linq
  isExternal: true
  name: IQueryable<TResult>
  nameWithType: IQueryable<TResult>
  fullName: System.Linq.IQueryable<TResult>
  spec.csharp:
  - uid: System.Linq.IQueryable`1
    name: IQueryable
    nameWithType: IQueryable
    fullName: IQueryable<TResult>
  - name: <
    nameWithType: <
    fullName: <
  - uid: TResult
    name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Reflection.MethodInfo
  parent: System.Reflection
  isExternal: true
  name: MethodInfo
  nameWithType: MethodInfo
  fullName: System.Reflection.MethodInfo
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.Linq.DataContext.DatabaseExists
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DatabaseExists()
  nameWithType: DataContext.DatabaseExists()
  fullName: System.Data.Linq.DataContext.DatabaseExists()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Data.Linq.DataContext.DeferredLoadingEnabled
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DeferredLoadingEnabled
  nameWithType: DataContext.DeferredLoadingEnabled
  fullName: System.Data.Linq.DataContext.DeferredLoadingEnabled
- uid: System.Data.Linq.DataContext.DeleteDatabase
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DeleteDatabase()
  nameWithType: DataContext.DeleteDatabase()
  fullName: System.Data.Linq.DataContext.DeleteDatabase()
- uid: System.Data.Linq.DataContext.Dispose
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Dispose()
  nameWithType: DataContext.Dispose()
  fullName: System.Data.Linq.DataContext.Dispose()
- uid: System.Data.Linq.DataContext.Dispose(System.Boolean)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: DataContext.Dispose(Boolean)
  fullName: System.Data.Linq.DataContext.Dispose(Boolean)
- uid: System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteCommand(String,Object[])
  nameWithType: DataContext.ExecuteCommand(String,Object[])
  fullName: System.Data.Linq.DataContext.ExecuteCommand(String,Object[])
- uid: System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteDynamicDelete(Object)
  nameWithType: DataContext.ExecuteDynamicDelete(Object)
  fullName: System.Data.Linq.DataContext.ExecuteDynamicDelete(Object)
- uid: System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteDynamicInsert(Object)
  nameWithType: DataContext.ExecuteDynamicInsert(Object)
  fullName: System.Data.Linq.DataContext.ExecuteDynamicInsert(Object)
- uid: System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteDynamicUpdate(Object)
  nameWithType: DataContext.ExecuteDynamicUpdate(Object)
  fullName: System.Data.Linq.DataContext.ExecuteDynamicUpdate(Object)
- uid: System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteMethodCall(Object,MethodInfo,Object[])
  nameWithType: DataContext.ExecuteMethodCall(Object,MethodInfo,Object[])
  fullName: System.Data.Linq.DataContext.ExecuteMethodCall(Object,MethodInfo,Object[])
- uid: System.Data.Linq.IExecuteResult
  parent: System.Data.Linq
  isExternal: false
  name: IExecuteResult
  nameWithType: IExecuteResult
  fullName: System.Data.Linq.IExecuteResult
- uid: System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteQuery(Type,String,Object[])
  nameWithType: DataContext.ExecuteQuery(Type,String,Object[])
  fullName: System.Data.Linq.DataContext.ExecuteQuery(Type,String,Object[])
- uid: System.Collections.IEnumerable
  parent: System.Collections
  isExternal: true
  name: IEnumerable
  nameWithType: IEnumerable
  fullName: System.Collections.IEnumerable
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteQuery(String,Object[])
  nameWithType: DataContext.ExecuteQuery(String,Object[])
  fullName: System.Data.Linq.DataContext.ExecuteQuery(String,Object[])
- uid: System.Collections.Generic.IEnumerable{TResult}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<TResult>
  nameWithType: IEnumerable<TResult>
  fullName: System.Collections.Generic.IEnumerable<TResult>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<TResult>
  - name: <
    nameWithType: <
    fullName: <
  - uid: TResult
    name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Data.Linq.DataContext.GetChangeSet
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: GetChangeSet()
  nameWithType: DataContext.GetChangeSet()
  fullName: System.Data.Linq.DataContext.GetChangeSet()
- uid: System.Data.Linq.ChangeSet
  parent: System.Data.Linq
  isExternal: false
  name: ChangeSet
  nameWithType: ChangeSet
  fullName: System.Data.Linq.ChangeSet
- uid: System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: GetCommand(IQueryable)
  nameWithType: DataContext.GetCommand(IQueryable)
  fullName: System.Data.Linq.DataContext.GetCommand(IQueryable)
- uid: System.Data.Common.DbCommand
  parent: System.Data.Common
  isExternal: false
  name: DbCommand
  nameWithType: DbCommand
  fullName: System.Data.Common.DbCommand
- uid: System.Linq.IQueryable
  parent: System.Linq
  isExternal: true
  name: IQueryable
  nameWithType: IQueryable
  fullName: System.Linq.IQueryable
- uid: System.Data.Linq.DataContext.GetTable(System.Type)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: GetTable(Type)
  nameWithType: DataContext.GetTable(Type)
  fullName: System.Data.Linq.DataContext.GetTable(Type)
- uid: System.Data.Linq.ITable
  parent: System.Data.Linq
  isExternal: false
  name: ITable
  nameWithType: ITable
  fullName: System.Data.Linq.ITable
- uid: System.Data.Linq.DataContext.GetTable``1
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: GetTable()
  nameWithType: DataContext.GetTable()
  fullName: System.Data.Linq.DataContext.GetTable()
- uid: System.Data.Linq.Table`1
  parent: System.Data.Linq
  isExternal: false
  name: Table<TEntity>
  nameWithType: Table<TEntity>
  fullName: System.Data.Linq.Table<TEntity>
- uid: System.Data.Linq.DataContext.LoadOptions
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: LoadOptions
  nameWithType: DataContext.LoadOptions
  fullName: System.Data.Linq.DataContext.LoadOptions
- uid: System.Data.Linq.DataLoadOptions
  parent: System.Data.Linq
  isExternal: false
  name: DataLoadOptions
  nameWithType: DataLoadOptions
  fullName: System.Data.Linq.DataLoadOptions
- uid: System.Data.Linq.DataContext.Log
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Log
  nameWithType: DataContext.Log
  fullName: System.Data.Linq.DataContext.Log
- uid: System.IO.TextWriter
  parent: System.IO
  isExternal: true
  name: TextWriter
  nameWithType: TextWriter
  fullName: System.IO.TextWriter
- uid: System.Data.Linq.DataContext.Mapping
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Mapping
  nameWithType: DataContext.Mapping
  fullName: System.Data.Linq.DataContext.Mapping
- uid: System.Data.Linq.Mapping.MetaModel
  parent: System.Data.Linq.Mapping
  isExternal: false
  name: MetaModel
  nameWithType: MetaModel
  fullName: System.Data.Linq.Mapping.MetaModel
- uid: System.Data.Linq.DataContext.ObjectTrackingEnabled
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ObjectTrackingEnabled
  nameWithType: DataContext.ObjectTrackingEnabled
  fullName: System.Data.Linq.DataContext.ObjectTrackingEnabled
- uid: System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Refresh(RefreshMode,IEnumerable)
  nameWithType: DataContext.Refresh(RefreshMode,IEnumerable)
  fullName: System.Data.Linq.DataContext.Refresh(RefreshMode,IEnumerable)
- uid: System.Data.Linq.RefreshMode
  parent: System.Data.Linq
  isExternal: false
  name: RefreshMode
  nameWithType: RefreshMode
  fullName: System.Data.Linq.RefreshMode
- uid: System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Refresh(RefreshMode,Object)
  nameWithType: DataContext.Refresh(RefreshMode,Object)
  fullName: System.Data.Linq.DataContext.Refresh(RefreshMode,Object)
- uid: System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Refresh(RefreshMode,Object[])
  nameWithType: DataContext.Refresh(RefreshMode,Object[])
  fullName: System.Data.Linq.DataContext.Refresh(RefreshMode,Object[])
- uid: System.Data.Linq.DataContext.SubmitChanges
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: SubmitChanges()
  nameWithType: DataContext.SubmitChanges()
  fullName: System.Data.Linq.DataContext.SubmitChanges()
- uid: System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: SubmitChanges(ConflictMode)
  nameWithType: DataContext.SubmitChanges(ConflictMode)
  fullName: System.Data.Linq.DataContext.SubmitChanges(ConflictMode)
- uid: System.Data.Linq.ConflictMode
  parent: System.Data.Linq
  isExternal: false
  name: ConflictMode
  nameWithType: ConflictMode
  fullName: System.Data.Linq.ConflictMode
- uid: System.Data.Linq.DataContext.Transaction
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Transaction
  nameWithType: DataContext.Transaction
  fullName: System.Data.Linq.DataContext.Transaction
- uid: System.Data.Common.DbTransaction
  parent: System.Data.Common
  isExternal: false
  name: DbTransaction
  nameWithType: DbTransaction
  fullName: System.Data.Common.DbTransaction
- uid: System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Translate(DbDataReader)
  nameWithType: DataContext.Translate(DbDataReader)
  fullName: System.Data.Linq.DataContext.Translate(DbDataReader)
- uid: System.Data.Linq.IMultipleResults
  parent: System.Data.Linq
  isExternal: false
  name: IMultipleResults
  nameWithType: IMultipleResults
  fullName: System.Data.Linq.IMultipleResults
- uid: System.Data.Common.DbDataReader
  parent: System.Data.Common
  isExternal: false
  name: DbDataReader
  nameWithType: DbDataReader
  fullName: System.Data.Common.DbDataReader
- uid: System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Translate(Type,DbDataReader)
  nameWithType: DataContext.Translate(Type,DbDataReader)
  fullName: System.Data.Linq.DataContext.Translate(Type,DbDataReader)
- uid: System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Translate(DbDataReader)
  nameWithType: DataContext.Translate(DbDataReader)
  fullName: System.Data.Linq.DataContext.Translate(DbDataReader)
- uid: System.Data.Linq.DataContext.#ctor*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DataContext
  nameWithType: DataContext.DataContext
- uid: System.Data.Linq.DataContext.ChangeConflicts*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ChangeConflicts
  nameWithType: DataContext.ChangeConflicts
- uid: System.Data.Linq.DataContext.CommandTimeout*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: CommandTimeout
  nameWithType: DataContext.CommandTimeout
- uid: System.Data.Linq.DataContext.Connection*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Connection
  nameWithType: DataContext.Connection
- uid: System.Data.Linq.DataContext.CreateDatabase*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: CreateDatabase
  nameWithType: DataContext.CreateDatabase
- uid: System.Data.Linq.DataContext.CreateMethodCallQuery<TResult>*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: CreateMethodCallQuery<TResult>
  nameWithType: DataContext.CreateMethodCallQuery<TResult>
- uid: System.Data.Linq.DataContext.DatabaseExists*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DatabaseExists
  nameWithType: DataContext.DatabaseExists
- uid: System.Data.Linq.DataContext.DeferredLoadingEnabled*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DeferredLoadingEnabled
  nameWithType: DataContext.DeferredLoadingEnabled
- uid: System.Data.Linq.DataContext.DeleteDatabase*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: DeleteDatabase
  nameWithType: DataContext.DeleteDatabase
- uid: System.Data.Linq.DataContext.Dispose*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Dispose
  nameWithType: DataContext.Dispose
- uid: System.Data.Linq.DataContext.ExecuteCommand*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteCommand
  nameWithType: DataContext.ExecuteCommand
- uid: System.Data.Linq.DataContext.ExecuteDynamicDelete*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteDynamicDelete
  nameWithType: DataContext.ExecuteDynamicDelete
- uid: System.Data.Linq.DataContext.ExecuteDynamicInsert*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteDynamicInsert
  nameWithType: DataContext.ExecuteDynamicInsert
- uid: System.Data.Linq.DataContext.ExecuteDynamicUpdate*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteDynamicUpdate
  nameWithType: DataContext.ExecuteDynamicUpdate
- uid: System.Data.Linq.DataContext.ExecuteMethodCall*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteMethodCall
  nameWithType: DataContext.ExecuteMethodCall
- uid: System.Data.Linq.DataContext.ExecuteQuery*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteQuery
  nameWithType: DataContext.ExecuteQuery
- uid: System.Data.Linq.DataContext.ExecuteQuery<TResult>*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ExecuteQuery<TResult>
  nameWithType: DataContext.ExecuteQuery<TResult>
- uid: System.Data.Linq.DataContext.GetChangeSet*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: GetChangeSet
  nameWithType: DataContext.GetChangeSet
- uid: System.Data.Linq.DataContext.GetCommand*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: GetCommand
  nameWithType: DataContext.GetCommand
- uid: System.Data.Linq.DataContext.GetTable*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: GetTable
  nameWithType: DataContext.GetTable
- uid: System.Data.Linq.DataContext.GetTable<TEntity>*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: GetTable<TEntity>
  nameWithType: DataContext.GetTable<TEntity>
- uid: System.Data.Linq.DataContext.LoadOptions*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: LoadOptions
  nameWithType: DataContext.LoadOptions
- uid: System.Data.Linq.DataContext.Log*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Log
  nameWithType: DataContext.Log
- uid: System.Data.Linq.DataContext.Mapping*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Mapping
  nameWithType: DataContext.Mapping
- uid: System.Data.Linq.DataContext.ObjectTrackingEnabled*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: ObjectTrackingEnabled
  nameWithType: DataContext.ObjectTrackingEnabled
- uid: System.Data.Linq.DataContext.Refresh*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Refresh
  nameWithType: DataContext.Refresh
- uid: System.Data.Linq.DataContext.SubmitChanges*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: SubmitChanges
  nameWithType: DataContext.SubmitChanges
- uid: System.Data.Linq.DataContext.Transaction*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Transaction
  nameWithType: DataContext.Transaction
- uid: System.Data.Linq.DataContext.Translate*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Translate
  nameWithType: DataContext.Translate
- uid: System.Data.Linq.DataContext.Translate<TResult>*
  parent: System.Data.Linq.DataContext
  isExternal: false
  name: Translate<TResult>
  nameWithType: DataContext.Translate<TResult>
